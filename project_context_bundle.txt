--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Wed Jun 11 08:57:36 PM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.  DO NOT ASSUME CONTENT EXISTS.  VERIFY FIRST
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/chat_parser.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/shop_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_npc.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/npc_dialogue_ticker.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/npc_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/abilities.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/chat.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/npc.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/character_classes.json
backend/app/seeds/chat_channels.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/loot_tables.json
backend/app/seeds/mob_spawn_definitions.json
backend/app/seeds/mob_templates.json
backend/app/seeds/npcs.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/chat_manager.py
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_admin_parser.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
backend/app/ws_command_parsers/ws_shop_parser.py
bundle_context.sh
frontend/src/components/AbilityList.css
frontend/src/components/BottomInfoBar.css
frontend/src/components/CharacterCreationScreen.css
frontend/src/components/CharacterInfoBar.css
frontend/src/components/CharacterSelectionScreen.css
frontend/src/components/ChatWindow.css
frontend/src/components/GroundItems.css
frontend/src/components/Inventory.css
frontend/src/components/ItemName.css
frontend/src/components/LoginScreen.css
frontend/src/components/LookResult.css
frontend/src/components/Map.css
frontend/src/components/Modal.css
frontend/src/components/ScoreSheet.css
frontend/src/components/TabBar.css
frontend/src/components/TabbedWindow.css
frontend/src/components/Terminal.css
frontend/src/components/VitalsMonitor.css
frontend/src/index.css
frontend/src/index.html
frontend/src/services/apiService.js
frontend/src/services/webSocketService.js
frontend/src/state/gameStore.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed.  DO NOT ASSUME CONTENT EXISTS.  VERIFY FIRST" >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh"
    "README.md"

    # --- THE NEW CRIME SCENE: SHOP & PLAYER LIFECYCLE ---
    "backend/app/commands/shop_parser.py"       # Primary target for the shop overhaul.
    "backend/app/models/item.py"                # We need its structure for stat comparison.
    "backend/app/models/character.py"           # Need to access equipped items and stats.
    "backend/app/websocket_manager.py"          # The heart of the connection logic. Needs an AFK timestamp.
    "backend/app/game_logic/world_ticker.py"    # The most likely place to run the AFK check.

    # --- THE WITNESSES: CLIENT-SIDE RENDERING & INTERACTION ---
    "frontend/src/components/TerminalOutput.jsx" # Needs to learn how to render the new shop listing.
    "frontend/src/services/webSocketService.js"  # Needs to handle the new shop listing payload.
    # --- PROPOSED NEW FILES (Ask me to create them) ---
    # "frontend/src/components/ShopListing.jsx"
    # "frontend/src/components/StatComparison.jsx"

    # --- Foundational Stuff (Still Relevant) ---
    "backend/app/api/v1/endpoints/command.py"
    "frontend/src/state/gameStore.js"
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (âœ¨ðŸ’°ðŸ’ªðŸ§©ðŸ’€ðŸšª) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Flesh out the damn world - Gear, Loot, and More Seeds!

The map is less of an abstract nightmare, and the core gameplay loop is... loopy. Now we need to make the interactions richer and the world feel less empty.

*   **Full Equipment System:** Define all equipment slots. Implement robust `equip` and `unequip` logic. Ensure stats update correctly.
*   **Mob Loot Tables:** Mobs need to drop more than just coins. Define loot tables (specific items, random items from categories, chances).
*   **Seed More Content (Externalize ALL THE THINGS):**
    *   `mob_templates.json`
    *   `character_classes.json`
    *   `skills.json`
    *   `traits.json`
    *   `mob_spawn_definitions.json`
    *   Update corresponding CRUD seeders to load from these JSONs.
*   **Seed Initial Equipment:** Place starting gear on character creation or in initial rooms.

This will involve a lot of backend work (models, CRUD, game logic) and careful JSON schema design for the seed files.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/commands/shop_parser.py ---
# backend/app/commands/shop_parser.py
import logging
from typing import List, Optional
from collections import defaultdict

from sqlalchemy.orm import Session

from app import crud, models, schemas
from .command_args import CommandContext

logger = logging.getLogger(__name__)

MERCHANT_BUY_PRICE_MODIFIER = 0.25

# --- HELPER FUNCTIONS ---
def _format_price(total_copper: int) -> str:
    if total_copper <= 0: return "Free"
    parts = []
    p, rem = divmod(total_copper, 10000)
    g, rem = divmod(rem, 100)
    s, c = divmod(rem, 100)
    if p > 0: parts.append(f"<span class='currency platinum'>{p}p</span>")
    if g > 0: parts.append(f"<span class='currency gold'>{g}g</span>")
    if s > 0: parts.append(f"<span class='currency silver'>{s}s</span>")
    if c > 0: parts.append(f"<span class='currency copper'>{c}c</span>")
    return " ".join(parts) if parts else "0c"

def _get_merchant_in_room(db: Session, room: models.Room) -> Optional[models.NpcTemplate]:
    npcs_in_room = crud.crud_room.get_npcs_in_room(db, room=room)
    for npc in npcs_in_room:
        if npc.npc_type == "merchant":
            return npc
    return None

def _get_shop_inventory_items(db: Session, merchant: models.NpcTemplate) -> List[models.Item]:
    inventory_items = []
    if not merchant.shop_inventory: return []
    for item_ref in merchant.shop_inventory:
        item = crud.crud_item.get_item_by_name(db, name=item_ref)
        if item: inventory_items.append(item)
    return sorted(inventory_items, key=lambda i: i.name)

# --- COMMAND HANDLERS ---
async def handle_list(context: CommandContext) -> schemas.CommandResponse:
    merchant = _get_merchant_in_room(context.db, context.current_room_orm)
    if not merchant:
        return schemas.CommandResponse(message_to_player="There is no one here to sell you anything.")

    shop_items = _get_shop_inventory_items(context.db, merchant)
    if not shop_items:
        return schemas.CommandResponse(message_to_player=f"{merchant.name} has nothing to sell.")

    response_lines = [f"--- {merchant.name}'s Wares ---"]
    for i, item in enumerate(shop_items, 1):
        price_str = _format_price(item.value)
        response_lines.append(f"[{i:2d}] {item.name:<25} - {price_str}")
    response_lines.append(f"Type <span class='command-suggestion'>buy <# or name></span> to purchase.")
    
    return schemas.CommandResponse(message_to_player="\n".join(response_lines))

async def handle_buy(context: CommandContext) -> schemas.CommandResponse:
    args_str = " ".join(context.args)
    if not args_str:
        return schemas.CommandResponse(message_to_player="Buy what?")

    merchant = _get_merchant_in_room(context.db, context.current_room_orm)
    if not merchant:
        return schemas.CommandResponse(message_to_player="There is no one here to buy from.")

    shop_items = _get_shop_inventory_items(context.db, merchant)
    item_to_buy: Optional[models.Item] = None
    if args_str.isdigit() and 1 <= int(args_str) <= len(shop_items):
        item_to_buy = shop_items[int(args_str) - 1]
    else:
        for item in shop_items:
            if args_str.lower() in item.name.lower():
                item_to_buy = item
                break
    
    if not item_to_buy:
        return schemas.CommandResponse(message_to_player=f"'{args_str}' is not for sale here.")

    updated_char, currency_message = crud.crud_character.update_character_currency(context.db, character_id=context.active_character.id, copper_change=-item_to_buy.value)
    
    if not updated_char or "Not enough funds" in currency_message:
        return schemas.CommandResponse(message_to_player="You can't afford that.")

    crud.crud_character_inventory.add_item_to_character_inventory(context.db, character_obj=updated_char, item_id=item_to_buy.id, quantity=1)
    
    price_str = _format_price(item_to_buy.value)
    return schemas.CommandResponse(message_to_player=f"You buy a {item_to_buy.name} for {price_str}.")

async def handle_sell(context: CommandContext) -> schemas.CommandResponse:
    merchant = _get_merchant_in_room(context.db, context.current_room_orm)
    if not merchant:
        return schemas.CommandResponse(message_to_player="There is no one here to sell to.")

    args_str = " ".join(context.args)
    if not args_str:
        return schemas.CommandResponse(message_to_player="Sell what? Try 'sell <item>', 'sell all', or 'sell all junk'.")

    parts = args_str.lower().split()
    command_mode = "single"
    keyword = ""

    if parts[0] == "all":
        command_mode = "all"
        if len(parts) > 1: keyword = parts[1]
    
    backpack = [item for item in context.active_character.inventory_items if not item.equipped]
    items_to_sell = []
    
    if command_mode == "single":
        for item in backpack:
            if args_str.lower() in item.item.name.lower():
                items_to_sell.append(item)
                break # Sell first match
    else: # "all" or "all junk" etc.
        for item in backpack:
            is_junk = item.item.item_type == "junk"
            matches_keyword = keyword in item.item.name.lower()
            
            if keyword == "junk" and is_junk: items_to_sell.append(item)
            elif keyword and matches_keyword: items_to_sell.append(item)
            elif not keyword: items_to_sell.append(item)

    items_to_sell = [item for item in items_to_sell if item.item.value > 0]

    if not items_to_sell:
        if keyword: return schemas.CommandResponse(message_to_player=f"You have no valuable items matching '{keyword}' to sell.")
        elif command_mode == "all": return schemas.CommandResponse(message_to_player="You have nothing of value in your backpack to sell.")
        else: return schemas.CommandResponse(message_to_player=f"You don't have a '{args_str}' or it is worthless.")
        
    total_payout_copper = 0
    sold_items_summary = defaultdict(int)

    for item_instance in items_to_sell:
        item_sell_price = max(1, int(item_instance.item.value * MERCHANT_BUY_PRICE_MODIFIER))
        total_payout_copper += item_sell_price * item_instance.quantity
        sold_items_summary[item_instance.item.name] += item_instance.quantity
        crud.crud_character_inventory.remove_item_from_character_inventory(context.db, inventory_item_id=item_instance.id, quantity_to_remove=item_instance.quantity)

    crud.crud_character.update_character_currency(context.db, character_id=context.active_character.id, copper_change=total_payout_copper)

    price_str = _format_price(total_payout_copper)
    sold_details = ", ".join([f"{qty}x {name}" for name, qty in sorted(sold_items_summary.items())])
    return schemas.CommandResponse(message_to_player=f"You sell {sold_details} for a total of {price_str}.")
--- END OF FILE backend/app/commands/shop_parser.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    rarity: Mapped[str] = mapped_column(String(50), nullable=False, default="common", index=True)
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Boolean, Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    is_brief_mode: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    owner: Mapped["Player"] = relationship(back_populates="characters", lazy="joined") 

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    god_level: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="0 for mortals, 1-10 for gods")
    titles: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [], comment="e.g., ['The Godslayer', 'Cheesewheel Enthusiast']")
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)
    is_brief_mode: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/websocket_manager.py ---
# backend/app/websocket_manager.py
import uuid
import logging # <<<< MAKE SURE LOGGING IS IMPORTED
from typing import Dict, List, Optional
from fastapi import WebSocket
from fastapi.encoders import jsonable_encoder

# We need access to the database to find out where characters are.
from app.db.session import SessionLocal
from app import crud

logger = logging.getLogger(__name__) # <<<< GET A LOGGER

class ConnectionManager:
    def __init__(self):
        # player_id -> WebSocket mapping
        self.active_player_connections: Dict[uuid.UUID, WebSocket] = {}
        # player_id -> active_character_id mapping
        self.player_active_characters: Dict[uuid.UUID, uuid.UUID] = {}
        # character_id -> room_id mapping (CACHE)
        self.character_locations: Dict[uuid.UUID, uuid.UUID] = {}

    async def connect(self, websocket: WebSocket, player_id: uuid.UUID, character_id: uuid.UUID):
        await websocket.accept()
        self.active_player_connections[player_id] = websocket
        self.player_active_characters[player_id] = character_id
        
        with SessionLocal() as db:
            character = crud.crud_character.get_character(db, character_id=character_id)
            if character:
                self.character_locations[character_id] = character.current_room_id
        
        logger.info(f"Player {player_id} (Character {character_id}) connected via WebSocket.")

    def disconnect(self, player_id: uuid.UUID):
        character_id = self.player_active_characters.get(player_id)
        if character_id and character_id in self.character_locations:
            del self.character_locations[character_id]
        if player_id in self.active_player_connections:
            del self.active_player_connections[player_id]
        if player_id in self.player_active_characters:
            del self.player_active_characters[player_id]
        
        logger.info(f"Player {player_id} disconnected from WebSocket.")

    def get_character_id(self, player_id: uuid.UUID) -> Optional[uuid.UUID]:
        return self.player_active_characters.get(player_id)
        
    def update_character_location(self, character_id: uuid.UUID, room_id: uuid.UUID):
        self.character_locations[character_id] = room_id

    def get_all_player_locations(self) -> Dict[uuid.UUID, uuid.UUID]:
        return self.character_locations

    def is_character_online(self, character_id: uuid.UUID) -> bool:
        return character_id in self.character_locations

    def is_player_connected(self, player_id: uuid.UUID) -> bool:
        return player_id in self.active_player_connections

    async def send_personal_message(self, message_payload: dict, player_id: uuid.UUID):
        if player_id in self.active_player_connections:
            websocket = self.active_player_connections[player_id]
            try:
                encoded_payload = jsonable_encoder(message_payload)
                await websocket.send_json(encoded_payload)
            except Exception as e:
                logger.error(f"Error sending personal WS message to {player_id}: {e}")

    async def broadcast_to_players(self, message_payload: dict, player_ids: List[uuid.UUID]):
        encoded_payload = jsonable_encoder(message_payload)
        for player_id in player_ids:
            if player_id in self.active_player_connections:
                websocket = self.active_player_connections[player_id]
                try:
                    await websocket.send_json(encoded_payload)
                except Exception as e:
                    logger.error(f"Error broadcasting to player {player_id}: {e}")
    
    # --- THIS IS THE NEW METHOD THAT MY BROKEN CODE WAS TRYING TO CALL ---
    async def broadcast(self, message_payload: dict):
        """Sends a message to every single connected WebSocket client."""
        logger.info(f"Broadcasting global message: {message_payload.get('message', 'No message content')}")
        encoded_payload = jsonable_encoder(message_payload)
        # We iterate over the WebSocket objects directly
        for connection in self.active_player_connections.values():
            try:
                await connection.send_json(encoded_payload)
            except Exception as e:
                # Log the error but continue trying to send to others. One bad client shouldn't stop a broadcast.
                logger.warning(f"Failed to broadcast to a client: {e}")
    # --- END OF NEW METHOD ---

    def get_all_active_player_ids(self) -> List[uuid.UUID]:
        return list(self.active_player_connections.keys())

# Global instance
connection_manager = ConnectionManager()
--- END OF FILE backend/app/websocket_manager.py ---

--- START OF FILE backend/app/game_logic/world_ticker.py ---
# backend/app/game_logic/world_ticker.py
import asyncio
import time 
from typing import Callable, Iterator, List, Awaitable, Dict, Any, Optional # Added Optional
from sqlalchemy.orm import Session
from contextlib import contextmanager

from app.db.session import SessionLocal
# We might need crud/models here if the ticker itself directly does something,
# but generally, tasks will import what they need.

from app.game_logic.mob_respawner import manage_mob_populations_task 
from app.game_logic.mob_ai_ticker import process_roaming_mobs_task, process_aggressive_mobs_task
from app.game_logic.player_vital_regenerator import regenerate_player_vitals_task 

# --- Configuration ---
WORLD_TICK_INTERVAL_SECONDS = 10.0

# --- Task Registry ---
world_tick_tasks: Dict[str, Callable[[Session], Awaitable[None]]] = {}


@contextmanager
def db_session_for_world_tick() -> Iterator[Session]: 
    """Provides a DB session for the duration of a world tick's tasks."""
    db = SessionLocal()
    try:
        yield db 
    finally:
        db.close()

def register_world_tick_task(task_name: str, task_func: Callable[[Session], Awaitable[None]]):
    if task_name in world_tick_tasks:
        print(f"Warning: World tick task '{task_name}' is being redefined.")
    world_tick_tasks[task_name] = task_func

def _initialize_and_register_all_world_tasks():
    """
    This function is called once when this module is loaded.
    It registers all known world tick tasks.
    """
    print("World Ticker: Initializing and registering world tick tasks...")
    
    register_world_tick_task("mob_population_manager", manage_mob_populations_task)
    register_world_tick_task("roaming_mob_processor", process_roaming_mobs_task) # <<< NEW TASK
    register_world_tick_task("aggressive_mob_processor", process_aggressive_mobs_task) # <<< NEW TASK
    register_world_tick_task("player_vital_regenerator", regenerate_player_vitals_task)
    
    print(f"World Ticker: All tasks registered. Active tasks: {list(world_tick_tasks.keys())}")

_initialize_and_register_all_world_tasks() 


async def world_ticker_loop():
    print(f"World Ticker: Loop now running with interval: {WORLD_TICK_INTERVAL_SECONDS}s.")
    while True:
        start_time = time.time()
        
        if not world_tick_tasks:
            await asyncio.sleep(WORLD_TICK_INTERVAL_SECONDS)
            continue

        try:
            with db_session_for_world_tick() as db:
                # Create a list of tasks to run to avoid issues if tasks modify the registry (not expected)
                tasks_to_run = list(world_tick_tasks.items())
                for task_name, task_func in tasks_to_run:
                    try:
                        # print(f"World Ticker: Running task '{task_name}'...") # Verbose logging
                        await task_func(db)
                        # print(f"World Ticker: Task '{task_name}' completed.") # Verbose logging
                    except Exception as e:
                        print(f"ERROR in world_tick task '{task_name}': {e}") 
                db.commit() 
        except Exception as e:
            print(f"CRITICAL ERROR in world_ticker_loop's DB session: {e}") 

        end_time = time.time()
        processing_time = end_time - start_time
        
        sleep_duration = WORLD_TICK_INTERVAL_SECONDS - processing_time
        if sleep_duration < 0:
            print(f"Warning: World tick processing time ({processing_time:.2f}s) exceeded interval ({WORLD_TICK_INTERVAL_SECONDS}s).")
            sleep_duration = 0 
        
        await asyncio.sleep(sleep_duration)

_world_ticker_task_handle: Optional[asyncio.Task] = None

def start_world_ticker_task():
    global _world_ticker_task_handle
    if _world_ticker_task_handle is None or _world_ticker_task_handle.done():
        print("World Ticker: Attempting to start task...")
        _world_ticker_task_handle = asyncio.create_task(world_ticker_loop())
        print("World Ticker: Task created and running.")
    else:
        print("World Ticker: Task already running.")

def stop_world_ticker_task():
    global _world_ticker_task_handle
    if _world_ticker_task_handle and not _world_ticker_task_handle.done():
        print("World Ticker: Attempting to stop task...")
        _world_ticker_task_handle.cancel()
        _world_ticker_task_handle = None 
        print("World Ticker: Task cancellation requested.")
    else:
        print("World Ticker: Task not running or already stopped.")
--- END OF FILE backend/app/game_logic/world_ticker.py ---

--- START OF FILE frontend/src/components/TerminalOutput.jsx ---
// frontend/src/components/TerminalOutput.jsx
import React from 'react';
import LookResult from './LookResult';
import ChatMessage from './ChatMessage'; // Import the new renderer

// React.forwardRef is essential for the parent component (TabbedWindow)
// to get a reference to the scrolling div and manage the scroll position.
const TerminalOutput = React.forwardRef(function TerminalOutput({ logLines }, ref) {
  return (
    // The ref is attached to the div that actually scrolls.
    <div id="output" className="terminal-output" ref={ref}>
      {logLines.map((line) => {
        // Use a stable, unique key for each log entry.
        const key = line.id; 

        // Decide how to render the line based on its 'type' property.
        switch (line.type) {
          // For structured 'look' responses, use the dedicated component.
          case 'look':
            return (
              <div key={key} className="terminal-line look-result-wrapper">
                <LookResult data={line.data} />
              </div>
            );
          
          // For our new structured 'chat' messages, use the ChatMessage component.
          case 'chat':
            return <ChatMessage key={key} data={line.data} />;

          // For everything else ('html' type or any legacy strings),
          // render it as raw HTML. This is our default fallback.
          case 'html':
          default:
            return (
              <div
                key={key}
                className="terminal-line"
                dangerouslySetInnerHTML={{ __html: line.data }}
              />
            );
        }
      })}
    </div>
  );
});

export default TerminalOutput;
--- END OF FILE frontend/src/components/TerminalOutput.jsx ---

--- START OF FILE frontend/src/services/webSocketService.js ---
// frontend/src/services/webSocketService.js
import useGameStore from '../state/gameStore';
import { v4 as uuidv4 } from 'uuid';

const WS_PROTOCOL = 'wss:';
const WS_HOST = 'llmud.trazen.org';

const { getState, setState } = useGameStore;

let socket = null;

const createLogEntry = (type, data) => ({
  id: uuidv4(),
  type: type,
  data: data,
});

// THIS IS THE CORRECTED FUNCTION BLOCK
const handleMessage = (event) => {
    try {
        const serverData = JSON.parse(event.data);
        console.log("WS RCV:", serverData);

        // <<< THE FIX: Get the functions from the store at the time of execution.
        const { addLogLine, addMessage } = getState();

        switch (serverData.type) {
            case "welcome_package":
                setState((state) => {
                    if (serverData.log && serverData.log.length > 0) {
                        const newLogEntries = serverData.log.map(line => createLogEntry('html', line));
                        state.logLines.push(...newLogEntries);
                    }
                    if (serverData.character_vitals) {
                        state.vitals.hp.current = serverData.character_vitals.current_hp;
                        state.vitals.hp.max = serverData.character_vitals.max_hp;
                        state.vitals.mp.current = serverData.character_vitals.current_mp;
                        state.vitals.mp.max = serverData.character_vitals.max_mp;
                        state.vitals.xp.current = serverData.character_vitals.current_xp;
                        if (serverData.character_vitals.next_level_xp !== undefined) {
                            state.vitals.xp.max = serverData.character_vitals.next_level_xp;
                        }
                        state.characterLevel = serverData.character_vitals.level;
                    }
                    if (serverData.room_data) {
                        state.currentRoomId = serverData.room_data.id;
                        getState().fetchMapData(serverData.room_data.z);
                    }
                });
                break;

            case "combat_update":
                setState((state) => {
                    if (serverData.log && serverData.log.length > 0) {
                        const newLogEntries = serverData.log.map(line => createLogEntry('html', line));
                        state.logLines.push(...newLogEntries);
                    }
                    if (serverData.character_vitals) {
                        Object.assign(state.vitals, serverData.character_vitals);
                        if(serverData.character_vitals.level) state.characterLevel = serverData.character_vitals.level;
                    }
                    if (serverData.room_data) {
                        state.currentRoomId = serverData.room_data.id;
                        const currentZ = state.mapData ? state.mapData.z_level : null;
                        if (currentZ !== null && currentZ !== serverData.room_data.z) {
                            getState().fetchMapData(serverData.room_data.z);
                        }
                    }
                });
                break;

            case "look_response":
                setState(state => {
                    state.logLines.push(createLogEntry('look', serverData)); 
                    if (serverData.room_data) {
                        state.currentRoomId = serverData.room_data.id;
                        const currentZ = state.mapData ? state.mapData.z_level : null;
                        if (currentZ === null || currentZ !== serverData.room_data.z) {
                             getState().fetchMapData(serverData.room_data.z);
                        }
                    }
                });
                break;

            case "vitals_update":
                setState((state) => {
                    Object.assign(state.vitals, serverData);
                    if(serverData.level) state.characterLevel = serverData.level;
                });
                break;
            
            case "inventory_update":
                setState(state => {
                    state.inventory = serverData.inventory_data;
                });
                break;

            case "game_event":
            // THIS CASE IS FOR NPC SPEECH, MOB MOVEMENTS, ETC.
            // IT CORRECTLY USES addLogLine TO ONLY GO TO THE TERMINAL.
                if(serverData.message) addLogLine(serverData.message, 'html');
                break;
            
            // This case should no longer be used by the backend for chat,
            // but we'll leave it in as a fallback to prevent crashes.
            case "ooc_message":
                 if(serverData.message) addLogLine(serverData.message, 'html');
                 break;
                 
            // <<< THIS IS THE NEW, CORRECT CASE FOR OUR STRUCTURED CHAT >>>
            case "chat_message":
                if (serverData.payload) {
                    addMessage(serverData.payload);
                }
                break;
 
            default:
                console.warn("Unhandled WS message type:", serverData.type, serverData);
                addLogLine(`<span class="system-message-inline">Unhandled event: ${serverData.type}</span>`, 'html');
                break;
        }

    } catch (e) {
        console.error("Error parsing or handling WebSocket message:", e);
    }
};

const handleClose = (event) => {
    console.log("WebSocket connection closed:", event.code, event.reason);
    socket = null;
    const { addLogLine } = getState();
    const closeMessage = `! Game server connection closed. (Code: ${event.code} ${event.reason || ''})`.trim();
    addLogLine(`<span class="system-message-inline">${closeMessage}</span>`, 'html');
};

const handleError = (event) => {
    console.error("WebSocket error observed:", event);
    const { addLogLine } = getState();
    addLogLine('<span class="system-message-inline">! WebSocket connection error.</span>', 'html');
};

export const webSocketService = {
    connect: () => {
        const token = getState().token;
        const characterId = getState().characterId;

        if (!token || !characterId) {
            console.error("WS Connect: Missing token or character ID.");
            return;
        }

        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log("WebSocket already open.");
            return;
        }

        const wsUrl = `${WS_PROTOCOL}//${WS_HOST}/ws?token=${token}&character_id=${characterId}`;
        
        socket = new WebSocket(wsUrl);
        socket.onopen = () => console.log("WebSocket connection established.");
        socket.onmessage = handleMessage;
        socket.onclose = handleClose;
        socket.onerror = handleError;
    },

    disconnect: () => {
        if (socket) {
            socket.close();
        }
    },

    sendMessage: (payload) => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(payload));
        } else {
            console.error("Cannot send WS message: Not connected.");
            const { addLogLine } = getState();
            addLogLine('<span class="system-message-inline">! Cannot send command: Not connected.</span>', 'html');
        }
    },
    
    addClientEcho: (command) => {
        const { addLogLine } = getState();
        addLogLine(`> ${command}`, 'html');
    }
};
--- END OF FILE frontend/src/services/webSocketService.js ---

--- START OF FILE backend/app/api/v1/endpoints/command.py ---
# backend/app/api/v1/endpoints/command.py
from fastapi import APIRouter, Depends, Body
from sqlalchemy.orm import Session
from typing import Dict, Callable, Awaitable

from app import schemas, models, crud
from app.db.session import get_db
from app.api.dependencies import get_current_active_character
from app.commands.command_args import CommandContext
from app.commands import shop_parser

# Import handler modules
from app.commands import chat_parser, movement_parser, inventory_parser, social_parser, debug_parser, meta_parser, interaction_parser
from app.services.chat_manager import chat_manager

import logging
logger = logging.getLogger(__name__)

router = APIRouter()

CommandHandler = Callable[[CommandContext], Awaitable[schemas.CommandResponse]]

COMMAND_REGISTRY: Dict[str, CommandHandler] = {}


# <<< THE FUNCTION DEFINITION YOU RIGHTFULLY POINTED OUT WAS MISSING FROM MY EXPLANATION >>>
def build_command_registry():
    """
    Dynamically builds the command registry at startup.
    This function populates the COMMAND_REGISTRY with both static commands
    and dynamic chat commands loaded from the chat_channels.json file.
    """
    global COMMAND_REGISTRY
    
    # 1. Add all static, non-chat commands to the registry.
    static_commands = {
        # Movement and Perception
        "look": movement_parser.handle_look, "l": movement_parser.handle_look,
        "north": movement_parser.handle_move, "n": movement_parser.handle_move,
        "south": movement_parser.handle_move, "s": movement_parser.handle_move,
        "east": movement_parser.handle_move, "e": movement_parser.handle_move,
        "west": movement_parser.handle_move, "w": movement_parser.handle_move,
        "up": movement_parser.handle_move, "u": movement_parser.handle_move,
        "down": movement_parser.handle_move, "d": movement_parser.handle_move,
        "go": movement_parser.handle_move,

        # Inventory Management
        "inventory": inventory_parser.handle_inventory, "i": inventory_parser.handle_inventory,
        "equip": inventory_parser.handle_equip, "eq": inventory_parser.handle_equip,
        "unequip": inventory_parser.handle_unequip, "uneq": inventory_parser.handle_unequip,
        "drop": inventory_parser.handle_drop,
        "get": inventory_parser.handle_get, "take": inventory_parser.handle_get,

        # Interactions
        "unlock": interaction_parser.handle_unlock,
        "search": interaction_parser.handle_search, "examine": interaction_parser.handle_search,
        "ex": interaction_parser.handle_search, "exa": interaction_parser.handle_search,

        # Local Social Commands (Room-based)
        "say": social_parser.handle_say, "'": social_parser.handle_say,
        "emote": social_parser.handle_emote, ":": social_parser.handle_emote,
        "fart": social_parser.handle_fart,

        # Debug
        "giveme": debug_parser.handle_giveme,
        "spawnmob": debug_parser.handle_spawnmob,
        "set_hp": debug_parser.handle_set_hp,
        "mod_xp": debug_parser.handle_mod_xp,
        "set_level": debug_parser.handle_set_level,
        "setmoney": debug_parser.handle_set_money,
        "addmoney": debug_parser.handle_add_money,

        # Meta
        "score": meta_parser.handle_score, "sc": meta_parser.handle_score,
        "skills": meta_parser.handle_skills, "sk": meta_parser.handle_skills,
        "traits": meta_parser.handle_traits, "tr": meta_parser.handle_traits,
        "status": meta_parser.handle_score, "st": meta_parser.handle_score,
        "help": meta_parser.handle_help, "?": meta_parser.handle_help,

        # Shop commands
        "list": shop_parser.handle_list,
        "buy": shop_parser.handle_buy,
        "sell": shop_parser.handle_sell,
    }
    COMMAND_REGISTRY.update(static_commands)

    # 2. Add all dynamic chat commands from the ChatManager.
    for command_alias in chat_manager.command_to_channel_map.keys():
        COMMAND_REGISTRY[command_alias.lower()] = chat_parser.handle_chat_command
    
    logger.info(f"Command registry built with {len(COMMAND_REGISTRY)} total commands.")

build_command_registry()

# <<< NEW CORE LOGIC FUNCTION >>>
async def execute_command_logic(context: CommandContext) -> schemas.CommandResponse:
    """The one true command processing function, now with consolidated permission checks."""

    # --- Permission Check for STATIC Debug/Sysop Commands ---
    # The new chat system handles permissions for dynamic channels like 'godsay' on its own.
    # We only need to protect the old-school, hardcoded debug commands here.
    static_sysop_commands = ["giveme", "spawnmob", "set_hp", "mod_xp", "set_level", "setmoney", "addmoney", "setgod"]
    if context.command_verb in static_sysop_commands:
        # Check if the character's owner has the 'is_sysop' flag.
        is_sysop = hasattr(context.active_character, 'owner') and context.active_character.owner.is_sysop
        if not is_sysop:
            return schemas.CommandResponse(message_to_player="A strange force prevents you from using that command.")

    # 1. Check the dynamically-built command registry.
    handler = COMMAND_REGISTRY.get(context.command_verb)
    if handler:
        return await handler(context)

    # 2. Check for interactable action verbs as a fallback.
    # This logic would be fully implemented here. For now, it's a placeholder.
    if context.current_room_orm.interactables:
        target_interactable_name = " ".join(context.args).lower()
        for interactable_dict in context.current_room_orm.interactables:
            try:
                # This is where you would put the full logic to match the verb and target
                # with an interactable object's action_verb and name/id_tag.
                # If a match is found, you would call the interaction parser.
                # e.g., return await interaction_parser.handle_contextual_interactable_action(context, matched_interactable)
                pass # Placeholder for full implementation
            except Exception as e:
                # Log error if interactable data is malformed
                logger.error(f"Could not parse interactable for contextual command: {e}")
                continue

    # 3. Handle commands that are exclusively for real-time WebSocket interaction.
    # This prevents them from being accidentally processed via other means.
    real_time_verbs = ["attack", "atk", "kill", "k", "use", "flee", "rest"]
    if context.command_verb in real_time_verbs:
        return schemas.CommandResponse(
            message_to_player=f"Actions like '{context.command_verb}' are handled in real-time. (This is a WebSocket-only command)"
        )

    # 4. If no handler is found after all checks, return the default unknown command message.
    return schemas.CommandResponse(
        message_to_player=f"I don't understand the command: '{context.original_command}'. Type 'help' or '?'."
    )


# <<< THE HTTP ENDPOINT IS NOW JUST A THIN WRAPPER >>>
@router.post("", response_model=schemas.CommandResponse)
async def process_command_for_character(
    payload: schemas.CommandRequest = Body(...),
    db: Session = Depends(get_db),
    active_character: models.Character = Depends(get_current_active_character)
):
    original_command_text = payload.command.strip()
    if not original_command_text:
        return schemas.CommandResponse(message_to_player="Please type a command.")

    command_parts = original_command_text.split()
    command_verb = command_parts[0].lower()
    args = command_parts[1:]

    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    if not current_room_orm:
        return schemas.CommandResponse(message_to_player="CRITICAL ERROR: Character in void.")
    
    context = CommandContext(
        db=db,
        active_character=active_character,
        current_room_orm=current_room_orm,
        current_room_schema=schemas.RoomInDB.from_orm(current_room_orm),
        original_command=original_command_text,
        command_verb=command_verb,
        args=args
    )

    # Call the new shared logic function
    response = await execute_command_logic(context)
    
    # HTTP endpoint still needs to commit the transaction if changes were made
    if response.message_to_player or response.room_data or response.special_payload:
        db.commit()

    return response
--- END OF FILE backend/app/api/v1/endpoints/command.py ---

--- START OF FILE frontend/src/state/gameStore.js ---
// frontend/src/state/gameStore.js
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { apiService } from '../services/apiService';
import { v4 as uuidv4 } from 'uuid';

const createLogLine = (data, type = 'html') => ({
  id: uuidv4(),
  type,
  data,
});

const initialState = {
  sessionState: 'LOGGED_OUT',
  token: null,
  characterId: null,
  characterName: '',
  characterClass: '',
  characterLevel: 1,
  characterList: [],
  classTemplates: [],
  logLines: [createLogLine('<span class="system-message-inline">Zustand brain is online. Please log in.</span>')],
  hasUnreadChatMessages: false,
  vitals: { hp: { current: 100, max: 100 }, mp: { current: 50, max: 50 }, xp: { current: 0, max: 100 }, platinum: 0, gold: 0, silver: 0, copper: 0 },
  mapData: null,
  currentRoomId: null,
  activeTab: 'Terminal',
  characterStats: null,
  inventory: null,
  abilities: null,
  whoListData: null,
};

const useGameStore = create(
  immer((set, get) => ({
    ...initialState,

    // === ACTIONS ===
    // For simple, pre-formatted HTML messages
    addLogLine: (data) => {
      set((state) => {
        state.logLines.push(createLogLine(data, 'html'));
      });
    },

    // For new structured chat payloads
    addMessage: (chatPayload) => {
      set((state) => {
        state.logLines.push(createLogLine(chatPayload, 'chat'));
        if (get().activeTab !== 'Chat') {
          state.hasUnreadChatMessages = true;
        }
      });
    },

    setSessionState: (newState) => set({ sessionState: newState }),
    login: (token) => set({ token, sessionState: 'CHAR_SELECT' }),
    startCharacterCreation: () => set({ sessionState: 'CHAR_CREATE' }),
    setClassTemplates: (templates) => set({ classTemplates: templates }),
    finishCharacterCreation: () => set({ sessionState: 'CHAR_SELECT' }),
    setCharacterList: (characters) => set({ characterList: characters }),

    selectCharacter: (character) => {
      set((state) => {
        state.characterId = character.id;
        state.characterName = character.name;
        state.characterClass = character.class_name;
        state.characterLevel = character.level;
        state.currentRoomId = character.current_room_id;
        state.sessionState = 'IN_GAME';
        state.logLines = [createLogLine(`<span class="system-message-inline">Welcome, ${character.name}!</span>`)];
      });
      get().fetchMapData();
    },

    setVitals: (vitalsUpdate) => set((state) => { Object.assign(state.vitals, vitalsUpdate); if (vitalsUpdate.level) state.characterLevel = vitalsUpdate.level; }),
    setInventory: (inventoryData) => set({ inventory: inventoryData }),
    setActiveTab: (tabName) => {
      if (tabName === 'Chat') {
        set({ hasUnreadChatMessages: false });
      }
      set({ activeTab: tabName });
      const state = get();
      if (tabName === 'Score' && !state.characterStats) state.fetchScoreSheet();
      if ((tabName === 'Backpack' || tabName === 'Equipment') && !state.inventory) state.fetchInventory();
      if ((tabName === 'Skills/Spells' || tabName === 'Traits') && !state.abilities) state.fetchAbilities();
    },

    fetchAbilities: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const abilitiesData = await apiService.fetchAbilities(token);
        set({ abilities: abilitiesData });
      } catch (error) {
        console.error("Failed to fetch abilities:", error);
        get().addLogLine("! Could not retrieve skills and traits list.");
      }
    },

    fetchScoreSheet: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const charDetails = await apiService.fetchCharacterDetails(token);
        set({ characterStats: charDetails });
      } catch (error) {
        console.error("Failed to fetch score sheet:", error);
        get().addLogLine("! Could not retrieve character score sheet.");
      }
    },

    fetchInventory: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const inventoryData = await apiService.fetchInventory(token);
        set({ inventory: inventoryData });
      } catch (error) {
        console.error("Failed to fetch inventory:", error);
        get().addLogLine("! Could not retrieve inventory.");
      }
    },

    fetchMapData: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const mapData = await apiService.fetchMapData(token);
        set({ mapData: mapData });
      } catch (error) {
        console.error("Failed to fetch map data:", error);
        get().addLogLine("! Failed to load map data.");
      }
    },

    fetchWhoList: async () => {
      get().addLogLine("! 'Who' command not yet implemented.");
    },

    logout: () => {
      set({ ...initialState, logLines: [createLogLine('<span class="system-message-inline">You have been logged out. Please log in again.</span>')] });
    },
  }))
);

export default useGameStore;
--- END OF FILE frontend/src/state/gameStore.js ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
