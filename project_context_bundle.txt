--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Mon Jun  2 02:54:21 PM UTC 2025

--- START OF FILE backend/app/main.py ---
# backend/app/main.py
import asyncio
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session

from app.api.v1.api_router import api_router as v1_api_router
from app.websocket_router import router as ws_router # <<< NEW
from app.db.session import engine, get_db
from app.db import base_class
from app.core.config import settings
from app.crud.crud_room import seed_initial_world
from app.crud.crud_item import seed_initial_items 
from app.crud.crud_mob import seed_initial_mob_templates
from app.game_logic.combat_manager import start_combat_ticker_task, stop_combat_ticker_task
from app.crud.crud_character_class import seed_initial_character_class_templates 
from app.crud.crud_skill import seed_initial_skill_templates # <<< NEW
from app.crud.crud_trait import seed_initial_trait_templates # <<< NEW
from app.game_logic.world_ticker import start_world_ticker_task, stop_world_ticker_task
from app.crud.crud_mob_spawn_definition import seed_initial_mob_spawn_definitions 

base_class.Base.metadata.create_all(bind=engine)
app = FastAPI(title=settings.PROJECT_NAME)

@app.on_event("startup")
def on_startup_sync(): # Renamed to avoid clash if we make it async later
    db: Session = next(get_db())
    try:
        print("Running startup event: Seeding initial world...")
        seed_initial_world(db)        
        seed_initial_mob_templates(db)        
        seed_initial_items(db)
        seed_initial_character_class_templates(db)
        seed_initial_skill_templates(db)
        seed_initial_mob_spawn_definitions(db)
        
        print("Starting combat ticker...")
        start_combat_ticker_task()
        print("Startup event finished.")        

        print("Starting world ticker...") 
        start_world_ticker_task()    
        print("Startup event finished.")     
    finally:
        db.close()

app.include_router(v1_api_router, prefix=settings.API_V1_STR)
app.include_router(ws_router)

@app.get("/")
async def root():
    return {"message": f"Welcome to {settings.PROJECT_NAME}. Now with a World Ticker humming in the background!"}

print("FastAPI app instance created.")
--- END OF FILE backend/app/main.py ---

--- START OF FILE backend/app/core/config.py ---
# backend/app/core/config.py
import os
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict

# Check if we're likely running in an Alembic 'env.py' context BEFORE settings are needed for DB connection
# This is a heuristic. Alembic sets 'alembic.version' in its context.
# A simpler heuristic: if a specific env var for alembic is set.
IS_ALEMBIC_ENV_PY_CONTEXT = os.getenv("ALEMBIC_ENV_PY_RUNNING") == "true"

class Settings(BaseSettings):
    PROJECT_NAME: str = "MUD Project - Backend"
    API_V1_STR: str = "/api/v1"
    
    DATABASE_URL: Optional[str] = "postgresql://dummy_user:dummy_password@dummy_host:5432/dummy_db" if IS_ALEMBIC_ENV_PY_CONTEXT else None
    SECRET_KEY: str = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7" # CHANGE THIS IN PRODUCTION!
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7 # Token expires in 7 days

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8', extra='ignore')

settings = Settings() 

# After instantiation, if it was a dummy, ensure it's overridden if not in Alembic context
# and the real env var is available. This is getting complex.
if IS_ALEMBIC_ENV_PY_CONTEXT and settings.DATABASE_URL is not None and settings.DATABASE_URL.startswith("postgresql://dummy_user"):
    print("INFO: Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.")
elif settings.DATABASE_URL is not None and not settings.DATABASE_URL.startswith("postgresql://dummy_user") and os.getenv("DATABASE_URL"):
     # This would be the normal app run, where env var should override any default
     pass
elif not IS_ALEMBIC_ENV_PY_CONTEXT and not os.getenv("DATABASE_URL"):
    # This will have already failed in Settings() if '...' was used and no env var
    print("WARNING: DATABASE_URL not found in environment for normal app run!")
--- END OF FILE backend/app/core/config.py ---

--- START OF FILE backend/app/core/security.py ---
# backend/app/core/security.py
from datetime import datetime, timedelta, timezone # Use timezone-aware datetimes
from typing import Optional, Any, Union
from jose import JWTError, jwt # Import from jose
from passlib.context import CryptContext

from ..core.config import settings # Import our settings instance

# Initialize CryptContext. We'll use bcrypt.
# "auto" will use the first scheme (bcrypt) for hashing new passwords
# and will also be able to verify passwords hashed with any scheme listed.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(subject: Union[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode = {"exp": expire, "sub": str(subject)} # "sub" is the standard claim for subject (e.g., player_id)
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
--- END OF FILE backend/app/core/security.py ---

--- START OF FILE backend/app/db/session.py ---
# backend/app/db/session.py
import time
from sqlalchemy import create_engine, exc
from sqlalchemy.orm import sessionmaker
from ..core.config import settings

if settings.DATABASE_URL is None:
    raise ValueError("DATABASE_URL is not set in the environment or configuration.")

MAX_RETRIES = 10
RETRY_DELAY = 5 # seconds

def create_db_engine_with_retries():
    for attempt in range(MAX_RETRIES):
        try:
            assert settings.DATABASE_URL is not None, "DATABASE_URL cannot be None"
            engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)
            # Try to establish a connection to check if DB is ready
            with engine.connect() as connection:
                print("Database connection successful.")
                return engine
        except exc.OperationalError as e:
            print(f"Database connection attempt {attempt + 1}/{MAX_RETRIES} failed: {e}")
            if attempt < MAX_RETRIES - 1:
                print(f"Retrying in {RETRY_DELAY} seconds...")
                time.sleep(RETRY_DELAY)
            else:
                print("Max retries reached. Could not connect to the database.")
                raise
    # This line should ideally not be reached if MAX_RETRIES > 0
    # but as a fallback or if MAX_RETRIES is 0:
    raise exc.OperationalError("Could not connect to database after multiple retries or no retries configured.", params=None, orig=None) # type: ignore


engine = create_db_engine_with_retries()

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    """
    FastAPI dependency that provides a database session.
    It ensures the session is closed after the request is finished.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
--- END OF FILE backend/app/db/session.py ---

--- START OF FILE backend/app/db/base_class.py ---
# backend/app/db/base_class.py
from sqlalchemy.orm import declarative_base
Base = declarative_base()
--- END OF FILE backend/app/db/base_class.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator # Added Generator for type hint
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session
from jose import JWTError, jwt
from contextlib import contextmanager # For synchronous context manager

from app.db.session import SessionLocal # For WS DB sessions
from app import crud, models, schemas # General app imports
from app.core.config import settings # Corrected settings import
from app.websocket_manager import connection_manager # Global connection manager instance
from app.game_logic import combat_manager # For initiating combat, sending structured messages
from app.commands.utils import ( # Ensure all formatters are imported
    format_room_items_for_player_message, 
    format_room_mobs_for_player_message, 
    format_room_characters_for_player_message, 
    resolve_mob_target
)

router = APIRouter()

# --- Synchronous DB Session Context Manager for WebSocket Handlers ---
@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    """Helper to authenticate a player from a JWT token."""
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str)
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError):
        return None

@router.websocket("/ws") # Main WebSocket endpoint
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character: Optional[models.Character] = None

    # --- Authentication and Character Validation (uses one DB session) ---
    with get_db_sync() as db: # Use synchronous context manager
        player = await get_player_from_token(token, db)
        if not player:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return

        character = crud.crud_character.get_character(db, character_id=character_id)
        if not character or character.player_id != player.id:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
    # --- End Authentication and Character Validation ---

    # If successful, connect to the manager
    await connection_manager.connect(websocket, player.id, character.id)
    
    # --- Send Initial Game State ---
    initial_messages = [f"Welcome {character.name}! You are connected."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db: 
        initial_room_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.")

            items_on_ground = crud.crud_room_item.get_items_in_room(db, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: initial_messages.append(items_text)
            
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: initial_messages.append(mobs_text)

            # <<< NEW: Add other characters to initial message
            other_chars_in_room = crud.crud_character.get_characters_in_room(
                db, room_id=initial_room_orm.id, exclude_character_id=character.id
            )
            chars_text_initial = format_room_characters_for_player_message(other_chars_in_room)
            if chars_text_initial: initial_messages.append(chars_text_initial)
    
    await combat_manager.send_combat_log( 
        player_id=player.id, 
        messages=initial_messages,
        room_data=initial_room_schema 
    )
    # --- End Initial Game State ---

    try:
        while True:
            # Expect JSON messages from client: {"type": "command", "command_text": "..."}
            received_data = await websocket.receive_json()
            
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            with get_db_sync() as db_loop: # New DB session for each incoming message
                # Refresh character ORM object for current state in this session
                # This is important if character state (like room_id) can change via HTTP commands too
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character.id)
                if not current_char_state: # Should not happen if connected
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost")
                    break 
                
                current_room_for_command = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_for_command) if current_room_for_command else None

                print(f"WS command from Player {player.id} (Char {character.id}): '{command_text}' in room {current_char_state.current_room_id}")

                if message_type == "command" and command_text:
                    verb = command_text.split(" ", 1)[0].lower()
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""

                    if verb in ["attack", "atk", "kill", "k"]:
                        if not args_str: # No target specified for attack
                            await combat_manager.send_combat_log(
                                player.id, 
                                ["Attack what? (e.g., 'attack Giant Rat' or 'attack 1')"], 
                                room_data=current_room_schema_for_command
                            )
                            continue # Skip to the next WebSocket message

                        # Fetch mobs in the character's current room for target resolution
                        mobs_in_char_room = crud.crud_mob.get_mobs_in_room(db_loop, room_id=current_char_state.current_room_id)
                        
                        if not mobs_in_char_room:
                            await combat_manager.send_combat_log(
                                player.id, 
                                ["There is nothing here to attack."], 
                                room_data=current_room_schema_for_command
                            )
                            continue

                        # Use the utility function to resolve the target reference
                        target_mob_instance, error_or_prompt = resolve_mob_target(args_str, mobs_in_char_room)
                        
                        if error_or_prompt:
                            # This covers "not found" or ambiguity prompts
                            await combat_manager.send_combat_log(
                                player.id, 
                                [error_or_prompt], 
                                room_data=current_room_schema_for_command
                            )
                        elif target_mob_instance:
                            # Successfully resolved target, now initiate or queue combat
                            # Check if character is already in any combat session
                            is_already_in_any_combat = character.id in combat_manager.active_combats
                            
                            # Check if specifically targeting an already engaged mob (by this character)
                            is_already_targeting_this_specific_mob = False
                            if is_already_in_any_combat:
                                if target_mob_instance.id in combat_manager.active_combats.get(character.id, set()):
                                    is_already_targeting_this_specific_mob = True
                            
                            if not is_already_in_any_combat:
                                # Not in combat, so initiate with this target
                                await combat_manager.initiate_combat_session(
                                    db_loop, player.id, character.id, character.name, target_mob_instance.id
                                )
                            elif not is_already_targeting_this_specific_mob:
                                # In combat, but switching to a new valid target (or adding a new one)
                                # Ensure initiate_combat_session or a similar function correctly adds
                                # this new target to the existing combat session if that's the desired logic,
                                # or if it always starts a "new" combat context against this mob.
                                # For now, let's assume initiate_combat_session can handle adding a new target.
                                # Or, more simply, just update the queued action to this new target.
                                combat_manager.active_combats.setdefault(character.id, set()).add(target_mob_instance.id)
                                combat_manager.mob_targets[target_mob_instance.id] = character.id # Ensure mob targets player
                                combat_manager.character_queued_actions[character.id] = f"attack {target_mob_instance.id}"
                                await combat_manager.send_combat_log(
                                    player.id, 
                                    [f"You switch your attack to the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>!"], 
                                    room_data=current_room_schema_for_command
                                )
                            else: 
                                # Already in combat and already targeting this mob (or re-affirming).
                                # Queue the attack action for the ticker.
                                combat_manager.character_queued_actions[character.id] = f"attack {target_mob_instance.id}"
                                # Optional: Send a minor confirmation, or let the ticker show the next round's action.
                                # await combat_manager.send_combat_log(player.id, [f"Continuing attack on {target_mob_instance.mob_template.name}."], room_data=current_room_schema_for_command)
                                # No 'else' needed for target_mob_instance here, as resolve_mob_target's error_or_prompt covers it.

                    elif verb == "flee":
                        if character.id in combat_manager.active_combats:
                            combat_manager.character_queued_actions[character.id] = "flee"
                            await combat_manager.send_combat_log(player.id, ["You prepare to flee..."], room_data=current_room_schema_for_command)
                        else:
                            await combat_manager.send_combat_log(player.id, ["You are not in combat."], room_data=current_room_schema_for_command)
                    
                    elif verb in ["look", "l"]: # Handle 'look' via WebSocket
                        look_messages = []
                        # Room name/desc will be in room_data part of send_combat_log
                        items_on_ground = crud.crud_room_item.get_items_in_room(db_loop, current_char_state.current_room_id)
                        items_text, _ = format_room_items_for_player_message(items_on_ground)
                        if items_text: look_messages.append(items_text)
                         
                        mobs_in_current_room = crud.crud_mob.get_mobs_in_room(db_loop, current_char_state.current_room_id)
                        mobs_text, _ = format_room_mobs_for_player_message(mobs_in_current_room)
                        if mobs_text: look_messages.append(mobs_text)

                        other_chars_look = crud.crud_character.get_characters_in_room(
                            db_loop, room_id=current_char_state.current_room_id, exclude_character_id=character.id
                        )
                        chars_text_look = format_room_characters_for_player_message(other_chars_look)
                        if chars_text_look: look_messages.append(chars_text_look)

                        await combat_manager.send_combat_log(player.id, look_messages, room_data=current_room_schema_for_command)
                    
                    # TODO: Add more WebSocket command handlers (move, inventory, etc.) or a dispatcher
                    # For commands not handled here, the client would still use HTTP
                    else:
                        await combat_manager.send_combat_log(player.id, [f"Command '{verb}' not yet supported over WebSocket. Try HTTP or combat actions."], room_data=current_room_schema_for_command)
                else: # Unrecognized message type or empty command
                    await combat_manager.send_combat_log(player.id, [f"Unrecognized message type: {message_type} or empty command."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        print(f"WebSocket disconnected for Player {player.id} (Character {character.id})")
        # Clean up combat state for this character
        if character.id in combat_manager.active_combats:
            combat_manager.active_combats.pop(character.id, None)
            mobs_to_clear = [mid for mid, cid_target in combat_manager.mob_targets.items() if cid_target == character.id]
            for mid in mobs_to_clear: combat_manager.mob_targets.pop(mid, None)
        combat_manager.character_queued_actions.pop(character.id, None)
    except Exception as e:
        print(f"Error in WebSocket for Player {player.id} (Character {character.id}): {e}")
        # Attempt to send an error to client if possible, then close
        try:
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred."})
        except Exception:
            pass # Ignore if send fails (connection likely already broken)
    finally:
        # This ensures disconnect is called even if an error occurs within the try block
        # before WebSocketDisconnect is raised.
        connection_manager.disconnect(player.id) 
        print(f"Cleaned up WebSocket resources for Player {player.id} (Character {character.id})")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/websocket_manager.py ---
# backend/app/websocket_manager.py
import uuid
from typing import Dict, List, Optional
from fastapi import WebSocket
from fastapi.encoders import jsonable_encoder

class ConnectionManager:
    def __init__(self):
        # player_id -> WebSocket mapping
        self.active_player_connections: Dict[uuid.UUID, WebSocket] = {}
        # player_id -> active_character_id mapping (CRUCIAL for WS knowing context)
        self.player_active_characters: Dict[uuid.UUID, uuid.UUID] = {}

    async def connect(self, websocket: WebSocket, player_id: uuid.UUID, character_id: uuid.UUID):
        await websocket.accept()
        self.active_player_connections[player_id] = websocket
        self.player_active_characters[player_id] = character_id # Associate character with this WS connection
        print(f"Player {player_id} (Character {character_id}) connected via WebSocket.")

    def disconnect(self, player_id: uuid.UUID):
        if player_id in self.active_player_connections:
            del self.active_player_connections[player_id]
        if player_id in self.player_active_characters:
            del self.player_active_characters[player_id]
        print(f"Player {player_id} disconnected from WebSocket.")

    def get_character_id(self, player_id: uuid.UUID) -> Optional[uuid.UUID]:
        return self.player_active_characters.get(player_id)

    async def send_personal_message(self, message_payload: dict, player_id: uuid.UUID): # Expects a dict
        if player_id in self.active_player_connections:
            websocket = self.active_player_connections[player_id]
            try:
                encoded_payload = jsonable_encoder(message_payload) # <<< USE JSONABLE ENCODER
                await websocket.send_json(encoded_payload)
            except Exception as e:
                # Log the original payload to see what might have caused an issue
                # Be careful logging sensitive data in production
                print(f"Error sending WS message to {player_id}: {e} (Original payload structure might be an issue for encoding: {type(message_payload)})")
                # For more detailed debug, print keys and types of values in message_payload
                # for k, v in message_payload.items():
                #     print(f"DEBUG PAYLOAD: key='{k}', type='{type(v)}'")
                #     if k == 'room_data' and v is not None:
                #         for rk, rv in v.items() if isinstance(v, dict) else vars(v).items() if hasattr(v, '__dict__') else []:
                #              print(f"  RoomData Sub: key='{rk}', type='{type(rv)}'")


    async def broadcast_to_room(self, message: dict, room_id: uuid.UUID, db_session_getter, current_player_id_to_skip: Optional[uuid.UUID] = None):
        # This is more advanced: requires knowing which players/characters are in which room
        # For now, this is a placeholder for future room-based broadcasts
        # It would iterate through self.active_player_connections, get their char_id,
        # then query DB (via db_session_getter) for char's room_id.
        print(f"Placeholder: Broadcast to room {room_id}: {message}")
        # For a simple broadcast to all connected (not room specific):
        # for player_id, websocket in self.active_player_connections.items():
        #     if player_id != current_player_id_to_skip:
        #         try:
        #             await websocket.send_json(message)
        #         except Exception:
        #             pass # Handle send errors or disconnects

    async def broadcast_to_players(self, message_payload: dict, player_ids: List[uuid.UUID]):
        """Sends a message to a specific list of connected player_ids."""
        encoded_payload = jsonable_encoder(message_payload)
        for player_id in player_ids:
            if player_id in self.active_player_connections:
                websocket = self.active_player_connections[player_id]
                try:
                    await websocket.send_json(encoded_payload)
                except Exception as e:
                    print(f"Error broadcasting to player {player_id}: {e}")
                    # Handle any specific cleanup or logging here
    def is_player_connected(self, player_id: uuid.UUID) -> bool:
        return player_id in self.active_player_connections
    
    def get_all_active_player_ids(self) -> List[uuid.UUID]: # Helper
        return list(self.active_player_connections.keys())

# Global instance
connection_manager = ConnectionManager()
--- END OF FILE backend/app/websocket_manager.py ---

--- START OF FILE backend/app/game_logic/combat_manager.py ---
# backend/app/game_logic/combat_manager.py
import asyncio
import uuid
import random
from typing import Dict, List, Set, Optional, Any

from sqlalchemy.orm import Session 

from app.db.session import SessionLocal 
from app import crud, models, schemas # Ensure all are available
from app.websocket_manager import connection_manager as ws_manager
from app.commands.utils import roll_dice, format_room_mobs_for_player_message, format_room_items_for_player_message 

from contextlib import contextmanager
@contextmanager
def db_session_for_task_sync(): 
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

active_combats: Dict[uuid.UUID, Set[uuid.UUID]] = {}
mob_targets: Dict[uuid.UUID, uuid.UUID] = {}
character_queued_actions: Dict[uuid.UUID, Optional[str]] = {}

COMBAT_ROUND_INTERVAL = 3.0

async def send_combat_log(player_id: uuid.UUID, messages: List[str], combat_ended: bool = False, room_data: Optional[schemas.RoomInDB] = None):
    if not messages and not combat_ended and not room_data:
        return

    payload = {
        "type": "combat_update",
        "log": messages,
        "combat_over": combat_ended,
        "room_data": room_data.model_dump() if room_data else None
    }
    await ws_manager.send_personal_message(payload, player_id)

async def _broadcast_combat_event(db: Session, room_id: uuid.UUID, acting_player_id: uuid.UUID, message: str):
    """Helper to broadcast a simplified combat message to others in the room."""
    # Get the character ID of the acting player to exclude their character model from the room query
    acting_char_id: Optional[uuid.UUID] = ws_manager.get_character_id(acting_player_id)

    player_ids_to_notify = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            db, room_id=room_id, exclude_character_id=acting_char_id
        ) if ws_manager.is_player_connected(char.player_id) and char.player_id != acting_player_id # Double ensure not sending to self
    ]
    if player_ids_to_notify:
        payload = {"type": "game_event", "message": message} # Using "game_event" for simplicity
        await ws_manager.broadcast_to_players(payload, player_ids_to_notify)

async def initiate_combat_session(
    db: Session, 
    player_id: uuid.UUID, 
    character_id: uuid.UUID, 
    character_name: str, # Name can be fetched from character object if needed
    target_mob_instance_id: uuid.UUID
):
    mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_instance_id)
    if not mob_instance or mob_instance.current_health <= 0:
        await send_combat_log(player_id, ["Target is invalid or already dead."])
        return False

    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character or character.current_health <= 0:
        await send_combat_log(player_id, ["You are too dead or incapacitated to start combat."])
        return False

    active_combats.setdefault(character_id, set()).add(target_mob_instance_id)
    mob_targets[target_mob_instance_id] = character_id 
    character_queued_actions[character_id] = f"attack {target_mob_instance_id}"

    await send_combat_log(player_id, [f"<span class='char-name'>{character.name}</span> engages the <span class='inv-item-name'>{mob_instance.mob_template.name}</span>!"])
    return True

async def combat_ticker_loop():
    while True:
        await asyncio.sleep(COMBAT_ROUND_INTERVAL)
        
        with db_session_for_task_sync() as db:
            player_ids_to_process = list(ws_manager.active_player_connections.keys())

            for player_id in player_ids_to_process:
                character_id = ws_manager.get_character_id(player_id) 
                if character_id and character_id in active_combats:
                    # Double check character is still alive before processing round
                    # This check might be redundant if process_combat_round handles it robustly.
                    char_check = crud.crud_character.get_character(db, character_id=character_id)
                    if char_check and char_check.current_health > 0:
                        await process_combat_round(db, character_id, player_id)
                    elif char_check and char_check.current_health <= 0 and character_id in active_combats:
                        # Character died, but combat state wasn't cleaned up. Clean it.
                        active_combats.pop(character_id, None)
                        mobs_to_clear_target = [mid for mid, cid in mob_targets.items() if cid == character_id]
                        for mid in mobs_to_clear_target: mob_targets.pop(mid, None)
                        character_queued_actions.pop(character_id, None)
                        # No need to send log here, process_combat_round or client disconnect handles it
                        print(f"Cleaned up combat state for dead char {character_id} in ticker loop.")


async def _get_other_connected_player_ids_in_room(db: Session, room_id: uuid.UUID, exclude_player_id: uuid.UUID) -> List[uuid.UUID]:
    # First, get character_id of the excluded player
    excluded_char_id: Optional[uuid.UUID] = None
    excluded_player_char = ws_manager.get_character_id(exclude_player_id) # Assuming ws_manager stores current char for player
    if excluded_player_char:
        excluded_char_id = excluded_player_char
    
    # Now fetch other characters in the room
    other_characters_in_room = crud.crud_character.get_characters_in_room(
        db, room_id=room_id, exclude_character_id=excluded_char_id # Exclude the character object
    )
    
    player_ids_to_broadcast = [
        char.player_id for char in other_characters_in_room 
        if ws_manager.is_player_connected(char.player_id) and char.player_id != exclude_player_id
    ]
    return player_ids_to_broadcast

_combat_ticker_task = None

def start_combat_ticker_task():
    global _combat_ticker_task
    if _combat_ticker_task is None:
        print("Starting combat ticker task...")
        _combat_ticker_task = asyncio.create_task(combat_ticker_loop())
        print("Combat ticker task created. God help us all.")
    else:
        print("Combat ticker task already running or requested. Don't get greedy.")

def stop_combat_ticker_task(): 
    global _combat_ticker_task
    if _combat_ticker_task and not _combat_ticker_task.done():
        print("Stopping combat ticker task...")
        _combat_ticker_task.cancel()
        _combat_ticker_task = None
        print("Combat ticker task cancelled. Probably for the best.")

async def process_combat_round(db: Session, character_id: uuid.UUID, player_id: uuid.UUID):
    # --- Initial Checks ---
    if character_id not in active_combats or not active_combats[character_id]:
        return 

    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character: 
        # ... (cleanup logic for invalid character, as before) ...
        active_combats.pop(character_id, None)
        mobs_to_clear_target = [mid for mid, cid in mob_targets.items() if cid == character_id]
        for mid in mobs_to_clear_target: mob_targets.pop(mid, None)
        character_queued_actions.pop(character_id, None)
        return

    if character.current_health <= 0:
        # ... (cleanup logic for dead character, send final personal log, as before) ...
        if character_id in active_combats:
            round_log_dead_char = ["You are dead and cannot act."]
            active_combats.pop(character_id, None)
            # ... (cleanup mob_targets, character_queued_actions) ...
            current_room_for_update = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
            current_room_schema_for_update = schemas.RoomInDB.from_orm(current_room_for_update) if current_room_for_update else None
            await send_combat_log(player_id, round_log_dead_char, True, current_room_schema_for_update)
        return

    # --- Setup for Round ---
    char_combat_stats = character.calculate_combat_stats()
    player_current_hp = character.current_health # Keep a local copy for this round's logic
    player_max_hp = character.max_health
    player_ac = char_combat_stats["effective_ac"]
    
    round_log: List[str] = [] # For this player's detailed log
    combat_resolved_this_round = False
    action_str = character_queued_actions.get(character_id)
    character_queued_actions[character_id] = None # Consume action
    current_room_id_for_broadcast = character.current_room_id # For broadcasting context

    # --- Player's Action ---
    if action_str == "flee":
        if random.random() < 0.5: # Success
            round_log.append("<span class='combat-success'>You successfully flee from combat!</span>")
            combat_resolved_this_round = True
            await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id, 
                                          f"<span class='char-name'>{character.name}</span> flees from combat!")
            # TODO: Actual movement logic if flee changes room
        else: # Fail
            round_log.append("<span class='combat-miss'>Your attempt to flee fails!</span>")
            await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                          f"<span class='char-name'>{character.name}</span> tries to flee, but fails!")

    elif action_str and action_str.startswith("attack"):
        try:
            target_mob_id_str = action_str.split(" ", 1)[1]
            target_mob_id = uuid.UUID(target_mob_id_str)
        except (IndexError, ValueError): target_mob_id = None

        if target_mob_id and target_mob_id in active_combats.get(character_id, set()):
            mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_id)
            if mob_instance and mob_instance.current_health > 0:
                mob_template = mob_instance.mob_template
                mob_ac = mob_template.base_defense if mob_template.base_defense is not None else 10
                
                # Player's attack stats from char_combat_stats
                player_attack_bonus = char_combat_stats["attack_bonus"]
                player_damage_dice = char_combat_stats["damage_dice"]
                player_damage_bonus = char_combat_stats["damage_bonus"]
                
                to_hit_roll = roll_dice("1d20")
                if (to_hit_roll + player_attack_bonus) >= mob_ac: # Player Hits
                    damage = max(1, roll_dice(player_damage_dice) + player_damage_bonus)
                    is_crit = False # Replace with actual crit logic if desired
                    damage_class = "combat-crit" if is_crit else "combat-hit"
                    
                    round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>HITS</span> <span class='inv-item-name'>{mob_template.name}</span> for <span class='{damage_class}'>{damage}</span> damage.")
                    await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"<span class='char-name'>{character.name}</span> HITS <span class='inv-item-name'>{mob_template.name}</span> for {damage} damage!")

                    updated_mob = crud.crud_mob.update_mob_instance_health(db, mob_instance.id, -damage)
                    if updated_mob and updated_mob.current_health <= 0: # Mob Dies
                        round_log.append(f"<span class='combat-death'>The {mob_template.name} DIES! Fucking finally.</span>")
                        await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                      f"The <span class='inv-item-name'>{mob_template.name}</span> DIES!")
                        
                        crud.crud_mob.despawn_mob_from_room(db, updated_mob.id) # This now handles spawn point timer reset
                        active_combats.get(character_id, set()).discard(updated_mob.id)
                        mob_targets.pop(updated_mob.id, None)
                        
                        if mob_template.xp_value > 0:
                            _, xp_messages = crud.crud_character.add_experience(db, character_id, mob_template.xp_value)
                            round_log.extend(xp_messages) # add_experience now returns messages
                            # No need to broadcast XP messages typically, it's personal.
                    elif updated_mob:
                        round_log.append(f"  {mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{mob_template.base_health}</span>.")
                else: # Player Misses
                    round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{mob_template.name}</span>.")
                    await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"<span class='char-name'>{character.name}</span> MISSES the <span class='inv-item-name'>{mob_template.name}</span>.")
            else: 
                active_combats.get(character_id, set()).discard(target_mob_id)
                round_log.append(f"Your target seems to have vanished or was already dealt with.")
        else: 
             round_log.append("You swing wildly at nothing in particular. What a muppet.")
    
    if not active_combats.get(character_id): 
        if not combat_resolved_this_round: # Only add this if not already resolved by flee/all mobs dead
            round_log.append("All targets are defeated or gone. You can stop flailing now.")
        combat_resolved_this_round = True

    # --- Mobs' Actions (Retaliation) ---
    if not combat_resolved_this_round and character.current_health > 0:
        mobs_attacking_player = [mid for mid, cid_target in mob_targets.items() if cid_target == character_id and mid in active_combats.get(character_id, set())]
        
        for mob_instance_id in mobs_attacking_player:
            if character.current_health <= 0: break # Player might have died from a previous mob this round

            mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_instance_id)
            if not mob_instance or mob_instance.current_health <= 0: 
                active_combats.get(character_id, set()).discard(mob_instance_id) 
                mob_targets.pop(mob_instance_id, None)
                continue

            mob_template = mob_instance.mob_template
            mob_attack_bonus = mob_template.level or 1 
            mob_damage_dice = mob_template.base_attack or "1d4"
            mob_to_hit = roll_dice("1d20")

            if (mob_to_hit + mob_attack_bonus) >= player_ac: # Mob Hits
                damage_to_player = max(1, roll_dice(mob_damage_dice))
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-success'>HITS</span> <span class='char-name'>{character.name}</span> for <span class='combat-hit-player'>{damage_to_player}</span> damage. Ouch, buttercup.")
                await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> HITS <span class='char-name'>{character.name}</span> for {damage_to_player} damage!")
                
                updated_char_state = crud.crud_character.update_character_health(db, character_id, -damage_to_player)
                if updated_char_state: player_current_hp = updated_char_state.current_health
                
                round_log.append(f"  Your HP: <span class='combat-hp'>{player_current_hp}/{player_max_hp}</span>.")
                
                if player_current_hp <= 0: # Player Dies
                    round_log.append("<span class='combat-death'>YOU HAVE DIED! How utterly predictable.</span>")
                    await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"<span class='char-name'>{character.name}</span> <span class='combat-death'>HAS DIED!</span>")
                    combat_resolved_this_round = True
                    
                    respawn_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0) # Central Processing Unit
                    if respawn_room_orm:
                        crud.crud_character.update_character_room(db, character_id=character.id, new_room_id=respawn_room_orm.id)
                        round_log.append(f"You have been teleported to {respawn_room_orm.name}.")
                        # The room_data in the final send_combat_log will reflect this new room for the player.
                    else:
                        round_log.append("Error: Respawn room not found. You are now a very dead, very lost ghost.")

                    dead_char_for_heal = crud.crud_character.get_character(db, character_id) 
                    if dead_char_for_heal: # Character should exist
                         crud.crud_character.update_character_health(db, character.id, dead_char_for_heal.max_health)
                         round_log.append("You feel a faint stirring of life, or maybe it's just indigestion.")
                    break # Stop other mobs attacking if player died
            else: # Mob Misses
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-miss'>MISSES</span> <span class='char-name'>{character.name}</span>.")
                await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> MISSES <span class='char-name'>{character.name}</span>.")

    # --- End of Round Cleanup & Next Action ---
    if combat_resolved_this_round:
        active_combats.pop(character_id, None)
        mobs_to_clear_target = [mid for mid, cid in mob_targets.items() if cid == character_id]
        for mid in mobs_to_clear_target: mob_targets.pop(mid, None)
        character_queued_actions.pop(character_id, None) 
    elif character_id in active_combats and character.current_health > 0 : 
        remaining_targets = list(active_combats.get(character_id, [])) # Ensure list for empty set
        if remaining_targets:
            character_queued_actions[character_id] = f"attack {remaining_targets[0]}"
        else: 
            active_combats.pop(character_id, None)
            character_queued_actions.pop(character_id, None)
            combat_resolved_this_round = True 
            if not round_log or not round_log[-1].startswith("All targets"): 
                 round_log.append("No valid targets remain. Combat ends by default.")

    # --- Send Final Log to Player ---
    final_char_state_for_room = crud.crud_character.get_character(db, character_id=character_id)
    # If player died and respawned, their current_room_id is updated.
    current_room_for_update = crud.crud_room.get_room_by_id(db, room_id=final_char_state_for_room.current_room_id) if final_char_state_for_room else None
    current_room_schema_for_update = schemas.RoomInDB.from_orm(current_room_for_update) if current_room_for_update else None
    
    # If combat ended and player is alive, add remaining room context to their personal log
    if combat_resolved_this_round and current_room_for_update and final_char_state_for_room and final_char_state_for_room.current_health > 0 :
        # ... (logic to append remaining mobs/items/characters to round_log for the player) ...
        # This part might be redundant if the room_data itself is sufficient for the client to re-render.
        # For now, let's keep it simple and rely on client re-rendering from room_data or a new 'look'
        pass

    await send_combat_log(player_id, round_log, combat_resolved_this_round, current_room_schema_for_update)
--- END OF FILE backend/app/game_logic/combat_manager.py ---

--- START OF FILE backend/app/game_logic/world_ticker.py ---
# backend/app/game_logic/world_ticker.py
import asyncio
import time 
from typing import Callable, Iterator, List, Awaitable, Dict, Any, Optional # Added Optional
from sqlalchemy.orm import Session
from contextlib import contextmanager

from app.db.session import SessionLocal
# We might need crud/models here if the ticker itself directly does something,
# but generally, tasks will import what they need.

from app.game_logic.mob_respawner import manage_mob_populations_task 

# --- Configuration ---
WORLD_TICK_INTERVAL_SECONDS = 30.0

# --- Task Registry ---
world_tick_tasks: Dict[str, Callable[[Session], Awaitable[None]]] = {}


@contextmanager
def db_session_for_world_tick() -> Iterator[Session]: # <<< CORRECTED RETURN TYPE HINT
    """Provides a DB session for the duration of a world tick's tasks."""
    db = SessionLocal()
    try:
        yield db # Yields the Session object
    finally:
        db.close()

# --- Task Registration Function (defined once) ---
def register_world_tick_task(task_name: str, task_func: Callable[[Session], Awaitable[None]]):
    if task_name in world_tick_tasks:
        print(f"Warning: World tick task '{task_name}' is being redefined.")
    world_tick_tasks[task_name] = task_func
    # print(f"World Ticker: Registered task '{task_name}'.") # Moved to init summary


# --- Import task functions from their respective modules ---
from app.game_logic.mob_respawner import manage_mob_populations_task
# Example for future tasks:
# from app.game_logic.weather_system import update_weather_task
# from app.game_logic.item_decay import process_item_decay_task


# --- Centralized Initialization and Registration of All Tasks ---
def _initialize_and_register_all_world_tasks():
    """
    This function is called once when this module is loaded.
    It registers all known world tick tasks.
    """
    print("World Ticker: Initializing and registering world tick tasks...")
    
    register_world_tick_task("mob_population_manager", manage_mob_populations_task)
    # register_world_tick_task("weather_updater", update_weather_task) # Example
    # register_world_tick_task("item_decay_processor", process_item_decay_task) # Example
    
    print(f"World Ticker: All tasks registered. Active tasks: {list(world_tick_tasks.keys())}")

_initialize_and_register_all_world_tasks() # Execute registration when this module is first imported


# --- Main Ticker Loop ---
async def world_ticker_loop():
    # Message moved to _initialize_and_register_all_world_tasks
    # print(f"World Ticker: Loop starting. Tick interval: {WORLD_TICK_INTERVAL_SECONDS}s.")
    print(f"World Ticker: Loop now running with interval: {WORLD_TICK_INTERVAL_SECONDS}s.")
    while True:
        start_time = time.time()
        
        if not world_tick_tasks:
            await asyncio.sleep(WORLD_TICK_INTERVAL_SECONDS)
            continue

        try:
            with db_session_for_world_tick() as db:
                for task_name, task_func in world_tick_tasks.items():
                    try:
                        await task_func(db)
                    except Exception as e:
                        print(f"ERROR in world_tick task '{task_name}': {e}") # Consider logging full traceback
                db.commit() 
        except Exception as e:
            print(f"CRITICAL ERROR in world_ticker_loop's DB session: {e}") # Consider logging full traceback

        end_time = time.time()
        processing_time = end_time - start_time
        
        sleep_duration = WORLD_TICK_INTERVAL_SECONDS - processing_time
        if sleep_duration < 0:
            print(f"Warning: World tick processing time ({processing_time:.2f}s) exceeded interval ({WORLD_TICK_INTERVAL_SECONDS}s).")
            sleep_duration = 0 
        
        await asyncio.sleep(sleep_duration)

# --- Control Functions ---
_world_ticker_task_handle: Optional[asyncio.Task] = None

def start_world_ticker_task():
    global _world_ticker_task_handle
    if _world_ticker_task_handle is None or _world_ticker_task_handle.done():
        print("World Ticker: Attempting to start task...")
        _world_ticker_task_handle = asyncio.create_task(world_ticker_loop())
        print("World Ticker: Task created and running.")
    else:
        print("World Ticker: Task already running.")

def stop_world_ticker_task():
    global _world_ticker_task_handle
    if _world_ticker_task_handle and not _world_ticker_task_handle.done():
        print("World Ticker: Attempting to stop task...")
        _world_ticker_task_handle.cancel()
        _world_ticker_task_handle = None 
        print("World Ticker: Task cancellation requested.")
    else:
        print("World Ticker: Task not running or already stopped.")
--- END OF FILE backend/app/game_logic/world_ticker.py ---

--- START OF FILE backend/app/game_logic/mob_respawner.py ---
# backend/app/game_logic/mob_respawner.py
import asyncio
from datetime import datetime, timedelta, timezone
from sqlalchemy.orm import Session
import random # For chance_to_spawn_percent
from app.websocket_manager import connection_manager 

from app import crud, models # Ensure models.RoomMobInstance is available

# This task function will be registered by world_ticker.py
async def manage_mob_populations_task(db: Session):
    now = datetime.now(timezone.utc)
    definitions_to_check = crud.crud_mob_spawn_definition.get_definitions_ready_for_check(db, current_time=now)

    if not definitions_to_check:
        return

    for definition in definitions_to_check:
        living_children_count = db.query(models.RoomMobInstance).filter(
            models.RoomMobInstance.spawn_definition_id == definition.id,
            models.RoomMobInstance.current_health > 0
        ).count()

        needed_to_reach_min = definition.quantity_min - living_children_count
        
        if needed_to_reach_min > 0:
            can_spawn_up_to_max = definition.quantity_max - living_children_count
            num_to_attempt_spawn = min(needed_to_reach_min, can_spawn_up_to_max)

            if num_to_attempt_spawn > 0:
                mob_template_for_log = crud.crud_mob.get_mob_template(db, definition.mob_template_id)
                mob_name_for_log = mob_template_for_log.name if mob_template_for_log else "A mysterious creature"
                room_for_log = crud.crud_room.get_room_by_id(db, definition.room_id)
                room_name_for_log = room_for_log.name if room_for_log else "an unknown location"
                
                print(f"Mob Respawner: Definition '{definition.definition_name}' needs {needed_to_reach_min} (attempting {num_to_attempt_spawn}) of '{mob_name_for_log}' in '{room_name_for_log}'.")

                spawned_this_cycle_for_def = 0
                for _ in range(num_to_attempt_spawn):
                    if random.randint(1, 100) <= definition.chance_to_spawn_percent:
                        new_mob = crud.crud_mob.spawn_mob_in_room(
                            db,
                            room_id=definition.room_id,
                            mob_template_id=definition.mob_template_id,
                            originating_spawn_definition_id=definition.id
                        )
                        if new_mob:
                            spawned_this_cycle_for_def +=1
                            # --- BROADCAST SPAWN MESSAGE TO ROOM ---
                            # Ensure mob_template is loaded on new_mob for its name
                            # spawn_mob_in_room should return an instance with mob_template eager loaded if possible,
                            # or we fetch it again if necessary. Assuming new_mob.mob_template is accessible.
                            # If not, fetch the template name again:
                            spawned_mob_name = new_mob.mob_template.name if new_mob.mob_template else "A creature"
                            
                            spawn_message_payload = {
                                "type": "game_event", # Or a more specific "mob_spawn_event"
                                "message": f"<span class='inv-item-name'>{spawned_mob_name}</span> forms from the shadows!" 
                                           # Or "...materializes out of thin air!"
                                           # Or "...crawls out of a crack in the wall!"
                            }
                            
                            # Get player_ids of characters in the room where the mob spawned
                            player_ids_in_spawn_room = [
                                char.player_id for char in crud.crud_character.get_characters_in_room(
                                    db, room_id=definition.room_id 
                                    # No need to exclude anyone, everyone sees the spawn
                                ) if connection_manager.is_player_connected(char.player_id)
                            ]

                            if player_ids_in_spawn_room:
                                print(f"  Broadcasting spawn of '{spawned_mob_name}' to {len(player_ids_in_spawn_room)} players in room {definition.room_id}.")
                                await connection_manager.broadcast_to_players(spawn_message_payload, player_ids_in_spawn_room)
                            # --- END BROADCAST ---
                if spawned_this_cycle_for_def > 0:
                     print(f"  Successfully spawned {spawned_this_cycle_for_def} mobs for '{definition.definition_name}'.")

        next_check = now + timedelta(seconds=definition.respawn_delay_seconds)
        crud.crud_mob_spawn_definition.update_mob_spawn_definition_next_check_time(
            db, definition_id=definition.id, next_check_time=next_check
        )

--- END OF FILE backend/app/game_logic/mob_respawner.py ---

--- START OF FILE backend/app/commands/command_args.py ---
# backend/app/commands/command_args.py
from typing import List, Optional
from sqlalchemy.orm import Session
from pydantic import BaseModel, Field

from app import models, schemas # Ensure these are accessible from app root

class CommandContext(BaseModel):
    db: Session
    active_character: models.Character
    current_room_orm: models.Room 
    current_room_schema: schemas.RoomInDB
    original_command: str 
    command_verb: str
    args: List[str] # The rest of the command words after the verb
    # For more complex parsing, args could be a pre-parsed Pydantic model itself

    class Config:
        arbitrary_types_allowed = True # For SQLAlchemy Session and ORM models
--- END OF FILE backend/app/commands/command_args.py ---

--- START OF FILE backend/app/commands/utils.py ---
# backend/app/commands/utils.py
import re
from typing import List, Optional, Tuple, Dict
import uuid
import random

from app import models, schemas
from app.models.item import EQUIPMENT_SLOTS

def get_visible_length(s: str) -> int: # ... content ...
    return len(re.sub(r'<[^>]+>', '', s))

def format_room_items_for_player_message(room_items: List[models.RoomItemInstance]) -> Tuple[str, Dict[int, uuid.UUID]]: # ... content ...
    lines = []
    item_map: Dict[int, uuid.UUID] = {}
    if room_items:
        lines.append("\nYou also see on the ground:")
        for idx, room_item_instance in enumerate(room_items):
            item_name = room_item_instance.item.name if room_item_instance.item else "Unknown Item"
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            item_name_html = f"<span class='inv-item-name'>{item_name}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {room_item_instance.quantity})</span>"
            prefix_html = f"  {item_number_html} "
            lines.append(f"{prefix_html}{item_name_html} {item_qty_html}")
            item_map[idx + 1] = room_item_instance.id
    return "\n".join(lines), item_map


def format_room_mobs_for_player_message(room_mobs: List[models.RoomMobInstance]) -> Tuple[str, Dict[int, uuid.UUID]]: # ... content ...
    lines = []
    mob_map: Dict[int, uuid.UUID] = {}
    if room_mobs:
        lines.append("\nAlso here:")
        for idx, mob_instance in enumerate(room_mobs):
            template = mob_instance.mob_template
            mob_name = template.name if template else "Unknown Creature"
            mob_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            mob_name_html = f"<span class='inv-item-name'>{mob_name}</span>"
            lines.append(f"  {mob_number_html} {mob_name_html}")
            mob_map[idx + 1] = mob_instance.id
    return "\n".join(lines), mob_map

def format_inventory_for_player_message(inventory_display_schema: schemas.CharacterInventoryDisplay) -> str: # ... content from previous version ...
    lines = []
    equipped_item_parts = [] 
    max_visible_equipped_prefix_len = 0
    if inventory_display_schema.equipped_items:
        for slot_key, inv_item_schema in inventory_display_schema.equipped_items.items():
            processed_slot_key = str(slot_key).strip()
            display_slot_name_raw = EQUIPMENT_SLOTS.get(processed_slot_key, processed_slot_key.capitalize())
            slot_name_html = f"<span class='inv-slot-name'>{display_slot_name_raw}</span>"
            prefix_html = f"  [{slot_name_html}]"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_equipped_prefix_len = max(max_visible_equipped_prefix_len, visible_prefix_len)
            item_name_raw = inv_item_schema.item.name.strip() if inv_item_schema.item else "Unknown Item"
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {inv_item_schema.quantity})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"
            equipped_item_parts.append({'sort_key': display_slot_name_raw,'prefix_html': prefix_html,'visible_prefix_len': visible_prefix_len,'suffix_html': suffix_html})
    lines.append(f"<span class='inv-section-header'>--- Equipped ---</span>")
    if equipped_item_parts:
        equipped_item_parts.sort(key=lambda x: x['sort_key'])
        for parts in equipped_item_parts:
            padding_needed = (max_visible_equipped_prefix_len + 2) - parts['visible_prefix_len']
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else: lines.append("  Nothing equipped.")
    backpack_item_parts = []
    max_visible_backpack_prefix_len = 0
    if inventory_display_schema.backpack_items:
        for idx, inv_item_schema in enumerate(inventory_display_schema.backpack_items):
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            prefix_html = f"  {item_number_html}"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_backpack_prefix_len = max(max_visible_backpack_prefix_len, visible_prefix_len)
            item_name_raw = inv_item_schema.item.name.strip() if inv_item_schema.item else "Unknown Item"
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {inv_item_schema.quantity})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"
            backpack_item_parts.append({'prefix_html': prefix_html,'visible_prefix_len': visible_prefix_len,'suffix_html': suffix_html})
    lines.append(f"\n<span class='inv-section-header'>--- Backpack ---</span>")
    if backpack_item_parts:
        for parts in backpack_item_parts:
            padding_needed = (max_visible_backpack_prefix_len + 1) - parts['visible_prefix_len']
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else: lines.append("  Your backpack is empty.")
    return "\n".join(lines)

def roll_dice(dice_str: str) -> int: # ... content ...
    if not dice_str: return 0
    dice_str = dice_str.replace(" ", "")
    parts = dice_str.lower().split('d')
    num_dice = 1
    if parts[0]:
        if parts[0] == "" and len(parts) > 1: num_dice = 1
        else:
            try: num_dice = int(parts[0])
            except ValueError:
                try: return int(parts[0])
                except ValueError: return 0
    if len(parts) < 2: return num_dice
    dice_spec = parts[1]
    modifier = 0
    if '+' in dice_spec:
        sides_mod = dice_spec.split('+')
        try:
            dice_sides = int(sides_mod[0]); modifier = int(sides_mod[1])
        except (ValueError, IndexError): return 0 
    elif '-' in dice_spec:
        sides_mod_neg = dice_spec.split('-')
        try:
            dice_sides = int(sides_mod_neg[0]); modifier = -int(sides_mod_neg[1])
        except (ValueError, IndexError): return 0
    else:
        try: dice_sides = int(dice_spec)
        except ValueError: return 0
    if dice_sides <= 0: return 0 
    total_roll = 0
    for _ in range(num_dice): total_roll += random.randint(1, dice_sides)
    return total_roll + modifier

def resolve_mob_target(
    target_ref: str, 
    mobs_in_room: List[models.RoomMobInstance] # Pass the list of RoomMobInstance ORM objects
) -> Tuple[Optional[models.RoomMobInstance], Optional[str]]:
    """
    Resolves a target reference (number, full name, or partial name) to a specific mob instance.
    Returns (mob_instance, error_message_or_ambiguity_prompt_or_None_if_success)
    """
    if not mobs_in_room: # No mobs to target
        return None, f"There is nothing called '{target_ref}' here to target."

    target_ref_lower = target_ref.lower()
    
    # 1. Try to parse as a number (from 1-based index)
    try:
        num_ref = int(target_ref)
        if 1 <= num_ref <= len(mobs_in_room):
            return mobs_in_room[num_ref - 1], None # Found by number
    except ValueError:
        pass # Not a number, proceed to name matching

    # 2. Try exact full name match (case-insensitive)
    exact_matches: List[models.RoomMobInstance] = []
    for mob_instance in mobs_in_room:
        if mob_instance.mob_template and mob_instance.mob_template.name.lower() == target_ref_lower:
            exact_matches.append(mob_instance)
    
    if len(exact_matches) == 1:
        return exact_matches[0], None # Unique exact match
    if len(exact_matches) > 1:
        # Prefer exact match over partial if multiple exacts (unlikely for unique mob instances)
        return exact_matches[0], "(Multiple exact name matches found, targeting first.)" 

    # 3. Try partial name match (prefix, case-insensitive)
    partial_matches: List[models.RoomMobInstance] = []
    for mob_instance in mobs_in_room:
        if mob_instance.mob_template and mob_instance.mob_template.name.lower().startswith(target_ref_lower):
            partial_matches.append(mob_instance)

    if len(partial_matches) == 1:
        return partial_matches[0], None # Unique partial match
    
    if len(partial_matches) > 1:
        # Ambiguous partial match
        prompt_lines = [f"Which '{target_ref}' did you mean?"]
        # Sort partial_matches by name for consistent numbering, if desired
        partial_matches.sort(key=lambda m: m.mob_template.name if m.mob_template else "")
        for i, mob_match in enumerate(partial_matches):
            mob_name = mob_match.mob_template.name if mob_match.mob_template else "Unknown Mob"
            prompt_lines.append(f"  {i + 1}. {mob_name}")
        return None, "\n".join(prompt_lines)

    # 4. No match found
    return None, f"Cannot find anything called '{target_ref}' here to target."

def format_room_characters_for_player_message(
    room_characters: List[models.Character] # Expects a list of Character ORM objects
) -> str: # No map needed here, just the text
    """Formats characters in the room into a readable string."""
    if not room_characters:
        return "" # No extra "Also here for characters" if none are present

    lines = ["\nAlso present:"] # Or "You also see:"
    for char_orm in room_characters:
        # TODO: Add more detail later, e.g., " (PlayerName's CharacterName the Warrior)"
        # For now, just the character name and class.
        char_name_html = f"<span class='char-name'>{char_orm.name}</span>" # Re-use char-name style
        char_class_html = f"<span class='char-class'>({char_orm.class_name})</span>" # Re-use char-class style
        lines.append(f"  {char_name_html} {char_class_html}")
    return "\n".join(lines)
--- END OF FILE backend/app/commands/utils.py ---

--- START OF FILE backend/app/commands/movement_parser.py ---
# backend/app/commands/movement_parser.py
import uuid
from typing import Dict, List, Optional, Tuple # Ensure all are imported

from app import schemas, crud, models 
from .command_args import CommandContext
from .utils import ( # Assuming these are all in utils.py now
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message # Make sure this is imported
)
from app.websocket_manager import connection_manager # For broadcasting

# --- Helper Function (Ideally in utils.py) ---
def format_room_mobs_for_player_message(
    room_mobs: List[models.RoomMobInstance]
) -> Tuple[str, Dict[int, uuid.UUID]]:
    """Formats mobs in the room into a readable string, numbered."""
    lines = []
    mob_map: Dict[int, uuid.UUID] = {}

    if room_mobs:
        lines.append("\nAlso here:") # Or "Creatures present:"
        for idx, mob_instance in enumerate(room_mobs):
            template = mob_instance.mob_template
            mob_name = template.name if template else "Unknown Creature"
            
            mob_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>" # Re-use style for numbering
            mob_name_html = f"<span class='inv-item-name'>{mob_name}</span>" # Re-use style for name

            lines.append(f"  {mob_number_html} {mob_name_html}")
            mob_map[idx + 1] = mob_instance.id
    return "\n".join(lines), mob_map
# --- End Helper Function ---


async def handle_look(context: CommandContext) -> schemas.CommandResponse:
    message_to_player_parts: List[str] = []
    look_target_name = " ".join(context.args).strip() if context.args else None

    if look_target_name:
        # ... (existing logic for looking at specific items/mobs) ...
        # Ensure this section also lists other characters if looking at a target
        # For brevity, I'll skip repeating the full "look at target" block, but add char listing there too.

        # At the end of "look at target", after item/mob description, add other entities:
        # ... (after specific target description)
        # message_to_player_parts.append(f"\n\n{context.current_room_schema.name}\n{context.current_room_schema.description}")
        
        # List other items, mobs, AND characters
        other_items_on_ground = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
        if other_items_on_ground:
            ground_items_text, _ = format_room_items_for_player_message(other_items_on_ground)
            if ground_items_text: message_to_player_parts.append(ground_items_text)

        other_mobs_in_room = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
        if other_mobs_in_room:
            mobs_text, _ = format_room_mobs_for_player_message(other_mobs_in_room)
            if mobs_text: message_to_player_parts.append(mobs_text)
        
        # <<< NEW: List other characters (excluding self) when looking at a target
        other_characters_in_room = crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.current_room_orm.id, 
            exclude_character_id=context.active_character.id
        )
        if other_characters_in_room:
            chars_text = format_room_characters_for_player_message(other_characters_in_room)
            if chars_text: message_to_player_parts.append(chars_text)

        final_message = "\n".join(filter(None, message_to_player_parts)).strip()
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=final_message if final_message else None)


    # Default "look" (general room look)
    items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
    ground_items_text, _ = format_room_items_for_player_message(items_on_ground_orm)
    if ground_items_text:
        message_to_player_parts.append(ground_items_text)
        
    mobs_in_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
    mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room_orm)
    if mobs_text:
        message_to_player_parts.append(mobs_text)

    # <<< NEW: List other characters (excluding self) for general look
    characters_in_room_orm = crud.crud_character.get_characters_in_room(
        context.db, 
        room_id=context.current_room_orm.id, 
        exclude_character_id=context.active_character.id
    )
    if characters_in_room_orm:
        chars_text = format_room_characters_for_player_message(characters_in_room_orm)
        if chars_text: message_to_player_parts.append(chars_text)
        
    final_message = "\n".join(filter(None, message_to_player_parts)).strip()
    return schemas.CommandResponse(
        room_data=context.current_room_schema,
        message_to_player=final_message if final_message else None # Send only if there's something to say
    )

async def handle_move(context: CommandContext) -> schemas.CommandResponse:
    message_to_player: Optional[str] = None 
    moved = False
    target_room_orm_for_move: Optional[models.Room] = None
    
    direction_map = {"n": "north", "s": "south", "e": "east", "w": "west", "u": "up", "d": "down"}
    target_direction_str_raw = "" # The raw input for direction

    if context.command_verb == "go":
        if context.args: 
            target_direction_str_raw = context.args[0].lower()
        else:
            message_to_player = "Go where?"
            return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
    else: 
        target_direction_str_raw = context.command_verb.lower() # Command itself is the direction
        
    # Determine the full direction name (e.g., "n" -> "north")
    # target_direction will be the canonical direction name like "north", "south", etc.
    target_direction = direction_map.get(target_direction_str_raw, target_direction_str_raw)

    if target_direction not in direction_map.values(): # Validate against canonical names
        message_to_player = "That's not a valid direction to move."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # Store details from before the move
    old_room_id = context.active_character.current_room_id
    character_name_for_broadcast = context.active_character.name # For messages to others

    # Attempt to find the exit and the target room
    current_exits = context.current_room_orm.exits if context.current_room_orm.exits is not None else {}
    if target_direction in current_exits:
        next_room_uuid_str = current_exits.get(target_direction)
        if next_room_uuid_str:
            try:
                target_room_uuid = uuid.UUID(hex=next_room_uuid_str)
                potential_target_room_orm = crud.crud_room.get_room_by_id(context.db, room_id=target_room_uuid)
                if potential_target_room_orm:
                    target_room_orm_for_move = potential_target_room_orm
                    moved = True
                else: 
                    message_to_player = "The path ahead seems to vanish into thin air. Spooky."
            except ValueError: 
                message_to_player = "The exit in that direction appears to be corrupted. Call a dev, maybe."
        else: 
            # This case should ideally not happen if exits dict is well-formed,
            # but good to have a fallback.
            message_to_player = "The way in that direction is unclear or broken."
    else: 
        message_to_player = "You can't go that way."

    # If the move was successful
    if moved and target_room_orm_for_move:
        # 1. Update character's location in DB
        crud.crud_character.update_character_room(
            context.db, character_id=context.active_character.id, new_room_id=target_room_orm_for_move.id
        )
        # The context.active_character object itself is not updated by the above call immediately
        # unless we re-fetch it. For broadcasting, we use the new room ID.
        
        new_room_schema = schemas.RoomInDB.from_orm(target_room_orm_for_move) # For the mover's response

        # 2. Broadcast "leaves" message to players in the OLD room
        player_ids_in_old_room = [
            char.player_id for char in crud.crud_character.get_characters_in_room(
                context.db, room_id=old_room_id, exclude_character_id=context.active_character.id
            ) if connection_manager.is_player_connected(char.player_id)
        ]
        if player_ids_in_old_room:
            leave_message_payload = {
                "type": "game_event", 
                "message": f"<span class='char-name'>{character_name_for_broadcast}</span> leaves, heading {target_direction}."
            }
            await connection_manager.broadcast_to_players(leave_message_payload, player_ids_in_old_room)

        # 3. Broadcast "arrives" message to players in the NEW room
        player_ids_in_new_room_others = [ # Others already in the new room
            char.player_id for char in crud.crud_character.get_characters_in_room(
                context.db, room_id=target_room_orm_for_move.id, exclude_character_id=context.active_character.id
            ) if connection_manager.is_player_connected(char.player_id)
        ]
        if player_ids_in_new_room_others:
            # TODO: Determine direction of arrival (e.g., if moved north, arrived from south)
            # For now, a generic arrival message.
            arrive_message_payload = {
                "type": "game_event", 
                "message": f"<span class='char-name'>{character_name_for_broadcast}</span> arrives."
            }
            await connection_manager.broadcast_to_players(arrive_message_payload, player_ids_in_new_room_others)
        
        # 4. Prepare the message_to_player for the character who moved
        # This message will include the description of items, mobs, and other characters in the new room.
        # Room name and description itself will be handled by the client using room_data.
        arrival_message_parts: List[str] = []
        
        items_in_new_room_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=target_room_orm_for_move.id)
        ground_items_text, _ = format_room_items_for_player_message(items_in_new_room_orm)
        if ground_items_text:
            arrival_message_parts.append(ground_items_text)
            
        mobs_in_new_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=target_room_orm_for_move.id)
        mobs_text, _ = format_room_mobs_for_player_message(mobs_in_new_room_orm)
        if mobs_text:
            arrival_message_parts.append(mobs_text)

        # List other characters in the new room for the mover
        other_characters_in_new_room = crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=target_room_orm_for_move.id, 
            exclude_character_id=context.active_character.id # Exclude self
        )
        if other_characters_in_new_room:
            chars_text_for_mover = format_room_characters_for_player_message(other_characters_in_new_room)
            if chars_text_for_mover: 
                arrival_message_parts.append(chars_text_for_mover)
            
        final_arrival_message = "\n".join(filter(None, arrival_message_parts)).strip()
        
        return schemas.CommandResponse(
            room_data=new_room_schema, 
            message_to_player=final_arrival_message if final_arrival_message else None # Send only if there's something to describe
        )
            
    # If move failed, return the failure message and current room data
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/movement_parser.py ---

--- FILE NOT FOUND: backend/app/commands/inventory_parser.py# ---

--- FILE NOT FOUND: inventory, ---

--- FILE NOT FOUND: equip, ---

--- FILE NOT FOUND: etc. ---

--- START OF FILE backend/app/commands/social_parser.py ---
# backend/app/commands/social_parser.py
import random
from app import schemas, models, crud # app.
from .command_args import CommandContext # app.commands.command_args
from app.websocket_manager import connection_manager


async def handle_fart(context: CommandContext) -> schemas.CommandResponse:
    character_name = context.active_character.name

    # --- Diverse Onomatopoeia & Descriptions ---
    fart_sounds = [
        "*Pfffft!*", "*Braaap!*", "*Thrrrip!*", "*Squelch...*", "*Poot.*", "*Brrrt!*", 
        "*Toot!*", "*Phhhht.*", "*SBD (Silent But Deadly)*", "*Flrph*", "*Thwapp!*",
        "*Poo-tee-weet?*", "*A high-pitched whistle*", "*A low, bassy rumble*"
    ]
    
    actor_descriptions = [ # What the farter experiences/thinks
        "You feel a sudden pressure release.",
        "You subtly (or not so subtly) let one rip.",
        "A fragrant cloud emanates from your being.",
        "You add your unique aroma to the room's ambiance.",
        "Ah, sweet relief!",
        "You check discreetly to see if anyone noticed. They did.",
        "You try to blame the dog, but there is no dog.",
        "A moment of internal rebellion, now externalized.",
        "You punctuate the silence with a personal statement."
    ]

    observer_actions = [ # What others see/hear the farter DOING
        "bends over slightly", "winces momentarily", "shifts uncomfortably in their britches",
        "looks around innocently", "grins mischievously", "lets out a sigh of contentment",
        "fans the air nonchalantly", "suddenly seems very interested in a cobweb on the ceiling",
        "blushes faintly", "chuckles to themselves"
    ]

    observer_smells_or_sounds = [ # The sensory experience for others
        "A suspicious noise emanates from their direction.",
        "The distinct sound of escaping gas is heard.",
        "A foul wind blows from where they stand.",
        "The air suddenly becomes... heavier.",
        "A faint (or not so faint) odor permeates the area.",
        "It sounds like a small, trapped animal finally escaped.",
        "Someone should probably open a window."
    ]

    # --- Constructing the Messages ---
    chosen_sound = random.choice(fart_sounds)
    actor_desc_part = random.choice(actor_descriptions)
    observer_action_part = random.choice(observer_actions)
    observer_smell_sound_part = random.choice(observer_smells_or_sounds)

    # Message to the player who farted
    # Player sees the sound, their internal monologue/action, and perhaps a general observation.
    message_to_player = f"You {observer_action_part}. {chosen_sound} {actor_desc_part}"

    # Message to everyone else in the room
    # Others see the player's action, the sound, and the sensory result.
    message_to_others = (
        f"<span class='char-name'>{character_name}</span> {observer_action_part}. "
        f"{chosen_sound} {observer_smell_sound_part}"
    )

    # --- Broadcasting ---
    others_message_payload = {
        "type": "game_event", # Or a more specific "social_event" or "emote"
        "message": message_to_others
    }

    player_ids_in_room_to_notify = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Don't send broadcast to self
        ) if connection_manager.is_player_connected(char.player_id)
    ]

    if player_ids_in_room_to_notify:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room_to_notify)
    
    return schemas.CommandResponse(
        room_data=context.current_room_schema, 
        message_to_player=message_to_player
    )

async def handle_say(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Say what?")

    message_text = " ".join(context.args)
    character_name = context.active_character.name

    # Message to self (echo)
    self_message = f"You say, \"{message_text}\""
    
    # Message to others in the room
    others_message_payload = {
        "type": "game_event", # Or "chat_message"
        "message": f"<span class='char-name'>{character_name}</span> says, \"{message_text}\""
    }

    player_ids_in_room = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Exclude self from broadcast
        ) if connection_manager.is_player_connected(char.player_id)
    ]

    if player_ids_in_room:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room)

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=self_message)


async def handle_emote(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Emote what? (e.g., emote grins)")

    emote_text = " ".join(context.args)
    character_name = context.active_character.name

    # Message to self (echo) - may or may not include your own name based on MUD style
    self_message = f"<span class='char-name'>{character_name}</span> {emote_text}" # Or "You {emote_text}"
    
    # Message to others in the room
    others_message_payload = {
        "type": "game_event", # Or "emote_message"
        "message": f"<span class='char-name'>{character_name}</span> {emote_text}"
    }

    player_ids_in_room = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Exclude self from broadcast
        ) if connection_manager.is_player_connected(char.player_id)
    ]
    
    # Send to others first, then construct self_message which might be slightly different for some MUDs
    if player_ids_in_room:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room)
    
    # For emote, the player also sees the "CharacterName emotes..." message
    # So, we send the same payload to self, but via send_personal_message
    # Or, if the command response message_to_player handles the self-echo:
    # self_message_for_command_response = f"You {emote_text}." # if you want "You emote"
    self_message_for_command_response = self_message # Echo the same as others see

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=self_message_for_command_response)

async def handle_ooc(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="OOC what? (Out Of Character global chat)")

    message_text = " ".join(context.args)
    character_name = context.active_character.name
    player_username = context.active_character.owner.username if hasattr(context.active_character, 'owner') and context.active_character.owner else "UnknownPlayer" 
    # To get player_username, Character model needs `owner: Mapped["Player"] = relationship(back_populates="characters")` 
    # and it needs to be loaded. For now, let's stick to character name or a generic.
    # Let's use Character Name for simplicity in OOC for now.

    # Message for global broadcast
    # Using a distinct style for OOC messages is good.
    ooc_message_payload = {
        "type": "ooc_message", # A new type for the frontend to potentially style differently
        "message": f"[OOC] <span class='char-name'>{character_name}</span>: {message_text}"
    }

    # Get ALL active player_ids from ConnectionManager
    all_player_ids = connection_manager.get_all_active_player_ids() # Needs to be implemented in ConnectionManager
    
    # Broadcast to everyone, including self
    if all_player_ids:
        await connection_manager.broadcast_to_players(ooc_message_payload, all_player_ids)
    
    # No direct message_to_player in CommandResponse needed if the broadcast includes self.
    # Or, you can have a self-echo: "You OOC: message"
    # For now, assume the broadcast handles echoing to self too.
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=None) # Or "OOC message sent."
--- END OF FILE backend/app/commands/social_parser.py ---

--- START OF FILE backend/app/commands/meta_parser.py ---
# backend/app/commands/meta_parser.py
from typing import List
from app import schemas, models, crud # <<< ADDED models
from .command_args import CommandContext 

async def handle_help(context: CommandContext) -> schemas.CommandResponse:
    categories = {
        "General": [
            ("look [target]", "Shows description of location, item, or mob."),
            ("score", "Shows your character's stats and status."),
            ("skills", "Displays skills you have learned."),         
            ("traits", "Displays traits you have acquired."),       
            ("help (?)", "Shows this incredibly helpful message."),
            ("fart", "Express yourself. With great feeling."),
        ],
        "Movement": [
            ("north (n)", "Move North."),
            ("south (s)", "Move South."),
            ("east (e)", "Move East."),
            ("west (w)", "Move West."),
            ("up (u)", "Move Up."),
            ("down (d)", "Move Down."),
            ("go <direction>", "Move in a specified direction."),
        ],
        "Inventory & Items": [
            ("inventory (i)", "Shows your inventory."),
            ("equip (eq) <item_ref> [slot]", "Equips an item (e.g., 'eq Sword main_hand')."),
            ("unequip (uneq) <item/slot>", "Unequips an item (e.g., 'uneq head')."),
            ("drop <item_ref>", "Drops an item from backpack to ground."),
            ("get (take) <item_ref>", "Picks up an item from the ground."),
        ],
        "Combat (WebSocket)": [
            ("attack (atk, kill) <target>", "Attack a creature in the room."),
            ("flee", "Attempt to flee from combat."),
        ],
        "Debug (Use With Caution, You Filthy Cheater)": [
            ("giveme <item_name>", "DEBUG: Gives you an item."),
            ("spawnmob <mob_template_name>", "DEBUG: Spawns a mob."),
        ]
    }

    help_message_lines = ["<span class='inv-section-header'>--- Available Commands ---</span>"]
    
    # Find the length of the longest command string for padding
    max_cmd_len = 0
    for _, commands in categories.items():
        for cmd_text, _ in commands:
            if len(cmd_text) > max_cmd_len:
                max_cmd_len = len(cmd_text)
    
    # The fixed width for the command part of the line.
    # All command texts will be padded to this width.
    command_column_width = max_cmd_len 

    help_message_lines = ["<span class='inv-section-header'>--- Available Commands ---</span>"]
    command_col_width = 30 

    for category_name, commands in categories.items():
        help_message_lines.append(f"\n<span class='room-name-header'>-- {category_name} --</span>")
        for cmd, desc in commands:
            padded_command_text = cmd.ljust(command_col_width)
            line = f"  <span class='inv-item-name'>{cmd.ljust(command_col_width)}</span>  - {desc}" # Use ljust on cmd directly
            help_message_lines.append(line)

    message_to_player = "\n".join(help_message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_score(context: CommandContext) -> schemas.CommandResponse:
    char: models.Character = context.active_character
    
    effective_stats = char.calculate_combat_stats()
    
    # --- Calculate XP for next level ---
    xp_for_next_level_val = crud.crud_character.get_xp_for_level(char.level + 1)
    xp_to_next_display = ""
    if xp_for_next_level_val == float('inf'):
        xp_to_next_display = "(Max Level)"
    else:
        # xp_needed_for_this_level_up = int(xp_for_next_level_val) - int(crud.crud_character.get_xp_for_level(char.level))
        # xp_progress_this_level = char.experience_points - int(crud.crud_character.get_xp_for_level(char.level))
        # xp_to_next_display = f"{xp_progress_this_level} / {xp_needed_for_this_level_up} (Next: {int(xp_for_next_level_val)})"
        # Simpler: just show current XP / total XP for next level
        xp_to_next_display = f"{char.experience_points} / {int(xp_for_next_level_val)}"


    score_message_lines = [
        f"--- <span class='char-name'>{char.name}</span> --- the <span class='char-class'>{char.class_name}</span> ---",
        f"Level: {char.level}   XP: {xp_to_next_display}", # <<< UPDATED XP DISPLAY
        f"HP: <span class='combat-hp'>{char.current_health}/{char.max_health}</span>   MP: <span class='combat-hp'>{char.current_mana}/{char.max_mana}</span>",
        "--- Attributes ---",
        f"  Strength:     {char.strength:<4} ({char.get_attribute_modifier('strength'):+}) Intelligence: {char.intelligence:<4} ({char.get_attribute_modifier('intelligence'):+})",
        f"  Dexterity:    {char.dexterity:<4} ({char.get_attribute_modifier('dexterity'):+})    Wisdom:       {char.wisdom:<4} ({char.get_attribute_modifier('wisdom'):+})",
        f"  Constitution: {char.constitution:<4} ({char.get_attribute_modifier('constitution'):+}) Charisma:     {char.charisma:<4} ({char.get_attribute_modifier('charisma'):+})",
        f"  Luck:         {char.luck:<4} ({char.get_attribute_modifier('luck'):+})",
        "--- Effective Combat Stats ---",
        f"  Armor Class:  {effective_stats['effective_ac']:<4}         Attack Bonus: {effective_stats['attack_bonus']:<+4}",
        f"  Damage:       {effective_stats['damage_dice']} + {effective_stats['damage_bonus']}",
        f"  (Attack Attribute: {effective_stats['primary_attribute_for_attack'].capitalize()})",
    ]
    message_to_player = "\n".join(score_message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_skills(context: CommandContext) -> schemas.CommandResponse:
    char_skills: List[str] = context.active_character.learned_skills or []
    
    if not char_skills:
        message_to_player = "You have not learned any skills yet. Perhaps try hitting things with a stick?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    message_lines = ["<span class='inv-section-header'>--- Your Skills ---</span>"]
    for skill_tag in char_skills:
        skill_template = crud.crud_skill.get_skill_template_by_tag(context.db, skill_id_tag=skill_tag)
        if skill_template:
            line = f"  <span class='inv-item-name'>{skill_template.name}</span>"
            if skill_template.description:
                # Basic alignment for description (adjust width as needed)
                desc_indent = " " * (25 - len(skill_template.name))
                if len(skill_template.name) >= 23: desc_indent = "\n    " # Newline if name is too long
                line += f"{desc_indent}- {skill_template.description}"
            message_lines.append(line)
        else:
            message_lines.append(f"  Unknown skill ID: {skill_tag} (This is probably a bug, you poor sod.)")
            
    message_to_player = "\n".join(message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_traits(context: CommandContext) -> schemas.CommandResponse:
    char_traits: List[str] = context.active_character.learned_traits or []

    if not char_traits:
        message_to_player = "You possess no noteworthy traits. You are remarkably unremarkable."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    message_lines = ["<span class='inv-section-header'>--- Your Traits ---</span>"]
    for trait_tag in char_traits:
        trait_template = crud.crud_trait.get_trait_template_by_tag(context.db, trait_id_tag=trait_tag)
        if trait_template:
            line = f"  <span class='inv-item-name'>{trait_template.name}</span>"
            if trait_template.description:
                desc_indent = " " * (25 - len(trait_template.name))
                if len(trait_template.name) >= 23: desc_indent = "\n    "
                line += f"{desc_indent}- {trait_template.description}"
            message_lines.append(line)
        else:
            message_lines.append(f"  Unknown trait ID: {trait_tag} (The devs are slacking again.)")
            
    message_to_player = "\n".join(message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/meta_parser.py ---

--- START OF FILE backend/app/commands/debug_parser.py ---
# backend/app/commands/debug_parser.py
from app import schemas, crud, models # app.
from .command_args import CommandContext # app.commands.command_args
import shlex

async def handle_giveme(context: CommandContext) -> schemas.CommandResponse:
    message_to_player = "Debug: giveme what? (e.g., 'giveme Rusty Sword')"
    if context.args:
        item_name_to_give = " ".join(context.args).strip()
        item_template = crud.crud_item.get_item_by_name(context.db, name=item_name_to_give)
        if item_template:
            _, add_message = crud.crud_character_inventory.add_item_to_character_inventory(
                context.db, character_id=context.active_character.id, item_id=item_template.id, quantity=1
            )
            message_to_player = add_message
        else:
            message_to_player = f"Debug: Item template '{item_name_to_give}' not found."
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_spawnmob(context: CommandContext) -> schemas.CommandResponse:
    message_to_player = "Debug: spawnmob <mob_template_name>"
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # CORRECTED: Join all args to get the full mob template name
    mob_template_name = " ".join(context.args).strip()
    
    if not mob_template_name: # Handle if args were just spaces
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Debug: Please specify a mob template name.")


    target_room_id = context.current_room_orm.id # Default to current room

    mob_template = crud.crud_mob.get_mob_template_by_name(context.db, name=mob_template_name)
    if not mob_template:
        message_to_player = f"Debug: Mob template '{mob_template_name}' not found."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    spawned_mob = crud.crud_mob.spawn_mob_in_room(
        db=context.db,
        room_id=target_room_id,
        mob_template_id=mob_template.id
    )

    if spawned_mob:
        # Ensure mob_template is loaded on spawned_mob if not already by relationship default
        # For display, it's good to have it. spawned_mob.mob_template.name
        mob_display_name = spawned_mob.mob_template.name if spawned_mob.mob_template else mob_template_name
        message_to_player = f"Debug: Spawned '{mob_display_name}' (ID: {spawned_mob.id}) in current room."
    else:
        message_to_player = f"Debug: Failed to spawn '{mob_template_name}'."
        
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_set_hp(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Usage: set_hp <value>")
    try:
        value = int(context.args[0])
    except ValueError:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Invalid HP value. Must be an integer.")

    character = context.active_character
    # Use the CRUD function, but it expects a change, not a set.
    # So, calculate change needed or modify crud_character to have a set_current_health.
    # For now, let's just directly set and clamp.
    
    character.current_health = value
    if character.current_health < 0:
        character.current_health = 0
    if character.current_health > character.max_health:
        character.current_health = character.max_health
    
    context.db.add(character)
    context.db.commit()
    context.db.refresh(character)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=f"HP set to {character.current_health}/{character.max_health}.")

async def handle_mod_xp(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Usage: mod_xp <amount>")
    try:
        amount = int(context.args[0])
    except ValueError:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Invalid XP amount. Must be an integer.")

    updated_char, messages = crud.crud_character.add_experience(context.db, context.active_character.id, amount)
    
    if not updated_char:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Error modifying XP.")

    full_message = "\n".join(messages)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=full_message)


async def handle_set_level(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Usage: set_level <level>")
    try:
        target_level = int(context.args[0])
        if target_level < 1:
            return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Target level must be 1 or greater.")
    except ValueError:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Invalid level. Must be an integer.")

    character = context.active_character
    messages = [f"Attempting to set level to {target_level}... Current XP: {character.experience_points}, Level: {character.level}"]
    
    initial_char_level_for_loop = character.level

    # Iteratively level up or down
    # Using a safety counter to prevent infinite loops if logic is off
    safety_counter = 0
    max_iterations = abs(target_level - initial_char_level_for_loop) + 5 # Max iterations

    while character.level < target_level and safety_counter < max_iterations:
        xp_to_next_level = crud.crud_character.get_xp_for_level(character.level + 1)
        if xp_to_next_level == float('inf'):
            messages.append(f"Max defined level ({character.level}) reached. Cannot set level to {target_level} by leveling up further.")
            break
        
        # To level up, ensure XP is at least the threshold for the next level
        character.experience_points = int(xp_to_next_level) # Set XP to exactly what's needed
        # _apply_level_up will increment level and can handle XP reset for new level if needed
        level_up_msgs = crud.crud_character._apply_level_up(context.db, character)
        messages.extend(level_up_msgs)
        # _apply_level_up should handle setting XP to start of new level + overflow if any,
        # but for set_level, we just care about reaching the level.
        # Let's ensure XP is at the start of the new current level.
        character.experience_points = int(crud.crud_character.get_xp_for_level(character.level))

        context.db.add(character) # Stage changes
        safety_counter += 1


    while character.level > target_level and safety_counter < max_iterations:
        if character.level <= 1: # Should be caught by target_level check, but good failsafe
            messages.append("Cannot de-level below 1.")
            break
        
        # To de-level, XP will be set by _apply_level_down
        delevel_msgs = crud.crud_character._apply_level_down(context.db, character)
        messages.extend(delevel_msgs)
        context.db.add(character) # Stage changes
        safety_counter += 1
    
    if safety_counter >= max_iterations:
        messages.append("Warning: Max iterations reached in set_level. Level may not be correctly set.")

    context.db.commit()
    context.db.refresh(character)
    
    messages.append(f"Character is now Level {character.level} with {character.experience_points} XP.")
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="\n".join(messages))    
--- END OF FILE backend/app/commands/debug_parser.py ---

--- START OF FILE backend/app/api/v1/endpoints/command.py ---
# backend/app/api/v1/endpoints/command.py
from fastapi import APIRouter, Depends, Body
from sqlalchemy.orm import Session
from typing import Dict, Callable, Awaitable # For typing the registry

from app import schemas, models, crud # app.
from app.db.session import get_db
from app.api.dependencies import get_current_active_character # app.api.dependencies
from app.commands.command_args import CommandContext # app.commands.command_args

# Import handler modules
from app.commands import movement_parser
from app.commands import inventory_parser
from app.commands import social_parser
from app.commands import debug_parser
from app.commands import meta_parser
# from app.commands import combat_parser 


router = APIRouter()

# Define the type for our handler functions
CommandHandler = Callable[[CommandContext], Awaitable[schemas.CommandResponse]] # If handlers are async
# Or if synchronous: CommandHandler = Callable[[CommandContext], schemas.CommandResponse]
# Let's assume handlers can be async for future flexibility, even if current ones are not.

COMMAND_REGISTRY: Dict[str, CommandHandler] = {
    # Movement and Perception
    "look": movement_parser.handle_look,
    "l": movement_parser.handle_look,
    "north": movement_parser.handle_move,
    "n": movement_parser.handle_move,
    "south": movement_parser.handle_move,
    "s": movement_parser.handle_move,
    "east": movement_parser.handle_move,
    "e": movement_parser.handle_move,
    "west": movement_parser.handle_move,
    "w": movement_parser.handle_move,
    "up": movement_parser.handle_move,
    "u": movement_parser.handle_move,
    "down": movement_parser.handle_move,
    "d": movement_parser.handle_move,
    "go": movement_parser.handle_move, # "go north" will be handled by move knowing original command

    # Inventory Management
    "inventory": inventory_parser.handle_inventory,
    "i": inventory_parser.handle_inventory,
    "equip": inventory_parser.handle_equip,
    "eq": inventory_parser.handle_equip,
    "unequip": inventory_parser.handle_unequip,
    "uneq": inventory_parser.handle_unequip,
    "drop": inventory_parser.handle_drop,
    "get": inventory_parser.handle_get,
    "take": inventory_parser.handle_get,

    # Combat >>> moved to websockets
    # "attack": combat_parser.handle_attack, 
    # "atk": combat_parser.handle_attack,    
    # "kill": combat_parser.handle_attack,    

    # Social
    "fart": social_parser.handle_fart,

    # Debug
    "giveme": debug_parser.handle_giveme,
    "spawnmob": debug_parser.handle_spawnmob,
    "set_hp": debug_parser.handle_set_hp,       # <<< NEW
    "mod_xp": debug_parser.handle_mod_xp,       # <<< NEW
    "set_level": debug_parser.handle_set_level, # <<< NEW

    # Meta
    "score": meta_parser.handle_score, # <<< ADDED
    "sc": meta_parser.handle_score, # <<< ADDED
    "skills": meta_parser.handle_skills,     # <<< NEW
    "sk": meta_parser.handle_skills,     # <<< NEW
    "traits": meta_parser.handle_traits,     # <<< NEW
    "tr": meta_parser.handle_traits,     # <<< NEW
    "status": meta_parser.handle_score, # Alias for score
    "st": meta_parser.handle_score, # Alias for score
    "help": meta_parser.handle_help,
    "?": meta_parser.handle_help,

    # Social
    "say": social_parser.handle_say,
    "'": social_parser.handle_say, # Common alias for say
    "emote": social_parser.handle_emote,
    ":": social_parser.handle_emote, # Common alias for emote
    "ooc": social_parser.handle_ooc,
    "fart": social_parser.handle_fart,
}

@router.post("", response_model=schemas.CommandResponse)
async def process_command_for_character(
    payload: schemas.CommandRequest = Body(...),
    db: Session = Depends(get_db),
    active_character: models.Character = Depends(get_current_active_character)
):
    original_command_text = payload.command.strip()
    if not original_command_text:
        return schemas.CommandResponse(message_to_player="Please type a command.")

    command_parts = original_command_text.split()
    command_verb = command_parts[0].lower()
    args = command_parts[1:]

    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    if not current_room_orm:
        return schemas.CommandResponse(message_to_player="CRITICAL ERROR: Character in void.")
    current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)

    context = CommandContext(
        db=db, active_character=active_character, current_room_orm=current_room_orm,
        current_room_schema=current_room_schema, original_command=original_command_text,
        command_verb=command_verb, args=args
    )

    handler = COMMAND_REGISTRY.get(command_verb)
    if handler:
        return await handler(context)
    else:
        # If command is an attack verb, suggest using game interface (implying WS)
        if command_verb in ["attack", "atk", "kill", "kil", "ki", "k"]:
             return schemas.CommandResponse(
                room_data=current_room_schema,
                message_to_player=f"Combat actions like '{command_verb}' are handled in real-time. (Use game interface)"
            )
        return schemas.CommandResponse(
            room_data=current_room_schema,
            message_to_player=f"I don't understand the command: '{original_command_text}'. Type 'help' or '?'."
        )
--- END OF FILE backend/app/api/v1/endpoints/command.py ---

--- START OF FILE backend/app/models/__init__.py ---
# File: backend/app/models/__init__.py

from .room import Room
from .player import Player
from .character import Character
from .item import Item
from .character_inventory_item import CharacterInventoryItem
from .room_item_instance import RoomItemInstance
from .mob_template import MobTemplate
from .room_mob_instance import RoomMobInstance
from .character_class_template import CharacterClassTemplate
from .skill_template import SkillTemplate
from .trait_template import TraitTemplate 
from .mob_spawn_definition import MobSpawnDefinition
--- END OF FILE backend/app/models/__init__.py ---

--- START OF FILE backend/app/models/player.py ---
# backend/app/models/player.py
import uuid
from typing import Optional, List, TYPE_CHECKING # List for future relationship typing

from sqlalchemy import Column, String # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship # Import Mapped, mapped_column

from ..db.base_class import Base

if TYPE_CHECKING: 
    from .character import Character 

class Player(Base):
    __tablename__ = "players"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
    characters: Mapped[List["Character"]] = relationship(back_populates="owner")

    # --- Relationships (Example for future) ---
    # If a Player can have multiple Characters:
    # characters: Mapped[List["Character"]] = relationship(back_populates="owner")
    # Note: Use "Character" as a string if Character class is defined later or in another file to avoid circular imports.

    def __repr__(self) -> str:
        return f"<Player(id={self.id}, username='{self.username}')>"
--- END OF FILE backend/app/models/player.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    owner: Mapped["Player"] = relationship(back_populates="characters")

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)

    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/character_class_template.py ---
# backend/app/models/character_class_template.py
import uuid
from typing import Optional, Dict, Any, List

from sqlalchemy import String, Text, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base
# No direct relationships to Character needed here, Character will link to this.

class CharacterClassTemplate(Base):
    __tablename__ = "character_class_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # How this class modifies base character stats (e.g., {"strength": 2, "dexterity": 1, "constitution": -1})
    base_stat_modifiers: Mapped[Optional[Dict[str, int]]] = mapped_column(JSONB, nullable=True)
    
    starting_health_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    starting_mana_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # Placeholder for skill/trait progression - LLM will populate this JSON structure
    # Example: {"core_skills_by_level": {"1": ["punch_good"], "5": ["kick_better"]}, "specializations": ...}
    skill_tree_definition: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)

    # List of item template names or tags the class starts with (e.g., ["Rusty Sword", "Cloth Tunic"])
    starting_equipment_refs: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True)
    
    # Tags to help categorize or for LLM to understand playstyle (e.g., ["melee", "caster", "tank"])
    playstyle_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True)

    def __repr__(self) -> str:
        return f"<CharacterClassTemplate(id={self.id}, name='{self.name}')>"
--- END OF FILE backend/app/models/character_class_template.py ---

--- START OF FILE backend/app/models/skill_template.py ---
# backend/app/models/skill_template.py
import uuid
from typing import Optional, Dict, Any, List

from sqlalchemy import String, Text, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column

from ..db.base_class import Base

class SkillTemplate(Base):
    __tablename__ = "skill_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # Unique internal identifier/tag, e.g., "power_attack", "pick_lock_basic", "fireball_rank1"
    # This is what will be stored in Character.learned_skills and referenced in skill_tree_definition
    skill_id_tag: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    
    name: Mapped[str] = mapped_column(String(100), nullable=False, comment="Player-facing name, e.g., 'Power Attack'")
    description: Mapped[Text] = mapped_column(Text, nullable=True, comment="Player-facing description of what the skill does.")
    
    skill_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, 
                                            comment="e.g., 'COMBAT_ACTIVE', 'COMBAT_PASSIVE', 'UTILITY_OOC', 'SOCIAL'")
    
    target_type: Mapped[str] = mapped_column(String(50), default="NONE", nullable=False,
                                             comment="e.g., 'SELF', 'ENEMY_MOB', 'FRIENDLY_CHAR', 'DOOR', 'ITEM_IN_ROOM', 'NONE'")
    
    # How the skill's effects are defined. Structure depends heavily on skill_type.
    # Examples:
    # COMBAT_ACTIVE: {"mana_cost": 5, "damage": {"dice": "1d6", "bonus_stat": "strength", "type": "physical"}, "status_effect_chance": {"effect_id": "stunned", "duration_rounds": 1, "chance_percent": 25}}
    # UTILITY_OOC (Pick Lock): {"target_subtype": "lock", "difficulty_check_attr": "dexterity", "base_dc": 15, "consumes_item_tag": "lockpick_set", "success_message": "The lock clicks open!", "failure_message": "You fumble with the lock."}
    # COMBAT_PASSIVE: {"stat_bonuses": {"attack_bonus": 1}, "conditional_trigger": "on_crit_hit"}
    effects_data: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False, default=lambda: {})

    # Requirements to learn/use the skill. Can be checked during level up or skill use.
    # Example: {"min_level": 3, "required_stats": {"intelligence": 12}, "requires_learned_skill": "basic_spellcasting_id", "requires_class_tag": "Mage"}
    requirements_data: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)

    # For skills that might have ranks or tiers (future use)
    rank: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1)
    # Cooldown in combat rounds, or seconds for OOC skills
    cooldown: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) 

    def __repr__(self) -> str:
        return f"<SkillTemplate(id={self.id}, skill_id_tag='{self.skill_id_tag}', name='{self.name}')>"
--- END OF FILE backend/app/models/skill_template.py ---

--- START OF FILE backend/app/models/trait_template.py ---
# backend/app/models/trait_template.py
import uuid
from typing import Optional, Dict, Any, List # <<< MAKE SURE List IS IMPORTED FROM typing

from sqlalchemy import String, Text
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column

from ..db.base_class import Base

class TraitTemplate(Base):
    __tablename__ = "trait_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    trait_id_tag: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    
    name: Mapped[str] = mapped_column(String(100), nullable=False, comment="Player-facing name, e.g., 'Nimble Fingers'")
    description: Mapped[Text] = mapped_column(Text, nullable=True, comment="Player-facing description.")
    
    trait_type: Mapped[str] = mapped_column(String(50), default="PASSIVE", nullable=False, 
                                            comment="Usually 'PASSIVE', but could be 'SOCIAL', 'BACKGROUND', etc.")
    
    effects_data: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False, default=lambda: {})

    # If this trait is mutually exclusive with others
    mutually_exclusive_with: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # type: ignore # Added default

    def __repr__(self) -> str:
        return f"<TraitTemplate(id={self.id}, trait_id_tag='{self.trait_id_tag}', name='{self.name}')>"
--- END OF FILE backend/app/models/trait_template.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/models/character_inventory_item.py ---
# backend/app/models/character_inventory_item.py
import uuid
from typing import TYPE_CHECKING, Optional

from sqlalchemy import ForeignKey, Integer, Boolean, String
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .character import Character  # noqa: F401
    from .item import Item  # noqa: F401


class CharacterInventoryItem(Base):
    __tablename__ = "character_inventory_items"

    # Composite Primary Key: (character_id, item_id)
    # However, SQLAlchemy prefers a single surrogate primary key for association objects
    # if they have additional attributes beyond just the foreign keys.
    # Let's add an explicit id for this table for easier reference, though character_id + item_id could form a unique constraint.
    # Or, if an item can appear multiple times (e.g. two identical non-stackable swords),
    # then an auto-incrementing ID for this table row is essential.
    # Let's assume for now a character can only have ONE "entry" for a given item_id, and quantity handles multiples if stackable.
    # If not stackable, and they have two of the same sword, they'd be two separate Item instances in the Item table (e.g. with serial numbers or unique IDs anyway).
    # For our MUD, usually an Item is a "template". If a player has two "Long Sword" (same item_id), this table handles it.
    # Okay, if Item.stackable is false, each instance is a separate row here with quantity 1.
    # If Item.stackable is true, one row with quantity > 1.
    # Let's give this table its own UUID PK for simplicity in referencing a specific *instance* in inventory.

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, comment="Unique ID for this specific instance of an item in a character's inventory")
    
    character_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Indicates if this specific inventory item instance is currently equipped
    equipped: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False, index=True)
    
    # If equipped, this specifies which of the character's equipment slots it occupies.
    # This must be one of the keys from models.item.EQUIPMENT_SLOTS.
    # Necessary for items that can fit into more than one type of slot (e.g. generic 'ring' item into 'finger_1' or 'finger_2')
    # or to distinguish main_hand vs off_hand for identical weapons.
    equipped_slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="Actual character slot occupied if equipped, e.g. 'finger_1'")

    # Relationships
    character: Mapped["Character"] = relationship(back_populates="inventory_items")
    item: Mapped["Item"] = relationship() # No back_populates needed if Item doesn't need to know all its inventory entries directly

    def __repr__(self) -> str:
        return f"<CharInvItem(id={self.id}, char_id='{self.character_id}', item_id='{self.item_id}', qty={self.quantity}, equipped={self.equipped}, slot='{self.equipped_slot}')>"
--- END OF FILE backend/app/models/character_inventory_item.py ---

--- START OF FILE backend/app/models/room_item_instance.py ---
# backend/app/models/room_item_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room import Room  # noqa: F401
    from .item import Item  # noqa: F401
    from .character import Character # noqa: F401

class RoomItemInstance(Base):
    __tablename__ = "room_item_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Optional: if this instance on the ground has different properties than the item template
    properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    
    dropped_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    dropped_by_character_id: Mapped[Optional[uuid.UUID]] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), nullable=True, index=True)

    # Relationships
    room: Mapped["Room"] = relationship(back_populates="items_on_ground")
    item: Mapped["Item"] = relationship(lazy="joined") # Eager load item template details by default
    dropped_by: Mapped[Optional["Character"]] = relationship() # Character who dropped it

    def __repr__(self) -> str:
        return f"<RoomItemInstance(id={self.id}, room_id='{self.room_id}', item_id='{self.item_id}', qty={self.quantity})>"
--- END OF FILE backend/app/models/room_item_instance.py ---

--- START OF FILE backend/app/models/mob_template.py ---
# backend/app/models/mob_template.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import String, Text, Integer # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class MobTemplate(Base):
    __tablename__ = "mob_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    mob_type: Mapped[Optional[str]] = mapped_column(String(50), index=True, nullable=True, comment="e.g., beast, humanoid, undead")
    
    base_health: Mapped[int] = mapped_column(Integer, nullable=False, default=10)
    # For base_attack, simple string for now. Could be JSON for more complex attacks.
    base_attack: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., 1d6") 
    base_defense: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=10, comment="e.g., Armor Class")
    
    xp_value: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    # loot_table_id: Mapped[Optional[uuid.UUID]] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("loot_tables.id"), nullable=True) # Future
    loot_table_ref: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, comment="Placeholder for loot table reference")

    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'aggression': 'neutral', 'faction': 'rats'}")
    level: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)

    # room_instances: Mapped[List["RoomMobInstance"]] = relationship(back_populates="mob_template") # If needed

    def __repr__(self) -> str:
        return f"<MobTemplate(id={self.id}, name='{self.name}')>"
--- END OF FILE backend/app/models/mob_template.py ---

--- START OF FILE backend/app/models/room_mob_instance.py ---
# backend/app/models/room_mob_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func, String, Boolean # Added Boolean
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room import Room 
    from .mob_template import MobTemplate 
    from .mob_spawn_definition import MobSpawnDefinition # Changed from MobSpawnPoint

class RoomMobInstance(Base):
    __tablename__ = "room_mob_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    mob_template_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_templates.id"), index=True, nullable=False)
    
    # Links to the MobSpawnDefinition that created this instance, if any.
    spawn_definition_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True), 
        ForeignKey("mob_spawn_definitions.id"), # <<< Will match new table name
        nullable=True, 
        index=True,
        name="spawn_point_id" # Keep old column name in DB for now to simplify migration if needed, or rename
    ) 
    # If you want to rename the DB column, the migration will be more complex.
    # For now, let's assume we might keep the column name `spawn_point_id` in the DB for a bit
    # but use `spawn_definition_id` in the ORM model. Or rename consistently.
    # Let's be consistent and rename in ORM:
    # spawn_definition_id: Mapped[Optional[uuid.UUID]] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_spawn_definitions.id"), nullable=True, index=True)


    current_health: Mapped[int] = mapped_column(Integer, nullable=False)
    instance_properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    spawned_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_action_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    is_static_placement: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False,
                                                      comment="True if this mob was placed specifically and should not be respawned by general systems.")

    # Relationships
    room: Mapped["Room"] = relationship(back_populates="mobs_in_room")
    mob_template: Mapped["MobTemplate"] = relationship(lazy="joined")
    
    # Optional: Relationship to MobSpawnDefinition
    # originating_spawn_definition: Mapped[Optional["MobSpawnDefinition"]] = relationship(foreign_keys=[spawn_definition_id])

    def __repr__(self) -> str:
        return f"<RoomMobInstance(id={self.id}, room_id='{self.room_id}', template_id='{self.mob_template_id}', spawn_def_id='{self.spawn_definition_id}', hp={self.current_health})>"
--- END OF FILE backend/app/models/room_mob_instance.py ---

--- START OF FILE backend/app/models/mob_spawn_definition.py ---
# backend/app/models/mob_spawn_definition.py
import uuid
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

from sqlalchemy import ForeignKey, Integer, DateTime, func, String, Boolean # Added Boolean
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class MobSpawnDefinition(Base):
    __tablename__ = "mob_spawn_definitions" # New table name

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    definition_name: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False,
                                                 comment="Unique descriptive name, e.g., 'CellarRatsNorthCorner'")
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False,
                                             comment="Primary room this definition is tied to / origin room for roamers.")
    mob_template_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_templates.id"), index=True, nullable=False)
    
    quantity_min: Mapped[int] = mapped_column(Integer, default=1, nullable=False,
                                             comment="Spawner tries to maintain at least this many alive from this definition.")
    quantity_max: Mapped[int] = mapped_column(Integer, default=1, nullable=False,
                                             comment="Spawner won't spawn more than this many from this definition if min is met.")
    
    respawn_delay_seconds: Mapped[int] = mapped_column(Integer, default=300, nullable=False, # e.g., 5 minutes
                                                      comment="Delay after population drops below min, or after individual kill.")
    
    chance_to_spawn_percent: Mapped[int] = mapped_column(Integer, default=100, nullable=False,
                                                        comment="0-100 percent chance to spawn when conditions are met.")
    
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False,
                                           comment="Whether this spawn definition is currently active.")

    # Tracks when the next check for respawning for THIS definition should occur.
    next_respawn_check_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True, index=True,
                                                                   comment="Next time the ticker should evaluate this spawner.")

    # For future roaming logic
    roaming_behavior: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True,
                                                                    comment="e.g., patrol routes, random chance to move.")
    # For future specific placement within a room
    # spawn_area_details: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)


    # Relationships (optional, if needed for direct access from definition object)
    # room: Mapped["Room"] = relationship()
    # mob_template: Mapped["MobTemplate"] = relationship()

    def __repr__(self) -> str:
        return f"<MobSpawnDefinition(id={self.id}, name='{self.definition_name}', mob='{self.mob_template_id}', room='{self.room_id}', qty='{self.quantity_min}-{self.quantity_max}')>"
--- END OF FILE backend/app/models/mob_spawn_definition.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py
import uuid
from typing import Optional, Dict, List, TYPE_CHECKING # Added List, TYPE_CHECKING

from sqlalchemy import Column, Integer, String, Text, JSON
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship # Added relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance 
    from .room_mob_instance import RoomMobInstance

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    exits: Mapped[Optional[Dict[str, str]]] = mapped_column(JSON, nullable=True, default=lambda: {})

    # --- Items on Ground Relationship --- (<<< ADDED)
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan", # If room is deleted, items on ground in it are also deleted.
        lazy="selectin" # Use selectin loading for items_on_ground when a Room is loaded
    )

    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan", # If room is deleted, mobs in it are also deleted.
        lazy="selectin" 
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', x={self.x}, y={self.y}, z={self.z})>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/schemas/__init__.py ---
# File: backend/app/schemas/__init__.py

# Make the Pydantic models from room.py available directly under the schemas package
from .room import RoomBase, RoomCreate, RoomUpdate, RoomInDB
from .player import PlayerBase, PlayerCreate, PlayerUpdate, Player, PlayerInDB
from .character import CharacterBase, CharacterCreate, CharacterUpdate, Character, CharacterInDB
from .command import CommandRequest, CommandResponse
from .item import (  # <<< ADDED
    ItemBase, ItemCreate, ItemUpdate, Item, ItemInDB,
    CharacterInventoryItemBase, CharacterInventoryItemCreate, CharacterInventoryItemUpdate,
    CharacterInventoryItem, CharacterInventoryDisplay, EquipRequest
)
from .room_item import ( # <<< ADDED
    RoomItemInstanceBase, RoomItemInstanceCreate, RoomItemInstanceUpdate,
    RoomItemInstance, RoomItemsView
)
from .mob import ( # <<< ADDED
    MobTemplateBase, MobTemplateCreate, MobTemplateUpdate, MobTemplate,
    RoomMobInstanceBase, RoomMobInstanceCreate, RoomMobInstanceUpdate,
    RoomMobInstance, RoomMobsView
)
from .character_class_template import ( # <<< ADD THIS BLOCK
    CharacterClassTemplateBase, CharacterClassTemplateCreate, CharacterClassTemplateUpdate,
    CharacterClassTemplate, CharacterClassTemplateInDB
)
from .map import MapLevelDataResponse, MapRoomData
from .skill import ( # <<< ADD THIS BLOCK
    SkillTemplateBase, SkillTemplateCreate, SkillTemplateUpdate, SkillTemplate
)
from .trait import ( # <<< ADD THIS BLOCK
    TraitTemplateBase, TraitTemplateCreate, TraitTemplateUpdate, TraitTemplate
)
from .mob_spawn_definition import (
    MobSpawnDefinitionBase, MobSpawnDefinitionCreate, MobSpawnDefinitionUpdate, MobSpawnDefinition
)
--- END OF FILE backend/app/schemas/__init__.py ---

--- START OF FILE backend/app/schemas/player.py ---
# backend/app/schemas/player.py
from typing import Optional
import uuid
from pydantic import BaseModel, Field, EmailStr # EmailStr if you add email later

class PlayerBase(BaseModel):
    username: Optional[str] = Field(None, min_length=3, max_length=100)
    # email: Optional[EmailStr] = None # Example for later

class PlayerCreate(PlayerBase):
    username: str = Field(..., min_length=3, max_length=100) # type: ignore[override] # Make username required
    password: str = Field(..., min_length=8) # Plain password for creation

class PlayerUpdate(PlayerBase): # Not used yet, but for completeness
    username: Optional[str] = None
    password: Optional[str] = None # For password change functionality

class PlayerInDBBase(PlayerBase):
    id: uuid.UUID
    # hashed_password should not be in schemas returned to client

    class Config:
        from_attributes = True

class Player(PlayerInDBBase): # Schema for returning player info (without password)
    pass

class PlayerInDB(PlayerInDBBase): # More complete internal representation if needed
    hashed_password: str
--- END OF FILE backend/app/schemas/player.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)


# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase): # Now inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/schemas/character_class_template.py ---
# backend/app/schemas/character_class_template.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

class CharacterClassTemplateBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=100)
    description: Optional[str] = None
    base_stat_modifiers: Optional[Dict[str, int]] = Field(default_factory=dict)
    starting_health_bonus: int = 0
    starting_mana_bonus: int = 0
    skill_tree_definition: Optional[Dict[str, Any]] = Field(default_factory=dict)
    starting_equipment_refs: Optional[List[str]] = Field(default_factory=list)
    playstyle_tags: Optional[List[str]] = Field(default_factory=list)

class CharacterClassTemplateCreate(CharacterClassTemplateBase):
    pass

class CharacterClassTemplateUpdate(BaseModel): # For partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    base_stat_modifiers: Optional[Dict[str, int]] = None
    starting_health_bonus: Optional[int] = None
    starting_mana_bonus: Optional[int] = None
    skill_tree_definition: Optional[Dict[str, Any]] = None
    starting_equipment_refs: Optional[List[str]] = None
    playstyle_tags: Optional[List[str]] = None

class CharacterClassTemplateInDBBase(CharacterClassTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class CharacterClassTemplate(CharacterClassTemplateInDBBase): # For returning to client
    pass

class CharacterClassTemplateInDB(CharacterClassTemplateInDBBase): # For DB internal use
    pass
--- END OF FILE backend/app/schemas/character_class_template.py ---

--- START OF FILE backend/app/schemas/skill.py ---
# backend/app/schemas/skill.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List # Added List

class SkillTemplateBase(BaseModel):
    skill_id_tag: str = Field(..., min_length=3, max_length=100, pattern="^[a-z0-9_]+$",
                               description="Unique internal identifier, e.g., 'power_attack'. Lowercase, numbers, underscores.")
    name: str = Field(..., min_length=3, max_length=100, description="Player-facing name, e.g., 'Power Attack'")
    description: Optional[str] = None
    skill_type: str = Field(..., description="e.g., 'COMBAT_ACTIVE', 'PASSIVE', 'UTILITY_OOC'")
    target_type: str = Field(default="NONE", description="e.g., 'SELF', 'ENEMY_MOB', 'NONE'")
    effects_data: Dict[str, Any] = Field(default_factory=dict)
    requirements_data: Optional[Dict[str, Any]] = Field(default_factory=dict)
    rank: Optional[int] = Field(1, ge=1)
    cooldown: Optional[int] = Field(0, ge=0)

class SkillTemplateCreate(SkillTemplateBase):
    pass

class SkillTemplateUpdate(BaseModel): # For partial updates
    skill_id_tag: Optional[str] = Field(None, min_length=3, max_length=100, pattern="^[a-z0-9_]+$")
    name: Optional[str] = Field(None, min_length=3, max_length=100)
    description: Optional[str] = None
    skill_type: Optional[str] = None
    target_type: Optional[str] = None
    effects_data: Optional[Dict[str, Any]] = None
    requirements_data: Optional[Dict[str, Any]] = None
    rank: Optional[int] = Field(None, ge=1)
    cooldown: Optional[int] = Field(None, ge=0)

class SkillTemplateInDBBase(SkillTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class SkillTemplate(SkillTemplateInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/skill.py ---

--- START OF FILE backend/app/schemas/trait.py ---
# backend/app/schemas/trait.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List # Added List

class TraitTemplateBase(BaseModel):
    trait_id_tag: str = Field(..., min_length=3, max_length=100, pattern="^[a-z0-9_]+$",
                                description="Unique internal identifier, e.g., 'nimble_fingers'. Lowercase, numbers, underscores.")
    name: str = Field(..., min_length=3, max_length=100, description="Player-facing name, e.g., 'Nimble Fingers'")
    description: Optional[str] = None
    trait_type: str = Field(default="PASSIVE", description="e.g., 'PASSIVE', 'SOCIAL'")
    effects_data: Dict[str, Any] = Field(default_factory=dict)
    mutually_exclusive_with: Optional[List[str]] = Field(default_factory=list)

class TraitTemplateCreate(TraitTemplateBase):
    pass

class TraitTemplateUpdate(BaseModel): # For partial updates
    trait_id_tag: Optional[str] = Field(None, min_length=3, max_length=100, pattern="^[a-z0-9_]+$")
    name: Optional[str] = None
    description: Optional[str] = None
    trait_type: Optional[str] = None
    effects_data: Optional[Dict[str, Any]] = None
    mutually_exclusive_with: Optional[List[str]] = None

class TraitTemplateInDBBase(TraitTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class TraitTemplate(TraitTemplateInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/trait.py ---

--- START OF FILE backend/app/schemas/item.py ---
# backend/app/schemas/item.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- Item Schemas ---
class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    item_type: str = Field(..., description="e.g., weapon, armor, potion, junk")
    slot: Optional[str] = Field(None, description="Primary equippable slot type, e.g., head, main_hand, consumable")
    properties: Optional[Dict[str, Any]] = Field(None, description="e.g., {'damage': '1d6', 'armor_class': 5}")
    weight: float = Field(0.0, ge=0)
    value: int = Field(0, ge=0)
    stackable: bool = False
    max_stack_size: Optional[int] = Field(1, ge=1)

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    item_type: Optional[str] = None
    slot: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    weight: Optional[float] = None
    value: Optional[int] = None
    stackable: Optional[bool] = None
    max_stack_size: Optional[int] = None

class ItemInDBBase(ItemBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class Item(ItemInDBBase): # For returning item info
    pass

class ItemInDB(ItemInDBBase): # More complete internal representation if needed
    pass


# --- CharacterInventoryItem Schemas ---
# This represents an item *instance* in a character's inventory

class CharacterInventoryItemBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    equipped: bool = False
    equipped_slot: Optional[str] = None # Actual character slot occupied if equipped

class CharacterInventoryItemCreate(CharacterInventoryItemBase):
    # character_id will be supplied by the service/path
    pass

class CharacterInventoryItemUpdate(BaseModel):
    quantity: Optional[int] = Field(None, ge=1)
    equipped: Optional[bool] = None
    equipped_slot: Optional[str] = None

class CharacterInventoryItemInDBBase(CharacterInventoryItemBase):
    id: uuid.UUID # The unique ID of this inventory entry
    character_id: uuid.UUID
    item: Item # Include full item details when displaying inventory

    class Config:
        from_attributes = True

class CharacterInventoryItem(CharacterInventoryItemInDBBase): # For returning to client
    pass


# --- Composite Schema for Displaying Full Inventory ---
class CharacterInventoryDisplay(BaseModel):
    equipped_items: Dict[str, CharacterInventoryItem] = Field(default_factory=dict, description="Items currently equipped, keyed by their equipped_slot")
    backpack_items: List[CharacterInventoryItem] = Field(default_factory=list, description="Items in inventory but not equipped")
    # Add more fields like total_weight, currency later

class EquipRequest(BaseModel):
    target_slot: Optional[str] = Field(None, description="Optional: The specific character slot to equip the item to, e.g., 'finger_1'")
--- END OF FILE backend/app/schemas/item.py ---

--- START OF FILE backend/app/schemas/room_item.py ---
# backend/app/schemas/room_item.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any

from .item import Item # Import the Item schema for nesting

class RoomItemInstanceBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    properties_override: Optional[Dict[str, Any]] = None

class RoomItemInstanceCreate(RoomItemInstanceBase):
    # room_id will be supplied by the service/path
    # dropped_by_character_id can be optional
    dropped_by_character_id: Optional[uuid.UUID] = None

class RoomItemInstanceUpdate(BaseModel): # For potential future use
    quantity: Optional[int] = Field(None, ge=1)
    properties_override: Optional[Dict[str, Any]] = None

class RoomItemInstanceInDBBase(RoomItemInstanceBase):
    id: uuid.UUID # The unique ID of this room item instance
    room_id: uuid.UUID
    dropped_at: datetime
    dropped_by_character_id: Optional[uuid.UUID] = None
    
    item: Item # Include full item details from the Item template

    class Config:
        from_attributes = True

class RoomItemInstance(RoomItemInstanceInDBBase): # For returning to client
    pass

# Schema for displaying items in a room (could be part of a larger RoomDetail schema)
class RoomItemsView(BaseModel):
    items_on_ground: List[RoomItemInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/room_item.py ---

--- START OF FILE backend/app/schemas/mob.py ---
# backend/app/schemas/mob.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- MobTemplate Schemas ---
class MobTemplateBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    mob_type: Optional[str] = None
    base_health: int = Field(10, gt=0)
    base_attack: Optional[str] = "1d4"
    base_defense: Optional[int] = 10
    xp_value: int = 0
    loot_table_ref: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    level: Optional[int] = None

class MobTemplateCreate(MobTemplateBase):
    pass

class MobTemplateUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    mob_type: Optional[str] = None
    base_health: Optional[int] = Field(None, gt=0)
    base_attack: Optional[str] = None
    base_defense: Optional[int] = None
    xp_value: Optional[int] = None
    loot_table_ref: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    level: Optional[int] = None

class MobTemplateInDBBase(MobTemplateBase):
    id: uuid.UUID
    class Config:
        from_attributes = True

class MobTemplate(MobTemplateInDBBase): # For returning template info
    pass


# --- RoomMobInstance Schemas ---
class RoomMobInstanceBase(BaseModel):
    mob_template_id: uuid.UUID
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None

class RoomMobInstanceCreate(BaseModel): # For service layer use
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    # current_health typically set from template by service
    instance_properties_override: Optional[Dict[str, Any]] = None 
    spawn_point_id: Optional[uuid.UUID] = None 
    
class RoomMobInstanceUpdate(BaseModel): # For combat updates
    current_health: Optional[int] = None
    instance_properties_override: Optional[Dict[str, Any]] = Field(None, description="Use with caution, replaces entire dict")

class RoomMobInstanceInDBBase(BaseModel): # Note: Not inheriting from RoomMobInstanceBase to control field order for MobTemplate
    id: uuid.UUID
    room_id: uuid.UUID
    mob_template_id: uuid.UUID # Keep this for reference
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None
    spawn_point_id: Optional[uuid.UUID] = None 
    spawned_at: datetime
    last_action_at: Optional[datetime] = None
    
    mob_template: MobTemplate # Include full mob template details

    class Config:
        from_attributes = True

class RoomMobInstance(RoomMobInstanceInDBBase): # For returning to client
    pass

# Schema for displaying mobs in a room (could be part of a larger RoomDetail schema)
class RoomMobsView(BaseModel):
    mobs_in_room: List[RoomMobInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/mob.py ---

--- START OF FILE backend/app/schemas/mob_spawn_definition.py ---
# backend/app/schemas/mob_spawn_definition.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any

from pydantic import BaseModel, Field

class MobSpawnDefinitionBase(BaseModel):
    definition_name: str = Field(..., min_length=3, max_length=255)
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    quantity_min: int = Field(default=1, ge=1)
    quantity_max: int = Field(default=1, ge=1) # Should validate quantity_max >= quantity_min later
    respawn_delay_seconds: int = Field(default=300, ge=5)
    chance_to_spawn_percent: int = Field(default=100, ge=0, le=100)
    is_active: bool = True
    roaming_behavior: Optional[Dict[str, Any]] = None
    # next_respawn_check_at is usually managed by the system, not set on create/update by user

class MobSpawnDefinitionCreate(MobSpawnDefinitionBase):
    pass

class MobSpawnDefinitionUpdate(BaseModel): # Allow partial updates
    definition_name: Optional[str] = Field(None, min_length=3, max_length=255)
    room_id: Optional[uuid.UUID] = None
    mob_template_id: Optional[uuid.UUID] = None
    quantity_min: Optional[int] = Field(None, ge=1)
    quantity_max: Optional[int] = Field(None, ge=1)
    respawn_delay_seconds: Optional[int] = Field(None, ge=5)
    chance_to_spawn_percent: Optional[int] = Field(None, ge=0, le=100)
    is_active: Optional[bool] = None
    roaming_behavior: Optional[Dict[str, Any]] = None
    next_respawn_check_at: Optional[datetime] = None # Allow admin to set/reset this

class MobSpawnDefinitionInDBBase(MobSpawnDefinitionBase):
    id: uuid.UUID
    next_respawn_check_at: Optional[datetime] = None

    class Config:
        from_attributes = True

class MobSpawnDefinition(MobSpawnDefinitionInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/mob_spawn_definition.py ---

--- START OF FILE backend/app/schemas/room.py ---
# backend/app/schemas/room.py
from pydantic import BaseModel, Field, field_validator # field_validator for Pydantic v2
import uuid # Import uuid
from typing import Dict, Optional, Any

class RoomBase(BaseModel):
    name: str
    description: Optional[str] = None
    x: int
    y: int
    z: int
    # Exits: keys are directions (str), values are target room UUIDs (str)
    exits: Optional[Dict[str, str]] = Field(default_factory=dict) 

class RoomCreate(RoomBase):
    # id can optionally be provided if you want to set it explicitly,
    # otherwise the DB model's default=uuid.uuid4 will handle it.
    id: Optional[uuid.UUID] = None 
    # name, description, x, y, z, exits are inherited
    pass

class RoomUpdate(BaseModel): # Not heavily used yet, but good to keep consistent
    name: Optional[str] = None
    description: Optional[str] = None
    x: Optional[int] = None
    y: Optional[int] = None
    z: Optional[int] = None
    exits: Optional[Dict[str, str]] = None

class RoomInDB(RoomBase): # This schema is used for reading rooms from DB
    id: uuid.UUID # ID from DB will definitely be a UUID

    class Config:
        from_attributes = True # For Pydantic v2 ORM mode

--- END OF FILE backend/app/schemas/room.py ---

--- START OF FILE backend/app/schemas/map.py ---
# backend/app/schemas/map.py (NEW FILE)
import uuid
from pydantic import BaseModel, Field
from typing import List, Dict, Optional

from .room import RoomInDB # We'll use the existing RoomInDB for individual room details

class MapRoomData(BaseModel):
    id: uuid.UUID
    x: int
    y: int
    name: Optional[str] = None # Optional: for tooltips or labels
    exits: Optional[Dict[str, str]] = Field(default_factory=dict)
    is_current_room: bool = False
    is_visited: bool = True # For now, all fetched rooms are considered visited

class MapLevelDataResponse(BaseModel):
    z_level: int
    current_room_id: Optional[uuid.UUID] = None
    rooms: List[MapRoomData] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/map.py ---

--- START OF FILE backend/app/schemas/command.py ---
# backend/app/schemas/command.py
from pydantic import BaseModel
from typing import Optional
from .room import RoomInDB

class CommandRequest(BaseModel):
    command: str

class CommandResponse(BaseModel):
    room_data: Optional[RoomInDB] = None
    message_to_player: Optional[str] = None
    combat_over: bool = False # True if combat resolved (death, flee)
    # Add other potential fields for game state updates if needed for HTTP path
--- END OF FILE backend/app/schemas/command.py ---

--- FILE NOT FOUND: backend/app/schemas/token.py ---

--- START OF FILE backend/app/crud/__init__.py ---
# File: backend/app/crud/__init__.py

from . import crud_room # This makes the crud_room.py module accessible as crud.crud_room
from . import crud_player
from . import crud_character
from . import crud_item  # <<< ADDED
from . import crud_character_inventory  # <<< ADDED
from . import crud_room_item  # <<< ADDED
from . import crud_mob
from . import crud_character_class
from . import crud_skill
from . import crud_trait
from . import crud_mob_spawn_definition
--- END OF FILE backend/app/crud/__init__.py ---

--- START OF FILE backend/app/crud/crud_player.py ---
# backend/app/crud/crud_player.py
from sqlalchemy.orm import Session
import uuid # Ensure uuid is imported
from typing import Optional

from .. import models, schemas # models.Player, schemas.PlayerCreate etc.
from ..core.security import get_password_hash # Our password hashing utility

def get_player(db: Session, player_id: uuid.UUID) -> Optional[models.Player]:
    return db.query(models.Player).filter(models.Player.id == player_id).first()

def get_player_by_username(db: Session, username: str) -> Optional[models.Player]:
    return db.query(models.Player).filter(models.Player.username == username).first()

def create_player(db: Session, *, player_in: schemas.PlayerCreate) -> models.Player:
    hashed_password = get_password_hash(player_in.password)
    # Create a dictionary for the DB model, excluding the plain password
    db_player_data = player_in.model_dump(exclude={'password'})
    db_player = models.Player(**db_player_data, hashed_password=hashed_password)
    
    db.add(db_player)
    db.commit()
    db.refresh(db_player)
    return db_player
--- END OF FILE backend/app/crud/crud_player.py ---

--- START OF FILE backend/app/crud/crud_character.py ---
# backend/app/crud/crud_character.py
from sqlalchemy.orm import Session, attributes
import uuid
from typing import Any, Dict, Optional, List, Tuple, Union 

from .. import models, schemas, crud # <<< ADDED crud FOR crud_character_class

DEFAULT_STATS = {
    "strength": 10, "dexterity": 10, "constitution": 10,
    "intelligence": 10, "wisdom": 10, "charisma": 10, "luck": 5,
    "current_health": 20, "max_health": 20,
    "current_mana": 10, "max_mana": 10,
    "level": 1, "experience_points": 0,
    "base_ac": 10, "base_attack_bonus": 0,
    "base_damage_dice": "1d4", "base_damage_bonus": 0,
    "learned_skills": [], "learned_traits": []
}

XP_THRESHOLDS = {
    1: 0,       # Start at level 1 with 0 XP
    2: 100,
    3: 300,     # Need 200 more XP from level 2 (100+200)
    4: 600,     # Need 300 more XP from level 3 (300+300)
    5: 1000,    # Need 400 more XP
    # ... add more levels as needed
}

CLASS_LEVEL_BONUSES = {
    "Warrior": {"hp_per_level": 5, "mp_per_level": 1, "base_attack_bonus_per_level": 0.5}, # BAB increases every 2 levels
    "Swindler": {"hp_per_level": 3, "mp_per_level": 2, "base_attack_bonus_per_level": 0.5},
    "Adventurer": {"hp_per_level": 4, "mp_per_level": 1, "base_attack_bonus_per_level": 0.5}, # Default
    # Add other seeded classes
}

def get_xp_for_level(level: int) -> Union[int, float]: # <<< CHANGED RETURN TYPE
    """Returns the total XP required to attain the specified level."""
    return XP_THRESHOLDS.get(level, float('inf')) # <<< USE float('inf')


def get_character(db: Session, character_id: uuid.UUID) -> Optional[models.Character]:
    return db.query(models.Character).filter(models.Character.id == character_id).first()

def get_character_by_name(db: Session, name: str) -> Optional[models.Character]:
    return db.query(models.Character).filter(models.Character.name == name).first()

def get_characters_by_player(db: Session, player_id: uuid.UUID, skip: int = 0, limit: int = 100) -> List[models.Character]:
    return db.query(models.Character).filter(models.Character.player_id == player_id).offset(skip).limit(limit).all()

def _grant_abilities_for_level(db: Session, character: models.Character, level_to_grant_for: int) -> List[str]:
    """Grants skills/traits for a specific level. Called by create_character for L1, and _apply_level_up for L2+."""
    granted_messages = []
    level_str = str(level_to_grant_for)
    # --- Debug prints to add if still having issues ---
    # print(f"DEBUG GrantAbilities: Char '{character.name}', Attempting for Level: {level_str}")

    class_template: Optional[models.CharacterClassTemplate] = None
    if character.character_class_template_id:
        if character.class_template_ref and character.class_template_ref.id == character.character_class_template_id:
            class_template = character.class_template_ref
        else:
            class_template = crud.crud_character_class.get_character_class_template(db, class_template_id=character.character_class_template_id)
    
    # --- Debug prints ---
    # if class_template:
    #     print(f"DEBUG GrantAbilities: Found class template '{class_template.name}' with skill tree: {class_template.skill_tree_definition is not None}")
    #     if class_template.skill_tree_definition: print(f"DEBUG GrantAbilities: Skill tree: {class_template.skill_tree_definition}")
    # else:
    #     print(f"DEBUG GrantAbilities: No class template found for character {character.name} (template_id: {character.character_class_template_id})")
    #     return granted_messages


    if class_template and class_template.skill_tree_definition:
        skill_tree: Dict[str, Any] = class_template.skill_tree_definition

        # Grant Core Skills
        core_skills_for_level: List[str] = skill_tree.get("core_skills_by_level", {}).get(level_str, [])
        # print(f"DEBUG GrantAbilities: Skills for level '{level_str}': {core_skills_for_level}")
        if core_skills_for_level:
            if character.learned_skills is None: character.learned_skills = []
            learned_new = False
            for skill_tag in core_skills_for_level:
                skill_def = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_tag)
                # print(f"DEBUG GrantAbilities: Trying skill '{skill_tag}', found def: {skill_def is not None}")
                if skill_def and skill_tag not in character.learned_skills:
                    character.learned_skills.append(skill_tag)
                    granted_messages.append(f"You have learned skill: {skill_def.name}!")
                    learned_new = True
            if learned_new: attributes.flag_modified(character, "learned_skills")

        # Grant Core Traits
        core_traits_for_level: List[str] = skill_tree.get("core_traits_by_level", {}).get(level_str, [])
        # print(f"DEBUG GrantAbilities: Traits for level '{level_str}': {core_traits_for_level}")
        if core_traits_for_level:
            if character.learned_traits is None: character.learned_traits = []
            learned_new = False
            for trait_tag in core_traits_for_level:
                trait_def = crud.crud_trait.get_trait_template_by_tag(db, trait_id_tag=trait_tag)
                # print(f"DEBUG GrantAbilities: Trying trait '{trait_tag}', found def: {trait_def is not None}")
                if trait_def and trait_tag not in character.learned_traits:
                    character.learned_traits.append(trait_tag)
                    granted_messages.append(f"You have gained trait: {trait_def.name}!")
                    learned_new = True
            if learned_new: attributes.flag_modified(character, "learned_traits")
    # else:
        # print(f"DEBUG GrantAbilities: No class template or skill tree for character {character.name} at level '{level_str}'")
        
    return granted_messages

def create_character(
    db: Session, *,
    character_in: schemas.CharacterCreate,
    player_id: uuid.UUID,
    initial_room_id: uuid.UUID
) -> models.Character:
    db_character_data = character_in.model_dump(exclude_unset=True)
    final_char_args = DEFAULT_STATS.copy()
    class_template_id_to_set: Optional[uuid.UUID] = None
    class_name_to_set = db_character_data.get("class_name", "Adventurer") # Changed default to Adventurer to match class bonuses
    class_template: Optional[models.CharacterClassTemplate] = None

    if class_name_to_set and class_name_to_set != "Adventurer": # Match the default
        class_template = crud.crud_character_class.get_character_class_template_by_name(db, name=class_name_to_set)
        if class_template:
            class_template_id_to_set = class_template.id
            class_name_to_set = class_template.name
            if class_template.base_stat_modifiers:
                for stat, modifier in class_template.base_stat_modifiers.items():
                    if stat in final_char_args: final_char_args[stat] += modifier
            final_char_args["max_health"] += class_template.starting_health_bonus
            final_char_args["current_health"] = final_char_args["max_health"]
            final_char_args["max_mana"] += class_template.starting_mana_bonus
            final_char_args["current_mana"] = final_char_args["max_mana"]
        else:
            print(f"Warning: Character class template '{class_name_to_set}' not found. Defaulting to Adventurer stats.")
            class_name_to_set = "Adventurer"
            
    db_character = models.Character(
        name=db_character_data["name"],
        class_name=class_name_to_set,
        player_id=player_id,
        current_room_id=initial_room_id,
        character_class_template_id=class_template_id_to_set,
        **final_char_args
    )
    db.add(db_character)
    db.commit()
    db.refresh(db_character)

    # --- Crucial: Grant Level 1 Abilities AFTER character is in DB and refreshed ---
    # Ensure class_template is available for _grant_abilities_for_level
    # The refresh above might not populate db_character.class_template_ref if not configured for eager loading.
    # So, we re-use the 'class_template' variable we fetched earlier if it's valid.
    # If 'class_template' is None (e.g. for "Adventurer" if no template defined or for a class not found),
    # then _grant_abilities_for_level will try to fetch it again using db_character.character_class_template_id
    if class_template: # If we had fetched a valid class template earlier
        db_character.class_template_ref = class_template # Explicitly assign to the instance for _grant_abilities_for_level

    initial_ability_messages = _grant_abilities_for_level(db, db_character, 1) # Grant for Level 1
    
    # If abilities were granted, the lists in db_character are modified.
    # We need to add to session again and commit.
    if initial_ability_messages: # Check if any messages were generated (implies changes)
        print(f"Character '{db_character.name}' initial abilities granted: {', '.join(initial_ability_messages)}")
        db.add(db_character) 
        db.commit()
        db.refresh(db_character) # Refresh again to get the latest state with learned skills/traits

    # Grant starting equipment
    if class_template and class_template.starting_equipment_refs:
        for item_ref_name in class_template.starting_equipment_refs:
            item_template_to_add = crud.crud_item.get_item_by_name(db, name=item_ref_name)
            if item_template_to_add:
                crud.crud_character_inventory.add_item_to_character_inventory(
                    db, character_id=db_character.id, item_id=item_template_to_add.id, quantity=1
                )
        db.commit()
        db.refresh(db_character)
        
    return db_character

def update_character_room(db: Session, character_id: uuid.UUID, new_room_id: uuid.UUID) -> Optional[models.Character]:
    db_character = get_character(db, character_id=character_id)
    if db_character:
        db_character.current_room_id = new_room_id # Direct assignment is fine
        db.add(db_character) # Add to session to mark as dirty
        db.commit()
        db.refresh(db_character)
        return db_character
    return None

def update_character_health(db: Session, character_id: uuid.UUID, amount_change: int) -> Optional[models.Character]:
    """Updates character's current health by amount_change. Clamps between 0 and max_health."""
    character = get_character(db, character_id=character_id)
    if not character:
        return None
    
    character.current_health += amount_change
    if character.current_health < 0:
        character.current_health = 0
    if character.current_health > character.max_health:
        character.current_health = character.max_health
        
    db.add(character)
    db.commit()
    db.refresh(character)
    return character

# Conceptual: def level_up_character(db: Session, character: models.Character): ...
def _apply_level_up(db: Session, character: models.Character) -> List[str]:
    level_up_messages = []
    
    current_max_defined_level = max(XP_THRESHOLDS.keys()) if XP_THRESHOLDS else 0 # Ensure XP_THRESHOLDS is not empty
    if character.level >= current_max_defined_level and get_xp_for_level(character.level + 1) == float('inf'):
         level_up_messages.append(f"You are already at the maximum defined level ({character.level}). Cannot level up further.")
         return level_up_messages

    character.level += 1
    new_level_str = str(character.level)
    level_up_messages.append(f"Ding! You have reached Level {character.level}!")

    class_bonuses = CLASS_LEVEL_BONUSES.get(character.class_name, CLASS_LEVEL_BONUSES["Adventurer"])
    con_mod = character.get_attribute_modifier("constitution")
    hp_gain = max(1, con_mod + class_bonuses.get("hp_per_level", 3)) 
    character.max_health += hp_gain
    level_up_messages.append(f"Your maximum health increases by {hp_gain}!")

    int_mod = character.get_attribute_modifier("intelligence")
    mp_gain = max(0, int_mod + class_bonuses.get("mp_per_level", 1)) 
    character.max_mana += mp_gain
    if mp_gain > 0:
        level_up_messages.append(f"Your maximum mana increases by {mp_gain}!")

    character.current_health = character.max_health
    character.current_mana = character.max_mana
    level_up_messages.append("You feel invigorated!")
    
    # Grant abilities for the NEW level achieved
    ability_messages = _grant_abilities_for_level(db, character, character.level) # Pass the new level
    level_up_messages.extend(ability_messages)
    
    db.add(character)
    return level_up_messages


def _apply_level_down(db: Session, character: models.Character) -> List[str]:
    if character.level <= 1:
        return ["You cannot de-level below level 1, you pathetic worm."]
    
    level_down_messages = []
    
    # Store previous level's XP requirement BEFORE changing level
    xp_for_new_lower_level = get_xp_for_level(character.level - 1)
    if xp_for_new_lower_level == float('inf'): # Should not happen if level > 1
        xp_for_new_lower_level = XP_THRESHOLDS.get(character.level -1, 0) # Failsafe


    class_bonuses = CLASS_LEVEL_BONUSES.get(character.class_name, CLASS_LEVEL_BONUSES["Adventurer"])
    con_mod = character.get_attribute_modifier("constitution") 
    hp_loss_estimate = max(1, con_mod + class_bonuses.get("hp_per_level", 3))
    character.max_health = max(1, character.max_health - hp_loss_estimate) 
    level_down_messages.append(f"Your maximum health decreases by {hp_loss_estimate}.")

    int_mod = character.get_attribute_modifier("intelligence")
    mp_loss_estimate = max(0, int_mod + class_bonuses.get("mp_per_level", 1))
    character.max_mana = max(0, character.max_mana - mp_loss_estimate)
    if mp_loss_estimate > 0:
        level_down_messages.append(f"Your maximum mana decreases by {mp_loss_estimate}.")

    character.current_health = min(character.current_health, character.max_health)
    character.current_mana = min(character.current_mana, character.max_mana)

    character.level -= 1
    level_down_messages.append(f"You feel weaker... You have de-leveled to Level {character.level}.")
    
    character.experience_points = int(xp_for_new_lower_level) # XP at start of new (lower) level

    db.add(character)
    return level_down_messages


def add_experience(db: Session, character_id: uuid.UUID, amount: int) -> Tuple[Optional[models.Character], List[str]]:

    
    character = get_character(db, character_id=character_id)
    if not character:
        return None, ["Character not found."]

    messages = []
    if amount == 0:
        return character, ["No experience gained or lost. How pointless."]

    initial_level = character.level
    character.experience_points += amount
    if amount !=0 : # only print if xp actually changed
      messages.append(f"{'Gained' if amount > 0 else 'Lost'} {abs(amount)} experience points. Current XP: {character.experience_points}")


    # Handle Leveling Up
    xp_for_next_level = get_xp_for_level(character.level + 1)
    while character.experience_points >= xp_for_next_level and xp_for_next_level != float('inf'):
        overflow_xp = character.experience_points - int(xp_for_next_level) # xp_for_next_level is total for that level
        
        # Temporarily set XP to what's needed for the level up, so _apply_level_up has correct context if it needs it.
        # character.experience_points = int(xp_for_next_level) # Not strictly necessary with current _apply_level_up
        
        level_up_messages = _apply_level_up(db, character) # character.level is incremented inside
        messages.extend(level_up_messages)
        
        # After level up, new character.level is set.
        # XP should be the XP requirement for this new level + any overflow from the previous.
        xp_at_start_of_new_level = get_xp_for_level(character.level)
        character.experience_points = int(xp_at_start_of_new_level) + overflow_xp
        
        xp_for_next_level = get_xp_for_level(character.level + 1) # Update for potential multi-level up

    # Handle De-Leveling
    xp_required_for_current_level = get_xp_for_level(character.level)
    while character.level > 1 and character.experience_points < xp_required_for_current_level :
        # Note: _apply_level_down sets XP to the start of the new lower level.
        delevel_messages = _apply_level_down(db, character) # character.level is decremented
        messages.extend(delevel_messages)
        xp_required_for_current_level = get_xp_for_level(character.level) # Update for new (lower) current level

    # Clamp XP if it went negative after de-leveling to level 1
    if character.level == 1 and character.experience_points < 0:
        character.experience_points = 0
        # messages.append("Your experience cannot fall below zero at level 1.") # Already part of _apply_level_down potentially

    db.add(character)
    db.commit()
    db.refresh(character)
    if character.level != initial_level and not any("Ding!" in m or "de-leveled" in m for m in messages): # Ensure level change message is there
        messages.append(f"Your level is now {character.level}.")
    return character, messages

def get_characters_in_room(db: Session, *, room_id: uuid.UUID, exclude_character_id: Optional[uuid.UUID] = None) -> List[models.Character]:
    """
    Retrieves all characters currently in the specified room,
    optionally excluding one character (e.g., the one looking).
    """
    query = db.query(models.Character).filter(models.Character.current_room_id == room_id)
    if exclude_character_id:
        query = query.filter(models.Character.id != exclude_character_id)
    return query.all()
--- END OF FILE backend/app/crud/crud_character.py ---

--- START OF FILE backend/app/crud/crud_character_class.py ---
# backend/app/crud/crud_character_class.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas

def get_character_class_template(db: Session, class_template_id: uuid.UUID) -> Optional[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).filter(models.CharacterClassTemplate.id == class_template_id).first()

def get_character_class_template_by_name(db: Session, name: str) -> Optional[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).filter(models.CharacterClassTemplate.name == name).first()

def get_character_class_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).offset(skip).limit(limit).all()

def create_character_class_template(db: Session, *, template_in: schemas.CharacterClassTemplateCreate) -> models.CharacterClassTemplate:
    db_template = models.CharacterClassTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def update_character_class_template(
    db: Session, *, 
    db_template: models.CharacterClassTemplate, 
    template_in: schemas.CharacterClassTemplateUpdate
) -> models.CharacterClassTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_template, field, value)
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def delete_character_class_template(db: Session, class_template_id: uuid.UUID) -> Optional[models.CharacterClassTemplate]:
    db_template = get_character_class_template(db, class_template_id)
    if db_template:
        db.delete(db_template)
        db.commit()
    return db_template

# --- Seeding Initial Class Templates (Example) ---
INITIAL_CLASS_TEMPLATES = [
    {
        "name": "Warrior",
        "description": "A stalwart fighter...",
        "base_stat_modifiers": {"strength": 2, "constitution": 1, "intelligence": -1},
        "starting_health_bonus": 5, "starting_mana_bonus": -5,
        "skill_tree_definition": {
            "core_skills_by_level": {
                "1": ["basic_punch"], # Assuming "basic_punch" is a seeded skill_id_tag
                "2": ["power_attack_melee"] # Assuming this is seeded
            },
            "core_traits_by_level": {
                "1": ["tough_hide"] # Assuming "tough_hide" is a seeded trait_id_tag
            }
        },
        "starting_equipment_refs": ["Rusty Sword", "Wooden Shield", "Cloth Tunic"],
        "playstyle_tags": ["melee", "tank", "physical_dps"]
    },
    {
        "name": "Swindler",
        "description": "A cunning rogue...",
        "base_stat_modifiers": {"dexterity": 2, "luck": 1, "strength": -1},
        "skill_tree_definition": {
            "core_skills_by_level": {
                "1": ["basic_punch"], # Swindlers can punch too!
                "3": ["pick_lock_basic"] # Assuming this is seeded
            },
            "core_traits_by_level": {
                 "2": ["quick_learner"] # Assuming this is seeded
            }
        },
        "starting_equipment_refs": ["Dagger", "Cloth Tunic"],
        "playstyle_tags": ["melee", "stealth", "utility", "debuff"]
    },
    # Add Adventurer if you want it to have a basic progression too
    {
        "name": "Adventurer",
        "description": "A jack-of-all-trades, master of none. Ready for anything, prepared for nothing.",
        "base_stat_modifiers": {}, # No stat mods, uses defaults
        "skill_tree_definition": {
            "core_skills_by_level": {
                "1": ["basic_punch"]
            }
            # No special traits by default for Adventurer unless you add them
        },
        "starting_equipment_refs": ["Dagger", "Cloth Tunic"], # Generic start
        "playstyle_tags": ["versatile", "generalist"]
    }
]

def seed_initial_character_class_templates(db: Session):
    print("Attempting to seed initial character class templates...")
    seeded_count = 0
    for template_data in INITIAL_CLASS_TEMPLATES:
        existing = get_character_class_template_by_name(db, name=template_data["name"])
        if not existing:
            print(f"  Creating class template: {template_data['name']}")
            create_character_class_template(db, template_in=schemas.CharacterClassTemplateCreate(**template_data))
            seeded_count += 1
        else:
            print(f"  Class template '{template_data['name']}' already exists.")
    if seeded_count > 0:
        print(f"Seeded {seeded_count} new class templates.")
    else:
        print("No new class templates seeded. They probably already existed, you overachiever.")
    print("Character class template seeding complete.")
--- END OF FILE backend/app/crud/crud_character_class.py ---

--- START OF FILE backend/app/crud/crud_skill.py ---
# backend/app/crud/crud_skill.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas # models.SkillTemplate, schemas.SkillTemplateCreate etc.

def get_skill_template(db: Session, skill_template_id: uuid.UUID) -> Optional[models.SkillTemplate]:
    return db.query(models.SkillTemplate).filter(models.SkillTemplate.id == skill_template_id).first()

def get_skill_template_by_tag(db: Session, skill_id_tag: str) -> Optional[models.SkillTemplate]:
    return db.query(models.SkillTemplate).filter(models.SkillTemplate.skill_id_tag == skill_id_tag).first()

def get_skill_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.SkillTemplate]:
    return db.query(models.SkillTemplate).offset(skip).limit(limit).all()

def create_skill_template(db: Session, *, template_in: schemas.SkillTemplateCreate) -> models.SkillTemplate:
    # Ensure skill_id_tag is unique if we're not relying solely on DB constraints during high volume creates
    existing = get_skill_template_by_tag(db, skill_id_tag=template_in.skill_id_tag)
    if existing:
        # Or raise an HTTPException if this were an API endpoint
        print(f"Warning: Skill template with tag '{template_in.skill_id_tag}' already exists. Skipping creation.")
        return existing # Or handle error appropriately
    
    db_template = models.SkillTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def update_skill_template(
    db: Session, *, 
    db_template: models.SkillTemplate, 
    template_in: schemas.SkillTemplateUpdate
) -> models.SkillTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    
    # If skill_id_tag is being changed, ensure new one isn't taken by another skill
    if "skill_id_tag" in update_data and update_data["skill_id_tag"] != db_template.skill_id_tag:
        existing = get_skill_template_by_tag(db, skill_id_tag=update_data["skill_id_tag"])
        if existing and existing.id != db_template.id:
            print(f"Warning: Cannot update skill_id_tag to '{update_data['skill_id_tag']}', it's already in use. Update failed for tag.")
            # Or raise error. For now, just don't update the tag.
            del update_data["skill_id_tag"] 

    for field, value in update_data.items():
        setattr(db_template, field, value)
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def delete_skill_template(db: Session, skill_template_id: uuid.UUID) -> Optional[models.SkillTemplate]:
    db_template = get_skill_template(db, skill_template_id)
    if db_template:
        db.delete(db_template)
        db.commit()
    return db_template

# --- Placeholder for Seeding Initial Skills ---
INITIAL_SKILL_TEMPLATES = [
    {
        "skill_id_tag": "basic_punch", "name": "Basic Punch", "description": "A simple, untrained punch.",
        "skill_type": "COMBAT_ACTIVE", "target_type": "ENEMY_MOB",
        "effects_data": {"damage": {"dice": "1d2", "bonus_stat": "strength", "type": "bludgeoning"}, "mana_cost": 0},
        "requirements_data": {"min_level": 1}, "cooldown": 0
    },
    {
        "skill_id_tag": "power_attack_melee", "name": "Power Attack", "description": "A forceful melee attack that is harder to land but deals more damage.",
        "skill_type": "COMBAT_ACTIVE", "target_type": "ENEMY_MOB",
        "effects_data": {
            "mana_cost": 5, 
            "attack_roll_modifier": -2, # Harder to hit
            "damage_modifier_flat": 3,  # Adds flat damage
            "uses_equipped_weapon": True # Implies it will use weapon's damage dice + this mod
        },
        "requirements_data": {"min_level": 2, "required_stats": {"strength": 12}}, "cooldown": 2 # 2 combat rounds
    },
    {
        "skill_id_tag": "pick_lock_basic", "name": "Pick Lock (Basic)", "description": "Attempt to pick a simple lock.",
        "skill_type": "UTILITY_OOC", "target_type": "DOOR", # Or "CONTAINER"
        "effects_data": {
            "difficulty_check_attr": "dexterity", "base_dc": 12,
            "success_message": "The lock clicks open.", "failure_message": "You fail to pick the lock."
        },
        "requirements_data": {"min_level": 1}, "cooldown": 10 # 10 seconds OOC
    }
]

def seed_initial_skill_templates(db: Session):
    print("Attempting to seed initial skill templates...")
    seeded_count = 0
    for template_data in INITIAL_SKILL_TEMPLATES:
        if not get_skill_template_by_tag(db, skill_id_tag=template_data["skill_id_tag"]):
            create_skill_template(db, template_in=schemas.SkillTemplateCreate(**template_data))
            print(f"  Created skill template: {template_data['name']} ({template_data['skill_id_tag']})")
            seeded_count += 1
        else:
            print(f"  Skill template '{template_data['name']}' ({template_data['skill_id_tag']}) already exists.")
    if seeded_count > 0: print(f"Seeded {seeded_count} new skill templates.")
    print("Skill template seeding complete.")
--- END OF FILE backend/app/crud/crud_skill.py ---

--- START OF FILE backend/app/crud/crud_trait.py ---
# backend/app/crud/crud_trait.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas # models.TraitTemplate, schemas.TraitTemplateCreate etc.

def get_trait_template(db: Session, trait_template_id: uuid.UUID) -> Optional[models.TraitTemplate]:
    return db.query(models.TraitTemplate).filter(models.TraitTemplate.id == trait_template_id).first()

def get_trait_template_by_tag(db: Session, trait_id_tag: str) -> Optional[models.TraitTemplate]:
    return db.query(models.TraitTemplate).filter(models.TraitTemplate.trait_id_tag == trait_id_tag).first()

def get_trait_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.TraitTemplate]:
    return db.query(models.TraitTemplate).offset(skip).limit(limit).all()

def create_trait_template(db: Session, *, template_in: schemas.TraitTemplateCreate) -> models.TraitTemplate:
    existing = get_trait_template_by_tag(db, trait_id_tag=template_in.trait_id_tag)
    if existing:
        print(f"Warning: Trait template with tag '{template_in.trait_id_tag}' already exists. Skipping creation.")
        return existing
        
    db_template = models.TraitTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def update_trait_template(
    db: Session, *, 
    db_template: models.TraitTemplate, 
    template_in: schemas.TraitTemplateUpdate
) -> models.TraitTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    
    if "trait_id_tag" in update_data and update_data["trait_id_tag"] != db_template.trait_id_tag:
        existing = get_trait_template_by_tag(db, trait_id_tag=update_data["trait_id_tag"])
        if existing and existing.id != db_template.id:
            print(f"Warning: Cannot update trait_id_tag to '{update_data['trait_id_tag']}', it's already in use. Update failed for tag.")
            del update_data["trait_id_tag"]

    for field, value in update_data.items():
        setattr(db_template, field, value)
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def delete_trait_template(db: Session, trait_template_id: uuid.UUID) -> Optional[models.TraitTemplate]:
    db_template = get_trait_template(db, trait_template_id)
    if db_template:
        db.delete(db_template)
        db.commit()
    return db_template

# --- Placeholder for Seeding Initial Traits ---
INITIAL_TRAIT_TEMPLATES = [
    {
        "trait_id_tag": "tough_hide", "name": "Tough Hide", "description": "Your skin is naturally resilient.",
        "trait_type": "PASSIVE", 
        "effects_data": {"ac_bonus_natural": 1} # Example: a natural AC bonus
    },
    {
        "trait_id_tag": "quick_learner", "name": "Quick Learner", "description": "You gain experience slightly faster.",
        "trait_type": "PASSIVE",
        "effects_data": {"xp_gain_modifier_percent": 5} # Gain 5% more XP
    }
]

def seed_initial_trait_templates(db: Session):
    print("Attempting to seed initial trait templates...")
    seeded_count = 0
    for template_data in INITIAL_TRAIT_TEMPLATES:
        if not get_trait_template_by_tag(db, trait_id_tag=template_data["trait_id_tag"]):
            create_trait_template(db, template_in=schemas.TraitTemplateCreate(**template_data))
            print(f"  Created trait template: {template_data['name']} ({template_data['trait_id_tag']})")
            seeded_count += 1
        else:
            print(f"  Trait template '{template_data['name']}' ({template_data['trait_id_tag']}) already exists.")
    if seeded_count > 0: print(f"Seeded {seeded_count} new trait templates.")
    print("Trait template seeding complete.")
--- END OF FILE backend/app/crud/crud_trait.py ---

--- START OF FILE backend/app/crud/crud_item.py ---
# backend/app/crud/crud_item.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas

# --- Item CRUD ---
def get_item(db: Session, item_id: uuid.UUID) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.id == item_id).first()

def get_item_by_name(db: Session, name: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.name == name).first()

def get_items(db: Session, skip: int = 0, limit: int = 100) -> List[models.Item]:
    return db.query(models.Item).offset(skip).limit(limit).all()

def create_item(db: Session, *, item_in: schemas.ItemCreate) -> models.Item:
    db_item_data = item_in.model_dump()
    db_item = models.Item(**db_item_data)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def update_item(
    db: Session, *, db_item: models.Item, item_in: schemas.ItemUpdate
) -> models.Item:
    update_data = item_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_item, field, value)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def delete_item(db: Session, *, item_id: uuid.UUID) -> Optional[models.Item]:
    db_item = db.query(models.Item).filter(models.Item.id == item_id).first()
    if db_item:
        db.delete(db_item)
        db.commit()
    return db_item

# --- Seeding Initial Items ---
INITIAL_ITEMS_TO_SEED = [
    {
        "name": "Rusty Sword", "description": "A short sword, pitted with rust. Better than nothing.",
        "item_type": "weapon", "slot": "main_hand",
        "properties": {
            "damage": "1d6", "damage_type": "slashing", "weapon_type": "sword"
            # "attack_bonus": 0, "damage_bonus": 0 // Explicitly 0 if not magical
            }, "weight": 3.0, "value": 5,
        "stackable": False, "max_stack_size": 1
    },
    {
        "name": "Cloth Tunic", "description": "Simple, patched-up clothing.",
        "item_type": "armor", "slot": "torso",
        "properties": {
            "armor_class_bonus": 1 
            # No max_dex_bonus_to_ac for simple cloth
            }, "weight": 1.0, "value": 2,
        "stackable": False, "max_stack_size": 1
    },
    # ... (Minor Healing Potion remains the same) ...
    {
        "name": "Wooden Shield", "description": "A basic round wooden shield.",
        "item_type": "armor", "slot": "off_hand", # "armor" type, "off_hand" slot implies shield behavior
        "properties": {
            "armor_class_bonus": 2, "item_subtype": "shield" 
            # Shields don't typically cap Dex in 5e, but some heavier ones might.
            }, "weight": 5.0, "value": 8,
        "stackable": False, "max_stack_size": 1
    },
    {
        "name": "Dagger", "description": "A small, easily concealable dagger.",
        "item_type": "weapon", "slot": "main_hand", 
        "properties": {
            "damage": "1d4", "damage_type": "piercing", "weapon_type": "dagger",
            "finesse": True # <<< IMPORTANT FOR DEX USAGE
            }, "weight": 1.0, "value": 2,
        "stackable": False, "max_stack_size": 1
    },
    # Example of heavier armor that might cap Dex:
    # {
    #     "name": "Chain Mail", "description": "A suit of interlocking metal rings.",
    #     "item_type": "armor", "slot": "torso",
    #     "properties": {
    #         "armor_class_bonus": 6, # e.g. total AC provided by chain mail is 16 if base is 10 and no dex
    #         "max_dex_bonus_to_ac": 0, # Heavy armor often gives no dex bonus to AC
    #         "strength_requirement": 13 # Future use
    #         }, "weight": 55.0, "value": 75,
    #     "stackable": False, "max_stack_size": 1
    # },
]


def seed_initial_items(db: Session):
    print("Attempting to seed initial items...")
    seeded_count = 0
    for item_data in INITIAL_ITEMS_TO_SEED:
        existing_item = get_item_by_name(db, name=item_data["name"])
        if not existing_item:
            print(f"  Creating item: {item_data['name']}")
            create_item(db, item_in=schemas.ItemCreate(**item_data))
            seeded_count += 1
        else:
            print(f"  Item '{item_data['name']}' already exists.")
    if seeded_count > 0:
        print(f"Seeded {seeded_count} new items.")
    print("Item seeding complete.")
--- END OF FILE backend/app/crud/crud_item.py ---

--- START OF FILE backend/app/crud/crud_character_inventory.py ---
# backend/app/crud/crud_character_inventory.py
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import List, Optional, Tuple

from .. import models, schemas
from ..models.item import EQUIPMENT_SLOTS # For validation

# Helper to get a specific inventory entry
def get_inventory_item_entry(db: Session, inventory_item_id: uuid.UUID) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item) # Eager load item details
    ).filter(models.CharacterInventoryItem.id == inventory_item_id).first()

# Helper to get inventory entry by character_id and item_id (useful for stackable items)
def get_inventory_item_by_character_and_item_ids(
    db: Session, character_id: uuid.UUID, item_id: uuid.UUID
) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item)
    ).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.CharacterInventoryItem.item_id == item_id
    ).first()


def get_character_inventory(db: Session, character_id: uuid.UUID) -> List[models.CharacterInventoryItem]:
    """Returns all inventory item entries for a character, with item details eager loaded."""
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item) # Eager load the related Item object
    ).filter(models.CharacterInventoryItem.character_id == character_id).all()


def add_item_to_character_inventory(
    db: Session, *, character_id: uuid.UUID, item_id: uuid.UUID, quantity: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Adds an item to a character's inventory.
    If item is stackable and already exists, increases quantity.
    If item is not stackable, creates a new entry for each quantity (e.g. two rusty swords).
    Returns the created/updated inventory item entry and a message.
    """
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    
    character = db.query(models.Character).filter(models.Character.id == character_id).first()
    if not character:
        return None, "Character not found."

    if quantity <= 0:
        return None, "Quantity must be positive."

    # Handle stackable items
    if item_template.stackable:
        existing_entry = get_inventory_item_by_character_and_item_ids(db, character_id, item_id)
        if existing_entry:
            max_stack = item_template.max_stack_size or float('inf') # Should have a default
            if existing_entry.quantity + quantity <= max_stack:
                existing_entry.quantity += quantity
                db.add(existing_entry)
                db.commit()
                db.refresh(existing_entry)
                return existing_entry, f"Added {quantity} to stack of {item_template.name}."
            else:
                # Handle overflow if necessary (e.g. create new stack or error)
                return None, f"Cannot add {quantity}; exceeds max stack size of {max_stack} for {item_template.name}."
        else: # New stackable item entry
            if quantity <= (item_template.max_stack_size or float('inf')):
                new_entry = models.CharacterInventoryItem(
                    character_id=character_id,
                    item_id=item_id,
                    quantity=quantity
                )
                db.add(new_entry)
                db.commit()
                db.refresh(new_entry)
                return new_entry, f"Added {quantity} x {item_template.name} to inventory."
            else:
                return None, f"Cannot add {quantity}; exceeds max stack size for new stack of {item_template.name}."
    else: # Handle non-stackable items (create one entry per item)
        # For non-stackable, 'quantity' means add 'quantity' distinct instances.
        # We'll return the last one created for simplicity, or a list if needed.
        created_entry = None
        for _ in range(quantity):
            new_entry = models.CharacterInventoryItem(
                character_id=character_id,
                item_id=item_id,
                quantity=1 # Non-stackable always has quantity 1 per entry
            )
            db.add(new_entry)
            created_entry = new_entry # Keep track of the last one
        db.commit()
        if created_entry: # Refresh the last created entry
             db.refresh(created_entry) # Need to refresh after commit to get generated ID
        return created_entry, f"Added {quantity} x {item_template.name} (non-stackable) to inventory."


def remove_item_from_character_inventory(
    db: Session, *, inventory_item_id: uuid.UUID, quantity_to_remove: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Removes a specific quantity of an item from an inventory entry.
    If quantity becomes zero or less, the entry is deleted.
    Returns the (potentially modified) entry or None if deleted, and a message.
    """
    entry = get_inventory_item_entry(db, inventory_item_id)
    if not entry:
        return None, "Inventory item entry not found."
    
    if entry.equipped:
        return None, f"Cannot remove '{entry.item.name}'; it is currently equipped. Unequip it first."

    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = entry.item.name # Get name before potential deletion

    if entry.quantity > quantity_to_remove:
        entry.quantity -= quantity_to_remove
        db.add(entry)
        db.commit()
        db.refresh(entry)
        return entry, f"Removed {quantity_to_remove} x {original_item_name}. {entry.quantity} remaining."
    else:
        removed_qty = entry.quantity
        db.delete(entry)
        db.commit()
        return None, f"Removed all {removed_qty} x {original_item_name} from inventory."


def equip_item_from_inventory(
    db: Session, *, character_id: uuid.UUID, inventory_item_id: uuid.UUID, target_slot: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Equips an item from the character's inventory to a specified slot.
    - inventory_item_id: The ID of the CharacterInventoryItem entry.
    - target_slot: The character's equipment slot (e.g., 'main_hand', 'finger_1').
                   Required if item can go in multiple slots or if slot needs disambiguation.
    """
    char_inv_entry = get_inventory_item_entry(db, inventory_item_id)

    if not char_inv_entry:
        return None, "Item not found in your inventory."
    if char_inv_entry.character_id != character_id:
        return None, "This item does not belong to you." # Should not happen with active char
    if char_inv_entry.equipped:
        return char_inv_entry, f"{char_inv_entry.item.name} is already equipped in {char_inv_entry.equipped_slot}."

    item_template = char_inv_entry.item # Already eager loaded
    if not item_template.slot or item_template.slot == "consumable": # 'slot' on item_template is its intended use type
        return None, f"{item_template.name} is not equippable in that manner."

    # Determine the actual character slot to use
    final_target_slot = target_slot
    if not final_target_slot:
        # If item's slot is directly one of EQUIPMENT_SLOTS keys, use it
        if item_template.slot in EQUIPMENT_SLOTS:
            final_target_slot = item_template.slot
        else:
            # This logic needs refinement for items fitting multiple abstract slots.
            # E.g. item.slot = "ring", target_slot could be "finger_1" or "finger_2"
            # For now, if target_slot is not given, and item.slot isn't direct, it's an error.
            return None, f"Please specify which slot to equip {item_template.name} (e.g., 'finger_1', 'finger_2' if it's a ring)."

    if final_target_slot not in EQUIPMENT_SLOTS:
        return None, f"Invalid equipment slot: '{final_target_slot}'. Valid slots are: {', '.join(EQUIPMENT_SLOTS.keys())}."

    # Check if the slot is already occupied by another item
    # (A character can't wear two helmets, etc. Rings are an exception if slots are distinct like finger_1, finger_2)
    # This includes checking for two-handed weapons taking up main_hand and off_hand (future)
    currently_equipped_in_slot = db.query(models.CharacterInventoryItem).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.CharacterInventoryItem.equipped == True,
        models.CharacterInventoryItem.equipped_slot == final_target_slot
    ).first()

    if currently_equipped_in_slot:
        return None, f"Slot '{EQUIPMENT_SLOTS[final_target_slot]}' is already occupied by {currently_equipped_in_slot.item.name}. Unequip it first."

    # All checks passed, equip the item
    char_inv_entry.equipped = True
    char_inv_entry.equipped_slot = final_target_slot
    db.add(char_inv_entry)
    db.commit()
    db.refresh(char_inv_entry)
    return char_inv_entry, f"{item_template.name} equipped to {EQUIPMENT_SLOTS[final_target_slot]}."


def unequip_item_to_inventory(
    db: Session, *, character_id: uuid.UUID, inventory_item_id: uuid.UUID
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """Unequips an item, moving it back to the general 'backpack' part of inventory."""
    char_inv_entry = get_inventory_item_entry(db, inventory_item_id)

    if not char_inv_entry:
        return None, "Item not found in your inventory records."
    if char_inv_entry.character_id != character_id:
        return None, "This item does not belong to you."
    if not char_inv_entry.equipped or not char_inv_entry.equipped_slot:
        return char_inv_entry, f"{char_inv_entry.item.name} is not currently equipped."

    item_name = char_inv_entry.item.name
    slot_name = EQUIPMENT_SLOTS.get(char_inv_entry.equipped_slot, char_inv_entry.equipped_slot)

    char_inv_entry.equipped = False
    char_inv_entry.equipped_slot = None
    db.add(char_inv_entry)
    db.commit()
    db.refresh(char_inv_entry)
    return char_inv_entry, f"{item_name} unequipped from {slot_name}."
--- END OF FILE backend/app/crud/crud_character_inventory.py ---

--- START OF FILE backend/app/crud/crud_room_item.py ---
# backend/app/crud/crud_room_item.py
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import Dict, List, Optional, Tuple

from .. import models, schemas

def get_room_item_instance(db: Session, room_item_instance_id: uuid.UUID) -> Optional[models.RoomItemInstance]:
    return db.query(models.RoomItemInstance).options(
        joinedload(models.RoomItemInstance.item) # Eager load item details
    ).filter(models.RoomItemInstance.id == room_item_instance_id).first()

def get_items_in_room(db: Session, room_id: uuid.UUID) -> List[models.RoomItemInstance]:
    """Returns all item instances on the ground in a room, with item details eager loaded."""
    return db.query(models.RoomItemInstance).options(
        joinedload(models.RoomItemInstance.item)
    ).filter(models.RoomItemInstance.room_id == room_id).all()

def add_item_to_room(
    db: Session, *, 
    room_id: uuid.UUID, 
    item_id: uuid.UUID, 
    quantity: int = 1,
    dropped_by_character_id: Optional[uuid.UUID] = None,
    properties_override: Optional[Dict] = None
) -> Tuple[Optional[models.RoomItemInstance], str]:
    """
    Adds an item instance to a room's floor.
    If item is stackable and an identical instance (same item_id, same properties_override) exists, increases quantity.
    Otherwise, creates a new RoomItemInstance entry.
    """
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    
    room = db.query(models.Room).filter(models.Room.id == room_id).first()
    if not room:
        return None, "Room not found."

    if quantity <= 0:
        return None, "Quantity must be positive."

    # For stackable items, check if an identical stack already exists on the floor
    # Identical means same item_id AND same properties_override (usually None)
    created_entry = None
    if item_template.stackable:
        existing_stack = db.query(models.RoomItemInstance).filter(
            models.RoomItemInstance.room_id == room_id,
            models.RoomItemInstance.item_id == item_id,
            models.RoomItemInstance.properties_override == properties_override # Crucial for stacking
        ).first()

        if existing_stack:
            max_stack = item_template.max_stack_size or float('inf')
            if existing_stack.quantity + quantity <= max_stack:
                existing_stack.quantity += quantity
                db.add(existing_stack)
                db.commit()
                db.refresh(existing_stack)
                return existing_stack, f"Added {quantity} to stack of {item_template.name} on the ground."
            else:
                # Create a new stack for the overflow if needed, or error.
                # For simplicity now, let's just create a new stack for the full requested quantity
                # if the existing stack would overflow. This might lead to multiple stacks of same item.
                # A more advanced logic would fill up the existing stack then create a new one for remainder.
                pass # Fall through to create a new instance for the current quantity


    # Create a new instance (either non-stackable, or new stack for stackable)
    # For non-stackable, quantity means number of distinct instances.
    # For stackable, if we reached here, it's a new stack of 'quantity'.
    
    num_instances_to_create = quantity if not item_template.stackable else 1
    actual_quantity_per_instance = 1 if not item_template.stackable else quantity
    
    if item_template.stackable and actual_quantity_per_instance > (item_template.max_stack_size or float('inf')):
        return None, f"Cannot drop stack of {actual_quantity_per_instance}; exceeds max stack size for {item_template.name}."

    for _ in range(num_instances_to_create):
        new_instance = models.RoomItemInstance(
            room_id=room_id,
            item_id=item_id,
            quantity=actual_quantity_per_instance,
            dropped_by_character_id=dropped_by_character_id,
            properties_override=properties_override
        )
        db.add(new_instance)
        created_entry = new_instance # Keep track of the last one

    db.commit()
    if created_entry:
        db.refresh(created_entry) # Ensure IDs are loaded
    
    if item_template.stackable:
         return created_entry, f"Dropped a stack of {quantity} x {item_template.name}."
    else:
         return created_entry, f"Dropped {quantity} x {item_template.name}."


def remove_item_from_room(
    db: Session, *, 
    room_item_instance_id: uuid.UUID, 
    quantity_to_remove: int = 1
) -> Tuple[Optional[models.RoomItemInstance], str]: # Returns (remaining_instance_or_None, message)
    """
    Removes a specific quantity of an item from a RoomItemInstance.
    If quantity becomes zero or less, the instance is deleted.
    """
    instance = get_room_item_instance(db, room_item_instance_id) # This already eager loads .item
    if not instance:
        return None, "Item instance not found on the ground."

    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = instance.item.name

    if instance.quantity > quantity_to_remove:
        instance.quantity -= quantity_to_remove
        db.add(instance)
        db.commit()
        db.refresh(instance)
        return instance, f"Picked up {quantity_to_remove} x {original_item_name}. {instance.quantity} remaining on ground."
    else:
        # Removing all or more than available from this specific instance
        removed_qty = instance.quantity
        db.delete(instance)
        db.commit()
        return None, f"Picked up all {removed_qty} x {original_item_name} from the ground (this stack/instance)."
--- END OF FILE backend/app/crud/crud_room_item.py ---

--- START OF FILE backend/app/crud/crud_mob.py ---
# backend/app/crud/crud_mob.py
from datetime import datetime, timezone
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import Dict, List, Optional, Tuple

from .. import models, schemas, crud

# --- MobTemplate CRUD ---
def get_mob_template(db: Session, mob_template_id: uuid.UUID) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.id == mob_template_id).first()

def get_mob_template_by_name(db: Session, name: str) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.name == name).first()

def get_mob_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.MobTemplate]:
    return db.query(models.MobTemplate).offset(skip).limit(limit).all()

def create_mob_template(db: Session, *, template_in: schemas.MobTemplateCreate) -> models.MobTemplate:
    db_template = models.MobTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

# --- RoomMobInstance CRUD ---
def get_room_mob_instance(db: Session, room_mob_instance_id: uuid.UUID) -> Optional[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template) # Eager load template
    ).filter(models.RoomMobInstance.id == room_mob_instance_id).first()

def get_mobs_in_room(db: Session, room_id: uuid.UUID) -> List[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template)
    ).filter(models.RoomMobInstance.room_id == room_id).all()

def spawn_mob_in_room(
    db: Session, *, 
    room_id: uuid.UUID, 
    mob_template_id: uuid.UUID,
    instance_properties_override: Optional[Dict] = None,
    originating_spawn_definition_id: Optional[uuid.UUID] = None # <<< RENAMED PARAMETER
) -> Optional[models.RoomMobInstance]:
    template = get_mob_template(db, mob_template_id)
    if not template: return None
    room = db.query(models.Room).filter(models.Room.id == room_id).first()
    if not room: return None

    mob_instance = models.RoomMobInstance(
        room_id=room_id,
        mob_template_id=mob_template_id,
        current_health=template.base_health,
        instance_properties_override=instance_properties_override,
        spawn_definition_id=originating_spawn_definition_id # <<< SETTING THE CORRECT FIELD
    )
    db.add(mob_instance)
    db.commit()
    db.refresh(mob_instance)
    return mob_instance

def despawn_mob_from_room(db: Session, room_mob_instance_id: uuid.UUID) -> bool:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance:
        spawn_def_id_to_update = instance.spawn_definition_id # Use the renamed field

        db.delete(instance)
        db.commit() 

        if spawn_def_id_to_update:
            # When a mob from a definition is despawned, its definition should be checked soon.
            # Set its next_respawn_check_at to now to make it eligible for the next tick.
            crud.crud_mob_spawn_definition.update_mob_spawn_definition_next_check_time(
                db, 
                definition_id=spawn_def_id_to_update, 
                next_check_time=datetime.now(timezone.utc)
            )
            print(f"Triggered immediate re-check for spawn definition {spawn_def_id_to_update} due to mob despawn.")
        return True
    return False

def update_mob_instance_health(
    db: Session, room_mob_instance_id: uuid.UUID, change_in_health: int
) -> Optional[models.RoomMobInstance]:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance:
        instance.current_health += change_in_health
        # Basic health clamping, can be more sophisticated (e.g. death on <=0)
        if instance.current_health < 0:
            instance.current_health = 0 
        # Max health check if applicable (e.g. instance.mob_template.base_health)
        # if instance.current_health > instance.mob_template.base_health:
        #     instance.current_health = instance.mob_template.base_health
            
        db.add(instance)
        db.commit()
        db.refresh(instance)
        return instance
    return None

# --- Seeding Initial Mob Templates ---
INITIAL_MOB_TEMPLATES = [
    {
        "name": "Giant Rat", "description": "A filthy rat, surprisingly large and aggressive.",
        "mob_type": "beast", "base_health": 8, "base_attack": "1d4", "base_defense": 11,
        "xp_value": 5, "properties": {"aggression": "aggressive_if_approached"}, "level": 1
    },
    {
        "name": "Goblin Scout", "description": "A small, green-skinned humanoid with beady eyes and a rusty dagger.",
        "mob_type": "humanoid", "base_health": 12, "base_attack": "1d6", "base_defense": 13,
        "xp_value": 10, "properties": {"aggression": "aggressive_on_sight", "faction": "goblins"}, "level": 1
    },
]

def seed_initial_mob_templates(db: Session):
    print("Attempting to seed initial mob templates...")
    seeded_count = 0
    for template_data in INITIAL_MOB_TEMPLATES:
        existing = get_mob_template_by_name(db, name=template_data["name"])
        if not existing:
            print(f"  Creating mob template: {template_data['name']}")
            create_mob_template(db, template_in=schemas.MobTemplateCreate(**template_data))
            seeded_count += 1
        else:
            print(f"  Mob template '{template_data['name']}' already exists.")
    if seeded_count > 0:
        print(f"Seeded {seeded_count} new mob templates.")
    print("Mob template seeding complete.")

--- END OF FILE backend/app/crud/crud_mob.py ---

--- START OF FILE backend/app/crud/crud_mob_spawn_definition.py ---
# backend/app/crud/crud_mob_spawn_definition.py
from sqlalchemy.orm import Session
import uuid
from datetime import datetime, timedelta, timezone # Added timezone
from typing import List, Optional

from .. import models, schemas # Uses new MobSpawnDefinition schemas
from ..crud import crud_room, crud_mob # For seeder

# --- MobSpawnDefinition CRUD ---

def get_mob_spawn_definition(db: Session, definition_id: uuid.UUID) -> Optional[models.MobSpawnDefinition]:
    return db.query(models.MobSpawnDefinition).filter(models.MobSpawnDefinition.id == definition_id).first()

def get_mob_spawn_definition_by_name(db: Session, definition_name: str) -> Optional[models.MobSpawnDefinition]:
    return db.query(models.MobSpawnDefinition).filter(models.MobSpawnDefinition.definition_name == definition_name).first()

def get_definitions_ready_for_check(db: Session, current_time: datetime, limit: int = 1000) -> List[models.MobSpawnDefinition]:
    """
    Gets active spawn definitions whose next_respawn_check_at is due.
    Or where next_respawn_check_at is NULL (meaning they haven't been processed yet or need immediate check).
    """
    return db.query(models.MobSpawnDefinition).filter(
        models.MobSpawnDefinition.is_active == True,
        (models.MobSpawnDefinition.next_respawn_check_at == None) | (models.MobSpawnDefinition.next_respawn_check_at <= current_time)
    ).limit(limit).all()

def create_mob_spawn_definition(db: Session, *, definition_in: schemas.MobSpawnDefinitionCreate) -> models.MobSpawnDefinition:
    # Basic validation
    if definition_in.quantity_min > definition_in.quantity_max:
        raise ValueError("quantity_min cannot be greater than quantity_max")

    existing = get_mob_spawn_definition_by_name(db, definition_name=definition_in.definition_name)
    if existing:
        # Handle error or return existing one; for now, let's assume names should be unique
        raise ValueError(f"MobSpawnDefinition with name '{definition_in.definition_name}' already exists.")

    db_definition_data = definition_in.model_dump()
    # Set initial next_respawn_check_at to now to make it eligible for first check
    db_definition_data["next_respawn_check_at"] = datetime.now(timezone.utc)
    
    db_definition = models.MobSpawnDefinition(**db_definition_data)
    db.add(db_definition)
    db.commit()
    db.refresh(db_definition)
    return db_definition

def update_mob_spawn_definition_next_check_time(
    db: Session, *, 
    definition_id: uuid.UUID, 
    next_check_time: datetime
) -> Optional[models.MobSpawnDefinition]:
    db_definition = get_mob_spawn_definition(db, definition_id)
    if db_definition:
        db_definition.next_respawn_check_at = next_check_time
        db.add(db_definition)
        db.commit() # Commit immediately as this is a frequent state update
        db.refresh(db_definition)
        return db_definition
    return None

def update_mob_spawn_definition(
    db: Session, *,
    db_definition: models.MobSpawnDefinition,
    definition_in: schemas.MobSpawnDefinitionUpdate
) -> models.MobSpawnDefinition:
    update_data = definition_in.model_dump(exclude_unset=True)
    if "quantity_min" in update_data and "quantity_max" in update_data:
        if update_data["quantity_min"] > update_data["quantity_max"]:
            raise ValueError("quantity_min cannot be greater than quantity_max")
    elif "quantity_min" in update_data:
        if update_data["quantity_min"] > db_definition.quantity_max:
            raise ValueError("quantity_min cannot be greater than current quantity_max")
    elif "quantity_max" in update_data:
        if db_definition.quantity_min > update_data["quantity_max"]:
            raise ValueError("current quantity_min cannot be greater than new quantity_max")

    for field, value in update_data.items():
        setattr(db_definition, field, value)
    db.add(db_definition)
    db.commit()
    db.refresh(db_definition)
    return db_definition


# --- Seeding ---
def seed_initial_mob_spawn_definitions(db: Session):
    print("Attempting to seed initial mob spawn definitions...")
    cpu_room = crud_room.get_room_by_coords(db, x=0, y=0, z=0)
    rat_template = crud_mob.get_mob_template_by_name(db, name="Giant Rat")
    goblin_template = crud_mob.get_mob_template_by_name(db, name="Goblin Scout")
    personnel_room = crud_room.get_room_by_coords(db, x=2, y=0, z=0) # From your new world seed
    
    definitions_to_seed = []
    if cpu_room and rat_template:
        definitions_to_seed.append(schemas.MobSpawnDefinitionCreate(
            definition_name="CPURatsMain", room_id=cpu_room.id, mob_template_id=rat_template.id,
            quantity_min=1, quantity_max=2, respawn_delay_seconds=60 # e.g. 1 minute
        ))
    if personnel_room and goblin_template:
        definitions_to_seed.append(schemas.MobSpawnDefinitionCreate(
            definition_name="PersonnelIntakeGoblinSentry", room_id=personnel_room.id, mob_template_id=goblin_template.id,
            quantity_min=1, quantity_max=1, respawn_delay_seconds=180 # e.g. 3 minutes
        ))

    seeded_count = 0
    for def_in in definitions_to_seed:
        if not get_mob_spawn_definition_by_name(db, definition_name=def_in.definition_name):
            create_mob_spawn_definition(db, definition_in=def_in)
            print(f"  Created mob spawn definition: {def_in.definition_name}")
            seeded_count += 1
        else:
            print(f"  Mob spawn definition '{def_in.definition_name}' already exists.")
    
    if seeded_count > 0: print(f"Seeded {seeded_count} new mob spawn definitions.")
    print("Mob spawn definition seeding complete.")
--- END OF FILE backend/app/crud/crud_mob_spawn_definition.py ---

--- START OF FILE backend/app/crud/crud_room.py ---
# backend/app/crud/crud_room.py
from sqlalchemy.orm import Session
import uuid # Import uuid
from typing import Optional, Dict, List
from .. import models, schemas

def get_rooms_by_z_level(db: Session, *, z_level: int) -> List[models.Room]:
    """
    Retrieve all rooms from the database by their Z-coordinate.
    """
    return db.query(models.Room).filter(models.Room.z == z_level).all()

def get_room_by_id(db: Session, room_id: uuid.UUID) -> Optional[models.Room]: # room_id is now uuid.UUID
    """
    Retrieve a room from the database by its ID (which is a UUID).
    """
    return db.query(models.Room).filter(models.Room.id == room_id).first()

def get_room_by_coords(db: Session, *, x: int, y: int, z: int) -> Optional[models.Room]:
    return db.query(models.Room).filter(
        models.Room.x == x,
        models.Room.y == y,
        models.Room.z == z
    ).first()

def create_room(db: Session, *, room_in: schemas.RoomCreate) -> models.Room:
    """
    Create a new room in the database.
    Takes a Pydantic schema RoomCreate as input.
    If room_in.id is None (typical), a new UUID will be generated by the model's default.
    If room_in.id is provided, that UUID will be used.
    Returns the created SQLAlchemy ORM model instance.
    """
    db_room_data = room_in.model_dump(exclude_unset=True) # Exclude unset to allow DB defaults like UUID
    
    # If an ID (UUID) is provided in room_in, use it. Otherwise, DB default uuid.uuid4() kicks in.
    # The model_dump already includes 'id' if it was set in room_in.
    
    db_room = models.Room(**db_room_data)
    db.add(db_room)
    db.commit()
    db.refresh(db_room)
    return db_room

# We'll need a robust way to update room exits as well, or a general update_room
def update_room(db: Session, *, db_room: models.Room, room_in: schemas.RoomUpdate) -> models.Room:
    """
    General purpose room update.
    """
    update_data = room_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_room, field, value)
    db.add(db_room)
    db.commit()
    db.refresh(db_room)
    return db_room

# --- World Seeding Logic ---
# This will be called from main.py's startup event
# We'll define 3 rooms: Genesis (0,0,0), Chilly North (0,1,0), Overlook East (1,1,0)

# Store known UUIDs for linking (these will be generated once)
# In a real app, these might be constants or looked up if seeding is idempotent.
# For simplicity, we'll generate them if rooms don't exist.
# This global dict is a temporary hack for seeding to pass UUIDs between room creations.
_SEED_ROOM_UUIDS: Dict[str, uuid.UUID] = {}

def seed_initial_world(db: Session):
    print("Attempting to seed a new, slightly more expansive initial world...")
    _SEED_ROOM_UUIDS.clear() # Ensure it's empty before seeding

    room_definitions = [
        {
            "coords": {"x": 0, "y": 0, "z": 0}, "name_tag": "central_hub",
            "data": schemas.RoomCreate(name="Central Processing Unit (CPU)", x=0, y=0, z=0,
                                       description="The air hums with the barely audible whir of unseen processes. Various identical corridors branch off. All business, no pleasure.")
        },
        {
            "coords": {"x": 0, "y": 1, "z": 0}, "name_tag": "north_corridor_1",
            "data": schemas.RoomCreate(name="North Data Conduit Alpha", x=0, y=1, z=0,
                                       description="A sterile corridor stretches northwards. The faint scent of ozone and regret hangs in the air.")
        },
        {
            "coords": {"x": 0, "y": 2, "z": 0}, "name_tag": "archive_access_north",
            "data": schemas.RoomCreate(name="Archival Sub-sector N-47b", x=0, y=2, z=0,
                                       description="Rows of identical, featureless data monoliths stand silent sentinel. One of them is probably important.")
        },
        {
            "coords": {"x": 1, "y": 0, "z": 0}, "name_tag": "east_corridor_1",
            "data": schemas.RoomCreate(name="East Packet-Switching Nexus", x=1, y=0, z=0,
                                       description="This passage heads east, past blinking lights that signify... something. Or perhaps nothing at all.")
        },
        {
            "coords": {"x": 2, "y": 0, "z": 0}, "name_tag": "personnel_intake_east",
            "data": schemas.RoomCreate(name="Personnel Intake & Re-Education", x=2, y=0, z=0,
                                       description="A single, uncomfortable chair sits under a harsh light. A faded motivational poster reads: 'Compliance is Key.'")
        },
        {
            "coords": {"x": 0, "y": -1, "z": 0}, "name_tag": "south_corridor_1",
            "data": schemas.RoomCreate(name="South Maintenance Tunnel 7", x=0, y=-1, z=0,
                                       description="Dimly lit and smelling faintly of burnt coffee and existential dread. The floor is slightly sticky.")
        },
        {
            "coords": {"x": 0, "y": -2, "z": 0}, "name_tag": "waste_reclamation_south",
            "data": schemas.RoomCreate(name="Waste Reclamation & Data Incineration", x=0, y=-2, z=0,
                                       description="A large, ominous chute dominates one wall. You try not to think about what 'Waste Reclamation' entails here.")
        },
        {
            "coords": {"x": -1, "y": 0, "z": 0}, "name_tag": "west_corridor_1",
            "data": schemas.RoomCreate(name="West Logic Gate Array", x=-1, y=0, z=0,
                                       description="To the west, a series of humming conduits. One emits a slightly higher-pitched hum than the others, a tiny rebellion in a sea of conformity.")
        },
        {
            "coords": {"x": -2, "y": 0, "z": 0}, "name_tag": "auxiliary_storage_west",
            "data": schemas.RoomCreate(name="Auxiliary Data Storage Unit W-Alpha", x=-2, y=0, z=0,
                                       description="More data storage. It's data all the way down. You suspect some of it might be recipes for lukewarm soup.")
        },
        # A room not directly connected to the hub, to make the map more interesting
        {
            "coords": {"x": 1, "y": 1, "z": 0}, "name_tag": "break_room_anomaly",
            "data": schemas.RoomCreate(name="Restricted Sub-routine Lounge (Anomaly)", x=1, y=1, z=0,
                                       description="An oddly out-of-place room. A dusty vending machine hums defiantly in the corner, offering only 'Nutrient Paste (Beige)'.")
        }
    ]

    created_rooms_this_run = False
    for room_def in room_definitions:
        coords = room_def["coords"]
        name_tag = room_def["name_tag"]
        
        existing_room = get_room_by_coords(db, **coords)
        if not existing_room:
            print(f"Creating room '{room_def['data'].name}' at {coords} with tag '{name_tag}'...")
            created_room_orm = create_room(db, room_in=room_def["data"])
            _SEED_ROOM_UUIDS[name_tag] = created_room_orm.id
            print(f"  Created '{created_room_orm.name}' with UUID: {_SEED_ROOM_UUIDS[name_tag]}")
            created_rooms_this_run = True
        else:
            print(f"Room '{existing_room.name}' at {coords} (tag: '{name_tag}') already exists with UUID: {existing_room.id}.")
            _SEED_ROOM_UUIDS[name_tag] = existing_room.id

    # Link rooms using their known/generated UUIDs
    print("Linking room exits for the new world configuration...")

    # Define exits as a list of tuples: (source_tag, direction, target_tag)
    exit_links = [
        ("central_hub", "north", "north_corridor_1"), ("north_corridor_1", "south", "central_hub"),
        ("north_corridor_1", "north", "archive_access_north"), ("archive_access_north", "south", "north_corridor_1"),
        
        ("central_hub", "east", "east_corridor_1"), ("east_corridor_1", "west", "central_hub"),
        ("east_corridor_1", "east", "personnel_intake_east"), ("personnel_intake_east", "west", "east_corridor_1"),
        
        ("central_hub", "south", "south_corridor_1"), ("south_corridor_1", "north", "central_hub"),
        ("south_corridor_1", "south", "waste_reclamation_south"), ("waste_reclamation_south", "north", "south_corridor_1"),

        ("central_hub", "west", "west_corridor_1"), ("west_corridor_1", "east", "central_hub"),
        ("west_corridor_1", "west", "auxiliary_storage_west"), ("auxiliary_storage_west", "east", "west_corridor_1"),

        # Connecting the "anomaly" room
        ("north_corridor_1", "east", "break_room_anomaly"), ("break_room_anomaly", "west", "north_corridor_1"),
        ("east_corridor_1", "north", "break_room_anomaly"), ("break_room_anomaly", "south", "east_corridor_1"),
    ]

    for source_tag, direction, target_tag in exit_links:
        if source_tag in _SEED_ROOM_UUIDS and target_tag in _SEED_ROOM_UUIDS:
            source_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS[source_tag])
            if source_room_orm:
                # Ensure exits dictionary exists and work with a mutable copy
                current_exits = source_room_orm.exits.copy() if source_room_orm.exits is not None else {} # type: ignore
                
                new_exit_uuid_str = str(_SEED_ROOM_UUIDS[target_tag])

                # Only update if the exit is different or doesn't exist
                if current_exits.get(direction) != new_exit_uuid_str:
                    source_name_for_log = source_room_orm.name if source_room_orm.name else f"Room with ID {_SEED_ROOM_UUIDS[source_tag]}"
                    target_name_for_log = "Unknown Target Room" # Placeholder
                    # Attempt to get target room name for better logging
                    target_room_for_log = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS[target_tag])
                    if target_room_for_log and target_room_for_log.name:
                        target_name_for_log = target_room_for_log.name
                    else:
                        target_name_for_log = f"Room with ID {_SEED_ROOM_UUIDS[target_tag]}"

                    print(f"  Setting exit for '{source_name_for_log}': {direction} -> '{target_name_for_log}' (UUID: {new_exit_uuid_str})")
                    
                    current_exits[direction] = new_exit_uuid_str
                    source_room_orm.exits = current_exits # Re-assign the modified dictionary
                    db.add(source_room_orm) # Add to session to mark as dirty for commit
        else:
            print(f"  Warning: Could not link exit {source_tag} -> {target_tag}. One or both tags not found in _SEED_ROOM_UUIDS.")
            print(f"    Available tags: {list(_SEED_ROOM_UUIDS.keys())}")

    db.commit() # Commit all exit updates at once
    print("New world seeding and exit linking complete.")



--- END OF FILE backend/app/crud/crud_room.py ---

--- START OF FILE backend/app/api/dependencies.py ---
# backend/app/api/dependencies.py
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
import uuid

from app.core.config import settings
from app import models, schemas, crud
from app.db.session import get_db
from app.game_state import active_game_sessions # <<< ADDED THIS IMPORT

reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/users/login"
)

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY

async def get_current_player(
    db: Session = Depends(get_db), token: str = Depends(reusable_oauth2)
) -> models.Player:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username_or_player_id: Optional[str] = payload.get("sub")
        if username_or_player_id is None:
            raise credentials_exception
        
        try:
            player_uuid = uuid.UUID(username_or_player_id)
        except ValueError:
            print(f"Error: Subject '{username_or_player_id}' in token is not a valid UUID.")
            raise credentials_exception
            
    except JWTError as e:
        print(f"JWTError during token decode: {e}")
        raise credentials_exception
    
    player = crud.crud_player.get_player(db, player_id=player_uuid)
    if player is None:
        raise credentials_exception
    return player

async def get_current_active_character( # <<< NEW DEPENDENCY
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
) -> models.Character:
    character_id = active_game_sessions.get(current_player.id)
    
    if not character_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, 
            detail="No active character selected for this session. Please select a character.",
        )
    
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        # This case implies data inconsistency or character deleted after selection.
        # Clear stale entry from active_game_sessions.
        active_game_sessions.pop(current_player.id, None)
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Active character with ID {character_id} not found. Session reset.",
        )

    # This check is crucial for data integrity, though selection process should ensure it.
    if character.player_id != current_player.id:
        active_game_sessions.pop(current_player.id, None) # Clear inconsistent state
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="CRITICAL: Active character's player ID does not match authenticated player. Session reset.",
        )
        
    return character
--- END OF FILE backend/app/api/dependencies.py ---

--- START OF FILE backend/app/api/v1/api_router.py ---
from fastapi import APIRouter
from .endpoints import room, command, user, character, inventory, map # This imports the router from endpoints/room.py

# This router will be included with a prefix like /api by main.py
# So paths here are relative to that.
api_router = APIRouter() 

# All routes defined in 'room.router' will be prefixed with '/room'
# So, a GET "/{x}/{y}/{z}" in room.router becomes GET "/room/{x}/{y}/{z}" here.
api_router.include_router(room.router, prefix="/room", tags=["Rooms"])
api_router.include_router(command.router, prefix="/command", tags=["Commands"])
api_router.include_router(user.router, prefix="/users", tags=["Users"])
api_router.include_router(character.router, prefix="/character", tags=["Characters"])
api_router.include_router(inventory.router, prefix="/inventory", tags=["Inventory"])
api_router.include_router(map.router, prefix="/map", tags=["Map"])
--- END OF FILE backend/app/api/v1/api_router.py ---

--- FILE NOT FOUND: backend/app/api/v1/endpoints/users.py ---

--- START OF FILE backend/app/api/v1/endpoints/character.py ---
# backend/app/api/v1/endpoints/character.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from sqlalchemy.orm import Session
import uuid
from typing import Any, List

from .... import schemas, crud, models
from ....db.session import get_db
# from ....crud.crud_room import get_room_by_coords # No longer needed for this file directly if only used in create
from ....api.dependencies import get_current_player
from ....game_state import active_game_sessions # <<< ADDED THIS IMPORT

router = APIRouter()


@router.post("/create", response_model=schemas.Character, status_code=status.HTTP_201_CREATED)
def create_new_character_for_current_player(
    *,
    db: Session = Depends(get_db),
    character_payload: schemas.CharacterCreate = Body(...), # Contains name, optional class_name
    current_player: models.Player = Depends(get_current_player)
) -> Any:
    # ... (existing_character check remains the same) ...
    existing_character = crud.crud_character.get_character_by_name(db, name=character_payload.name)
    if existing_character:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"A character with the name '{character_payload.name}' already exists."
        )
    
    start_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0)
    if not start_room_orm:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Starting room not found. Cannot create character. Server misconfiguration."
        )
    
    # The character_payload (schemas.CharacterCreate) now passes name and class_name (optional)
    # to crud.crud_character.create_character.
    # The CRUD function handles looking up the class template and applying defaults/modifiers.
    character = crud.crud_character.create_character(
        db,
        character_in=character_payload, # Contains name and potentially class_name
        player_id=current_player.id,
        initial_room_id=start_room_orm.id
    )
    
    print(f"Character '{character.name}' (Class: {character.class_name}) created for player '{current_player.username}', starting in room '{start_room_orm.name}'.")
    return character # FastAPI will convert to schemas.Character


@router.get("/mine", response_model=List[schemas.Character])
def read_characters_for_current_player(
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
):
    """
    Retrieve all characters for the currently authenticated player.
    """
    characters = crud.crud_character.get_characters_by_player(db, player_id=current_player.id)
    return characters


@router.post("/{character_id}/select", response_model=schemas.RoomInDB) # <<< NEW ENDPOINT
def select_character_for_session(
    *,
    db: Session = Depends(get_db),
    character_id: uuid.UUID,
    current_player: models.Player = Depends(get_current_player)
) -> Any:
    """
    Selects a character to be the active character for the player's session.
    Returns the character's current room data.
    """
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Character with ID {character_id} not found."
        )
    
    if character.player_id != current_player.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Operation not permitted: This character does not belong to you."
        )

    # Set this character as active for the player's session
    active_game_sessions[current_player.id] = character.id
    
    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    if not current_room_orm:
        active_game_sessions.pop(current_player.id, None) # Clean up inconsistent state
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Character '{character.name}' (ID: {character.id}) is in an invalid room (ID: {character.current_room_id}). Data integrity error. Session not started."
        )
    
    print(f"Player '{current_player.username}' (ID: {current_player.id}) selected character '{character.name}' (ID: {character.id}).")
    print(f"Active sessions: {active_game_sessions}") # For debugging
    return current_room_orm # FastAPI will convert ORM to schemas.RoomInDB
--- END OF FILE backend/app/api/v1/endpoints/character.py ---

--- START OF FILE backend/app/api/v1/endpoints/map.py ---
# backend/app/api/v1/endpoints/map.py (NEW FILE)
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import Any # List for type hint

from app import schemas, models, crud
from app.db.session import get_db
from app.api.dependencies import get_current_active_character

router = APIRouter()

@router.get("/level_data", response_model=schemas.MapLevelDataResponse)
def get_map_data_for_current_level(
    *,
    db: Session = Depends(get_db),
    active_character: models.Character = Depends(get_current_active_character)
) -> Any:
    """
    Provides map data for the Z-level the active character is currently on.
    """
    if active_character.current_room_id is None:
        # This should ideally not happen if a character is active
        raise HTTPException(status_code=404, detail="Active character is not in a valid room.")

    # Fetch the current room to get the Z-level
    # current_room_orm = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    # We can get Z directly from the character's current_room object if it's loaded with coords,
    # or from the current_room_orm if we fetch it.
    # For simplicity, let's assume active_character.current_room (if relationship is loaded) has x,y,z
    # Or, safer, fetch the current room again to ensure we have its Z.
    # Let's rely on the character's current room being valid and its details accessible
    # For this, we need to ensure current_room is loaded on active_character, or we fetch it.
    # The get_current_active_character dependency already fetches the character.
    # We need to ensure its `current_room_id` can be used to get the room's Z.

    current_room = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    if not current_room:
         raise HTTPException(status_code=500, detail="Current room for active character not found.")
    
    character_z_level = current_room.z

    rooms_on_level_orm = crud.crud_room.get_rooms_by_z_level(db, z_level=character_z_level)

    map_rooms_data: list[schemas.MapRoomData] = []
    for room_orm in rooms_on_level_orm:
        map_rooms_data.append(
            schemas.MapRoomData(
                id=room_orm.id,
                x=room_orm.x,
                y=room_orm.y,
                name=room_orm.name,
                exits=room_orm.exits or {}, # Ensure exits is a dict, not None
                is_current_room=(room_orm.id == active_character.current_room_id),
                is_visited=True # Placeholder: For now, all rooms on the Z-level are "visited"
            )
        )
    
    return schemas.MapLevelDataResponse(
        z_level=character_z_level,
        current_room_id=active_character.current_room_id,
        rooms=map_rooms_data
    )
--- END OF FILE backend/app/api/v1/endpoints/map.py ---

--- FILE NOT FOUND: /src/script.js ---

--- FILE NOT FOUND: /src/index.html ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
