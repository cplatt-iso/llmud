--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Fri Jun  6 04:04:02 PM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/character_classes.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/mob_templates.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
bundle_context.sh
frontend/src/api.js
frontend/src/config.js
frontend/src/index.html
frontend/src/main.js
frontend/src/map.js
frontend/src/script.js
frontend/src/state.js
frontend/src/style.css
frontend/src/ui.js
frontend/src/websocket.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed." >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh" # Self-reference, good for context on context!
    "README.md"         # Always good to have

    # --- Backend - Core application & setup ---
    "$BACKEND_APP_DIR/main.py" # For app setup, logging config might be here
    "$BACKEND_APP_DIR/core/config.py" # For LOG_LEVEL, other settings
    # If you have a dedicated logging config file like backend/app/logging_config.py, add it:
    # "$BACKEND_APP_DIR/logging_config.py" 
    "$BACKEND_APP_DIR/websocket_router.py" # For overall WS command flow

    # --- Backend - Primary Focus for Current Issues ---
    "$BACKEND_APP_DIR/game_logic/combat/combat_round_processor.py" # AUTO-ATTACK LOOT
    "$BACKEND_APP_DIR/game_logic/combat/skill_resolver.py"       # LOOT LOGIC & DEBUG LOGS
    "$BACKEND_APP_DIR/game_logic/combat/combat_state_manager.py" # Potentially involved in mob death detection
    "$BACKEND_APP_DIR/crud/crud_mob.py" # MOB COMMIT REFACTOR

    # --- Backend - Models (Essential Context) ---
    "$BACKEND_APP_DIR/models/character.py"
    "$BACKEND_APP_DIR/models/item.py" 
    "$BACKEND_APP_DIR/models/room.py" 
    "$BACKEND_APP_DIR/models/mob_template.py" 
    "$BACKEND_APP_DIR/models/room_mob_instance.py" # Important for mob interactions
    "$BACKEND_APP_DIR/models/character_inventory_item.py"
    "$BACKEND_APP_DIR/models/character_class_template.py"
    "$BACKEND_APP_DIR/models/skill_template.py"
    "$BACKEND_APP_DIR/models/trait_template.py"

    # --- Backend - CRUD (Supporting Files) ---
    "$BACKEND_APP_DIR/crud/crud_item.py"
    "$BACKEND_APP_DIR/crud/crud_room.py" # Contains exit seeding
    "$BACKEND_APP_DIR/crud/crud_character.py" 
    "$BACKEND_APP_DIR/crud/crud_character_inventory.py"
    "$BACKEND_APP_DIR/crud/crud_skill.py"
    "$BACKEND_APP_DIR/crud/crud_trait.py"
    "$BACKEND_APP_DIR/crud/crud_character_class.py"
    "$BACKEND_APP_DIR/crud/crud_mob_spawn_definition.py" # May be affected by mob despawn changes


    # --- Backend - Schemas (Data Structures) ---
    "$BACKEND_APP_DIR/schemas/item.py" # Contains CharacterInventoryItem schema
    "$BACKEND_APP_DIR/schemas/room.py"
    "$BACKEND_APP_DIR/schemas/mob.py"
    "$BACKEND_APP_DIR/schemas/character.py"
    "$BACKEND_APP_DIR/schemas/character_class_template.py"
    "$BACKEND_APP_DIR/schemas/skill.py"
    "$BACKEND_APP_DIR/schemas/trait.py"
    "$BACKEND_APP_DIR/schemas/common_structures.py" # For ExitDetail etc.
    # map.py schema might be less critical for these specific backend logic issues
    # "$BACKEND_APP_DIR/schemas/map.py" 

    # --- Backend - API Endpoints & Command Parsers (General Context) ---
    "$BACKEND_APP_DIR/api/v1/endpoints/command.py" # For HTTP commands context
    # "$BACKEND_APP_DIR/api/v1/endpoints/map.py" # Less critical for current task
    "$BACKEND_APP_DIR/commands/inventory_parser.py" # We touched this for equip
    "$BACKEND_APP_DIR/ws_command_parsers/ws_movement_parser.py" # Movement context

    # --- Seed Data (Crucial for Loot and Game State) ---
    "$BACKEND_APP_DIR/seeds/items.json"
    "$BACKEND_APP_DIR/seeds/mob_templates.json"
    "$BACKEND_APP_DIR/seeds/character_classes.json"
    "$BACKEND_APP_DIR/seeds/skills.json"
    "$BACKEND_APP_DIR/seeds/traits.json"
    "$BACKEND_APP_DIR/seeds/rooms_z0.json"
    "$BACKEND_APP_DIR/seeds/exits_z0.json"

    # --- Frontend (Less focus for these backend tasks, but good for completeness) ---
    "$FRONTEND_SRC_DIR/main.js"      # Handles WS messages, command input
    "$FRONTEND_SRC_DIR/websocket.js" # WS connection logic
    "$FRONTEND_SRC_DIR/map.js"       # Map display (highlight issue was here)
    "$FRONTEND_SRC_DIR/ui.js"        # UI updates
    "$FRONTEND_SRC_DIR/state.js"     # Game state management
    "$FRONTEND_SRC_DIR/api.js" 
    "$FRONTEND_SRC_DIR/index.html" 
    "$FRONTEND_SRC_DIR/style.css" 
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (âœ¨ðŸ’°ðŸ’ªðŸ§©ðŸ’€ðŸšª) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Flesh out the damn world - Gear, Loot, and More Seeds!

The map is less of an abstract nightmare, and the core gameplay loop is... loopy. Now we need to make the interactions richer and the world feel less empty.

*   **Full Equipment System:** Define all equipment slots. Implement robust `equip` and `unequip` logic. Ensure stats update correctly.
*   **Mob Loot Tables:** Mobs need to drop more than just coins. Define loot tables (specific items, random items from categories, chances).
*   **Seed More Content (Externalize ALL THE THINGS):**
    *   `mob_templates.json`
    *   `character_classes.json`
    *   `skills.json`
    *   `traits.json`
    *   `mob_spawn_definitions.json`
    *   Update corresponding CRUD seeders to load from these JSONs.
*   **Seed Initial Equipment:** Place starting gear on character creation or in initial rooms.

This will involve a lot of backend work (models, CRUD, game logic) and careful JSON schema design for the seed files.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/main.py ---
# backend/app/main.py
import asyncio
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
import sys # For detailed print statements
from app.core.config import settings
import logging # Import logging

# --- Setup Logging First ---
# This needs to happen before other modules that might use logging are imported,
# or at least before they try to log.
try:
    from app.core.logging_config import setup_logging
    setup_logging()
    print("--- MAIN.PY: setup_logging() CALLED (no exception caught) ---", flush=True)
except ImportError as e_log_setup:
    print(f"--- CRITICAL: main.py - FAILED to import or run setup_logging: {e_log_setup} ---", flush=True)
    sys.exit(1) # Exit if logging can't be set up, as it's crucial for debugging

logger = logging.getLogger(__name__) # Get a logger for this module

# --- Add these lines for immediate feedback on logger level ---
print(f"--- MAIN.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_main = logger.getEffectiveLevel()
print(f"--- MAIN.PY: Effective log level for 'app.main' logger = {effective_level_main} ({logging.getLevelName(effective_level_main)}) ---", flush=True)
logger.debug(f"--- MAIN.PY DEBUG LOG TEST: Top of file, Python version: {sys.version} ---") # Changed from logger.debug to ensure it prints if DEBUG is working
logger.info(f"--- MAIN.PY INFO LOG TEST: Top of file, Python version: {sys.version} ---")
# --- End of added lines ---

from app.api.v1.api_router import api_router as v1_api_router
logger.debug("--- main.py - Imported v1_api_router ---")
from app.websocket_router import router as ws_router
logger.debug("--- main.py - Imported ws_router ---")
from app.db.session import engine, get_db
logger.debug("--- main.py - Imported engine, get_db from app.db.session ---")
from app.db import base_class
logger.debug("--- main.py - Imported base_class from app.db ---")
from app.core.config import settings
logger.debug(f"--- main.py - Imported settings. Project Name: {settings.PROJECT_NAME} ---")
from app.crud.crud_room import seed_initial_world
logger.debug("--- main.py - Imported seed_initial_world ---")
from app.crud.crud_item import seed_initial_items 
logger.debug("--- main.py - Imported seed_initial_items ---")
from app.crud.crud_mob import seed_initial_mob_templates
logger.debug("--- main.py - Imported seed_initial_mob_templates ---")
from app.game_logic.combat import start_combat_ticker_task, stop_combat_ticker_task
logger.debug("--- main.py - Imported combat_manager tasks ---")
from app.crud.crud_character_class import seed_initial_character_class_templates 
logger.debug("--- main.py - Imported seed_initial_character_class_templates ---")
from app.crud.crud_skill import seed_initial_skill_templates 
logger.debug("--- main.py - Imported seed_initial_skill_templates ---")
from app.crud.crud_trait import seed_initial_trait_templates 
logger.debug("--- main.py - Imported seed_initial_trait_templates ---")
from app.game_logic.world_ticker import start_world_ticker_task, stop_world_ticker_task
logger.debug("--- main.py - Imported world_ticker tasks ---")
from app.crud.crud_mob_spawn_definition import seed_initial_mob_spawn_definitions 
logger.debug("--- main.py - Imported seed_initial_mob_spawn_definitions ---")

logger.debug("--- main.py - About to call Base.metadata.create_all(bind=engine) ---")
try:
    base_class.Base.metadata.create_all(bind=engine)
    logger.info("--- main.py - Base.metadata.create_all(bind=engine) COMPLETED ---")
except Exception as e:
    logger.error(f"--- main.py - ERROR during Base.metadata.create_all: {e} ---", exc_info=True)
    # Depending on the severity, you might want to sys.exit() here

logger.debug("--- main.py - Creating FastAPI app instance ---")
app = FastAPI(title=settings.PROJECT_NAME)
logger.info("--- main.py - FastAPI app instance CREATED ---")

@app.on_event("startup")
def on_startup_sync():
    logger.info("--- main.py - START of on_startup_sync event ---")
    db: Session = next(get_db())
    logger.debug("--- main.py - on_startup_sync: Acquired DB session ---")
    try:
        logger.info("--- main.py - on_startup_sync: Running startup event: Seeding initial data... ---")
        
        # CORRECT ORDER:
        # 1. Seed items FIRST
        seed_initial_items(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_items COMPLETED ---")

        # 2. THEN seed the world (rooms/exits), which might place items
        seed_initial_world(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_world COMPLETED ---")
        
        # 3. THEN other things
        seed_initial_mob_templates(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_templates COMPLETED ---")
        
        seed_initial_character_class_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_character_class_templates COMPLETED ---")
        
        seed_initial_skill_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_skill_templates COMPLETED ---")
        
        seed_initial_trait_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_trait_templates COMPLETED ---")
        
        seed_initial_mob_spawn_definitions(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_spawn_definitions COMPLETED ---")
        
        logger.info("--- main.py - on_startup_sync: Starting combat ticker... ---")
        start_combat_ticker_task()
        logger.debug("--- main.py - on_startup_sync: Combat ticker STARTED ---")      

        logger.info("--- main.py - on_startup_sync: Starting world ticker... ---") 
        start_world_ticker_task()    
        logger.debug("--- main.py - on_startup_sync: World ticker STARTED ---")     
        logger.info("--- main.py - on_startup_sync: Startup event processing FINISHED ---")
    except Exception as e_startup:
        logger.error(f"--- main.py - ERROR during on_startup_sync: {e_startup} ---", exc_info=True)
    finally:
        logger.debug("--- main.py - on_startup_sync: Closing DB session ---")
        db.close()
        logger.debug("--- main.py - on_startup_sync: DB session CLOSED ---")
    logger.info("--- main.py - END of on_startup_sync event ---")

logger.debug("--- main.py - About to include v1_api_router ---")
app.include_router(v1_api_router, prefix=settings.API_V1_STR)
logger.debug("--- main.py - v1_api_router INCLUDED ---")

logger.debug("--- main.py - About to include ws_router ---")
app.include_router(ws_router)
logger.debug("--- main.py - ws_router INCLUDED ---")

@app.get("/")
async def root():
    logger.debug("--- main.py - GET / request received ---")
    return {"message": f"Welcome to {settings.PROJECT_NAME}. Now with a World Ticker humming in the background!"}

logger.info("--- main.py - FastAPI app instance configured. End of file. ---")
--- END OF FILE backend/app/main.py ---

--- START OF FILE backend/app/core/config.py ---
# backend/app/core/config.py
import os
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict

# Check if we're likely running in an Alembic 'env.py' context BEFORE settings are needed for DB connection
# This is a heuristic. Alembic sets 'alembic.version' in its context.
# A simpler heuristic: if a specific env var for alembic is set.
IS_ALEMBIC_ENV_PY_CONTEXT = os.getenv("ALEMBIC_ENV_PY_RUNNING") == "true"

class Settings(BaseSettings):
    PROJECT_NAME: str = "MUD Project - Backend"
    API_V1_STR: str = "/api/v1"
    
    DATABASE_URL: Optional[str] = "postgresql://dummy_user:dummy_password@dummy_host:5432/dummy_db" if IS_ALEMBIC_ENV_PY_CONTEXT else os.getenv("DATABASE_URL", "postgresql://user:password@db/llmud_db") # Added os.getenv for normal case
    SECRET_KEY: str = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7" # CHANGE THIS IN PRODUCTION!
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7 # Token expires in 7 days

    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO").upper() # Default to INFO
    SHOW_COMBAT_ROLLS_TO_PLAYER: bool = os.getenv("SHOW_COMBAT_ROLLS_TO_PLAYER", "True").lower() == "true"


    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8', extra='ignore')

settings = Settings() 

# After instantiation, if it was a dummy, ensure it's overridden if not in Alembic context
# and the real env var is available.
if IS_ALEMBIC_ENV_PY_CONTEXT and settings.DATABASE_URL is not None and "dummy_user" in settings.DATABASE_URL:
    # logger.info("Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.") # Can't use logger before setup
    print("INFO: Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.")
elif not IS_ALEMBIC_ENV_PY_CONTEXT and os.getenv("DATABASE_URL"):
    settings.DATABASE_URL = os.getenv("DATABASE_URL") # Ensure it's set from env if not in alembic context
elif not IS_ALEMBIC_ENV_PY_CONTEXT and not os.getenv("DATABASE_URL"):
    # This will have already failed in Settings() if '...' was used and no env var
    # logger.warning("DATABASE_URL not found in environment for normal app run!") # Can't use logger before setup
    print("WARNING: DATABASE_URL not found in environment for normal app run!")
--- END OF FILE backend/app/core/config.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple, Union
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session # attributes removed as it's used in parsers now
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

from app.core.config import settings
from app.db.session import SessionLocal
from app import crud, models, schemas # Full app imports
from app.websocket_manager import connection_manager
from app.game_logic import combat # For access to combat.active_combats, combat.send_combat_log etc.

from app.commands.utils import ( # General utils
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message
    # resolve_mob_target is used within ws_combat_actions_parser
    # resolve_room_item_target is used within ws_interaction_parser
)
from app.game_state import is_character_resting, set_character_resting_status
# ExitDetail is used within ws_movement_parser.attempt_player_move

# Import the new WS command parsers
from app.ws_command_parsers import (
    handle_ws_movement, handle_ws_flee,
    handle_ws_attack, handle_ws_use_combat_skill,
    handle_ws_get_take, handle_ws_unlock, handle_ws_search_examine,
    handle_ws_contextual_interactable, handle_ws_use_ooc_skill,
    handle_ws_look, handle_ws_rest
)

logger = logging.getLogger(__name__)
# --- Logger setup print lines (can be removed once stable) ---
print(f"--- WEBSOCKET_ROUTER.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_ws = logger.getEffectiveLevel()
print(f"--- WEBSOCKET_ROUTER.PY: Effective log level for '{logger.name}' logger = {effective_level_ws} ({logging.getLevelName(effective_level_ws)}) ---", flush=True)
logger.info("--- WEBSOCKET_ROUTER.PY INFO LOG TEST: Module loaded (Post-Refactor) ---")
# --- End of logger setup print lines ---

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str) # Ensure player_id_str is a valid UUID string
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError): # Catch JWT errors and ValueError from UUID conversion
        return None

# _handle_websocket_move_if_not_in_combat has been moved to ws_movement_parser.attempt_player_move

@router.websocket("/ws") 
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character_orm: Optional[models.Character] = None # Renamed from 'character' to avoid confusion with character_id param

    with get_db_sync() as db_conn_init: 
        player = await get_player_from_token(token, db_conn_init)
        if not player:
            logger.warning(f"WS Connect: Invalid token for char_id: {character_id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return
        
        fetched_char = crud.crud_character.get_character(db_conn_init, character_id=character_id)
        if not fetched_char or fetched_char.player_id != player.id:
            logger.warning(f"WS Connect: Invalid char_id: {character_id} for player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character_orm = fetched_char # Assign to the correctly scoped variable
    
    await connection_manager.connect(websocket, player.id, character_orm.id)
    logger.info(f"Player {player.id} (Character {character_orm.name} - {character_orm.id}) connected via WebSocket.")
    
    # --- Welcome Package ---
    initial_messages = [f"Welcome {character_orm.name}! You are connected via WebSocket."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db_welcome: 
        initial_room_orm = crud.crud_room.get_room_by_id(db_welcome, room_id=character_orm.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.")
            items_on_ground = crud.crud_room_item.get_items_in_room(db_welcome, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: initial_messages.append(items_text)
            
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db_welcome, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: initial_messages.append(mobs_text)
            
            other_chars_in_room = crud.crud_character.get_characters_in_room(db_welcome, room_id=initial_room_orm.id, exclude_character_id=character_orm.id)
            chars_text_initial = format_room_characters_for_player_message(other_chars_in_room)
            if chars_text_initial: initial_messages.append(chars_text_initial)
    
    xp_for_next_level = crud.crud_character.get_xp_for_level(character_orm.level + 1)
    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump(exclude_none=True) if initial_room_schema else None,
        "character_vitals": {
            "current_hp": character_orm.current_health, "max_hp": character_orm.max_health,
            "current_mp": character_orm.current_mana, "max_mp": character_orm.max_mana,
            "current_xp": character_orm.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character_orm.level,
            "platinum": character_orm.platinum_coins, "gold": character_orm.gold_coins,
            "silver": character_orm.silver_coins, "copper": character_orm.copper_coins
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)
    # --- End Welcome Package ---

    try:
        while True:
            received_data = await websocket.receive_json()
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            # It's crucial to get fresh state at the beginning of each command processing loop
            with get_db_sync() as db_loop: 
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character_orm.id)
                if not current_char_state: 
                    logger.error(f"WS Loop: Character state lost for char_id: {character_orm.id}.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost in loop")
                    break 
                
                current_room_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                if not current_room_orm:
                    logger.error(f"WS Loop: Character {current_char_state.name} in invalid room {current_char_state.current_room_id}.")
                    await combat.send_combat_log(player.id, ["Error: Your current location is unstable. Please relog or contact support."], combat_ended=True)
                    continue 

                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_orm)
                
                verb_for_rest_check = command_text.split(" ", 1)[0].lower() if command_text else ""
                
                non_breaking_verbs = [ # Commands that don't break resting
                    "rest", "look", "l", "score", "sc", "status", "st", 
                    "help", "?", "skills", "sk", "traits", "tr", 
                    "inventory", "i", "ooc", "say", "'", "emote", ":" 
                ]
                
                if verb_for_rest_check and verb_for_rest_check not in non_breaking_verbs and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat.send_combat_log(player.id, ["You stop resting."], room_data=current_room_schema_for_command)

                if message_type == "command" and command_text:
                    verb = verb_for_rest_check 
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""
                    args_list = args_str.split() # For handlers that need a list

                    logger.debug(f"WS Router: Processing verb='{verb}', args='{args_str}' for char {current_char_state.name}")

                    # --- Command Dispatching ---
                    if verb == "rest":
                        await handle_ws_rest(db_loop, player, current_char_state, current_room_orm)
                    elif verb in ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]:
                        await handle_ws_movement(db_loop, player, current_char_state, current_room_schema_for_command, verb, args_str)
                    elif verb == "flee":
                        await handle_ws_flee(db_loop, player, current_char_state, current_room_schema_for_command, args_str)
                    elif verb in ["attack", "atk", "kill", "k"]:
                        await handle_ws_attack(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "use":
                        if not args_str: 
                            await combat.send_combat_log(player.id, ["Use what skill?"], room_data=current_room_schema_for_command); continue
                        
                        temp_args_list_for_skill_parse = args_str.split()
                        learned_skill_tags = current_char_state.learned_skills or []
                        if not learned_skill_tags: 
                            await combat.send_combat_log(player.id, ["You have no skills."], room_data=current_room_schema_for_command); continue

                        # Simplified skill name parsing (copied from previous) - THIS SHOULD BE A UTILITY
                        parsed_skill_template: Optional[models.SkillTemplate] = None
                        parsed_remaining_args: str = ""
                        possible_matches_temp: List[Tuple[models.SkillTemplate, str]] = []
                        for i in range(len(temp_args_list_for_skill_parse), 0, -1):
                            current_skill_input = " ".join(temp_args_list_for_skill_parse[:i]).lower()
                            potential_target_str = " ".join(temp_args_list_for_skill_parse[i:]).strip()
                            for skill_tag_loop in learned_skill_tags:
                                st_db = crud.crud_skill.get_skill_template_by_tag(db_loop, skill_id_tag=skill_tag_loop)
                                if not st_db: continue
                                if st_db.skill_id_tag.lower().startswith(current_skill_input) or st_db.name.lower().startswith(current_skill_input):
                                    if not any(em.id == st_db.id for em, _ in possible_matches_temp):
                                        possible_matches_temp.append((st_db, potential_target_str))
                            if possible_matches_temp and len(current_skill_input.split()) > 0: break
                        
                        if not possible_matches_temp: await combat.send_combat_log(player.id, [f"No skill matching '{temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else args_str}'."], room_data=current_room_schema_for_command); continue
                        elif len(possible_matches_temp) == 1: parsed_skill_template, parsed_remaining_args = possible_matches_temp[0]
                        else:
                            exact_match_s = None; s_input_first = temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else ""
                            for sm_t, sm_a in possible_matches_temp:
                                if sm_t.name.lower() == s_input_first or sm_t.skill_id_tag.lower() == s_input_first:
                                    exact_match_s = sm_t; parsed_remaining_args = sm_a; break
                            if exact_match_s: parsed_skill_template = exact_match_s
                            else: await combat.send_combat_log(player.id, [f"Multiple skills match. Specify: {', '.join(list(set([st.name for st, _ in possible_matches_temp])))}"], room_data=current_room_schema_for_command); continue
                        
                        if not parsed_skill_template: await combat.send_combat_log(player.id, ["Error selecting skill for 'use' command."], room_data=current_room_schema_for_command); continue

                        # Dispatch based on skill type
                        if parsed_skill_template.skill_type == "COMBAT_ACTIVE":
                            await handle_ws_use_combat_skill(db_loop, player, current_char_state, current_room_schema_for_command, args_str) # Pass original args_str for its own parsing
                        elif parsed_skill_template.skill_type == "UTILITY_OOC":
                            # parsed_remaining_args is the target for the OOC skill (e.g., direction string)
                            await handle_ws_use_ooc_skill(db_loop, player, current_char_state, current_room_orm, parsed_skill_template, parsed_remaining_args)
                        else:
                            await combat.send_combat_log(player.id, [f"Skill '{parsed_skill_template.name}' type ({parsed_skill_template.skill_type}) cannot be 'used' this way."], room_data=current_room_schema_for_command)
                    
                    elif verb in ["get", "take"]:
                        await handle_ws_get_take(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "unlock":
                        await handle_ws_unlock(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "search" or verb == "examine":
                        await handle_ws_search_examine(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "look" or verb == "l":
                        await handle_ws_look(db_loop, player, current_char_state, current_room_orm, args_str)
                    else: # Fallback: Try contextual interactable actions
                        is_interactable_action_handled = False
                        if current_room_orm.interactables: # Check if list is not None and not empty
                            target_interactable_name_or_id = args_str.lower()
                            for interactable_dict_ws in current_room_orm.interactables:
                                try:
                                    interactable_obj_ws = schemas.InteractableDetail(**interactable_dict_ws) # Validate from DB data
                                    is_visible = not interactable_obj_ws.is_hidden or current_char_state.id in interactable_obj_ws.revealed_to_char_ids
                                    
                                    if is_visible and verb == interactable_obj_ws.action_verb.lower():
                                        matches_this_interactable = False
                                        if not target_interactable_name_or_id: # e.g. "pull"
                                            # Count how many pullable things are visible
                                            count_with_verb = 0
                                            for other_i_d in current_room_orm.interactables:
                                                other_i = schemas.InteractableDetail(**other_i_d)
                                                other_vis = not other_i.is_hidden or current_char_state.id in other_i.revealed_to_char_ids
                                                if other_vis and other_i.action_verb.lower() == verb:
                                                    count_with_verb +=1
                                            if count_with_verb == 1: matches_this_interactable = True
                                        elif interactable_obj_ws.id_tag.lower() == target_interactable_name_or_id or \
                                             target_interactable_name_or_id in interactable_obj_ws.name.lower():
                                            matches_this_interactable = True
                                        
                                        if matches_this_interactable:
                                            await handle_ws_contextual_interactable(db_loop, player, current_char_state, current_room_orm, verb, args_list, interactable_obj_ws)
                                            is_interactable_action_handled = True; break 
                                except Exception as e_parse_interactable_ws_ctx: 
                                    logger.error(f"WS: Error parsing interactable for contextual check: {e_parse_interactable_ws_ctx}. Data: {interactable_dict_ws}")
                        
                        if not is_interactable_action_handled:
                            # If not any of the above, it's an unknown command for WebSocket
                            await combat.send_combat_log(player.id, [f"Unrecognized command via WebSocket: '{command_text}'. Try 'help' (HTTP)."], room_data=current_room_schema_for_command)
                
                    try:
                        db_loop.commit() # Commit changes made by the handler
                        logger.debug(f"WS Router: DB commit successful for command '{command_text}' by {current_char_state.name}")
                    except Exception as e_commit:
                        db_loop.rollback()
                        logger.error(f"WS Router: DB commit failed for command '{command_text}' by {current_char_state.name}: {e_commit}", exc_info=True)
                        await combat.send_combat_log(player.id, ["A glitch in the matrix occurred. Your last action may not have saved."], room_data=current_room_schema_for_command) # Send error to player
                
                elif message_type != "command": 
                    await combat.send_combat_log(player.id, [f"Unrecognized message type: {message_type}."], room_data=current_room_schema_for_command)
                elif not command_text : # Empty command string for type "command"
                     await combat.send_combat_log(player.id, ["Empty command received."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'} (Character {character_orm.id if character_orm else 'N/A'})")
        if character_orm and character_orm.id: 
            combat.end_combat_for_character(character_orm.id, reason="websocket_disconnect_main_handler")
            if is_character_resting(character_orm.id):
                set_character_resting_status(character_orm.id, False)
    except Exception as e:
        err_player_id_str = str(player.id) if player else "Unknown Player"
        err_char_id_str = str(character_orm.id) if character_orm else "Unknown Character"
        logger.error(f"Critical Error in WebSocket handler for Player {err_player_id_str} (Character {err_char_id_str}): {e}", exc_info=True)
        try:
            # Attempt to send a generic error to the client before closing
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred. Please try reconnecting."})
        except Exception as send_err: 
            logger.error(f"Failed to send critical error to WebSocket for Player {err_player_id_str}: {send_err}")
    finally:
        if player and player.id: 
            connection_manager.disconnect(player.id) 
            if character_orm and character_orm.id and is_character_resting(character_orm.id): 
                set_character_resting_status(character_orm.id, False)
        char_id_log_final = str(character_orm.id) if character_orm else "N/A"
        player_id_log_final = str(player.id) if player else "N/A"
        logger.info(f"WebSocket connection for Player {player_id_log_final} (Character {char_id_log_final}) fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/game_logic/combat/combat_round_processor.py ---
# backend/app/game_logic/combat/combat_round_processor.py
import uuid
import random
import logging
from typing import List, Optional, Tuple, Union, Dict, Any

from sqlalchemy.orm import Session, attributes

from app import crud, models, schemas
from app.commands.utils import roll_dice


# combat sub-package imports
from .combat_state_manager import (
    active_combats, mob_targets, character_queued_actions,
    end_combat_for_character
)
from .skill_resolver import resolve_skill_effect
from .combat_utils import (
    send_combat_log, broadcast_combat_event,
    perform_server_side_move, direction_map
)

logger = logging.getLogger(__name__)

async def process_combat_round(db: Session, character_id: uuid.UUID, player_id: uuid.UUID):
    # --- 1. Initial Character & Combat State Checks ---
    if character_id not in active_combats or not active_combats[character_id]:
        if character_id in active_combats:
            end_combat_for_character(character_id, reason="no_targets_in_active_combats_dict_proc_round")
        return

    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character: 
        logger.critical(f"PROC_ROUND: Character {character_id} not found. Cleaning combat states.")
        end_combat_for_character(character_id, reason="character_not_found_in_db_proc_round")
        return

    # Now 'character' is guaranteed to be a models.Character object.
    if character.current_health <= 0:
        # ... (dead character handling as before, 'character' is not None here) ...
        round_log_dead_char = ["You are dead and cannot act."]
        end_combat_for_character(character_id, reason="character_is_dead_proc_round")
        current_room_for_update = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
        current_room_schema_for_update = schemas.RoomInDB.from_orm(current_room_for_update) if current_room_for_update else None
        xp_for_next_lvl = crud.crud_character.get_xp_for_level(character.level + 1)
        vitals_for_payload = {
            "current_hp": character.current_health, "max_hp": character.max_health,
            "current_mp": character.current_mana, "max_mp": character.max_mana,
            "current_xp": character.experience_points,
            "next_level_xp": int(xp_for_next_lvl) if xp_for_next_lvl != float('inf') else -1,
            "level": character.level,
            "platinum": character.platinum_coins, "gold": character.gold_coins,
            "silver": character.silver_coins, "copper": character.copper_coins
        }
        await send_combat_log(player_id, round_log_dead_char, True, current_room_schema_for_update, character_vitals=vitals_for_payload)
        return

    # --- 2. Round Setup ---
    char_combat_stats = character.calculate_combat_stats()
    player_ac = char_combat_stats["effective_ac"]
    round_log: List[str] = [] 
    combat_resolved_this_round = False
    action_str = character_queued_actions.get(character_id)
    character_queued_actions[character_id] = None
    
    room_of_action_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    if not room_of_action_orm:
        logger.error(f"PROC_ROUND: Character {character.name} ({character.id}) in invalid room_id {character.current_room_id}. Ending combat.")
        end_combat_for_character(character_id, reason="character_in_invalid_room_proc_round")
        await send_combat_log(player_id, ["Error: Your location is unstable. Combat disengaged."], combat_ended=True)
        # Commit character state change if any (e.g. mana from previous turn) before returning
        db.add(character)
        db.commit()
        return
    current_room_id_for_action_broadcasts = room_of_action_orm.id

    # --- 3. Player's Action Processing ---
    if action_str:
        if action_str.startswith("flee"):
            # ... (flee logic as before, perform_server_side_move itself should handle None rooms) ...
            action_parts = action_str.split(" ", 1)
            flee_direction_canonical = action_parts[1] if len(action_parts) > 1 and action_parts[1] else "random"
            if random.random() < 0.6: 
                new_room_id, flee_departure_msg, flee_arrival_msg, _ = await perform_server_side_move(
                    db, character, flee_direction_canonical, player_id
                )
                if new_room_id:
                    round_log.append(f"<span class='combat-success'>{flee_departure_msg}</span>")
                    if flee_arrival_msg: round_log.append(flee_arrival_msg)
                    combat_resolved_this_round = True 
                else: 
                    round_log.append(f"<span class='combat-miss'>You try to flee {flee_direction_canonical if flee_direction_canonical != 'random' else ''}, but there's nowhere to go! ({flee_departure_msg})</span>") # Include flee_departure_msg if it's an error
            else: 
                round_log.append("<span class='combat-miss'>Your attempt to flee fails! You stumble.</span>")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='char-name'>{character.name}</span> tries to flee, but stumbles!")
        
        elif action_str.startswith("attack"):
            target_mob_id: Optional[uuid.UUID] = None
            try:
                target_mob_id_str = action_str.split(" ", 1)[1]
                target_mob_id = uuid.UUID(target_mob_id_str)
            except (IndexError, ValueError):
                round_log.append("Invalid attack target format in queue.")
            
            if target_mob_id and target_mob_id in active_combats.get(character_id, set()):
                mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_id)
                if mob_instance and mob_instance.mob_template: # CRUCIAL: Check mob_template exists
                    if mob_instance.current_health > 0: # Check health AFTER confirming mob_instance and template
                        mob_template = mob_instance.mob_template # Now safe to access
                        mob_ac = mob_template.base_defense if mob_template.base_defense is not None else 10
                        player_attack_bonus = char_combat_stats["attack_bonus"]
                        player_damage_dice = char_combat_stats["damage_dice"]
                        player_damage_bonus = char_combat_stats["damage_bonus"]
                        to_hit_roll = roll_dice("1d20")

                        updated_mob = None  # Ensure updated_mob is always defined

                        if (to_hit_roll + player_attack_bonus) >= mob_ac:
                            damage = max(1, roll_dice(player_damage_dice) + player_damage_bonus)
                            round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>HITS</span> <span class='inv-item-name'>{mob_template.name}</span> for <span class='combat-hit'>{damage}</span> damage.")
                            await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"<span class='char-name'>{character.name}</span> HITS <span class='inv-item-name'>{mob_template.name}</span> for {damage} damage!")
                            updated_mob = crud.crud_mob.update_mob_instance_health(db, mob_instance.id, -damage)
                        if updated_mob and updated_mob.current_health <= 0:
                            round_log.append(f"<span class='combat-death'>The {mob_template.name} DIES! Fucking finally.</span>")
                            await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"The <span class='inv-item-name'>{mob_template.name}</span> DIES!")
                            
                            # XP Award
                            if mob_template.xp_value > 0:
                                char_obj_after_xp, xp_msgs = crud.crud_character.add_experience(db, character.id, mob_template.xp_value)
                                if char_obj_after_xp : character = char_obj_after_xp 
                                round_log.extend(xp_msgs)

                            # >>> ADD CURRENCY DROP LOGIC HERE (copied from skill_resolver) <<<
                            platinum_dropped, gold_dropped, silver_dropped, copper_dropped = 0, 0, 0, 0
                            if mob_template.currency_drop: # mob_template is already confirmed to exist
                                cd = mob_template.currency_drop
                                copper_dropped = random.randint(cd.get("c_min", 0), cd.get("c_max", 0))
                                if random.randint(1, 100) <= cd.get("s_chance", 0):
                                    silver_dropped = random.randint(cd.get("s_min", 0), cd.get("s_max", 0))
                                if random.randint(1, 100) <= cd.get("g_chance", 0):
                                    gold_dropped = random.randint(cd.get("g_min", 0), cd.get("g_max", 0))
                                if random.randint(1, 100) <= cd.get("p_chance", 0):
                                    platinum_dropped = random.randint(cd.get("p_min", 0), cd.get("p_max", 0))
                            
                            if platinum_dropped > 0 or gold_dropped > 0 or silver_dropped > 0 or copper_dropped > 0:
                                char_obj_after_currency, currency_message = crud.crud_character.update_character_currency(
                                    db, character.id, platinum_dropped, gold_dropped, silver_dropped, copper_dropped
                                )
                                if char_obj_after_currency:
                                     character = char_obj_after_currency # Update local character
                                
                                drop_msg_parts_attack = []
                                if platinum_dropped > 0: drop_msg_parts_attack.append(f"{platinum_dropped}p")
                                if gold_dropped > 0: drop_msg_parts_attack.append(f"{gold_dropped}g")
                                if silver_dropped > 0: drop_msg_parts_attack.append(f"{silver_dropped}s")
                                if copper_dropped > 0: drop_msg_parts_attack.append(f"{copper_dropped}c")
                                
                                if drop_msg_parts_attack:
                                     round_log.append(f"The {mob_template.name} drops: {', '.join(drop_msg_parts_attack)}.")
                                     round_log.append(currency_message) # "You gained X. Current balance: Y"
                            # >>> END CURRENCY DROP LOGIC <<<
                            
                            # TODO: Item drops for basic attacks

                            crud.crud_mob.despawn_mob_from_room(db, updated_mob.id)
                            active_combats.get(character_id, set()).discard(updated_mob.id)
                            if updated_mob.id in mob_targets: mob_targets.pop(updated_mob.id, None)
                            elif updated_mob:
                                round_log.append(f"  {mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{mob_template.base_health}</span>.")
                        else: 
                            round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{mob_template.name}</span>.")
                            await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"<span class='char-name'>{character.name}</span> MISSES the <span class='inv-item-name'>{mob_template.name}</span>.")
                    else: # Mob is dead or has 0 HP
                        round_log.append(f"Your target, {mob_instance.mob_template.name if mob_instance.mob_template else 'the creature'}, is already defeated.")
                        if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
                elif mob_instance: # Mob instance exists but mob_template is None (data issue)
                    logger.error(f"PROC_ROUND: Mob instance {mob_instance.id} missing mob_template. Cannot process attack.")
                    round_log.append(f"Your target is an unrecognizable entity. Attack fails.")
                    if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
                else: # Mob instance not found in DB
                    round_log.append(f"Your target (ID: {target_mob_id}) seems to have vanished utterly.")
                    if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
            elif target_mob_id: # Target mob ID was valid UUID but not in this character's combat
                round_log.append("You try to attack, but your target isn't part of this fight.")
            else: # target_mob_id was None (parsing error from queue)
                 round_log.append("You flail at the air, unsure who to attack. What a loser.")
        
        elif action_str.startswith("use_skill"):
            parts = action_str.split(" ", 2) 
            skill_id_tag_from_queue = parts[1] if len(parts) > 1 else None
            target_identifier_from_queue = parts[2] if len(parts) > 2 else "NONE"
            
            target_entity_for_skill_resolution: Optional[Union[models.RoomMobInstance, str]] = None
            skill_template_to_use = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_id_tag_from_queue) if skill_id_tag_from_queue else None
            valid_target_context_for_skill = False

            if skill_template_to_use:
                if skill_template_to_use.target_type == "ENEMY_MOB":
                    if target_identifier_from_queue.lower() not in ["none", "self"]:
                        try:
                            target_mob_uuid = uuid.UUID(target_identifier_from_queue)
                            if target_mob_uuid in active_combats.get(character_id, set()):
                                mob_for_skill = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_uuid)
                                # CRITICAL: Check mob_for_skill AND mob_for_skill.mob_template
                                if mob_for_skill and mob_for_skill.mob_template and mob_for_skill.current_health > 0:
                                    target_entity_for_skill_resolution = mob_for_skill
                                    valid_target_context_for_skill = True
                                else: round_log.append(f"Skill target '{mob_for_skill.mob_template.name if mob_for_skill and mob_for_skill.mob_template else 'creature'}' is invalid or dead.")
                            else: round_log.append(f"You can't use '{skill_template_to_use.name}' on something you're not actively fighting ({target_identifier_from_queue}).")
                        except ValueError: round_log.append(f"Invalid target ID '{target_identifier_from_queue}' for skill.")
                    else: round_log.append(f"'{skill_template_to_use.name}' requires an enemy target.")
                
                elif skill_template_to_use.target_type == "DOOR":
                    if target_identifier_from_queue.lower() not in ["none", "self"]:
                        target_entity_for_skill_resolution = target_identifier_from_queue 
                        valid_target_context_for_skill = True
                    else: round_log.append(f"You need to specify a direction for '{skill_template_to_use.name}'.")

                elif skill_template_to_use.target_type in ["SELF", "NONE"]:
                    target_entity_for_skill_resolution = None 
                    valid_target_context_for_skill = True
                
                if valid_target_context_for_skill:
                    skill_messages, action_was_taken_by_skill, char_after_skill = await resolve_skill_effect(
                        db, character, skill_template_to_use, target_entity_for_skill_resolution, 
                        player_id, current_room_id_for_action_broadcasts
                    )
                    round_log.extend(skill_messages)
                    if char_after_skill: character = char_after_skill 
                    
                    if not action_was_taken_by_skill and not any("enough mana" in m.lower() for m in skill_messages) and \
                       not any("already unlocked" in m.lower() for m in skill_messages):
                        round_log.append(f"Your attempt to use {skill_template_to_use.name} fizzles.")
                elif not round_log: 
                    round_log.append(f"Could not determine a valid target or context for '{skill_template_to_use.name}'.")
            else:
                round_log.append(f"You try to use a skill '{skill_id_tag_from_queue}', but it's invalid or unknown.")
    else: 
        round_log.append("You pause, bewildered by the chaos.")

    # --- 4. Check if Player's Targets Are Defeated (Post-Player Action) ---
    current_targets_for_player = list(active_combats.get(character_id, set()))
    all_targets_down_after_player_action = True
    if not current_targets_for_player:
        all_targets_down_after_player_action = True
    else:
        for mob_target_id in current_targets_for_player:
            mob_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_target_id)
            if mob_check and mob_check.current_health > 0: # Ensure mob exists AND is alive
                all_targets_down_after_player_action = False; break
    
    if all_targets_down_after_player_action and not combat_resolved_this_round:
        round_log.append("All your targets are defeated or gone. Combat ends.")
        combat_resolved_this_round = True

    # --- 5. Mobs' Actions (Retaliation) ---
    if not combat_resolved_this_round and character.current_health > 0:
        mobs_attacking_character_this_round: List[models.RoomMobInstance] = []
        for mob_id, targeted_char_id in list(mob_targets.items()): # Iterate copy
            if targeted_char_id == character_id:
                mob_instance_to_act = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id)
                if mob_instance_to_act and mob_instance_to_act.mob_template and \
                   mob_instance_to_act.current_health > 0 and \
                   mob_instance_to_act.room_id == character.current_room_id:
                    mobs_attacking_character_this_round.append(mob_instance_to_act)
        
        for mob_instance in mobs_attacking_character_this_round:
            if character.current_health <= 0: break 
            mob_template = mob_instance.mob_template # Safe due to check above
            # ... (mob attack logic as before, character health is updated directly) ...
            mob_attack_bonus = mob_template.level or 1 
            mob_damage_dice = mob_template.base_attack or "1d4"
            mob_to_hit_roll = roll_dice("1d20")

            if (mob_to_hit_roll + mob_attack_bonus) >= player_ac:
                damage_to_player = max(1, roll_dice(mob_damage_dice))
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-success'>HITS</span> <span class='char-name'>{character.name}</span> for <span class='combat-hit-player'>{damage_to_player}</span> damage.")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> HITS <span class='char-name'>{character.name}</span> for {damage_to_player} damage!")
                character.current_health -= damage_to_player 
                round_log.append(f"  Your HP: <span class='combat-hp'>{character.current_health}/{character.max_health}</span>.")
                if character.current_health <= 0:
                    character.current_health = 0 
                    round_log.append("<span class='combat-death'>YOU HAVE DIED! How utterly predictable.</span>")
                    await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                  f"<span class='char-name'>{character.name}</span> <span class='combat-death'>HAS DIED!</span>")
                    combat_resolved_this_round = True 
                    max_health_at_death = character.max_health
                    respawn_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0)
                    if respawn_room_orm:
                        char_after_respawn = crud.crud_character.update_character_room(db, character_id=character.id, new_room_id=respawn_room_orm.id)
                        if char_after_respawn: 
                            character = char_after_respawn # Update local character
                            round_log.append(f"A mystical force whisks your fading spirit away. You awaken, gasping, in <span class='room-name'>{respawn_room_orm.name}</span>.")
                        else: round_log.append("Error: Failed to update character room during respawn."); break 
                    else: round_log.append("Error: Respawn room (0,0,0) not found."); break 
                    character.current_health = max_health_at_death 
                    round_log.append("You feel a surge of life, your wounds miraculously healed.")
                    break 
            else: 
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-miss'>MISSES</span> <span class='char-name'>{character.name}</span>.")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> MISSES <span class='char-name'>{character.name}</span>.")
    
    # --- 6. End of Round Cleanup & Next Action Queuing ---
    if combat_resolved_this_round:
        end_combat_for_character(character_id, reason="combat_resolved_this_round_proc_round")
    elif character.current_health > 0 and character_id in active_combats:
        if not action_str or action_str.startswith("attack") or (action_str.startswith("flee") and not combat_resolved_this_round):
            remaining_targets_for_next_round = list(active_combats.get(character_id, set()))
            first_valid_target_id_for_next_round = None
            if remaining_targets_for_next_round:
                for mob_id_check in remaining_targets_for_next_round:
                    mob_next_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id_check)
                    if mob_next_check and mob_next_check.current_health > 0:
                        first_valid_target_id_for_next_round = mob_id_check; break 
            if first_valid_target_id_for_next_round:
                character_queued_actions[character_id] = f"attack {first_valid_target_id_for_next_round}"
            else: 
                if not combat_resolved_this_round : 
                    round_log.append("No valid targets remain for next round. Combat ends.")
                end_combat_for_character(character_id, reason="no_valid_targets_remain_proc_round")
                combat_resolved_this_round = True 
    
    # --- 7. Final DB Commit & Send Log ---
    db.add(character) # Ensure character changes are staged
    # Room changes (e.g. from lockpicking) are staged by resolve_skill_effect
    db.commit()
    db.refresh(character) 
    
    # Send log with potentially updated room (if fled/died)
    final_room_for_payload_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    final_room_schema_for_payload = schemas.RoomInDB.from_orm(final_room_for_payload_orm) if final_room_for_payload_orm else None
    
    xp_for_next_level_final = crud.crud_character.get_xp_for_level(character.level + 1)
    final_vitals_payload = {
        "current_hp": character.current_health, "max_hp": character.max_health,
        "current_mp": character.current_mana, "max_mp": character.max_mana,
        "current_xp": character.experience_points,
        "next_level_xp": int(xp_for_next_level_final) if xp_for_next_level_final != float('inf') else -1,
        "level": character.level,
        "platinum": character.platinum_coins, "gold": character.gold_coins,
        "silver": character.silver_coins, "copper": character.copper_coins
    }
    
    await send_combat_log(
        player_id, round_log, combat_resolved_this_round, 
        final_room_schema_for_payload, character_vitals=final_vitals_payload
    )
--- END OF FILE backend/app/game_logic/combat/combat_round_processor.py ---

--- START OF FILE backend/app/game_logic/combat/skill_resolver.py ---
# backend/app/game_logic/combat/skill_resolver.py
import uuid
import random
import logging
from typing import List, Optional, Tuple, Union, Dict, Any

from sqlalchemy.orm import Session, attributes

from app import crud, models, schemas
from app.commands.utils import roll_dice
from .combat_utils import broadcast_combat_event, broadcast_to_room_participants
from app.schemas.common_structures import ExitDetail # For door lock skills

logger = logging.getLogger(__name__)

# --- Placeholder Loot Table Definitions ---
# This should ideally be moved to a dedicated JSON file and loaded.
# Format: loot_table_tag -> list of [item_name_or_tag, chance_percent, min_qty, max_qty]
# Assumes item_name_or_tag is the item's unique `name` for `crud.crud_item.get_item_by_name`.
PLACEHOLDER_LOOT_TABLES: Dict[str, List[Tuple[str, int, int, int]]] = {
    "vermin_common": [("Rat Tail", 50, 1, 1), ("Cracked Tooth", 25, 1, 1)],
    "small_beast_parts": [("Beast Pelt (Small)", 30, 1, 1), ("Animal Bone", 60, 1, 2)],
    "tier1_trash": [("Old Boot", 10, 1, 1), ("Rusty Tin Can", 15, 1, 1)],
    "goblin_common": [("Goblin Ear", 40, 1, 2), ("Crude Dagger Scrap", 20, 1, 1), ("Torn Pouch", 30, 1, 1)],
    "crude_gear": [("Rusty Sword", 5, 1, 1), ("Dagger", 8, 1, 1), ("Wooden Shield", 3, 1, 1)],
    "construct_parts_common": [("Bent Gear", 50, 1, 3), ("Frayed Wire", 40, 1, 2), ("Small Lens", 15, 1, 1)],
    "tech_scrap": [("Scrap Metal", 60, 1, 5)],
    "spider_parts": [("Spider Silk Gland", 35, 1, 1), ("Spider Fang", 25, 1, 2)],
    "tier1_beast_loot": [("Beast Meat", 40, 1, 1)],
    "ectoplasm": [("Ectoplasmic Residue", 70, 1, 3)],
    "spirit_essence": [("Faint Spirit Essence", 25, 1, 1)],
    "tier2_ethereal": [("Ghostly Shroud Scrap", 10, 1, 1)],
    "elemental_mote_air": [("Whirling Dust Mote", 60, 1, 2)],
    "tier1_elemental": [("Charged Sand", 20, 1, 1)],
    "bandit_gear": [("Tarnished Ring", 5, 1, 1), ("Patched Leather Jerkin", 10, 1, 1)], # Item names
    "stolen_goods_common": [("Cheap Locket", 15, 1, 1), ("Bent Silver Spoon", 20, 1, 1)],
    "tier2_humanoid": [("Sharpened Bone", 30, 1, 1)],
    "bat_parts": [("Bat Wing", 70, 1, 2)],
    "tier1_swarm_remains": [("Guano", 20, 1, 3)], # Charming
    "construct_parts_rare": [("Intact Servomotor", 10, 1, 1)],
    "enchanted_metal_shards": [("Faintly Glowing Shard", 20, 1, 2)],
    "tier2_construct": [("Polished Steel Plate", 5, 1, 1)],
    "dire_wolf_pelt": [("Dire Wolf Pelt", 60, 1, 1)],
    "large_beast_trophy": [("Large Wolf Fang", 30, 1, 1)],
    "tier3_beast_loot": [("Prime Beast Meat", 15, 1, 1)]
}


async def _handle_mob_death_loot_and_cleanup(
    db: Session,
    character: models.Character, 
    killed_mob_instance: models.RoomMobInstance,
    log_messages_list: List[str], 
    player_id: uuid.UUID, 
    current_room_id_for_broadcast: uuid.UUID
) -> models.Character:
    mob_template = killed_mob_instance.mob_template 
    character_after_loot = character # Start with the character passed in

    logger.debug(f"LOOT: Handling death of {mob_template.name if mob_template else 'Unknown Mob'} in room {current_room_id_for_broadcast}")

    if not mob_template:
        logger.warning(f"LOOT: No mob_template for killed_mob_instance {killed_mob_instance.id}")
        crud.crud_mob.despawn_mob_from_room(db, killed_mob_instance.id) # Despawn and commit handled by despawn_mob_from_room
        return character_after_loot

    # --- XP Award ---
    if mob_template.xp_value > 0:
        logger.debug(f"LOOT: Awarding {mob_template.xp_value} XP to {character.name}.")
        # add_experience commits internally
        updated_char_for_xp, xp_messages = crud.crud_character.add_experience(
            db, character_after_loot.id, mob_template.xp_value
        )
        if updated_char_for_xp:
            character_after_loot = updated_char_for_xp # Use the character returned by add_experience
        log_messages_list.extend(xp_messages)

    # --- Currency Drop ---
    platinum_dropped, gold_dropped, silver_dropped, copper_dropped = 0, 0, 0, 0
    if mob_template.currency_drop:
        cd = mob_template.currency_drop
        copper_dropped = random.randint(cd.get("c_min", 0), cd.get("c_max", 0))
        if random.randint(1, 100) <= cd.get("s_chance", 0):
            silver_dropped = random.randint(cd.get("s_min", 0), cd.get("s_max", 0))
        if random.randint(1, 100) <= cd.get("g_chance", 0):
            gold_dropped = random.randint(cd.get("g_min", 0), cd.get("g_max", 0))
        if random.randint(1, 100) <= cd.get("p_chance", 0):
            platinum_dropped = random.randint(cd.get("p_min", 0), cd.get("p_max", 0))
    
    if platinum_dropped > 0 or gold_dropped > 0 or silver_dropped > 0 or copper_dropped > 0:
        # update_character_currency commits internally
        updated_char_for_currency, currency_message = crud.crud_character.update_character_currency(
            db, character_after_loot.id, platinum_dropped, gold_dropped, silver_dropped, copper_dropped
        )
        if updated_char_for_currency:
             character_after_loot = updated_char_for_currency # Use the character returned by update_character_currency
        
        drop_messages_parts = []
        if platinum_dropped > 0: drop_messages_parts.append(f"{platinum_dropped}p")
        if gold_dropped > 0: drop_messages_parts.append(f"{gold_dropped}g")
        if silver_dropped > 0: drop_messages_parts.append(f"{silver_dropped}s")
        if copper_dropped > 0: drop_messages_parts.append(f"{copper_dropped}c")
        
        if drop_messages_parts:
             log_messages_list.append(f"The {mob_template.name} drops: {', '.join(drop_messages_parts)}.")
             log_messages_list.append(currency_message) 

    # --- Item Loot Drop ---
    items_dropped_this_kill_details: List[str] = [] # For logging
    if mob_template.loot_table_tags:
        logger.debug(f"LOOT: Processing loot_table_tags: {mob_template.loot_table_tags} for {mob_template.name}")
        for loot_tag in mob_template.loot_table_tags:
            if loot_tag in PLACEHOLDER_LOOT_TABLES:
                potential_drops = PLACEHOLDER_LOOT_TABLES[loot_tag]
                for item_name_or_tag_from_loot_def, chance, min_qty, max_qty in potential_drops:
                    if random.randint(1, 100) <= chance:
                        item_template_to_drop = crud.crud_item.get_item_by_name(db, name=item_name_or_tag_from_loot_def)
                        if not item_template_to_drop: # Fallback to item_tag if name lookup fails
                             item_template_to_drop = crud.crud_item.get_item_by_item_tag(db, item_tag=item_name_or_tag_from_loot_def)

                        if item_template_to_drop:
                            quantity_to_drop = random.randint(min_qty, max_qty)
                            logger.debug(f"LOOT: Attempting to drop {quantity_to_drop}x {item_template_to_drop.name} in room {current_room_id_for_broadcast}")
                            
                            # crud.crud_room_item.add_item_to_room commits internally.
                            # This is not ideal for batching operations within a single combat round.
                            # For now, we proceed, accepting multiple small commits if many items drop.
                            added_room_item, add_msg = crud.crud_room_item.add_item_to_room(
                                db=db, room_id=current_room_id_for_broadcast, 
                                item_id=item_template_to_drop.id, quantity=quantity_to_drop
                            )
                            if added_room_item:
                                items_dropped_this_kill_details.append(f"{quantity_to_drop}x {item_template_to_drop.name}")
                            else:
                                logger.error(f"LOOT: crud.crud_room_item.add_item_to_room failed for {item_template_to_drop.name}: {add_msg}")
                        else:
                            logger.warning(f"LOOT: Item template '{item_name_or_tag_from_loot_def}' (from loot_tag '{loot_tag}') not found in DB.")
            else:
                logger.warning(f"LOOT: Loot table tag '{loot_tag}' for mob '{mob_template.name}' not defined in PLACEHOLDER_LOOT_TABLES.")
        
        if items_dropped_this_kill_details:
            log_messages_list.append(f"The {mob_template.name} also drops: {', '.join(items_dropped_this_kill_details)} on the ground.")
            await broadcast_to_room_participants(
                db, current_room_id_for_broadcast,
                f"The {mob_template.name} drops {', '.join(items_dropped_this_kill_details)}!",
                exclude_player_id=player_id
            )

    # --- Despawn Mob ---
    logger.debug(f"LOOT: Despawning mob instance {killed_mob_instance.id} for {mob_template.name}.")
    # despawn_mob_from_room handles its own commit if it updates a spawn definition.
    crud.crud_mob.despawn_mob_from_room(db, killed_mob_instance.id) 
    
    # The overall commit for the combat round (including character mana/health changes from the skill itself)
    # will be handled by the calling function (process_combat_round).
    # We return character_after_loot which has been updated by XP and currency.
    return character_after_loot


async def resolve_skill_effect(
    db: Session,
    character: models.Character,
    skill_template: models.SkillTemplate,
    target_entity: Optional[Union[models.RoomMobInstance, models.Character, str]], 
    player_id: uuid.UUID, 
    current_room_id_for_broadcast: uuid.UUID
) -> Tuple[List[str], bool, Optional[models.Character]]:
    skill_log: List[str] = []
    action_taken = False 
    character_after_skill = character 
    char_combat_stats = character.calculate_combat_stats()

    mana_cost = skill_template.effects_data.get("mana_cost", 0)
    if character.current_mana < mana_cost and skill_template.skill_type != "PASSIVE":
        skill_log.append(f"You don't have enough mana to use {skill_template.name} (needs {mana_cost}, have {character.current_mana}).")
        return skill_log, False, character_after_skill # Return original character, no mana spent

    # --- Target and Mana Logic ---
    target_mob_instance: Optional[models.RoomMobInstance] = None # Initialize to None

    if skill_template.skill_type == "COMBAT_ACTIVE":
        # General validation for ENEMY_MOB target type if applicable
        if skill_template.target_type == "ENEMY_MOB":
            if isinstance(target_entity, models.RoomMobInstance) and target_entity.current_health > 0:
                target_mob_instance = target_entity
            else:
                skill_log.append(f"Your target for {skill_template.name} is invalid or already defeated.")
                return skill_log, False, character_after_skill # Return original character

        # Pay Mana Cost for COMBAT_ACTIVE (if target valid or skill is self-targeted/no specific mob target needed yet)
        if mana_cost > 0:
            character_after_skill.current_mana -= mana_cost 
            skill_log.append(f"You spend {mana_cost} mana.")
        action_taken = True

        # --- Specific COMBAT_ACTIVE Skill Logic ---
        if skill_template.skill_id_tag == "basic_punch":
            if skill_template.target_type != "ENEMY_MOB" or not target_mob_instance: # Explicit check for this skill
                skill_log.append(f"'Basic Punch' requires a valid enemy mob target.")
                return skill_log, True, character_after_skill # Mana spent, but action failed

            # Now target_mob_instance is guaranteed to be a valid RoomMobInstance
            mob_ac = target_mob_instance.mob_template.base_defense if target_mob_instance.mob_template.base_defense is not None else 10
            punch_char_ref = character_after_skill 
            punch_combat_stats = punch_char_ref.calculate_combat_stats()
            damage_dice = skill_template.effects_data.get("damage_dice_override", punch_combat_stats["damage_dice"])
            attack_bonus_add = skill_template.effects_data.get("attack_bonus_add", 0)
            damage_bonus_add = skill_template.effects_data.get("damage_bonus_add", 0)
            primary_attr_for_bonus = "strength" if skill_template.effects_data.get("uses_strength_for_bonus") else punch_combat_stats["primary_attribute_for_attack"]
            attr_mod = punch_char_ref.get_attribute_modifier(primary_attr_for_bonus)
            final_attack_bonus = attr_mod + attack_bonus_add + punch_char_ref.base_attack_bonus
            final_damage_bonus = attr_mod + damage_bonus_add
            to_hit_roll = roll_dice("1d20")

            if (to_hit_roll + final_attack_bonus) >= mob_ac:
                damage = max(1, roll_dice(damage_dice) + final_damage_bonus)
                skill_log.append(f"<span class='char-name'>{punch_char_ref.name}</span> <span class='combat-success'>PUNCHES</span> <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for <span class='combat-hit'>{damage}</span> damage.")
                await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='char-name'>{punch_char_ref.name}</span> PUNCHES <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for {damage} damage!")
                updated_mob = crud.crud_mob.update_mob_instance_health(db, target_mob_instance.id, -damage)
                if updated_mob and updated_mob.current_health <= 0:
                    skill_log.append(f"<span class='combat-death'>The {target_mob_instance.mob_template.name} DIES! Good punch, champ.</span>")
                    await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"The <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> DIES!")
                    character_after_skill = await _handle_mob_death_loot_and_cleanup(
                        db, character_after_skill, updated_mob, skill_log, player_id, current_room_id_for_broadcast
                    )
                elif updated_mob:
                     skill_log.append(f"  {target_mob_instance.mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{target_mob_instance.mob_template.base_health}</span>.")
            else: 
                skill_log.append(f"<span class='char-name'>{punch_char_ref.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> with a punch.")
                await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='char-name'>{punch_char_ref.name}</span> MISSES the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> with a punch.")

        elif skill_template.skill_id_tag == "power_attack_melee":
            if skill_template.target_type != "ENEMY_MOB" or not target_mob_instance: # Explicit check
                skill_log.append(f"'Power Attack' requires a valid enemy mob target.")
                return skill_log, True, character_after_skill # Mana spent, action failed

            pa_char_ref = character_after_skill
            pa_combat_stats = pa_char_ref.calculate_combat_stats()
            mob_ac = target_mob_instance.mob_template.base_defense if target_mob_instance.mob_template.base_defense is not None else 10
            skill_effects = skill_template.effects_data
            attack_roll_modifier = skill_effects.get("attack_roll_modifier", 0)
            damage_modifier_flat = skill_effects.get("damage_modifier_flat", 0)
            player_attack_bonus = pa_combat_stats["attack_bonus"]
            player_damage_dice = pa_combat_stats["damage_dice"]
            player_damage_bonus = pa_combat_stats["damage_bonus"]
            final_attack_bonus_for_skill = player_attack_bonus + attack_roll_modifier
            to_hit_roll = roll_dice("1d20")

            if (to_hit_roll + final_attack_bonus_for_skill) >= mob_ac:
                base_weapon_damage = roll_dice(player_damage_dice)
                total_damage = max(1, base_weapon_damage + player_damage_bonus + damage_modifier_flat)
                skill_log.append(f"<span class='char-name'>{pa_char_ref.name}</span> unleashes a <span class='combat-success'>POWER ATTACK</span> on <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>, hitting for <span class='combat-hit'>{total_damage}</span> damage!")
                await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='char-name'>{pa_char_ref.name}</span> POWER ATTACKS <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for {total_damage} damage!")
                updated_mob = crud.crud_mob.update_mob_instance_health(db, target_mob_instance.id, -total_damage)
                if updated_mob and updated_mob.current_health <= 0:
                    skill_log.append(f"<span class='combat-death'>The {target_mob_instance.mob_template.name} is OBLITERATED by the Power Attack!</span>")
                    await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"The <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> DIES from a mighty blow!")
                    character_after_skill = await _handle_mob_death_loot_and_cleanup(
                        db, character_after_skill, updated_mob, skill_log, player_id, current_room_id_for_broadcast
                    )
                elif updated_mob:
                     skill_log.append(f"  {target_mob_instance.mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{target_mob_instance.mob_template.base_health}</span>.")
            else: 
                skill_log.append(f"<span class='char-name'>{pa_char_ref.name}</span>'s <span class='combat-miss'>Power Attack</span> against <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> goes wide!")
                await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='char-name'>{pa_char_ref.name}</span> misses a Power Attack on <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>.")
        
        elif skill_template.skill_id_tag == "minor_heal_active":
            # This skill might target SELF or FRIENDLY_CHAR
            heal_char_ref = character_after_skill 
            actual_target_char = heal_char_ref # Default to self
            
            if skill_template.target_type == "FRIENDLY_CHAR_OR_SELF":
                if isinstance(target_entity, models.Character): # and target_entity.id != heal_char_ref.id: (allow self-target via entity)
                    # TODO: Add logic to check if target_entity is friendly / in same party / in range
                    actual_target_char = target_entity 
                elif target_entity is None or target_entity == "self": # Explicit self target or no target given
                     actual_target_char = heal_char_ref
                else:
                    skill_log.append(f"Invalid target for Minor Heal. Must be self or a friendly character.")
                    return skill_log, True, character_after_skill # Mana spent, action failed
            else: # Should not happen if skill definition is correct
                skill_log.append(f"Minor Heal has unexpected target_type: {skill_template.target_type}")
                return skill_log, True, character_after_skill

            heal_effects = skill_template.effects_data
            heal_dice = heal_effects.get("heal_dice", "1d4")
            heal_bonus_stat = heal_effects.get("heal_bonus_from_stat", "wisdom")
            attr_mod_for_heal = actual_target_char.get_attribute_modifier(heal_bonus_stat)
            heal_amount = max(0, roll_dice(heal_dice) + attr_mod_for_heal)
            old_hp = actual_target_char.current_health
            actual_target_char.current_health = min(actual_target_char.max_health, actual_target_char.current_health + heal_amount)
            healed_for = actual_target_char.current_health - old_hp
            
            target_name_log = "yourself" if actual_target_char.id == heal_char_ref.id else f"<span class='char-name'>{actual_target_char.name}</span>"
            skill_log.append(f"You channel divine energy, healing {target_name_log} for <span class='combat-heal'>{healed_for}</span> health.")
            if actual_target_char.id != heal_char_ref.id:
                 await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                             f"<span class='char-name'>{heal_char_ref.name}</span> heals <span class='char-name'>{actual_target_char.name}</span>.")
            # If actual_target_char was modified and it's not character_after_skill, it needs to be added to session too
            if actual_target_char.id != character_after_skill.id:
                db.add(actual_target_char)

        # ... (other COMBAT_ACTIVE skills, each ensuring its own target validity) ...
        else:
            skill_log.append(f"The combat skill '{skill_template.name}' is not fully implemented for the target type '{skill_template.target_type}'.")

    # ... (UTILITY_OOC and PASSIVE sections as before, they manage their own target_entity or lack thereof) ...
    elif skill_template.skill_type == "UTILITY_OOC":
        if mana_cost > 0:
            character_after_skill.current_mana -= mana_cost
            skill_log.append(f"You spend {mana_cost} mana.")
        action_taken = True

        if skill_template.target_type == "DOOR":
            # ... (pick_lock_basic logic as before, it validates target_entity is a string (direction)) ...
            if not isinstance(target_entity, str):
                skill_log.append("You must specify a direction for this skill (e.g., 'use pick_lock north').")
                return skill_log, True, character_after_skill # Mana spent, action failed
            
            target_direction = target_entity.lower() 
            current_room_orm = crud.crud_room.get_room_by_id(db, room_id=current_room_id_for_broadcast)
            if not current_room_orm:
                skill_log.append("Error: Cannot determine your current location to use this skill.")
                return skill_log, True, character_after_skill

            current_exits_dict = current_room_orm.exits or {}
            exit_data_dict = current_exits_dict.get(target_direction)

            if not exit_data_dict or not isinstance(exit_data_dict, dict):
                skill_log.append(f"There's no exit in that direction ({target_direction}) or it's malformed.")
                return skill_log, True, character_after_skill

            try:
                exit_detail = ExitDetail(**exit_data_dict)
            except Exception as e_parse:
                skill_log.append(f"The lock mechanism on the {target_direction} exit seems broken ({e_parse}).")
                logger.error(f"Pydantic parse error for ExitDetail in skill: {e_parse}, data: {exit_data_dict}")
                return skill_log, True, character_after_skill

            if not exit_detail.is_locked:
                skill_log.append(f"The way {target_direction} is already unlocked.")
                action_taken = False # No real action/failure if already unlocked
                # Don't refund mana if it was already spent, but it was a "no-op"
                return skill_log, action_taken, character_after_skill 
            
            skill_can_pick_this_lock = False
            if not exit_detail.skill_to_pick: # Check if skill_to_pick is defined at all
                skill_log.append(f"The lock on the {target_direction} exit doesn't seem to require a specific skill, or its lock data is malformed.")
                # Or, if no skill_to_pick means it *cannot* be picked by skill, this is a failure.
                # Depending on game logic:
                # skill_log.append(f"This lock cannot be picked with your current skills.")
                return skill_log, True, character_after_skill # Mana spent, action failed due to lock type
            
            # Now we know exit_detail.skill_to_pick is not None
            skill_can_pick_this_lock = False
            if exit_detail.skill_to_pick.skill_id_tag == skill_template.skill_id_tag:
                skill_can_pick_this_lock = True
            
            if not skill_can_pick_this_lock:
                skill_log.append(f"You can't use '{skill_template.name}' on the lock for the {target_direction} exit.")
                return skill_log, True, character_after_skill

            required_item_tag = skill_template.effects_data.get("requires_item_tag_equipped_or_inventory")
            if required_item_tag:
                # Ensure crud.crud_character_inventory.character_has_item_with_tag is implemented
                has_required_item = crud.crud_character_inventory.character_has_item_with_tag(db, character_id=character_after_skill.id, item_tag=required_item_tag)
                if not has_required_item:
                    item_name_for_msg = required_item_tag.replace("_", " ").title()
                    skill_log.append(f"You need {item_name_for_msg} to use {skill_template.name}.")
                    return skill_log, True, character_after_skill

            check_attribute = skill_template.effects_data.get("check_attribute", "dexterity")
            attribute_score = getattr(character_after_skill, check_attribute, 10) 
            modifier = (attribute_score - 10) // 2
            roll = random.randint(1, 20) + modifier 
            required_dc = exit_detail.skill_to_pick.dc

            if roll >= required_dc:
                exit_detail.is_locked = False
                updated_exits_for_orm = dict(current_room_orm.exits or {})
                updated_exits_for_orm[target_direction] = exit_detail.model_dump(mode='json')
                current_room_orm.exits = updated_exits_for_orm
                attributes.flag_modified(current_room_orm, "exits")
                db.add(current_room_orm) # Stage room change

                skill_log.append(f"<span class='success-message'>Success!</span> With a satisfying *click*, you pick the lock to the {target_direction} (Roll: {roll} vs DC: {required_dc}).")
                await broadcast_to_room_participants(
                    db, current_room_id_for_broadcast,
                    f"<span class='char-name'>{character_after_skill.name}</span> skillfully picks the lock to the {target_direction}ern passage.",
                    exclude_player_id=player_id
                )
            else:
                skill_log.append(f"<span class='failure-message'>Failure!</span> You failed to pick the lock to the {target_direction} (Roll: {roll} vs DC: {required_dc}). Your lockpicks make a frustrated scraping sound.")

        elif skill_template.target_type == "SELF":
            skill_log.append(f"You use {skill_template.name} on yourself. (Effect needs specific implementation for {skill_template.skill_id_tag})")
            # Example: crud.crud_status_effect.add_status_effect(db, character_after_skill, skill_template.effects_data.get("status_effect_apply"))

        else:
            skill_log.append(f"The OOC utility skill '{skill_template.name}' has an unhandled target type: {skill_template.target_type}.")
    
    elif skill_template.skill_type == "PASSIVE":
        skill_log.append(f"'{skill_template.name}' is a passive skill and does not need to be actively used.")
        action_taken = False

    else:
        skill_log.append(f"The skill '{skill_template.name}' (Type: {skill_template.skill_type}, Target: {skill_template.target_type}) is not fully implemented or used incorrectly. Typical.")
        action_taken = False

    # Stage the character if their mana (or other direct attributes like health from healing) changed.
    if character_after_skill.current_mana != character.current_mana or \
       character_after_skill.current_health != character.current_health:
        db.add(character_after_skill)

    return skill_log, action_taken, character_after_skill
--- END OF FILE backend/app/game_logic/combat/skill_resolver.py ---

--- START OF FILE backend/app/game_logic/combat/combat_state_manager.py ---
# backend/app/game_logic/combat/combat_state_manager.py
import uuid
from typing import Dict, Set, Optional, List # Added List
import logging

from sqlalchemy.orm import Session

from app import crud, models, schemas # For type hints and DB access
from app.game_state import is_character_resting, set_character_resting_status
from .combat_utils import send_combat_log, broadcast_combat_event # Use from local package

logger = logging.getLogger(__name__)

# Global combat state dictionaries (consider if these should be encapsulated in a class later)
active_combats: Dict[uuid.UUID, Set[uuid.UUID]] = {}  # character_id -> set of mob_instance_ids
mob_targets: Dict[uuid.UUID, uuid.UUID] = {}  # mob_instance_id -> character_id
character_queued_actions: Dict[uuid.UUID, Optional[str]] = {} # character_id -> "action_verb target_id"

def is_mob_in_any_player_combat(mob_id: uuid.UUID) -> bool:
    """Checks if a mob is currently being targeted by any character in active_combats."""
    for _character_id, targeted_mob_ids in active_combats.items():
        if mob_id in targeted_mob_ids:
            return True
    # Also check if mob_targets has this mob_id (mob is targeting a player)
    if mob_id in mob_targets:
        return True
    return False

async def initiate_combat_session(
    db: Session, player_id: uuid.UUID, character_id: uuid.UUID, character_name: str, target_mob_instance_id: uuid.UUID
) -> bool: # Return bool for success/failure
    mob_instance_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_instance_id)
    if not mob_instance_check or mob_instance_check.current_health <= 0:
        await send_combat_log(player_id, ["Target is invalid or already dead."])
        return False
        
    character_check = crud.crud_character.get_character(db, character_id=character_id)
    if not character_check or character_check.current_health <= 0:
        # This check might be redundant if called from process_combat_round where char health is already checked
        await send_combat_log(player_id, ["You are too dead or incapacitated to start combat."])
        return False

    personal_log_messages = []
    if is_character_resting(character_check.id): 
        set_character_resting_status(character_check.id, False)
        personal_log_messages.append("You leap into action, abandoning your rest!")
    
    active_combats.setdefault(character_id, set()).add(target_mob_instance_id)
    mob_targets[target_mob_instance_id] = character_id 
    character_queued_actions[character_id] = f"attack {target_mob_instance_id}" # Default to attack
    
    engagement_message = f"<span class='char-name'>{character_name}</span> engages the <span class='inv-item-name'>{mob_instance_check.mob_template.name}</span>!"
    personal_log_messages.append(engagement_message)
    
    current_room_orm = crud.crud_room.get_room_by_id(db, character_check.current_room_id)
    current_room_schema = schemas.RoomInDB.from_orm(current_room_orm) if current_room_orm else None
    await send_combat_log(player_id, personal_log_messages, room_data=current_room_schema)
    # Broadcast engagement to room handled by caller or process_combat_round's hit messages
    return True


def end_combat_for_character(character_id: uuid.UUID, reason: str = "unknown"):
    """Clears a character from active_combats and mob_targets (if they were targeted)."""
    logger.debug(f"Ending combat for character {character_id}. Reason: {reason}.")
    if character_id in active_combats:
        mobs_character_was_fighting = list(active_combats.pop(character_id, set()))
        logger.debug(f"Character {character_id} was fighting mobs: {mobs_character_was_fighting}")
        for mob_id in mobs_character_was_fighting:
            if mob_id in mob_targets and mob_targets[mob_id] == character_id:
                logger.debug(f"Mob {mob_id} was targeting character {character_id}. Clearing target.")
                mob_targets.pop(mob_id, None)
    else: # Ensure mobs aren't stuck targeting a player who isn't in active_combats anymore
        mobs_to_clear_target_for = [mid for mid, cid_target in mob_targets.items() if cid_target == character_id]
        if mobs_to_clear_target_for:
            logger.debug(f"Character {character_id} not in active_combats, but mobs {mobs_to_clear_target_for} were targeting them. Clearing.")
            for mid_clear in mobs_to_clear_target_for:
                mob_targets.pop(mid_clear, None)
                
    character_queued_actions.pop(character_id, None)
    logger.debug(f"Combat states for character {character_id} cleared.")


async def mob_initiates_combat(db: Session, mob_instance: models.RoomMobInstance, target_character: models.Character):
    """Handles a mob initiating combat with a character."""
    if not mob_instance or mob_instance.current_health <= 0: return
    if not target_character or target_character.current_health <= 0: return
    
    # Check if this specific engagement already exists
    if target_character.id in active_combats and mob_instance.id in active_combats[target_character.id]:
        # logger.debug(f"Mob {mob_instance.mob_template.name} already fighting {target_character.name}.")
        return 

    logger.info(f"COMBAT: {mob_instance.mob_template.name} ({mob_instance.id}) initiates combat with {target_character.name} ({target_character.id})!")
    
    active_combats.setdefault(target_character.id, set()).add(mob_instance.id)
    mob_targets[mob_instance.id] = target_character.id  
    # Mobs don't queue actions in character_queued_actions; their actions are determined in process_combat_round.

    mob_name_html = f"<span class='inv-item-name'>{mob_instance.mob_template.name}</span>"
    char_name_html = f"<span class='char-name'>{target_character.name}</span>"
    
    initiation_message_to_player_parts: List[str] = []
    if is_character_resting(target_character.id): 
        set_character_resting_status(target_character.id, False)
        initiation_message_to_player_parts.append("<span class='combat-warning'>You are startled from your rest!</span>")
    
    initiation_message_to_player_parts.append(f"{mob_name_html} turns its baleful gaze upon you and <span class='combat-hit-player'>attacks!</span>")
    
    player_room_orm = crud.crud_room.get_room_by_id(db, room_id=target_character.current_room_id)
    player_room_schema = schemas.RoomInDB.from_orm(player_room_orm) if player_room_orm else None
    await send_combat_log(player_id=target_character.player_id, messages=initiation_message_to_player_parts, room_data=player_room_schema)
    
    broadcast_message = f"{mob_name_html} shrieks and <span class='combat-hit-player'>attacks</span> {char_name_html}!"
    if "<span class='combat-warning'>You are startled from your rest!</span>" in " ".join(initiation_message_to_player_parts): # Check if rest was broken
         broadcast_message = f"{char_name_html} is startled from their rest as {mob_name_html} <span class='combat-hit-player'>attacks</span>!"
    
    await broadcast_combat_event(db, mob_instance.room_id, target_character.player_id, broadcast_message)
--- END OF FILE backend/app/game_logic/combat/combat_state_manager.py ---

--- START OF FILE backend/app/crud/crud_mob.py ---
# backend/app/crud/crud_mob.py
import json # For loading JSON
import os   # For path joining
import logging # For logging (finally!)
from datetime import datetime, timezone
from sqlalchemy.orm import Session, joinedload, attributes
import uuid
from typing import Dict, List, Optional, Tuple, Any # Added Any for seed data

from .. import models, schemas, crud

logger = logging.getLogger(__name__)

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_generic(filename: str, data_type_name: str) -> List[Dict[str, Any]]: # Made generic
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"{data_type_name} seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {data_type_name} seed file {filepath}: {e}")
        return []

# --- MobTemplate CRUD ---
def get_mob_template(db: Session, mob_template_id: uuid.UUID) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.id == mob_template_id).first()

def get_mob_template_by_name(db: Session, name: str) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.name == name).first()

def get_mob_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.MobTemplate]:
    return db.query(models.MobTemplate).offset(skip).limit(limit).all()

def create_mob_template(db: Session, *, template_in: schemas.MobTemplateCreate) -> models.MobTemplate:
    db_template = models.MobTemplate(**template_in.model_dump())
    db.add(db_template)
    return db_template

def update_mob_template(db: Session, *, db_template: models.MobTemplate, template_in: schemas.MobTemplateUpdate) -> models.MobTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    changed = False
    for field, value in update_data.items():
        if getattr(db_template, field) != value:
            setattr(db_template, field, value)
            # For JSONB fields, ensure they are flagged if necessary
            if field in ['currency_drop', 'special_abilities', 'loot_table_tags', 'dialogue_lines', 'faction_tags', 'properties']:
                attributes.flag_modified(db_template, field)
            changed = True
    if changed:
        db.add(db_template)
    return db_template # Return template whether changed or not, caller might need it


# --- RoomMobInstance CRUD ---
def get_room_mob_instance(db: Session, room_mob_instance_id: uuid.UUID) -> Optional[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template) 
    ).filter(models.RoomMobInstance.id == room_mob_instance_id).first()

def get_mobs_in_room(db: Session, room_id: uuid.UUID) -> List[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template)
    ).filter(models.RoomMobInstance.room_id == room_id).all()

def spawn_mob_in_room(
    db: Session, *, 
    room_id: uuid.UUID, 
    mob_template_id: uuid.UUID,
    instance_properties_override: Optional[Dict] = None,
    originating_spawn_definition_id: Optional[uuid.UUID] = None 
) -> Optional[models.RoomMobInstance]:
    template = get_mob_template(db, mob_template_id)
    if not template: 
        logger.error(f"spawn_mob_in_room: Mob template ID {mob_template_id} not found.")
        return None
    room = db.query(models.Room).filter(models.Room.id == room_id).first() # Consider using crud.crud_room.get_room_by_id
    if not room: 
        logger.error(f"spawn_mob_in_room: Room ID {room_id} not found.")
        return None

    mob_instance = models.RoomMobInstance(
        room_id=room_id,
        mob_template_id=mob_template_id,
        current_health=template.base_health,
        instance_properties_override=instance_properties_override,
        spawn_definition_id=originating_spawn_definition_id 
    )
    db.add(mob_instance)
    # db.commit() # Caller of spawn_mob_in_room should commit, esp. if part of larger transaction (e.g. mob_respawner)
    # db.refresh(mob_instance) # Also by caller if needed immediately after commit
    logger.info(f"Staged spawn of mob '{template.name}' (Template ID: {template.id}) in room '{room.name}' (Room ID: {room_id}). Instance ID will be assigned on commit.")
    return mob_instance # Return uncommitted instance

def despawn_mob_from_room(db: Session, room_mob_instance_id: uuid.UUID) -> bool:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance:
        spawn_def_id_to_update = instance.spawn_definition_id 
        mob_name_for_log = instance.mob_template.name if instance.mob_template else "Unknown Mob"
        logger.info(f"Despawning mob '{mob_name_for_log}' (Instance ID: {room_mob_instance_id}).")

        db.delete(instance)
        
        if spawn_def_id_to_update:
            crud.crud_mob_spawn_definition.update_mob_spawn_definition_next_check_time(
                db, 
                definition_id=spawn_def_id_to_update, 
                next_check_time=datetime.now(timezone.utc) # Trigger immediate re-check
            )
            logger.debug(f"Flagged immediate re-check for spawn definition {spawn_def_id_to_update} due to mob despawn.")
        
        # db.commit() # Caller of despawn (e.g. combat processor) should handle commit
        return True
    logger.warning(f"despawn_mob_from_room: Mob instance ID {room_mob_instance_id} not found.")
    return False

def update_mob_instance_health(
    db: Session, room_mob_instance_id: uuid.UUID, change_in_health: int
) -> Optional[models.RoomMobInstance]:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance and instance.mob_template:
        instance.current_health += change_in_health
        instance.current_health = max(0, min(instance.current_health, instance.mob_template.base_health))
            
        db.add(instance)
        # db.commit() # Caller (combat processor) handles commit
        # db.refresh(instance) # Caller handles refresh
        return instance
    elif instance: # Mob instance exists, but template somehow missing (should not happen with joinedload)
        logger.warning(f"update_mob_instance_health: Mob instance {room_mob_instance_id} missing mob_template. Health update might be unreliable.")
        instance.current_health += change_in_health # Apply change without cap
        instance.current_health = max(0, instance.current_health)
        db.add(instance)
        return instance
    else: # Instance not found
        logger.warning(f"update_mob_instance_health: Mob instance ID {room_mob_instance_id} not found.")
    return None

# --- Seeding Initial Mob Templates ---
def seed_initial_mob_templates(db: Session):
    logger.info("Attempting to seed initial mob templates from mob_templates.json...")
    mob_template_definitions = _load_seed_data_generic("mob_templates.json", "Mob template")

    if not mob_template_definitions:
        logger.warning("No mob template definitions found or error loading mob_templates.json. Aborting mob template seeding.")
        return

    seeded_count = 0
    updated_count = 0
    skipped_count = 0 # For items that exist and have no changes

    for template_data in mob_template_definitions:
        template_name = template_data.get("name")
        if not template_name:
            logger.warning(f"Skipping mob template entry due to missing name: {template_data}")
            skipped_count += 1
            continue
        
        existing_template = get_mob_template_by_name(db, name=template_name)
        
        try:
            if existing_template:
                template_update_schema = schemas.MobTemplateUpdate(**template_data)
                # Pass the ORM object and the Pydantic update schema to the update function
                updated_template = update_mob_template(db, db_template=existing_template, template_in=template_update_schema)
                # Check if update_mob_template actually staged a change by checking session dirty status or a flag.
                # For now, we'll assume if no exception, it's either updated or was identical.
                # To be more precise, compare dicts or check db.is_modified(existing_template) before commit
                
                # A simple way to check if changes were made for logging purposes:
                original_dump = schemas.MobTemplate.from_orm(existing_template).model_dump(exclude={'id'}) # Exclude id for comparison
                updated_dump_from_data = schemas.MobTemplateCreate(**template_data).model_dump() # Create a full model from data

                # Compare relevant fields. This is a bit verbose.
                # A better way might be for update_mob_template to return a boolean indicating change.
                is_actually_changed = False
                for key, value_from_json in updated_dump_from_data.items():
                    if original_dump.get(key) != value_from_json:
                        is_actually_changed = True
                        break
                
                if is_actually_changed: # If update_mob_template would have made changes
                    logger.info(f"Updating mob template: {template_name}")
                    updated_count += 1
                else:
                    # logger.debug(f"Mob template '{template_name}' exists and no changes detected.")
                    skipped_count +=1
            else: # Template does not exist, create it
                template_create_schema = schemas.MobTemplateCreate(**template_data)
                logger.info(f"Creating mob template: {template_create_schema.name}")
                create_mob_template(db, template_in=template_create_schema)
                seeded_count += 1
        except Exception as e_pydantic_or_db: # Catch broader exceptions
            logger.error(f"Validation or DB operation failed for mob template '{template_name}': {e_pydantic_or_db}. Data: {template_data}", exc_info=True)
            skipped_count += 1
            db.rollback() # Rollback this specific item's attempt
            continue # Continue to next item

    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new and {updated_count} updated mob templates.")
            db.commit()
            logger.info("Mob template seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing mob template seeds: {e_commit}. Rolling back.", exc_info=True)
            db.rollback()
    else:
        logger.info("No new mob templates to seed or templates to update. No commit needed for mob templates.")

    logger.info(f"Mob template seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")
--- END OF FILE backend/app/crud/crud_mob.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    owner: Mapped["Player"] = relationship(back_populates="characters")

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)

    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py

import uuid
from typing import Optional, Dict, List, TYPE_CHECKING, Any 
from enum import Enum as PyEnum # To avoid conflict with potential future 'Enum' table

from sqlalchemy import Column, Integer, String, Text, Enum as SQLEnum # Enum for DB
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance 
    from .room_mob_instance import RoomMobInstance

# NEW RoomType Enum
class RoomTypeEnum(PyEnum):
    STANDARD = "standard"
    SANCTUARY = "sanctuary" # No combat, perhaps faster regen
    SHOP = "shop"
    TRAINER = "trainer"
    DUNGEON_ENTRANCE = "dungeon_entrance"
    PUZZLE = "puzzle"
    # Add more as needed

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    
    room_type: Mapped[RoomTypeEnum] = mapped_column( # <<< NEW FIELD
        SQLEnum(RoomTypeEnum, name="roomtypeenum", create_type=True), # create_type=True for SQLAlchemy to manage Enum in DB
        default=RoomTypeEnum.STANDARD, 
        nullable=False,
        index=True
    )

    exits: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB, 
        nullable=True, 
        default=lambda: {}
    )
    interactables: Mapped[Optional[List[Dict[str, Any]]]] = mapped_column(
        JSONB, 
        nullable=True, 
        default=lambda: []
    )
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin"
    )
    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin" 
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', type='{self.room_type.value}', x={self.x}, y={self.y}, z={self.z})>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/models/mob_template.py ---
# backend/app/models/mob_template.py
import uuid
from typing import Optional, Dict, Any, List # Added List

from sqlalchemy import String, Text, Integer, Float # Keep Column, Add Float
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class MobTemplate(Base):
    __tablename__ = "mob_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # mob_type: Mapped[Optional[str]] = mapped_column(String(50), index=True, nullable=True, comment="e.g., beast, humanoid, undead") # Replaced by faction_tags

    level: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1)
    base_health: Mapped[int] = mapped_column(Integer, nullable=False, default=10)
    base_mana: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) # <<< MODIFIED
    base_attack: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., 1d6") 
    base_defense: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=10, comment="e.g., Armor Class")
    
    attack_speed_secs: Mapped[Optional[float]] = mapped_column(Float, nullable=True, default=3.0) # <<< MODIFIED
    aggro_radius: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=5) # <<< MODIFIED
    roam_radius: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) # <<< MODIFIED
    
    xp_value: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    
    # loot_table_ref: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, comment="Placeholder for loot table reference") # Replaced by loot_table_tags
    loot_table_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED (JSONB for list of strings)
    
    currency_drop: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB, 
        nullable=True,
        comment="Defines currency drop. E.g., {'c_min':0, ...}"
    ) # Default can be set by Pydantic model if not provided in JSON
    
    dialogue_lines: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    faction_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    special_abilities: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, default=lambda: {})
    
    # aggression_type: Mapped[Optional[str]] = mapped_column(String(50), default="NEUTRAL", nullable=True, index=True, comment="e.g., NEUTRAL, AGGRESSIVE_ON_SIGHT, AGGRESSIVE_IF_APPROACHED") 
    # Decided to remove this, as aggro_radius and faction logic should cover it.
    # If you reinstate it in schemas/JSON, add it back here too.

    def __repr__(self) -> str:
        return f"<MobTemplate(id={self.id}, name='{self.name}', level='{self.level}')>"
--- END OF FILE backend/app/models/mob_template.py ---

--- START OF FILE backend/app/models/room_mob_instance.py ---
# backend/app/models/room_mob_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func, String, Boolean 
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base
# from .. import models # Let's remove this direct import from here

if TYPE_CHECKING:
    from .room import Room # Import specific model for type hinting
    from .mob_template import MobTemplate
    from .mob_spawn_definition import MobSpawnDefinition

class RoomMobInstance(Base):
    __tablename__ = "room_mob_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    mob_template_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_templates.id"), index=True, nullable=False)
    
    spawn_definition_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True), 
        ForeignKey("mob_spawn_definitions.id"),
        nullable=True, 
        index=True,
        name="spawn_point_id" 
    ) 

    current_health: Mapped[int] = mapped_column(Integer, nullable=False)
    instance_properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    spawned_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_action_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    is_static_placement: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False,
                                                      comment="True if this mob was placed specifically and should not be respawned by general systems.")

    # Relationships
    # For the Mapped type hint, use the specific import from TYPE_CHECKING
    # For the relationship string, use the class name directly if it's defined in another module
    # or the fully qualified string if needed.
    room: Mapped["Room"] = relationship(back_populates="mobs_in_room")
    mob_template: Mapped["MobTemplate"] = relationship(lazy="joined") 
    
    originating_spawn_definition: Mapped[Optional["MobSpawnDefinition"]] = relationship(
        foreign_keys=[spawn_definition_id], 
        back_populates="spawned_mob_instances"
    )

    def __repr__(self) -> str:
        return f"<RoomMobInstance(id={self.id}, room_id='{self.room_id}', template_id='{self.mob_template_id}', spawn_def_id='{self.spawn_definition_id}', hp={self.current_health})>"
--- END OF FILE backend/app/models/room_mob_instance.py ---

--- START OF FILE backend/app/models/character_inventory_item.py ---
# backend/app/models/character_inventory_item.py
import uuid
from typing import TYPE_CHECKING, Optional

from sqlalchemy import ForeignKey, Integer, Boolean, String
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .character import Character  # noqa: F401
    from .item import Item  # noqa: F401


class CharacterInventoryItem(Base):
    __tablename__ = "character_inventory_items"

    # Composite Primary Key: (character_id, item_id)
    # However, SQLAlchemy prefers a single surrogate primary key for association objects
    # if they have additional attributes beyond just the foreign keys.
    # Let's add an explicit id for this table for easier reference, though character_id + item_id could form a unique constraint.
    # Or, if an item can appear multiple times (e.g. two identical non-stackable swords),
    # then an auto-incrementing ID for this table row is essential.
    # Let's assume for now a character can only have ONE "entry" for a given item_id, and quantity handles multiples if stackable.
    # If not stackable, and they have two of the same sword, they'd be two separate Item instances in the Item table (e.g. with serial numbers or unique IDs anyway).
    # For our MUD, usually an Item is a "template". If a player has two "Long Sword" (same item_id), this table handles it.
    # Okay, if Item.stackable is false, each instance is a separate row here with quantity 1.
    # If Item.stackable is true, one row with quantity > 1.
    # Let's give this table its own UUID PK for simplicity in referencing a specific *instance* in inventory.

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, comment="Unique ID for this specific instance of an item in a character's inventory")
    
    character_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Indicates if this specific inventory item instance is currently equipped
    equipped: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False, index=True)
    
    # If equipped, this specifies which of the character's equipment slots it occupies.
    # This must be one of the keys from models.item.EQUIPMENT_SLOTS.
    # Necessary for items that can fit into more than one type of slot (e.g. generic 'ring' item into 'finger_1' or 'finger_2')
    # or to distinguish main_hand vs off_hand for identical weapons.
    equipped_slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="Actual character slot occupied if equipped, e.g. 'finger_1'")

    # Relationships
    character: Mapped["Character"] = relationship(back_populates="inventory_items")
    item: Mapped["Item"] = relationship() # No back_populates needed if Item doesn't need to know all its inventory entries directly

    def __repr__(self) -> str:
        return f"<CharInvItem(id={self.id}, char_id='{self.character_id}', item_id='{self.item_id}', qty={self.quantity}, equipped={self.equipped}, slot='{self.equipped_slot}')>"
--- END OF FILE backend/app/models/character_inventory_item.py ---

--- START OF FILE backend/app/models/character_class_template.py ---
# backend/app/models/character_class_template.py
import uuid
from typing import Optional, Dict, Any, List, Union # <<< Added Union

from sqlalchemy import String, Text, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class CharacterClassTemplate(Base):
    __tablename__ = "character_class_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    base_stat_modifiers: Mapped[Optional[Dict[str, int]]] = mapped_column(JSONB, nullable=True)
    starting_health_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    starting_mana_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    skill_tree_definition: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    starting_equipment_refs: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    playstyle_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    
    # <<< NEW FIELD >>>
    stat_gains_per_level: Mapped[Optional[Dict[str, Union[int, float]]]] = mapped_column(
        JSONB, 
        nullable=True, 
        comment="Defines HP, MP, BAB, etc. gains per level. E.g. {'hp': 5, 'mp': 1, 'base_attack_bonus': 0.5}"
    )

    def __repr__(self) -> str:
        return f"<CharacterClassTemplate(id={self.id}, name='{self.name}')>"
--- END OF FILE backend/app/models/character_class_template.py ---

--- START OF FILE backend/app/models/skill_template.py ---
# backend/app/models/skill_template.py
import uuid
from typing import Optional, Dict, Any, List

from sqlalchemy import String, Text, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column

from ..db.base_class import Base

class SkillTemplate(Base):
    __tablename__ = "skill_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # Unique internal identifier/tag, e.g., "power_attack", "pick_lock_basic", "fireball_rank1"
    # This is what will be stored in Character.learned_skills and referenced in skill_tree_definition
    skill_id_tag: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    
    name: Mapped[str] = mapped_column(String(100), nullable=False, comment="Player-facing name, e.g., 'Power Attack'")
    description: Mapped[Text] = mapped_column(Text, nullable=True, comment="Player-facing description of what the skill does.")
    
    skill_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, 
                                            comment="e.g., 'COMBAT_ACTIVE', 'COMBAT_PASSIVE', 'UTILITY_OOC', 'SOCIAL'")
    
    target_type: Mapped[str] = mapped_column(String(50), default="NONE", nullable=False,
                                             comment="e.g., 'SELF', 'ENEMY_MOB', 'FRIENDLY_CHAR', 'DOOR', 'ITEM_IN_ROOM', 'NONE'")
    
    # How the skill's effects are defined. Structure depends heavily on skill_type.
    # Examples:
    # COMBAT_ACTIVE: {"mana_cost": 5, "damage": {"dice": "1d6", "bonus_stat": "strength", "type": "physical"}, "status_effect_chance": {"effect_id": "stunned", "duration_rounds": 1, "chance_percent": 25}}
    # UTILITY_OOC (Pick Lock): {"target_subtype": "lock", "difficulty_check_attr": "dexterity", "base_dc": 15, "consumes_item_tag": "lockpick_set", "success_message": "The lock clicks open!", "failure_message": "You fumble with the lock."}
    # COMBAT_PASSIVE: {"stat_bonuses": {"attack_bonus": 1}, "conditional_trigger": "on_crit_hit"}
    effects_data: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False, default=lambda: {})

    # Requirements to learn/use the skill. Can be checked during level up or skill use.
    # Example: {"min_level": 3, "required_stats": {"intelligence": 12}, "requires_learned_skill": "basic_spellcasting_id", "requires_class_tag": "Mage"}
    requirements_data: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)

    # For skills that might have ranks or tiers (future use)
    rank: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1)
    # Cooldown in combat rounds, or seconds for OOC skills
    cooldown: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) 

    def __repr__(self) -> str:
        return f"<SkillTemplate(id={self.id}, skill_id_tag='{self.skill_id_tag}', name='{self.name}')>"
--- END OF FILE backend/app/models/skill_template.py ---

--- START OF FILE backend/app/models/trait_template.py ---
# backend/app/models/trait_template.py
import uuid
from typing import Optional, Dict, Any, List # <<< MAKE SURE List IS IMPORTED FROM typing

from sqlalchemy import String, Text
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column

from ..db.base_class import Base

class TraitTemplate(Base):
    __tablename__ = "trait_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    trait_id_tag: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    
    name: Mapped[str] = mapped_column(String(100), nullable=False, comment="Player-facing name, e.g., 'Nimble Fingers'")
    description: Mapped[Text] = mapped_column(Text, nullable=True, comment="Player-facing description.")
    
    trait_type: Mapped[str] = mapped_column(String(50), default="PASSIVE", nullable=False, 
                                            comment="Usually 'PASSIVE', but could be 'SOCIAL', 'BACKGROUND', etc.")
    
    effects_data: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False, default=lambda: {})

    # If this trait is mutually exclusive with others
    mutually_exclusive_with: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # type: ignore # Added default

    def __repr__(self) -> str:
        return f"<TraitTemplate(id={self.id}, trait_id_tag='{self.trait_id_tag}', name='{self.name}')>"
--- END OF FILE backend/app/models/trait_template.py ---

--- START OF FILE backend/app/crud/crud_item.py ---
# backend/app/crud/crud_item.py
import json
import os
import uuid
import logging # Import logging
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session

from .. import models, schemas

logger = logging.getLogger(__name__) # Get a logger for this module

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_for_items(filename: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"Seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {filepath}: {e}")
        return []

def get_item_by_id(db: Session, item_id: uuid.UUID) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.id == item_id).first()

def get_item_by_name(db: Session, name: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.name == name).first()

def get_item_by_item_tag(db: Session, item_tag: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.properties["item_tag"].astext == item_tag).first()

def get_all_items(db: Session, skip: int = 0, limit: int = 100) -> List[models.Item]:
    return db.query(models.Item).offset(skip).limit(limit).all()

def create_item(db: Session, *, item_in: schemas.ItemCreate) -> models.Item:
    db_item = models.Item(**item_in.model_dump())
    db.add(db_item)
    # Caller should handle commit/flush
    return db_item

def seed_initial_items(db: Session):
    logger.info("Attempting to seed initial items from JSON...")
    item_definitions = _load_seed_data_for_items("items.json")

    if not item_definitions:
        logger.warning("No item definitions found or error loading items.json. Aborting item seeding.")
        return

    seeded_count = 0
    skipped_count = 0
    updated_count = 0 # For clarity

    for item_data in item_definitions:
        item_name = item_data.get("name")
        if not item_name:
            logger.warning(f"Skipping item entry due to missing name: {item_data}")
            skipped_count += 1
            continue

        existing_item = get_item_by_name(db, name=item_name)
        
        try:
            if existing_item:
                logger.debug(f"Item '{item_name}' already exists. Attempting update...")
                item_update_schema = schemas.ItemUpdate(**item_data) 
                changed = False
                for field, value in item_update_schema.model_dump(exclude_unset=True).items():
                    if getattr(existing_item, field) != value:
                        setattr(existing_item, field, value)
                        changed = True
                if changed:
                    db.add(existing_item)
                    logger.info(f"Updated item: {item_name}")
                    updated_count += 1
                else:
                    # logger.debug(f"Item '{item_name}' exists and no changes detected. Skipping update.")
                    skipped_count +=1 # Not really skipped, but not "newly seeded" or "updated"
            else:
                item_create_schema = schemas.ItemCreate(**item_data)
                logger.info(f"Creating item: {item_create_schema.name}")
                create_item(db, item_in=item_create_schema)
                seeded_count += 1
        except Exception as e_pydantic:
            logger.error(f"Pydantic validation or DB operation failed for item '{item_name}': {e_pydantic}. Data: {item_data}")
            skipped_count += 1
            continue
    
    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new items and {updated_count} updated items.")
            db.commit() 
            logger.info("Item seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing item seeds: {e_commit}. Rolling back.")
            db.rollback()
    else:
        logger.info("No new items to seed or items to update. No commit needed for items.")

    logger.info(f"Item seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")


def update_item(db: Session, *, db_item: models.Item, item_in: schemas.ItemUpdate) -> models.Item:
    update_data = item_in.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_item, key, value)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def delete_item(db: Session, *, item_id: uuid.UUID) -> Optional[models.Item]:
    db_item = db.query(models.Item).filter(models.Item.id == item_id).first()
    if db_item:
        db.delete(db_item)
        db.commit()
    return db_item
--- END OF FILE backend/app/crud/crud_item.py ---

--- START OF FILE backend/app/crud/crud_room.py ---
# backend/app/crud/crud_room.py
import json
import os 
import uuid
import logging 
from typing import Optional, Dict, List, Any, Tuple 
from sqlalchemy.orm import Session, attributes 

from .. import models, schemas, crud 
from ..schemas.common_structures import ExitDetail, ExitSkillToPickDetail # Ensure these are imported

logger = logging.getLogger(__name__) 

SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")
_SEED_ROOM_UUIDS_CACHE: Dict[str, uuid.UUID] = {}

def _load_seed_data(filename: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"Seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {filepath}: {e}")
        return []

def get_room_by_id(db: Session, room_id: uuid.UUID) -> Optional[models.Room]:
    return db.query(models.Room).filter(models.Room.id == room_id).first()

def get_rooms_by_z_level(db: Session, *, z_level: int) -> List[models.Room]:
    return db.query(models.Room).filter(models.Room.z == z_level).all()

def get_room_by_coords(db: Session, *, x: int, y: int, z: int) -> Optional[models.Room]:
    return db.query(models.Room).filter(
        models.Room.x == x,
        models.Room.y == y,
        models.Room.z == z
    ).first()

def create_room(db: Session, *, room_in: schemas.RoomCreate) -> models.Room:
    db_room_data = room_in.model_dump(exclude_unset=True)
    # Ensure defaults for JSONB fields if not provided
    if 'exits' not in db_room_data: 
        db_room_data['exits'] = {}
    if 'interactables' not in db_room_data: 
        db_room_data['interactables'] = []
    
    # Handle RoomTypeEnum conversion
    if 'room_type' in db_room_data and isinstance(db_room_data['room_type'], str):
        try:
            db_room_data['room_type'] = models.RoomTypeEnum(db_room_data['room_type'])
        except ValueError:
            logger.warning(f"Invalid room_type '{db_room_data['room_type']}' in create_room. Defaulting to STANDARD.")
            db_room_data['room_type'] = models.RoomTypeEnum.STANDARD
    elif 'room_type' not in db_room_data: # Ensure default if not provided at all
         db_room_data['room_type'] = models.RoomTypeEnum.STANDARD


    db_room = models.Room(**db_room_data)
    db.add(db_room) 
    # No commit here, handled by caller (e.g., seeder)
    return db_room

def update_room(db: Session, *, db_room: models.Room, room_in: schemas.RoomUpdate) -> models.Room:
    update_data = room_in.model_dump(exclude_unset=True) # Get only fields that were set in the update
    changed = False
    for field, value in update_data.items():
        if field == 'room_type' and isinstance(value, str): # Handle enum conversion for updates too
            try:
                value = models.RoomTypeEnum(value)
            except ValueError:
                logger.warning(f"Invalid room_type '{value}' in update_room for room '{db_room.name}'. Skipping update of this field.")
                continue # Skip this field if invalid
        
        current_value = getattr(db_room, field)
        if current_value != value:
            setattr(db_room, field, value)
            # For JSONB fields, ensure SQLAlchemy detects changes
            if field in ["exits", "interactables"]: 
                attributes.flag_modified(db_room, field)
            changed = True
            
    if changed:
        db.add(db_room) 
    # No commit here, handled by caller
    return db_room

def seed_initial_world(db: Session):
    logger.info("Attempting to seed initial world (rooms and exits) from JSON files...")
    _SEED_ROOM_UUIDS_CACHE.clear()

    room_definitions_from_file = _load_seed_data("rooms_z0.json")
    if not room_definitions_from_file:
        logger.warning("No room definitions found. Aborting room seeding.")
        return
    logger.info(f"Loaded {len(room_definitions_from_file)} room definitions.")
    
    processed_room_tags_coords: Dict[str, Tuple[int,int,int]] = {} 

    for room_entry in room_definitions_from_file:
        unique_tag = room_entry.get("unique_tag")
        room_data_dict = room_entry.get("data")
        if not unique_tag or not room_data_dict:
            logger.warning(f"Skipping malformed room entry: {room_entry}")
            continue
        try:
            # Ensure 'exits' and 'interactables' have defaults if missing from JSON data for RoomCreate
            if 'exits' not in room_data_dict: room_data_dict['exits'] = {}
            if 'interactables' not in room_data_dict: room_data_dict['interactables'] = []
            room_create_schema = schemas.RoomCreate(**room_data_dict)
            processed_room_tags_coords[unique_tag] = (room_create_schema.x, room_create_schema.y, room_create_schema.z)
        except Exception as e_pydantic_room:
            logger.error(f"Pydantic validation error for room data associated with tag '{unique_tag}': {e_pydantic_room}. Data: {room_data_dict}", exc_info=True)
            continue
            
        existing_room = get_room_by_coords(db, x=room_create_schema.x, y=room_create_schema.y, z=room_create_schema.z)
        if not existing_room:
            # logger.info(f"Staging creation: '{room_create_schema.name}' (tag: {unique_tag})")
            create_room(db, room_in=room_create_schema) # create_room handles db.add()
        else:
            # logger.info(f"Staging update: '{existing_room.name}' (tag: {unique_tag})")
            # Use room_create_schema for update_room as it contains all fields from JSON
            # RoomUpdate schema is for partial updates via API. Here we want to ensure JSON is source of truth.
            # We can construct RoomUpdate from room_create_schema's dict.
            update_payload_data = room_create_schema.model_dump(exclude_unset=False) # Get all fields from JSON
            room_update_for_seed = schemas.RoomUpdate(**update_payload_data)
            update_room(db, db_room=existing_room, room_in=room_update_for_seed) # update_room handles db.add() if changed

    logger.info("Flushing staged room data to assign IDs before exit processing...")
    try:
        db.flush() # Assigns IDs to newly created rooms without committing transaction
    except Exception as e_flush:
        logger.error(f"ERROR during db.flush() for rooms: {e_flush}. Rolling back this seeding stage.", exc_info=True)
        db.rollback() # Rollback any staged room changes if flush fails
        return # Abort seeding if rooms can't be flushed
        
    logger.info("Populating room UUID cache from flushed data...")
    for tag, coords_tuple in processed_room_tags_coords.items():
        # Fetch by coords again to get the ORM object with its ID post-flush
        room_orm_after_flush = get_room_by_coords(db, x=coords_tuple[0], y=coords_tuple[1], z=coords_tuple[2])
        if room_orm_after_flush and room_orm_after_flush.id:
            _SEED_ROOM_UUIDS_CACHE[tag] = room_orm_after_flush.id
            logger.debug(f"CACHE: Room Tag '{tag}' at {coords_tuple} -> UUID '{room_orm_after_flush.id}'")
        else:
            logger.warning(f"Room tag '{tag}' at {coords_tuple} not found in DB or ID missing after flush. Cannot cache for exit linking.")
            
    # Commit rooms once all are processed and cache is attempted
    logger.info("Committing room creations/updates (if any)...")
    try:
        db.commit() # Commit all staged room creations/updates
        logger.info("Room data committed successfully.")
    except Exception as e_commit_rooms:
        logger.error(f"ERROR committing rooms: {e_commit_rooms}. Rolling back.", exc_info=True)
        db.rollback()
        return # Abort if room commit fails

    # --- Process Exits ---
    exits_data_from_file = _load_seed_data("exits_z0.json")
    if not exits_data_from_file:
        logger.warning("No exits data found in exits_z0.json. Skipping exit linking.")
    else:
        logger.info(f"Loaded {len(exits_data_from_file)} exit definitions from exits_z0.json.")
        exit_updates_staged_count = 0
        for exit_def in exits_data_from_file:
            source_tag = exit_def.get("source_tag")
            direction_str = exit_def.get("direction")
            target_tag = exit_def.get("target_tag")
            details_override = exit_def.get("details", {}) # Ensure details_override is always a dict
            
            if not (source_tag and direction_str and target_tag):
                logger.warning(f"Skipping malformed exit definition (missing source_tag, direction, or target_tag): {exit_def}")
                continue

            source_id = _SEED_ROOM_UUIDS_CACHE.get(source_tag)
            target_id = _SEED_ROOM_UUIDS_CACHE.get(target_tag)
            
            logger.debug(f"EXIT PROC: Source Tag='{source_tag}', Direction='{direction_str}', Target Tag='{target_tag}'")
            logger.debug(f"EXIT PROC: Source ID (from cache)='{source_id}', Target ID (from cache)='{target_id}'")
            if source_tag == "south_corridor_0_m1_0" and direction_str == "south": # Specific debug for known problematic exit
                 logger.info(f"CRITICAL EXIT DEBUG: Processing 'south_corridor_0_m1_0' -> 'south' -> '{target_tag}'. Source UUID: {source_id}, Target UUID: {target_id}")

            if not source_id or not target_id:
                logger.warning(f"Cannot link exit: Missing UUID for source_tag='{source_tag}' (found: {bool(source_id)}) or target_tag='{target_tag}' (found: {bool(target_id)}). This exit will be skipped.")
                continue
            
            source_room_orm = get_room_by_id(db, room_id=source_id) # Get a fresh ORM object for this session
            if not source_room_orm:
                logger.warning(f"Source room ORM for tag '{source_tag}' (ID: {source_id}) not found in DB for exit link. This is unexpected if room seeding was successful.")
                continue

            if source_room_orm.exits is None: source_room_orm.exits = {} # Ensure exits field is a dict
            
            # Prepare data for ExitDetail Pydantic model, ensuring defaults are handled for missing optional fields
            exit_detail_fields = schemas.ExitDetail.model_fields
            
            desc_locked_from_json = details_override.get("description_when_locked")
            default_desc_locked = exit_detail_fields["description_when_locked"].get_default()
            final_desc_locked = desc_locked_from_json if desc_locked_from_json is not None else default_desc_locked
            if final_desc_locked is None: final_desc_locked = "It's securely locked." # Hard fallback

            desc_unlocked_from_json = details_override.get("description_when_unlocked")
            default_desc_unlocked = exit_detail_fields["description_when_unlocked"].get_default() # This can be None
            final_desc_unlocked = desc_unlocked_from_json if desc_unlocked_from_json is not None else default_desc_unlocked
            # No hard fallback for unlocked if None is acceptable by Pydantic model (Optional[str]=None)

            raw_skill_to_pick_data = details_override.get("skill_to_pick")
            parsed_skill_to_pick_for_exit_data = None
            if isinstance(raw_skill_to_pick_data, dict):
                try:
                    parsed_skill_to_pick_for_exit_data = ExitSkillToPickDetail(**raw_skill_to_pick_data).model_dump(mode='json')
                except Exception as e_skill_parse:
                    logger.error(f"Pydantic error parsing skill_to_pick for exit {source_tag}->{direction_str}: {e_skill_parse}. Data: {raw_skill_to_pick_data}", exc_info=True)
            elif raw_skill_to_pick_data is not None: # If it's not a dict and not None, it's invalid
                logger.warning(f"Invalid data type for skill_to_pick for exit {source_tag}->{direction_str}. Expected dict or None, got {type(raw_skill_to_pick_data)}. Ignoring.")

            exit_data_for_pydantic = {
                "target_room_id": str(target_id), # Ensure UUID is string for Pydantic if it expects str then converts
                "is_locked": details_override.get("is_locked", exit_detail_fields["is_locked"].get_default()),
                "lock_id_tag": details_override.get("lock_id_tag"),
                "key_item_tag_opens": details_override.get("key_item_tag_opens"),
                "skill_to_pick": parsed_skill_to_pick_for_exit_data, # Use parsed data
                "description_when_locked": final_desc_locked,
                "description_when_unlocked": final_desc_unlocked,
                "force_open_dc": details_override.get("force_open_dc")
            }
            
            try:
                exit_detail_pydantic_obj = schemas.ExitDetail(**exit_data_for_pydantic)
                new_exit_json_for_db = exit_detail_pydantic_obj.model_dump(mode='json') # Serialize the validated model
                
                current_exits_on_orm = dict(source_room_orm.exits) # Make a mutable copy
                if current_exits_on_orm.get(direction_str) != new_exit_json_for_db:
                    logger.info(f"Staging exit update for Room '{source_room_orm.name}' ({source_tag}) -> '{direction_str}' -> Target Room Tag '{target_tag}' (Target UUID: {target_id})")
                    current_exits_on_orm[direction_str] = new_exit_json_for_db
                    source_room_orm.exits = current_exits_on_orm # Assign back to ORM object
                    attributes.flag_modified(source_room_orm, "exits") # Mark as modified for SQLAlchemy
                    db.add(source_room_orm) # Add to session to stage the update
                    exit_updates_staged_count += 1
                # else: logger.debug(f"Exit {source_tag}->{direction_str} unchanged, no update staged.")

            except Exception as e_pydantic_exit_final:
                logger.error(f"Pydantic validation or model_dump failed for final exit structure of {source_tag}->{direction_str}: {e_pydantic_exit_final}. Prepared Input: {exit_data_for_pydantic}", exc_info=True)
        
        if exit_updates_staged_count > 0:
            logger.info(f"Committing {exit_updates_staged_count} exit updates...")
            try:
                db.commit() # Commit all staged exit updates
                logger.info("Exit updates committed successfully.")
            except Exception as e_commit_exits:
                logger.error(f"ERROR committing exit updates: {e_commit_exits}. Rolling back.", exc_info=True)
                db.rollback()
        else:
            logger.info("No exit updates were staged or needed committing.")
            
    # --- Key Placement (Example of placing an item post-room/exit seeding) ---
    key_room_tag, key_name = "east_storage_1_0_0", "Archive Key Alpha" # As per original example
    key_room_id = _SEED_ROOM_UUIDS_CACHE.get(key_room_tag)
    if not key_room_id:
        logger.warning(f"Room tag '{key_room_tag}' for key placement not found in cache. Cannot place key.")
    else:
        key_template = crud.crud_item.get_item_by_name(db, name=key_name)
        if not key_template:
            logger.warning(f"Item template '{key_name}' not found. Cannot place key.")
        else:
            # Check if key already exists in the target room to ensure idempotency
            existing_key_instance = db.query(models.RoomItemInstance).filter(
                models.RoomItemInstance.room_id == key_room_id,
                models.RoomItemInstance.item_id == key_template.id
            ).first()

            if not existing_key_instance:
                logger.info(f"Placing item '{key_template.name}' in room '{key_room_tag}' (ID: {key_room_id}).")
                # crud.crud_room_item.add_item_to_room does NOT commit.
                _, msg = crud.crud_room_item.add_item_to_room(db, room_id=key_room_id, item_id=key_template.id, quantity=1)
                logger.info(f"Key placement staging message: {msg}")
                try:
                    db.commit() # Commit this specific item placement transaction
                    logger.info(f"Key '{key_template.name}' placed and committed.")
                except Exception as e_commit_key:
                    logger.error(f"Error committing key placement: {e_commit_key}. Rolling back this key placement.", exc_info=True)
                    db.rollback()
            else:
                logger.info(f"Key '{key_template.name}' already found in room with tag '{key_room_tag}'. Skipping placement.")
    
    logger.info("World seeding process finished.")
--- END OF FILE backend/app/crud/crud_room.py ---

--- START OF FILE backend/app/crud/crud_character.py ---
# backend/app/crud/crud_character.py
from sqlalchemy.orm import Session, attributes
import uuid
import logging # Added logging
from typing import Any, Dict, Optional, List, Tuple, Union 

from .. import models, schemas, crud 

logger = logging.getLogger(__name__)

# Base stats for a character before any class modifiers are applied.
# Class templates will modify these.
DEFAULT_STATS = {
    "strength": 10, "dexterity": 10, "constitution": 10,
    "intelligence": 10, "wisdom": 10, "charisma": 10, "luck": 5,
    "current_health": 20, "max_health": 20, # These will be further adjusted by class bonuses
    "current_mana": 10, "max_mana": 10,   # These will be further adjusted by class bonuses
    "level": 1, "experience_points": 0,
    "base_ac": 10, 
    "base_attack_bonus": 0, # This is a flat bonus, attribute modifiers are added separately
    "base_damage_dice": "1d4", # Default unarmed/improvised weapon
    "base_damage_bonus": 0,    # Flat damage bonus, attribute modifiers added separately
    "learned_skills": [], 
    "learned_traits": []
}

XP_THRESHOLDS = {
    1: 0, 2: 100, 3: 300, 4: 600, 5: 1000, 6: 1500, 7: 2100, 8: 2800, 9: 3600, 
    10: 4500, 11: 5500, 12: 6600, 13: 7800, 14: 9100, 15: 10500, 16: 12000, 
    17: 13600, 18: 15300, 19: 17100, 20: 19000
    # 21: float('inf') # Example for a hard cap
}

COPPER_PER_SILVER = 100
SILVER_PER_GOLD = 100
GOLD_PER_PLATINUM = 100

# CLASS_LEVEL_BONUSES dictionary is REMOVED as this data now comes from CharacterClassTemplate.stat_gains_per_level

def update_character_currency(
    db: Session, 
    character_id: uuid.UUID, 
    platinum_change: int = 0,
    gold_change: int = 0, 
    silver_change: int = 0, 
    copper_change: int = 0
) -> Tuple[Optional[models.Character], str]:
    character = get_character(db, character_id=character_id)
    if not character:
        return None, "Character not found."

    current_total_copper = (character.platinum_coins * GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                           (character.gold_coins * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                           (character.silver_coins * COPPER_PER_SILVER) + \
                            character.copper_coins
    
    change_total_copper = (platinum_change * GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                          (gold_change * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                          (silver_change * COPPER_PER_SILVER) + \
                           copper_change

    if current_total_copper + change_total_copper < 0:
        return character, "Not enough funds for this transaction."

    new_total_copper = current_total_copper + change_total_copper

    new_platinum = new_total_copper // (GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER)
    remainder_after_platinum = new_total_copper % (GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER)
    new_gold = remainder_after_platinum // (SILVER_PER_GOLD * COPPER_PER_SILVER) 
    remainder_after_gold = remainder_after_platinum % (SILVER_PER_GOLD * COPPER_PER_SILVER)    
    new_silver = remainder_after_gold // COPPER_PER_SILVER
    new_copper = remainder_after_gold % COPPER_PER_SILVER

    character.platinum_coins = new_platinum
    character.gold_coins = new_gold
    character.silver_coins = new_silver
    character.copper_coins = new_copper

    db.add(character) # Stage the change
    # db.commit() # <<< REMOVED
    # db.refresh(character) # <<< REMOVED
    
    change_parts = []
    if platinum_change != 0: change_parts.append(f"{abs(platinum_change)}p")
    if gold_change != 0: change_parts.append(f"{abs(gold_change)}g")
    if silver_change != 0: change_parts.append(f"{abs(silver_change)}s")
    if copper_change != 0: change_parts.append(f"{abs(copper_change)}c")
    action = "gained" if change_total_copper > 0 else "lost" if change_total_copper < 0 else "changed by"
    balance_parts = []
    if new_platinum > 0: balance_parts.append(f"{new_platinum}p")
    if new_gold > 0: balance_parts.append(f"{new_gold}g")
    if new_silver > 0: balance_parts.append(f"{new_silver}s")
    if new_copper > 0 or not balance_parts: balance_parts.append(f"{new_copper}c")
    current_balance_str = " ".join(balance_parts) if balance_parts else "0c"

    if not change_parts and change_total_copper == 0:
        message = "Currency unchanged."
    elif not change_parts and change_total_copper != 0: 
         message = f"Currency updated. New total: {current_balance_str}"
    else:
        message = f"You {action} {' '.join(change_parts)}. Current balance: {current_balance_str}"

    return character, message

def get_xp_for_level(level: int) -> Union[int, float]:
    return XP_THRESHOLDS.get(level, float('inf'))

def get_character(db: Session, character_id: uuid.UUID) -> Optional[models.Character]:
    # Ensure class_template_ref is loaded if needed frequently after fetching a character.
    # Consider adding options(joinedload(models.Character.class_template_ref)) if it's always used.
    return db.query(models.Character).filter(models.Character.id == character_id).first()

def get_character_by_name(db: Session, name: str) -> Optional[models.Character]:
    return db.query(models.Character).filter(models.Character.name == name).first()

def get_characters_by_player(db: Session, player_id: uuid.UUID, skip: int = 0, limit: int = 100) -> List[models.Character]:
    return db.query(models.Character).filter(models.Character.player_id == player_id).offset(skip).limit(limit).all()

def _fetch_class_template_for_character(db: Session, character: models.Character) -> Optional[models.CharacterClassTemplate]:
    """Ensures the character.class_template_ref is populated."""
    if character.class_template_ref and character.class_template_ref.id == character.character_class_template_id:
        return character.class_template_ref
    if character.character_class_template_id:
        class_template = crud.crud_character_class.get_character_class_template(db, class_template_id=character.character_class_template_id)
        if class_template:
            character.class_template_ref = class_template # Cache it on the character object for this session
            return class_template
    logger.warning(f"Character {character.name} (ID: {character.id}) has no class_template_id or template not found.")
    return None

def _grant_abilities_for_level(db: Session, character: models.Character, level_to_grant_for: int) -> List[str]:
    granted_messages = []
    level_str = str(level_to_grant_for)
    
    class_template = _fetch_class_template_for_character(db, character)
        
    if class_template and class_template.skill_tree_definition:
        skill_tree: Dict[str, Any] = class_template.skill_tree_definition
        core_skills_for_level: List[str] = skill_tree.get("core_skills_by_level", {}).get(level_str, [])
        if core_skills_for_level:
            if character.learned_skills is None: character.learned_skills = [] # Initialize if None
            learned_new_skill = False
            for skill_tag in core_skills_for_level:
                skill_def = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_tag)
                if skill_def and skill_tag not in character.learned_skills:
                    character.learned_skills.append(skill_tag)
                    granted_messages.append(f"You have learned skill: {skill_def.name}!")
                    learned_new_skill = True
            if learned_new_skill: attributes.flag_modified(character, "learned_skills")

        core_traits_for_level: List[str] = skill_tree.get("core_traits_by_level", {}).get(level_str, [])
        if core_traits_for_level:
            if character.learned_traits is None: character.learned_traits = [] # Initialize if None
            learned_new_trait = False
            for trait_tag in core_traits_for_level:
                trait_def = crud.crud_trait.get_trait_template_by_tag(db, trait_id_tag=trait_tag)
                if trait_def and trait_tag not in character.learned_traits:
                    character.learned_traits.append(trait_tag)
                    granted_messages.append(f"You have gained trait: {trait_def.name}!")
                    learned_new_trait = True
            if learned_new_trait: attributes.flag_modified(character, "learned_traits")
    elif not class_template:
        logger.warning(f"Cannot grant abilities for level {level_to_grant_for} to character {character.name}: No class template loaded.")
        
    return granted_messages

def create_character(
    db: Session, *,
    character_in: schemas.CharacterCreate,
    player_id: uuid.UUID,
    initial_room_id: uuid.UUID
) -> models.Character:
    db_character_data = character_in.model_dump(exclude_unset=True)
    
    # Start with base defaults
    final_char_args = DEFAULT_STATS.copy() 
    # Ensure JSONB fields from defaults are mutable lists/dicts if needed downstream directly
    final_char_args["learned_skills"] = list(final_char_args["learned_skills"]) 
    final_char_args["learned_traits"] = list(final_char_args["learned_traits"])

    class_template_id_to_set: Optional[uuid.UUID] = None
    class_name_from_input = db_character_data.get("class_name", "Adventurer") 
    
    # Fetch the class template; "Adventurer" is the default if none specified or found
    class_template: Optional[models.CharacterClassTemplate] = crud.crud_character_class.get_character_class_template_by_name(db, name=class_name_from_input)
    if not class_template and class_name_from_input != "Adventurer": # If a specific class was requested but not found, try Adventurer
        logger.warning(f"Character class template '{class_name_from_input}' not found. Attempting to default to 'Adventurer'.")
        class_template = crud.crud_character_class.get_character_class_template_by_name(db, name="Adventurer")

    effective_class_name = "Adventurer" # Fallback name

    if class_template:
        class_template_id_to_set = class_template.id
        effective_class_name = class_template.name # Use the name from the template
        
        # Apply base stat modifiers from class template
        if class_template.base_stat_modifiers:
            for stat, modifier in class_template.base_stat_modifiers.items():
                if stat in final_char_args: 
                    final_char_args[stat] = final_char_args.get(stat, 0) + modifier # Use .get for safety if stat wasn't in DEFAULT_STATS
        
        # Apply starting health/mana bonuses
        final_char_args["max_health"] = final_char_args.get("max_health", 0) + class_template.starting_health_bonus
        final_char_args["current_health"] = final_char_args["max_health"] # Full health at creation
        final_char_args["max_mana"] = final_char_args.get("max_mana", 0) + class_template.starting_mana_bonus
        final_char_args["current_mana"] = final_char_args["max_mana"] # Full mana at creation
    else:
        logger.warning(f"No class template found for '{class_name_from_input}' or 'Adventurer'. Character will use raw default stats.")
        # effective_class_name remains "Adventurer" or could be set to something generic

    db_character = models.Character(
        name=db_character_data["name"],
        class_name=effective_class_name,
        player_id=player_id,
        current_room_id=initial_room_id,
        character_class_template_id=class_template_id_to_set,
        **final_char_args 
    )
    db.add(db_character) # db_character is now pending

    if class_template: 
        db_character.class_template_ref = class_template

    initial_ability_messages = _grant_abilities_for_level(db, db_character, 1) 
    if initial_ability_messages:
        logger.info(f"Character '{db_character.name}' initial abilities granted: {', '.join(initial_ability_messages)}")

    # Grant starting equipment
    if class_template and class_template.starting_equipment_refs:
        logger.info(f"Attempting to grant starting equipment for {db_character.name} (ID pending: {db_character.id})")
        for item_ref_name_or_tag in class_template.starting_equipment_refs:
            item_template_to_add = crud.crud_item.get_item_by_name(db, name=item_ref_name_or_tag)
            if not item_template_to_add: 
                 item_template_to_add = crud.crud_item.get_item_by_item_tag(db, item_tag=item_ref_name_or_tag)

            if item_template_to_add:
                # Call the modified add_item_to_character_inventory, passing the character_obj
                # This function will now append to db_character.inventory_items
                _, msg = crud.crud_character_inventory.add_item_to_character_inventory(
                    db, character_obj=db_character, item_id=item_template_to_add.id, quantity=1
                )
                logger.info(f"Staging starting item '{item_template_to_add.name}' for '{db_character.name}'. Inv Msg: {msg}")
            else:
                logger.warning(f"Starting equipment item/tag '{item_ref_name_or_tag}' not found for class '{class_template.name}'.")
    
    # Before commit, let's see if items are in the pending list
    if hasattr(db_character, 'inventory_items') and db_character.inventory_items:
        logger.info(f"Character {db_character.name} has {len(db_character.inventory_items)} items in inventory_items relationship before commit.")
        for idx, item_entry in enumerate(db_character.inventory_items):
            logger.debug(f"  Item {idx}: Item ID {item_entry.item_id}, Qty {item_entry.quantity}, Char ID (on entry) {item_entry.character_id}")
    else:
        logger.warning(f"Character {db_character.name} has NO items in inventory_items relationship before commit.")

    db.commit() 
    db.refresh(db_character) 
    # After refresh, inventory_items should be populated from DB if commit was successful
    if hasattr(db_character, 'inventory_items') and db_character.inventory_items:
         logger.info(f"Character {db_character.name} has {len(db_character.inventory_items)} items in inventory_items AFTER commit & refresh.")
    else:
        logger.info(f"Character {db_character.name} has NO items in inventory_items AFTER commit & refresh.")

    logger.info(f"Character '{db_character.name}' created successfully with ID {db_character.id}.")
    return db_character

def update_character_room(db: Session, character_id: uuid.UUID, new_room_id: uuid.UUID) -> Optional[models.Character]:
    db_character = get_character(db, character_id=character_id)
    if db_character:
        db_character.current_room_id = new_room_id
        db.add(db_character) # Stage the change
        # db.commit() # <<< REMOVED
        # db.refresh(db_character) # <<< REMOVED
        return db_character
    return None

def update_character_health(db: Session, character_id: uuid.UUID, amount_change: int) -> Optional[models.Character]:
    character = get_character(db, character_id=character_id)
    if not character:
        return None
    
    character.current_health += amount_change
    character.current_health = max(0, min(character.current_health, character.max_health))
        
    db.add(character) # Stage the change
    # db.commit() # <<< REMOVED
    # db.refresh(character) # <<< REMOVED
    return character

def _apply_level_up(db: Session, character: models.Character) -> List[str]:
    level_up_messages = []
    
    current_max_defined_level = max(XP_THRESHOLDS.keys()) if XP_THRESHOLDS else 0
    if character.level >= current_max_defined_level and get_xp_for_level(character.level + 1) == float('inf'):
         level_up_messages.append(f"You are already at the maximum defined level ({character.level}). Cannot level up further.")
         return level_up_messages

    character.level += 1
    level_up_messages.append(f"Ding! You have reached Level {character.level}!")

    # Get stat gains from class template
    class_template = _fetch_class_template_for_character(db, character)
    hp_gain_from_class = 0
    mp_gain_from_class = 0
    # bab_gain_from_class = 0 # Not directly adding to character.base_attack_bonus, as that's flat.
                            # BAB is usually calculated dynamically or traits/feats grant it.
                            # If you have a character.base_attack_bonus_per_level field, update it here.

    if class_template and class_template.stat_gains_per_level:
        sgl = class_template.stat_gains_per_level
        hp_gain_from_class = int(sgl.get("hp", 3)) # Default to 3 if not specified
        mp_gain_from_class = int(sgl.get("mp", 1)) # Default to 1
        # bab_from_class_per_level = float(sgl.get("base_attack_bonus", 0.0))
        # character.base_attack_bonus += bab_from_class_per_level # Example if you store BAB progression this way
                                                                # Ensure base_attack_bonus is Float if so.
    else: # Fallback if no template or no stat_gains defined (e.g. very basic Adventurer)
        logger.warning(f"No stat_gains_per_level found for class '{character.class_name}' on level up for {character.name}. Using fallback.")
        hp_gain_from_class = 3 # Generic fallback
        mp_gain_from_class = 1 # Generic fallback

    con_mod = character.get_attribute_modifier("constitution")
    hp_gain_total = max(1, con_mod + hp_gain_from_class) 
    character.max_health += hp_gain_total
    level_up_messages.append(f"Your maximum health increases by {hp_gain_total}!")

    # Example: Mana gain could also be influenced by a primary casting stat like intelligence or wisdom
    int_mod = character.get_attribute_modifier("intelligence") # Or relevant mana attribute for the class
    mp_gain_total = max(0, int_mod + mp_gain_from_class) 
    character.max_mana += mp_gain_total
    if mp_gain_total > 0 or mp_gain_from_class > 0 : # Only message if there was potential for mana gain
        level_up_messages.append(f"Your maximum mana increases by {mp_gain_total}!")

    character.current_health = character.max_health # Full heal on level up
    character.current_mana = character.max_mana   # Full mana on level up
    level_up_messages.append("You feel invigorated!")
    
    ability_messages = _grant_abilities_for_level(db, character, character.level)
    level_up_messages.extend(ability_messages)
    
    db.add(character) # Stage changes from level up
    return level_up_messages


def _apply_level_down(db: Session, character: models.Character) -> List[str]:
    if character.level <= 1:
        return ["You cannot de-level below level 1, you pathetic worm."]
    
    level_down_messages = []
    xp_for_new_lower_level = get_xp_for_level(character.level - 1)
    if xp_for_new_lower_level == float('inf'): # Should not happen if level > 1
        xp_for_new_lower_level = XP_THRESHOLDS.get(character.level -1, 0)

    # Estimate loss based on what was gained. This is tricky without storing historical gains.
    # Simplification: remove gains as if they were from the class template for the *new lower level*.
    class_template = _fetch_class_template_for_character(db, character)
    hp_loss_from_class = 3 # Default
    mp_loss_from_class = 1 # Default

    if class_template and class_template.stat_gains_per_level:
        sgl = class_template.stat_gains_per_level
        hp_loss_from_class = int(sgl.get("hp", 3))
        mp_loss_from_class = int(sgl.get("mp", 1))
    else:
        logger.warning(f"No stat_gains_per_level for class '{character.class_name}' on level down for {character.name}. Using fallback loss.")

    con_mod = character.get_attribute_modifier("constitution")
    hp_loss_estimate = max(1, con_mod + hp_loss_from_class)
    character.max_health = max(1, character.max_health - hp_loss_estimate) 
    level_down_messages.append(f"Your maximum health decreases by {hp_loss_estimate}.")

    int_mod = character.get_attribute_modifier("intelligence")
    mp_loss_estimate = max(0, int_mod + mp_loss_from_class)
    character.max_mana = max(0, character.max_mana - mp_loss_estimate)
    if mp_loss_estimate > 0 or mp_loss_from_class > 0:
        level_down_messages.append(f"Your maximum mana decreases by {mp_loss_estimate}.")

    character.current_health = min(character.current_health, character.max_health)
    character.current_mana = min(character.current_mana, character.max_mana)

    character.level -= 1
    level_down_messages.append(f"You feel weaker... You have de-leveled to Level {character.level}.")
    character.experience_points = int(xp_for_new_lower_level) 

    # TODO: Logic to remove skills/traits learned at the level lost. This is complex.
    # For now, skills/traits are not removed on de-level.

    db.add(character) # Stage changes from level down
    return level_down_messages


def add_experience(db: Session, character_id: uuid.UUID, amount: int) -> Tuple[Optional[models.Character], List[str]]:
    character = get_character(db, character_id=character_id)
    if not character:
        return None, ["Character not found."]
    messages = []
    if amount == 0: # Check if still needed or handled by caller
        # return character, ["No experience gained or lost. How pointless."] 
        pass # Allow 0 for potential future effects, combat loop might filter this.

    initial_level = character.level
    character.experience_points += amount
    if amount !=0 : # Only message if XP actually changed
      messages.append(f"{'Gained' if amount > 0 else 'Lost'} {abs(amount)} experience points. Current XP: {character.experience_points}")

    # Level up loop
    xp_for_next_level = get_xp_for_level(character.level + 1)
    while character.experience_points >= xp_for_next_level and xp_for_next_level != float('inf'):
        overflow_xp = character.experience_points - int(xp_for_next_level) # XP beyond what's needed for next level
        level_up_messages = _apply_level_up(db, character) # _apply_level_up stages changes
        messages.extend(level_up_messages)
        
        # Set XP to the start of the new current level, plus overflow
        xp_at_start_of_new_level = get_xp_for_level(character.level)
        if xp_at_start_of_new_level == float('inf'): # Should not happen if level up occurred
            character.experience_points = 0
        else:
            character.experience_points = int(xp_at_start_of_new_level) + overflow_xp
        
        xp_for_next_level = get_xp_for_level(character.level + 1) # Recalculate for potential multi-level up

    # De-level loop (only if XP is negative or below current level's threshold)
    xp_required_for_current_level = get_xp_for_level(character.level)
    while character.level > 1 and character.experience_points < xp_required_for_current_level :
        # Note: If XP becomes negative, this loop will run.
        # _apply_level_down will set XP to the start of the new lower level.
        delevel_messages = _apply_level_down(db, character) # _apply_level_down stages changes
        messages.extend(delevel_messages)
        xp_required_for_current_level = get_xp_for_level(character.level) # For the new, lower level

    # Ensure XP doesn't go below 0 for level 1 characters
    if character.level == 1 and character.experience_points < 0:
        character.experience_points = 0

    db.add(character) # Ensure character is staged after all XP and level modifications
    # db.commit() # <<< REMOVED - Caller (e.g. skill_resolver or command handler) commits
    # db.refresh(character) # <<< REMOVED
    
    # Add a generic level change message if specific Ding/Delevel messages weren't generated
    # (e.g. if level changed via admin command without going through xp gain/loss)
    if character.level != initial_level and not any("Ding!" in m or "de-leveled" in m for m in messages):
        messages.append(f"Your level is now {character.level}.")
    return character, messages

def get_characters_in_room(db: Session, *, room_id: uuid.UUID, exclude_character_id: Optional[uuid.UUID] = None) -> List[models.Character]:
    query = db.query(models.Character).filter(models.Character.current_room_id == room_id)
    if exclude_character_id:
        query = query.filter(models.Character.id != exclude_character_id)
    return query.all()
--- END OF FILE backend/app/crud/crud_character.py ---

--- START OF FILE backend/app/crud/crud_character_inventory.py ---
# backend/app/crud/crud_character_inventory.py
from sqlalchemy.orm import Session, joinedload, attributes 
import uuid
from typing import List, Optional, Tuple, Dict # Added Dict
import logging

from .. import models, schemas # models.Item, models.Character, models.CharacterInventoryItem
from ..models.item import EQUIPMENT_SLOTS # For validation

logger = logging.getLogger(__name__)

def get_inventory_item_entry_by_id(db: Session, inventory_item_id: uuid.UUID) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item) 
    ).filter(models.CharacterInventoryItem.id == inventory_item_id).first()

def get_character_inventory(db: Session, character_id: uuid.UUID) -> List[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item) 
    ).filter(models.CharacterInventoryItem.character_id == character_id).all()

def character_has_item_with_tag(db: Session, character_id: uuid.UUID, item_tag: str) -> bool:
    count = db.query(models.CharacterInventoryItem.id).join(
        models.Item, models.CharacterInventoryItem.item_id == models.Item.id
    ).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.Item.properties["item_tag"].astext == item_tag
    ).count()
    return count > 0

def add_item_to_character_inventory( 
    db: Session, *, character_obj: models.Character, item_id: uuid.UUID, quantity: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    if quantity <= 0:
        return None, "Quantity must be positive."

    created_or_updated_entry: Optional[models.CharacterInventoryItem] = None
    message: str = ""

    if item_template.stackable:
        existing_unequipped_stack: Optional[models.CharacterInventoryItem] = None
        # Iterate through the character's current inventory (assuming it's loaded or accessible)
        # This avoids a separate query if character_obj.inventory_items is already populated.
        # If character_obj.inventory_items might not be loaded, a query would be safer:
        # existing_unequipped_stack = db.query(models.CharacterInventoryItem).filter(
        #     models.CharacterInventoryItem.character_id == character_obj.id,
        #     models.CharacterInventoryItem.item_id == item_id,
        #     models.CharacterInventoryItem.equipped == False
        # ).first()
        for inv_item in character_obj.inventory_items: # Assumes inventory_items is loaded
            if inv_item.item_id == item_id and not inv_item.equipped:
                existing_unequipped_stack = inv_item
                break
        
        if existing_unequipped_stack:
            max_stack = item_template.max_stack_size if item_template.max_stack_size is not None else float('inf')
            if existing_unequipped_stack.quantity + quantity <= max_stack:
                existing_unequipped_stack.quantity += quantity
                # db.add(existing_unequipped_stack) # SQLAlchemy tracks changes on attached objects
                created_or_updated_entry = existing_unequipped_stack
                message = f"Staged update to stack of {item_template.name} (+{quantity})."
            else: 
                if quantity <= max_stack: # Create a new stack if current one overflows
                    new_entry = models.CharacterInventoryItem(item_id=item_id, quantity=quantity)
                    new_entry.character = character_obj 
                    # character_obj.inventory_items.append(new_entry) # Alternative
                    db.add(new_entry) # Explicitly add new object to session
                    created_or_updated_entry = new_entry
                    message = f"Staged addition of new stack of {quantity} x {item_template.name} (old stack full/different)."
                else:
                    return None, f"Cannot add {quantity}; exceeds max stack size for {item_template.name} even as new stack."
        else: 
            max_stack = item_template.max_stack_size if item_template.max_stack_size is not None else float('inf')
            if quantity <= max_stack:
                new_entry = models.CharacterInventoryItem(item_id=item_id, quantity=quantity)
                new_entry.character = character_obj
                # character_obj.inventory_items.append(new_entry)
                db.add(new_entry)
                created_or_updated_entry = new_entry
                message = f"Staged addition of {quantity} x {item_template.name} to inventory."
            else:
                return None, f"Cannot add {quantity}; exceeds max stack size for new stack of {item_template.name}."
    else: 
        last_created_entry = None
        for _ in range(quantity):
            new_entry = models.CharacterInventoryItem(item_id=item_id, quantity=1)
            new_entry.character = character_obj
            # character_obj.inventory_items.append(new_entry)
            db.add(new_entry)
            last_created_entry = new_entry
        created_or_updated_entry = last_created_entry
        message = f"Staged addition of {quantity} individual {item_template.name}(s) to inventory."
        
    return created_or_updated_entry, message


def remove_item_from_character_inventory(
    db: Session, *, inventory_item_id: uuid.UUID, quantity_to_remove: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    # This function operates on a specific inventory_item_id, so character_obj isn't strictly needed for the core logic
    # if ownership is checked by the caller or if the item is guaranteed to belong to the active char.
    entry = get_inventory_item_entry_by_id(db, inventory_item_id)
    if not entry:
        return None, "Inventory item entry not found."
    if entry.equipped:
        item_name = entry.item.name if entry.item else "item"
        return None, f"Cannot remove '{item_name}'; it is currently equipped. Unequip it first."
    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = entry.item.name if entry.item else "Unknown Item"

    if entry.quantity > quantity_to_remove:
        entry.quantity -= quantity_to_remove
        db.add(entry)
        return entry, f"Staged removal of {quantity_to_remove} x {original_item_name}. {entry.quantity} remaining."
    else:
        removed_qty = entry.quantity
        db.delete(entry) # This will be part of the session's unit of work
        return None, f"Staged deletion of all {removed_qty} x {original_item_name} from inventory."


def equip_item_from_inventory(
    db: Session, *, character_obj: models.Character, inventory_item_id: uuid.UUID, target_slot: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    logger.info(f"[CRUD_EQUIP] Attempting to equip item_id: {inventory_item_id} for char: {character_obj.name} to slot: {target_slot}")
    char_inv_entry = get_inventory_item_entry_by_id(db, inventory_item_id)

    if not char_inv_entry:
        logger.warning(f"[CRUD_EQUIP_FAIL] Item instance {inventory_item_id} not found.")
        return None, "Item instance not found in your inventory records."
    if char_inv_entry.character_id != character_obj.id:
        logger.warning(f"[CRUD_EQUIP_FAIL] Ownership mismatch: Item {inventory_item_id} (owner: {char_inv_entry.character_id}) vs Char {character_obj.id}")
        return None, "This item does not belong to you."
    
    item_name_for_log = char_inv_entry.item.name if char_inv_entry.item else "UnknownItem"
    if char_inv_entry.equipped:
        logger.info(f"[CRUD_EQUIP_FAIL] Item '{item_name_for_log}' ({inventory_item_id}) already equipped in {char_inv_entry.equipped_slot}.")
        return char_inv_entry, f"{item_name_for_log} is already equipped in {char_inv_entry.equipped_slot}."

    item_template = char_inv_entry.item
    if not item_template: 
        logger.error(f"[CRUD_EQUIP_FAIL] Inventory item {char_inv_entry.id} is missing its item_template relationship.")
        return None, "Item template data missing for this inventory item."
        
    if not item_template.slot or item_template.slot in ["consumable", "inventory", "junk", "key", "tool", "crafting_material"]:
        logger.warning(f"[CRUD_EQUIP_FAIL] Item '{item_template.name}' (type: {item_template.item_type}, defined slot: {item_template.slot}) is not equippable.")
        return None, f"{item_template.name} is not equippable in a character slot."

    final_target_slot = target_slot 
    item_defined_slot_type = item_template.slot

    if not final_target_slot: 
        if item_defined_slot_type in EQUIPMENT_SLOTS: 
            final_target_slot = item_defined_slot_type
            logger.info(f"[CRUD_EQUIP] Auto-determined slot for '{item_template.name}' to be '{final_target_slot}' based on item.slot '{item_defined_slot_type}'.")
        elif item_defined_slot_type == "ring": 
             logger.warning(f"[CRUD_EQUIP_FAIL] Specific finger slot not provided for ring '{item_template.name}'.")
             return None, f"Please specify which finger slot to equip {item_template.name} (e.g., equip {item_template.name} finger_1)."
        else:
            logger.warning(f"[CRUD_EQUIP_FAIL] Cannot auto-determine slot for '{item_template.name}' (type: {item_defined_slot_type}). User must specify.")
            return None, f"Cannot automatically determine slot for {item_template.name} (defined slot type: {item_defined_slot_type}). Please specify a target slot."
    
    if final_target_slot not in EQUIPMENT_SLOTS:
        logger.warning(f"[CRUD_EQUIP_FAIL] Invalid target_slot '{final_target_slot}' specified by user or logic.")
        return None, f"Invalid equipment slot: '{final_target_slot}'. Valid slots are: {', '.join(EQUIPMENT_SLOTS.keys())}."

    # Compatibility checks (example)
    if item_defined_slot_type == "ring" and not final_target_slot.startswith("finger"):
        return None, f"{item_template.name} (a ring) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."
    if item_defined_slot_type == "main_hand" and final_target_slot != "main_hand":
        # Allow equipping to off_hand if user explicitly states `equip sword off_hand`
        if final_target_slot != "off_hand":
             return None, f"{item_template.name} (main_hand weapon) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."
    # Add more rules: e.g. cannot equip "shield" to "main_hand" if item.slot is "off_hand"
    if item_defined_slot_type == "off_hand" and final_target_slot != "off_hand":
        return None, f"{item_template.name} (off_hand item) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."


    # Unequip logic - iterate over character_obj.inventory_items (assuming it's loaded)
    # Ensure character_obj.inventory_items reflects the current state of the session if items were added/removed earlier in the same transaction.
    # It's safer to query if unsure, but for HTTP command context, active_character should be relatively fresh.
    current_inventory_for_equip = character_obj.inventory_items # Use the potentially already loaded list

    # 1. Item in the target slot
    for item_to_unequip in current_inventory_for_equip:
        if item_to_unequip.id == char_inv_entry.id: continue # Don't try to unequip the item we are trying to equip if it's somehow processed here
        if item_to_unequip.equipped and item_to_unequip.equipped_slot == final_target_slot:
            logger.info(f"[CRUD_EQUIP] Unequipping '{item_to_unequip.item.name if item_to_unequip.item else 'item'}' from slot '{final_target_slot}' to make space.")
            item_to_unequip.equipped = False
            item_to_unequip.equipped_slot = None
            db.add(item_to_unequip)

    if item_template.properties and item_template.properties.get("two_handed", False):
        slots_to_clear_for_two_hander = []
        if final_target_slot == "main_hand": slots_to_clear_for_two_hander.append("off_hand")
        elif final_target_slot == "off_hand": slots_to_clear_for_two_hander.append("main_hand")
        
        for slot_to_clear in slots_to_clear_for_two_hander:
            for other_hand_item in current_inventory_for_equip:
                if other_hand_item.id == char_inv_entry.id: continue
                if other_hand_item.equipped and other_hand_item.equipped_slot == slot_to_clear:
                    logger.info(f"[CRUD_EQUIP] Unequipping '{other_hand_item.item.name if other_hand_item.item else 'item'}' from '{slot_to_clear}' for two-handed '{item_template.name}'.")
                    other_hand_item.equipped = False
                    other_hand_item.equipped_slot = None
                    db.add(other_hand_item)
    
    logger.info(f"[CRUD_EQUIP] Setting item '{item_template.name}' ({char_inv_entry.id}): equipped=True, equipped_slot='{final_target_slot}'")
    char_inv_entry.equipped = True
    char_inv_entry.equipped_slot = final_target_slot
    db.add(char_inv_entry) # Stage this change
    logger.info(f"[CRUD_EQUIP] Item '{item_template.name}' staged for equip. Session dirty: {db.dirty}")
    
    return char_inv_entry, f"Staged equipping of {item_template.name} to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."

def unequip_item_to_inventory(
    db: Session, *, character_obj: models.Character, inventory_item_id: Optional[uuid.UUID] = None, slot_to_unequip: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    char_inv_entry: Optional[models.CharacterInventoryItem] = None

    if inventory_item_id:
        temp_entry = get_inventory_item_entry_by_id(db, inventory_item_id)
        if temp_entry and temp_entry.character_id == character_obj.id:
            char_inv_entry = temp_entry
        elif temp_entry:
            logger.warning(f"Attempt to unequip item {inventory_item_id} by char {character_obj.name} but item belongs to char_id {temp_entry.character_id}")
            return None, "This item instance does not belong to you."
    elif slot_to_unequip:
        if slot_to_unequip not in EQUIPMENT_SLOTS:
             return None, f"Invalid equipment slot: '{slot_to_unequip}'."
        for item in character_obj.inventory_items: # Assumes inventory_items is loaded
            if item.equipped and item.equipped_slot == slot_to_unequip:
                char_inv_entry = item
                break
    else:
        return None, "Must specify an item ID or a slot to unequip."

    if not char_inv_entry:
        return None, "No equipped item found for the given criteria."
    
    # Ensure item object is loaded for its name
    if not char_inv_entry.item: # Should be loaded by get_inventory_item_entry_by_id or relationship
        logger.error(f"Equipped item {char_inv_entry.id} is missing its item_template relationship.")
        return None, "Item template data missing for this equipped item." # Should not happen

    if not char_inv_entry.equipped or not char_inv_entry.equipped_slot: 
        return char_inv_entry, f"{char_inv_entry.item.name} is not currently equipped."

    item_name = char_inv_entry.item.name
    slot_display_name = EQUIPMENT_SLOTS.get(char_inv_entry.equipped_slot, char_inv_entry.equipped_slot)

    char_inv_entry.equipped = False
    char_inv_entry.equipped_slot = None
    db.add(char_inv_entry)
    
    return char_inv_entry, f"Staged unequipping of {item_name} from {slot_display_name}."
--- END OF FILE backend/app/crud/crud_character_inventory.py ---

--- START OF FILE backend/app/crud/crud_skill.py ---
# backend/app/crud/crud_skill.py
import json # For loading JSON
import os   # For path joining
import logging # For logging
from sqlalchemy.orm import Session, attributes # Added attributes
import uuid
from typing import List, Optional, Dict, Any # Added Dict, Any

from .. import models, schemas

logger = logging.getLogger(__name__)

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_generic(filename: str, data_type_name: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"{data_type_name} seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {data_type_name} seed file {filepath}: {e}")
        return []

def get_skill_template(db: Session, skill_template_id: uuid.UUID) -> Optional[models.SkillTemplate]:
    return db.query(models.SkillTemplate).filter(models.SkillTemplate.id == skill_template_id).first()

def get_skill_template_by_tag(db: Session, skill_id_tag: str) -> Optional[models.SkillTemplate]:
    return db.query(models.SkillTemplate).filter(models.SkillTemplate.skill_id_tag == skill_id_tag).first()

def get_skill_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.SkillTemplate]:
    return db.query(models.SkillTemplate).offset(skip).limit(limit).all()

def create_skill_template(db: Session, *, template_in: schemas.SkillTemplateCreate) -> models.SkillTemplate:
    # Removed unique check here as seeder will handle it before calling create.
    # For direct API calls, a unique constraint on DB + try/except IntegrityError is better.
    db_template = models.SkillTemplate(**template_in.model_dump())
    db.add(db_template)
    # Commit and refresh handled by caller, e.g., the seeder.
    return db_template

def update_skill_template(
    db: Session, *, 
    db_template: models.SkillTemplate, 
    template_in: schemas.SkillTemplateUpdate
) -> models.SkillTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    changed = False
    
    if "skill_id_tag" in update_data and update_data["skill_id_tag"] != db_template.skill_id_tag:
        existing_with_new_tag = get_skill_template_by_tag(db, skill_id_tag=update_data["skill_id_tag"])
        if existing_with_new_tag and existing_with_new_tag.id != db_template.id:
            logger.warning(f"Cannot update skill_id_tag for '{db_template.name}' to '{update_data['skill_id_tag']}', it's already in use by '{existing_with_new_tag.name}'. Skipping tag update.")
            del update_data["skill_id_tag"] # Don't attempt to update the tag
        elif "skill_id_tag" in update_data : # If tag can be updated (not caught by above)
            setattr(db_template, "skill_id_tag", update_data["skill_id_tag"])
            changed = True

    for field, value in update_data.items():
        if field == "skill_id_tag": continue # Already handled

        if getattr(db_template, field) != value:
            setattr(db_template, field, value)
            if field in ['effects_data', 'requirements_data']: # JSONB fields
                attributes.flag_modified(db_template, field)
            changed = True
            
    if changed:
        db.add(db_template)
    return db_template

def delete_skill_template(db: Session, skill_template_id: uuid.UUID) -> Optional[models.SkillTemplate]:
    db_template = get_skill_template(db, skill_template_id)
    if db_template:
        db.delete(db_template)
        db.commit() # Deletion is usually a direct action, commit immediately.
    return db_template

# --- Seeding Initial Skill Templates ---
def seed_initial_skill_templates(db: Session):
    logger.info("Attempting to seed initial skill templates from skills.json...")
    skill_template_definitions = _load_seed_data_generic("skills.json", "Skill template")

    if not skill_template_definitions:
        logger.warning("No skill template definitions found or error loading skills.json. Aborting skill template seeding.")
        return

    seeded_count = 0
    updated_count = 0
    skipped_count = 0

    for template_data in skill_template_definitions:
        template_tag = template_data.get("skill_id_tag")
        template_name = template_data.get("name") 
        if not template_tag or not template_name:
            logger.warning(f"Skipping skill template entry due to missing skill_id_tag or name: {template_data}")
            skipped_count += 1
            continue
        
        existing_template = get_skill_template_by_tag(db, skill_id_tag=template_tag)
        
        try:
            if existing_template:
                template_update_schema = schemas.SkillTemplateUpdate(**template_data)
                update_skill_template(db, db_template=existing_template, template_in=template_update_schema)
                
                # Simplified check for logging updates
                # A more robust check would compare dicts before and after potential update_skill_template modifications
                # For now, if the object is in session and dirty, it's an update.
                # Or, if update_skill_template itself indicated a change.
                # Let's assume a change if any field in template_data differs from existing_template
                original_dump = schemas.SkillTemplate.from_orm(existing_template).model_dump(exclude={'id'})
                current_data_dump = schemas.SkillTemplateCreate(**template_data).model_dump() # Use Create schema for full data
                
                is_actually_changed = False
                for key, value_from_json in current_data_dump.items():
                    if original_dump.get(key) != value_from_json:
                        is_actually_changed = True
                        break
                if is_actually_changed:
                    logger.info(f"Updating skill template: {template_name} ({template_tag})")
                    updated_count += 1
                else:
                    # logger.debug(f"Skill template '{template_name}' ({template_tag}) exists and no changes detected.")
                    skipped_count +=1
            else: 
                template_create_schema = schemas.SkillTemplateCreate(**template_data)
                logger.info(f"Creating skill template: {template_create_schema.name} ({template_create_schema.skill_id_tag})")
                create_skill_template(db, template_in=template_create_schema)
                seeded_count += 1
        except Exception as e_pydantic_or_db:
            logger.error(f"Validation or DB operation failed for skill template '{template_name}' ({template_tag}): {e_pydantic_or_db}. Data: {template_data}", exc_info=True)
            skipped_count += 1
            db.rollback()
            continue

    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new and {updated_count} updated skill templates.")
            db.commit()
            logger.info("Skill template seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing skill template seeds: {e_commit}. Rolling back.", exc_info=True)
            db.rollback()
    else:
        logger.info("No new skill templates to seed or templates to update. No commit needed for skill templates.")

    logger.info(f"Skill template seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")
--- END OF FILE backend/app/crud/crud_skill.py ---

--- START OF FILE backend/app/crud/crud_trait.py ---
# backend/app/crud/crud_trait.py
import json # For loading JSON
import os   # For path joining
import logging # For logging
from sqlalchemy.orm import Session, attributes # Added attributes
import uuid
from typing import List, Optional, Dict, Any # Added Dict, Any

from .. import models, schemas

logger = logging.getLogger(__name__)

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_generic(filename: str, data_type_name: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"{data_type_name} seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {data_type_name} seed file {filepath}: {e}")
        return []

def get_trait_template(db: Session, trait_template_id: uuid.UUID) -> Optional[models.TraitTemplate]:
    return db.query(models.TraitTemplate).filter(models.TraitTemplate.id == trait_template_id).first()

def get_trait_template_by_tag(db: Session, trait_id_tag: str) -> Optional[models.TraitTemplate]:
    return db.query(models.TraitTemplate).filter(models.TraitTemplate.trait_id_tag == trait_id_tag).first()

def get_trait_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.TraitTemplate]:
    return db.query(models.TraitTemplate).offset(skip).limit(limit).all()

def create_trait_template(db: Session, *, template_in: schemas.TraitTemplateCreate) -> models.TraitTemplate:
    # Unique check handled by seeder.
    db_template = models.TraitTemplate(**template_in.model_dump())
    db.add(db_template)
    # Commit and refresh handled by caller.
    return db_template

def update_trait_template(
    db: Session, *, 
    db_template: models.TraitTemplate, 
    template_in: schemas.TraitTemplateUpdate
) -> models.TraitTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    changed = False

    if "trait_id_tag" in update_data and update_data["trait_id_tag"] != db_template.trait_id_tag:
        existing_with_new_tag = get_trait_template_by_tag(db, trait_id_tag=update_data["trait_id_tag"])
        if existing_with_new_tag and existing_with_new_tag.id != db_template.id:
            logger.warning(f"Cannot update trait_id_tag for '{db_template.name}' to '{update_data['trait_id_tag']}', it's already in use by '{existing_with_new_tag.name}'. Skipping tag update.")
            del update_data["trait_id_tag"]
        elif "trait_id_tag" in update_data: # If tag can be updated
             setattr(db_template, "trait_id_tag", update_data["trait_id_tag"])
             changed = True
             
    for field, value in update_data.items():
        if field == "trait_id_tag": continue

        if getattr(db_template, field) != value:
            setattr(db_template, field, value)
            if field in ['effects_data', 'mutually_exclusive_with']: # JSONB fields
                attributes.flag_modified(db_template, field)
            changed = True

    if changed:
        db.add(db_template)
    return db_template

def delete_trait_template(db: Session, trait_template_id: uuid.UUID) -> Optional[models.TraitTemplate]:
    db_template = get_trait_template(db, trait_template_id)
    if db_template:
        db.delete(db_template)
        db.commit() # Deletion is usually a direct action.
    return db_template

# --- Seeding Initial Trait Templates ---
def seed_initial_trait_templates(db: Session):
    logger.info("Attempting to seed initial trait templates from traits.json...")
    trait_template_definitions = _load_seed_data_generic("traits.json", "Trait template")

    if not trait_template_definitions:
        logger.warning("No trait template definitions found or error loading traits.json. Aborting trait template seeding.")
        return

    seeded_count = 0
    updated_count = 0
    skipped_count = 0

    for template_data in trait_template_definitions:
        template_tag = template_data.get("trait_id_tag")
        template_name = template_data.get("name")
        if not template_tag or not template_name:
            logger.warning(f"Skipping trait template entry due to missing trait_id_tag or name: {template_data}")
            skipped_count += 1
            continue
        
        existing_template = get_trait_template_by_tag(db, trait_id_tag=template_tag)
        
        try:
            if existing_template:
                template_update_schema = schemas.TraitTemplateUpdate(**template_data)
                update_trait_template(db, db_template=existing_template, template_in=template_update_schema)

                original_dump = schemas.TraitTemplate.from_orm(existing_template).model_dump(exclude={'id'})
                current_data_dump = schemas.TraitTemplateCreate(**template_data).model_dump()
                is_actually_changed = False
                for key, value_from_json in current_data_dump.items():
                    if original_dump.get(key) != value_from_json:
                        is_actually_changed = True
                        break
                if is_actually_changed:
                    logger.info(f"Updating trait template: {template_name} ({template_tag})")
                    updated_count += 1
                else:
                    # logger.debug(f"Trait template '{template_name}' ({template_tag}) exists and no changes detected.")
                    skipped_count +=1
            else:
                template_create_schema = schemas.TraitTemplateCreate(**template_data)
                logger.info(f"Creating trait template: {template_create_schema.name} ({template_create_schema.trait_id_tag})")
                create_trait_template(db, template_in=template_create_schema)
                seeded_count += 1
        except Exception as e_pydantic_or_db:
            logger.error(f"Validation or DB operation failed for trait template '{template_name}' ({template_tag}): {e_pydantic_or_db}. Data: {template_data}", exc_info=True)
            skipped_count += 1
            db.rollback()
            continue

    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new and {updated_count} updated trait templates.")
            db.commit()
            logger.info("Trait template seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing trait template seeds: {e_commit}. Rolling back.", exc_info=True)
            db.rollback()
    else:
        logger.info("No new trait templates to seed or templates to update. No commit needed for trait templates.")

    logger.info(f"Trait template seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")
--- END OF FILE backend/app/crud/crud_trait.py ---

--- START OF FILE backend/app/crud/crud_character_class.py ---
# backend/app/crud/crud_character_class.py
import json # For loading JSON
import os   # For path joining
import logging # For logging
from sqlalchemy.orm import Session, attributes # Added attributes
import uuid
from typing import List, Optional, Dict, Any # Added Dict, Any

from .. import models, schemas

logger = logging.getLogger(__name__) # Get a logger

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_generic(filename: str, data_type_name: str) -> List[Dict[str, Any]]: # Copied from crud_mob
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"{data_type_name} seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {data_type_name} seed file {filepath}: {e}")
        return []

def get_character_class_template(db: Session, class_template_id: uuid.UUID) -> Optional[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).filter(models.CharacterClassTemplate.id == class_template_id).first()

def get_character_class_template_by_name(db: Session, name: str) -> Optional[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).filter(models.CharacterClassTemplate.name == name).first()

def get_character_class_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).offset(skip).limit(limit).all()

def create_character_class_template(db: Session, *, template_in: schemas.CharacterClassTemplateCreate) -> models.CharacterClassTemplate:
    db_template = models.CharacterClassTemplate(**template_in.model_dump())
    db.add(db_template)
    # db.commit() # Commit handled by seeder or calling function
    # db.refresh(db_template)
    return db_template

def update_character_class_template(
    db: Session, *, 
    db_template: models.CharacterClassTemplate, 
    template_in: schemas.CharacterClassTemplateUpdate
) -> models.CharacterClassTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    changed = False
    for field, value in update_data.items():
        if getattr(db_template, field) != value:
            setattr(db_template, field, value)
            # For JSONB fields, ensure they are flagged if necessary
            if field in ['base_stat_modifiers', 'skill_tree_definition', 'starting_equipment_refs', 'playstyle_tags']:
                attributes.flag_modified(db_template, field)
            changed = True
    if changed:
        db.add(db_template)
    return db_template # Return template whether changed or not

def delete_character_class_template(db: Session, class_template_id: uuid.UUID) -> Optional[models.CharacterClassTemplate]:
    db_template = get_character_class_template(db, class_template_id)
    if db_template:
        db.delete(db_template)
        db.commit()
    return db_template

# --- Seeding Initial Class Templates ---
def seed_initial_character_class_templates(db: Session):
    logger.info("Attempting to seed initial character class templates from character_classes.json...")
    class_template_definitions = _load_seed_data_generic("character_classes.json", "Character class template")

    if not class_template_definitions:
        logger.warning("No character class definitions found or error loading character_classes.json. Aborting class template seeding.")
        return

    seeded_count = 0
    updated_count = 0
    skipped_count = 0

    for template_data in class_template_definitions:
        template_name = template_data.get("name")
        if not template_name:
            logger.warning(f"Skipping class template entry due to missing name: {template_data}")
            skipped_count += 1
            continue

        existing_template = get_character_class_template_by_name(db, name=template_name)
        
        try:
            if existing_template:
                template_update_schema = schemas.CharacterClassTemplateUpdate(**template_data)
                # Pass the ORM object and the Pydantic update schema to the update function
                update_character_class_template(db, db_template=existing_template, template_in=template_update_schema)
                
                # Crude check for logging if changes were actually made
                original_dump = schemas.CharacterClassTemplate.from_orm(existing_template).model_dump(exclude={'id'})
                updated_dump_from_data = schemas.CharacterClassTemplateCreate(**template_data).model_dump()
                is_actually_changed = False
                for key, value_from_json in updated_dump_from_data.items():
                    if original_dump.get(key) != value_from_json:
                        is_actually_changed = True
                        break
                if is_actually_changed:
                    logger.info(f"Updating character class template: {template_name}")
                    updated_count += 1
                else:
                    # logger.debug(f"Class template '{template_name}' exists and no changes detected.")
                    skipped_count +=1
            else:
                template_create_schema = schemas.CharacterClassTemplateCreate(**template_data)
                logger.info(f"Creating character class template: {template_create_schema.name}")
                create_character_class_template(db, template_in=template_create_schema)
                seeded_count += 1
        except Exception as e_pydantic_or_db:
            logger.error(f"Pydantic validation or DB operation failed for class template '{template_name}': {e_pydantic_or_db}. Data: {template_data}", exc_info=True)
            skipped_count += 1
            db.rollback() # Rollback this specific item's attempt
            continue

    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new and {updated_count} updated class templates.")
            db.commit()
            logger.info("Character class template seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing class template seeds: {e_commit}. Rolling back.", exc_info=True)
            db.rollback()
    else:
        logger.info("No new class templates to seed or templates to update. No commit needed for class templates.")

    logger.info(f"Character class template seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")
--- END OF FILE backend/app/crud/crud_character_class.py ---

--- START OF FILE backend/app/crud/crud_mob_spawn_definition.py ---
# backend/app/crud/crud_mob_spawn_definition.py
from sqlalchemy.orm import Session
import uuid
from datetime import datetime, timedelta, timezone # Added timezone
from typing import List, Optional

from .. import models, schemas # Uses new MobSpawnDefinition schemas
from ..crud import crud_room, crud_mob # For seeder

# --- MobSpawnDefinition CRUD ---

def get_mob_spawn_definition(db: Session, definition_id: uuid.UUID) -> Optional[models.MobSpawnDefinition]:
    return db.query(models.MobSpawnDefinition).filter(models.MobSpawnDefinition.id == definition_id).first()

def get_mob_spawn_definition_by_name(db: Session, definition_name: str) -> Optional[models.MobSpawnDefinition]:
    return db.query(models.MobSpawnDefinition).filter(models.MobSpawnDefinition.definition_name == definition_name).first()

def get_definitions_ready_for_check(db: Session, current_time: datetime, limit: int = 1000) -> List[models.MobSpawnDefinition]:
    """
    Gets active spawn definitions whose next_respawn_check_at is due.
    Or where next_respawn_check_at is NULL (meaning they haven't been processed yet or need immediate check).
    """
    return db.query(models.MobSpawnDefinition).filter(
        models.MobSpawnDefinition.is_active == True,
        (models.MobSpawnDefinition.next_respawn_check_at == None) | (models.MobSpawnDefinition.next_respawn_check_at <= current_time)
    ).limit(limit).all()

def create_mob_spawn_definition(db: Session, *, definition_in: schemas.MobSpawnDefinitionCreate) -> models.MobSpawnDefinition:
    # Basic validation
    if definition_in.quantity_min > definition_in.quantity_max:
        raise ValueError("quantity_min cannot be greater than quantity_max")

    existing = get_mob_spawn_definition_by_name(db, definition_name=definition_in.definition_name)
    if existing:
        # Handle error or return existing one; for now, let's assume names should be unique
        raise ValueError(f"MobSpawnDefinition with name '{definition_in.definition_name}' already exists.")

    db_definition_data = definition_in.model_dump()
    # Set initial next_respawn_check_at to now to make it eligible for first check
    db_definition_data["next_respawn_check_at"] = datetime.now(timezone.utc)
    
    db_definition = models.MobSpawnDefinition(**db_definition_data)
    db.add(db_definition)
    db.commit()
    db.refresh(db_definition)
    return db_definition

def update_mob_spawn_definition_next_check_time(
    db: Session, *, 
    definition_id: uuid.UUID, 
    next_check_time: datetime
) -> Optional[models.MobSpawnDefinition]:
    db_definition = get_mob_spawn_definition(db, definition_id)
    if db_definition:
        db_definition.next_respawn_check_at = next_check_time
        db.add(db_definition)
        db.commit() # Commit immediately as this is a frequent state update
        db.refresh(db_definition)
        return db_definition
    return None

def update_mob_spawn_definition(
    db: Session, *,
    db_definition: models.MobSpawnDefinition,
    definition_in: schemas.MobSpawnDefinitionUpdate
) -> models.MobSpawnDefinition:
    update_data = definition_in.model_dump(exclude_unset=True)
    if "quantity_min" in update_data and "quantity_max" in update_data:
        if update_data["quantity_min"] > update_data["quantity_max"]:
            raise ValueError("quantity_min cannot be greater than quantity_max")
    elif "quantity_min" in update_data:
        if update_data["quantity_min"] > db_definition.quantity_max:
            raise ValueError("quantity_min cannot be greater than current quantity_max")
    elif "quantity_max" in update_data:
        if db_definition.quantity_min > update_data["quantity_max"]:
            raise ValueError("current quantity_min cannot be greater than new quantity_max")

    for field, value in update_data.items():
        setattr(db_definition, field, value)
    db.add(db_definition)
    db.commit()
    db.refresh(db_definition)
    return db_definition


# --- Seeding ---
def seed_initial_mob_spawn_definitions(db: Session):
    print("Attempting to seed initial mob spawn definitions...")
    cpu_room = crud_room.get_room_by_coords(db, x=0, y=0, z=0)
    rat_template = crud_mob.get_mob_template_by_name(db, name="Giant Rat")
    goblin_template = crud_mob.get_mob_template_by_name(db, name="Goblin Scout")
    personnel_room = crud_room.get_room_by_coords(db, x=2, y=0, z=0) 
    
    definitions_to_seed = []
    if cpu_room and rat_template:
        definitions_to_seed.append(schemas.MobSpawnDefinitionCreate(
            definition_name="CPURatsMain", room_id=cpu_room.id, mob_template_id=rat_template.id,
            quantity_min=1, quantity_max=2, respawn_delay_seconds=60,
            roaming_behavior={"type": "random_adjacent", "move_chance_percent": 40, "max_distance_from_spawn": 2} # <<< ADD ROAMING
        ))
    if personnel_room and goblin_template:
        definitions_to_seed.append(schemas.MobSpawnDefinitionCreate(
            definition_name="PersonnelIntakeGoblinSentry", room_id=personnel_room.id, mob_template_id=goblin_template.id,
            quantity_min=1, quantity_max=1, respawn_delay_seconds=180 
            # Goblin is AGGRESSIVE_ON_SIGHT from its template, no specific roaming here.
        ))

    seeded_count = 0
    for def_in in definitions_to_seed:
        existing_def = get_mob_spawn_definition_by_name(db, definition_name=def_in.definition_name)
        if not existing_def:
            create_mob_spawn_definition(db, definition_in=def_in)
            print(f"  Created mob spawn definition: {def_in.definition_name}")
            seeded_count += 1
        else:
            # Optionally update existing definitions
            print(f"  Mob spawn definition '{def_in.definition_name}' already exists. Current roaming: {existing_def.roaming_behavior}, Seeded: {def_in.roaming_behavior}")
            if existing_def.roaming_behavior != def_in.roaming_behavior: # Simple dict comparison
                print(f"    Updating roaming behavior for {existing_def.definition_name}")
                existing_def.roaming_behavior = def_in.roaming_behavior
                db.add(existing_def)
                db.commit() # Commit update
    
    if seeded_count > 0: print(f"Seeded {seeded_count} new mob spawn definitions.")
    print("Mob spawn definition seeding complete.")
--- END OF FILE backend/app/crud/crud_mob_spawn_definition.py ---

--- START OF FILE backend/app/schemas/item.py ---
# backend/app/schemas/item.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- Item Schemas ---
class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    item_type: str = Field(..., description="e.g., weapon, armor, potion, junk")
    slot: Optional[str] = Field(None, description="Primary equippable slot type, e.g., head, main_hand, consumable")
    properties: Optional[Dict[str, Any]] = Field(None, description="e.g., {'damage': '1d6', 'armor_class': 5}")
    weight: float = Field(0.0, ge=0)
    value: int = Field(0, ge=0)
    stackable: bool = False
    max_stack_size: Optional[int] = Field(1, ge=1)

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    item_type: Optional[str] = None
    slot: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    weight: Optional[float] = None
    value: Optional[int] = None
    stackable: Optional[bool] = None
    max_stack_size: Optional[int] = None

class ItemInDBBase(ItemBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class Item(ItemInDBBase): # For returning item info
    pass

class ItemInDB(ItemInDBBase): # More complete internal representation if needed
    pass


# --- CharacterInventoryItem Schemas ---
# This represents an item *instance* in a character's inventory

class CharacterInventoryItemBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    equipped: bool = False
    equipped_slot: Optional[str] = None # Actual character slot occupied if equipped

class CharacterInventoryItemCreate(CharacterInventoryItemBase):
    # character_id will be supplied by the service/path
    pass

class CharacterInventoryItemUpdate(BaseModel):
    quantity: Optional[int] = Field(None, ge=1)
    equipped: Optional[bool] = None
    equipped_slot: Optional[str] = None

class CharacterInventoryItemInDBBase(CharacterInventoryItemBase):
    id: uuid.UUID # The unique ID of this inventory entry
    character_id: uuid.UUID
    item: Item # Include full item details when displaying inventory

    class Config:
        from_attributes = True

class CharacterInventoryItem(CharacterInventoryItemInDBBase): # For returning to client
    pass


# --- Composite Schema for Displaying Full Inventory ---
class CharacterInventoryDisplay(BaseModel):
    equipped_items: Dict[str, CharacterInventoryItem] = Field(default_factory=dict, description="Items currently equipped, keyed by their equipped_slot")
    backpack_items: List[CharacterInventoryItem] = Field(default_factory=list, description="Items in inventory but not equipped")
    platinum: int = 0
    gold: int = 0
    silver: int = 0
    copper: int = 0
    # Add more fields like total_weight, currency later

class EquipRequest(BaseModel):
    target_slot: Optional[str] = Field(None, description="Optional: The specific character slot to equip the item to, e.g., 'finger_1'")
--- END OF FILE backend/app/schemas/item.py ---

--- START OF FILE backend/app/schemas/room.py ---
# backend/app/schemas/room.py
from pydantic import BaseModel, Field
import uuid
from typing import Dict, Optional, Any, List

# Import the new detail schemas and RoomTypeEnum
from ..models.room import RoomTypeEnum # <<< Import from models
from .common_structures import ExitDetail, InteractableDetail

class RoomBase(BaseModel):
    name: str
    description: Optional[str] = None
    x: int
    y: int
    z: int
    room_type: RoomTypeEnum = Field(default=RoomTypeEnum.STANDARD) # <<< NEW FIELD
    exits: Optional[Dict[str, ExitDetail]] = Field(default_factory=dict) 
    interactables: Optional[List[InteractableDetail]] = Field(default_factory=list)

class RoomCreate(RoomBase):
    id: Optional[uuid.UUID] = None 
    pass

class RoomUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    x: Optional[int] = None
    y: Optional[int] = None
    z: Optional[int] = None
    room_type: Optional[RoomTypeEnum] = None # <<< NEW FIELD
    exits: Optional[Dict[str, ExitDetail]] = None
    interactables: Optional[List[InteractableDetail]] = None

class RoomInDB(RoomBase):
    id: uuid.UUID
    # room_type is already in RoomBase

    class Config:
        from_attributes = True
--- END OF FILE backend/app/schemas/room.py ---

--- START OF FILE backend/app/schemas/mob.py ---
# backend/app/schemas/mob.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field, validator
from typing import Optional, Dict, Any, List

# --- MobTemplate Schemas ---
class MobTemplateBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    
    level: Optional[int] = Field(1, ge=0) 
    base_health: int = Field(10, gt=0)
    base_mana: Optional[int] = Field(0, ge=0) # <<< MODIFIED
    base_attack: Optional[str] = Field("1d4") 
    base_defense: Optional[int] = Field(10, ge=0)
    
    attack_speed_secs: Optional[float] = Field(3.0, gt=0, description="Time in seconds between attacks.") # <<< MODIFIED
    aggro_radius: Optional[int] = Field(5, ge=0, description="Radius in map units for auto-aggression.") # <<< MODIFIED
    roam_radius: Optional[int] = Field(0, ge=0, description="Radius from spawn point for roaming behavior. 0 means stationary unless pulled.") # <<< MODIFIED
    
    xp_value: int = Field(0, ge=0)
    
    loot_table_tags: Optional[List[str]] = Field(default_factory=list, description="Tags to determine loot drops, e.g., ['goblin_common', 'small_treasure']") # <<< MODIFIED
    currency_drop: Optional[Dict[str, Any]] = Field(None, description="Defines currency drop amounts and chances.") # <<< MODIFIED
    
    dialogue_lines: Optional[List[str]] = Field(default_factory=list, description="Lines the mob might say.") # <<< MODIFIED
    faction_tags: Optional[List[str]] = Field(default_factory=list, description="Faction affiliations, e.g., ['goblins', 'undead']") # <<< MODIFIED
    special_abilities: Optional[List[str]] = Field(default_factory=list, description="List of skill/ability tags the mob possesses.") # <<< MODIFIED
    
    properties: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Generic properties bag for future expansion.")
    
    @validator('currency_drop', pre=True, always=True)
    def check_currency_drop(cls, v):
        if v is None: # If the input JSON doesn't have currency_drop, this sets a default structure
            return {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        # If v is provided, ensure all keys are present, defaulting to 0 if missing
        # This makes downstream access safer (e.g. mob_template.currency_drop.get("c_min", 0) will always work)
        default_keys = {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        if isinstance(v, dict):
            for key, default_val in default_keys.items():
                v.setdefault(key, default_val)
        return v

class MobTemplateCreate(MobTemplateBase):
    pass

class MobTemplateUpdate(BaseModel): # Does NOT inherit from MobTemplateBase
    name: Optional[str] = Field(None, min_length=1, max_length=100) # All fields are optional
    description: Optional[str] = None
    level: Optional[int] = Field(None, ge=0) 
    base_health: Optional[int] = Field(None, gt=0)
    base_mana: Optional[int] = Field(None, ge=0) 
    base_attack: Optional[str] = None
    base_defense: Optional[int] = Field(None, ge=0)
    attack_speed_secs: Optional[float] = Field(None, gt=0)
    aggro_radius: Optional[int] = Field(None, ge=0)
    roam_radius: Optional[int] = Field(None, ge=0)
    xp_value: Optional[int] = Field(None, ge=0)
    loot_table_tags: Optional[List[str]] = None
    currency_drop: Optional[Dict[str, Any]] = None
    dialogue_lines: Optional[List[str]] = None
    faction_tags: Optional[List[str]] = None
    special_abilities: Optional[List[str]] = None
    properties: Optional[Dict[str, Any]] = None
    
    @validator('currency_drop', pre=True, always=True)
    def check_currency_drop_update(cls, v): # Validator for update too
        if v is None:
            return None # If not provided in update, it remains None, won't overwrite with defaults
        
        default_keys = {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        if isinstance(v, dict):
            # For update, only fill missing keys if the currency_drop field itself is provided
            # This allows partial updates like just changing 'c_min'
            # No, this is wrong. If 'currency_drop' is provided, it should be a complete structure or pydantic will complain.
            # The validator should ensure that IF 'currency_drop' is given, it's valid.
            # The BaseSettings with `extra='ignore'` for `model_config` is for the top-level Settings, not for these Pydantic models.
            # The current validator on MobTemplateBase already handles setting defaults IF currency_drop is provided.
            # For updates, if currency_drop is in the payload, it must be valid. If it's not, it's not updated.
            # This validator needs to be smarter or removed for Update, relying on the Base validator if the field is present.
            # Let's simplify: if it's present, it's validated by MobTemplateBase's logic if inherited, or by its own Field types.
            # The goal is to ensure that IF currency_drop is being set/updated, it's a valid structure.
            # Let's stick to the original validator on MobTemplateBase. Pydantic will handle validation on update if the field is present.
            # The `always=True` and `pre=True` means it runs even if the field is not in the input data for `Create`.
            # For `Update`, if the field is not in the input, the validator for `currency_drop` (inherited or direct) won't run.
            # So, the validator on MobTemplateBase is what we need for creation. For update, it's fine.
            pass # No specific validator needed for Update if fields are optional.
                 # Relies on field constraints.
        return v


class MobTemplateInDBBase(MobTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class MobTemplate(MobTemplateInDBBase): 
    pass


# --- RoomMobInstance Schemas ---
class RoomMobInstanceBase(BaseModel):
    mob_template_id: uuid.UUID
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None

class RoomMobInstanceCreate(BaseModel): 
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    instance_properties_override: Optional[Dict[str, Any]] = None 
    spawn_definition_id: Optional[uuid.UUID] = None
    
class RoomMobInstanceUpdate(BaseModel): 
    current_health: Optional[int] = None
    instance_properties_override: Optional[Dict[str, Any]] = Field(None, description="Use with caution, replaces entire dict")

class RoomMobInstanceInDBBase(BaseModel): 
    id: uuid.UUID
    room_id: uuid.UUID
    mob_template_id: uuid.UUID 
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None
    spawn_definition_id: Optional[uuid.UUID] = None
    spawned_at: datetime
    last_action_at: Optional[datetime] = None
    
    mob_template: MobTemplate # Changed from MobTemplateInDB to MobTemplate for consistency

    class Config:
        from_attributes = True

class RoomMobInstance(RoomMobInstanceInDBBase): 
    pass

class RoomMobsView(BaseModel):
    mobs_in_room: List[RoomMobInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/mob.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)

    # Currency: Optional at creation, with defaults
    platinum_coins: Optional[int] = Field(0, description="Platinum coins owned by the character")
    gold_coins: Optional[int] = Field(0, description="Gold coins owned by the character")
    silver_coins: Optional[int] = Field(0, description="Silver coins owned by the character")
    copper_coins: Optional[int] = Field(100, description="Copper coins owned by the character, default 100 for new chars")

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):  # Inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    platinum_coins: int # type: ignore
    gold_coins: int # type: ignore
    silver_coins: int # type: ignore
    copper_coins: int # type: ignore

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/schemas/character_class_template.py ---
# backend/app/schemas/character_class_template.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List, Union # <<< Added Union

class CharacterClassTemplateBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=100)
    description: Optional[str] = None
    base_stat_modifiers: Optional[Dict[str, int]] = Field(default_factory=dict)
    starting_health_bonus: int = 0
    starting_mana_bonus: int = 0
    skill_tree_definition: Optional[Dict[str, Any]] = Field(default_factory=dict)
    starting_equipment_refs: Optional[List[str]] = Field(default_factory=list)
    playstyle_tags: Optional[List[str]] = Field(default_factory=list)
    # <<< NEW FIELD >>>
    stat_gains_per_level: Optional[Dict[str, Union[int, float]]] = Field(
        default_factory=dict,
        description="Defines HP, MP, BAB, etc. gains per level. E.g. {'hp': 5, 'mp': 1, 'base_attack_bonus': 0.5}"
    )


class CharacterClassTemplateCreate(CharacterClassTemplateBase):
    pass

class CharacterClassTemplateUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    base_stat_modifiers: Optional[Dict[str, int]] = None
    starting_health_bonus: Optional[int] = None
    starting_mana_bonus: Optional[int] = None
    skill_tree_definition: Optional[Dict[str, Any]] = None
    starting_equipment_refs: Optional[List[str]] = None
    playstyle_tags: Optional[List[str]] = None
    # <<< NEW FIELD >>>
    stat_gains_per_level: Optional[Dict[str, Union[int, float]]] = None


class CharacterClassTemplateInDBBase(CharacterClassTemplateBase):
    id: uuid.UUID
    class Config:
        from_attributes = True

class CharacterClassTemplate(CharacterClassTemplateInDBBase):
    pass

class CharacterClassTemplateInDB(CharacterClassTemplateInDBBase):
    pass
--- END OF FILE backend/app/schemas/character_class_template.py ---

--- START OF FILE backend/app/schemas/skill.py ---
# backend/app/schemas/skill.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List # Added List

class SkillTemplateBase(BaseModel):
    skill_id_tag: str = Field(..., min_length=3, max_length=100, pattern="^[a-z0-9_]+$",
                               description="Unique internal identifier, e.g., 'power_attack'. Lowercase, numbers, underscores.")
    name: str = Field(..., min_length=3, max_length=100, description="Player-facing name, e.g., 'Power Attack'")
    description: Optional[str] = None
    skill_type: str = Field(..., description="e.g., 'COMBAT_ACTIVE', 'PASSIVE', 'UTILITY_OOC'")
    target_type: str = Field(default="NONE", description="e.g., 'SELF', 'ENEMY_MOB', 'NONE'")
    effects_data: Dict[str, Any] = Field(default_factory=dict)
    requirements_data: Optional[Dict[str, Any]] = Field(default_factory=dict)
    rank: Optional[int] = Field(1, ge=1)
    cooldown: Optional[int] = Field(0, ge=0)

class SkillTemplateCreate(SkillTemplateBase):
    pass

class SkillTemplateUpdate(BaseModel): # For partial updates
    skill_id_tag: Optional[str] = Field(None, min_length=3, max_length=100, pattern="^[a-z0-9_]+$")
    name: Optional[str] = Field(None, min_length=3, max_length=100)
    description: Optional[str] = None
    skill_type: Optional[str] = None
    target_type: Optional[str] = None
    effects_data: Optional[Dict[str, Any]] = None
    requirements_data: Optional[Dict[str, Any]] = None
    rank: Optional[int] = Field(None, ge=1)
    cooldown: Optional[int] = Field(None, ge=0)

class SkillTemplateInDBBase(SkillTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class SkillTemplate(SkillTemplateInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/skill.py ---

--- START OF FILE backend/app/schemas/trait.py ---
# backend/app/schemas/trait.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List # Added List

class TraitTemplateBase(BaseModel):
    trait_id_tag: str = Field(..., min_length=3, max_length=100, pattern="^[a-z0-9_]+$",
                                description="Unique internal identifier, e.g., 'nimble_fingers'. Lowercase, numbers, underscores.")
    name: str = Field(..., min_length=3, max_length=100, description="Player-facing name, e.g., 'Nimble Fingers'")
    description: Optional[str] = None
    trait_type: str = Field(default="PASSIVE", description="e.g., 'PASSIVE', 'SOCIAL'")
    effects_data: Dict[str, Any] = Field(default_factory=dict)
    mutually_exclusive_with: Optional[List[str]] = Field(default_factory=list)

class TraitTemplateCreate(TraitTemplateBase):
    pass

class TraitTemplateUpdate(BaseModel): # For partial updates
    trait_id_tag: Optional[str] = Field(None, min_length=3, max_length=100, pattern="^[a-z0-9_]+$")
    name: Optional[str] = None
    description: Optional[str] = None
    trait_type: Optional[str] = None
    effects_data: Optional[Dict[str, Any]] = None
    mutually_exclusive_with: Optional[List[str]] = None

class TraitTemplateInDBBase(TraitTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class TraitTemplate(TraitTemplateInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/trait.py ---

--- START OF FILE backend/app/schemas/common_structures.py ---
# backend/app/schemas/common_structures.py

import uuid
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

class ExitSkillToPickDetail(BaseModel):
    skill_id_tag: str = Field(..., description="Skill ID tag required to pick this lock, e.g., 'pick_lock_basic'")
    dc: int = Field(..., description="Difficulty Class for the skill check.")

class ExitDetail(BaseModel):
    target_room_id: uuid.UUID = Field(..., description="UUID of the room this exit leads to.")
    is_locked: bool = Field(False, description="Is this exit currently locked?")
    lock_id_tag: Optional[str] = Field(None, description="Unique tag for this lock instance, for interactables to target.")
    key_item_tag_opens: Optional[str] = Field(None, description="Item tag (or name) that can unlock this door.")
    skill_to_pick: Optional[ExitSkillToPickDetail] = Field(None, description="Skill and DC needed to pick the lock.")
    description_when_locked: str = Field("It's securely locked.", description="Message shown if player tries to move through a locked door.")
    description_when_unlocked: Optional[str] = Field(None, description="Alternate description for this exit when it is unlocked (e.g., 'The way stands open.'). Used by dynamic room descriptions.")
    force_open_dc: Optional[int] = Field(None, description="DC for a strength check to bash the door open.")

class InteractableEffectDetail(BaseModel):
    type: str = Field(..., description="Type of effect, e.g., 'toggle_exit_lock', 'spawn_item', 'custom_event'.")
    
    target_exit_direction: Optional[str] = Field(None, description="Direction of the exit in the current room to toggle lock state (e.g., 'north').")
    
    message_success_self: Optional[str] = Field("You interact with it, and something happens.", description="Message to the character performing the action on success.")
    message_success_others: Optional[str] = Field("Someone interacts with something, and something happens.", description="Message to others in the room on success.")
    
    message_fail_self: str = Field(default="You try, but nothing seems to happen.", description="Message to self on failure (e.g. DC fail, wrong item).")
    message_fail_others: str = Field(default="Someone fumbles with something.", description="Message to others on failure.")
        
class InteractableDetail(BaseModel):
    id_tag: str = Field(..., description="Unique ID for this interactable within the room, e.g., 'rusty_lever', 'stone_pedestal'.")
    name: str = Field(..., description="Short name for targeting and initial look, e.g., 'a rusty lever'.")
    description: str = Field(..., description="Detailed description when examined or revealed.")
    
    is_hidden: bool = Field(False, description="Is this interactable initially hidden?")
    reveal_dc_perception: Optional[int] = Field(None, description="Perception DC to reveal if hidden. If None and is_hidden, needs specific trigger or is always hidden until event.")
    revealed_to_char_ids: List[uuid.UUID] = Field(default_factory=list, description="List of character UUIDs who have revealed this interactable.")

    action_verb: str = Field("examine", description="Primary verb to interact, e.g., 'pull', 'push', 'touch', 'insert'.")
    on_interact_effect: InteractableEffectDetail = Field(..., description="Defines what happens upon successful interaction.")
--- END OF FILE backend/app/schemas/common_structures.py ---

--- START OF FILE backend/app/api/v1/endpoints/command.py ---
# backend/app/api/v1/endpoints/command.py
from fastapi import APIRouter, Depends, Body
from sqlalchemy.orm import Session
from typing import Dict, Callable, Awaitable # For typing the registry

from app import schemas, models, crud # app.
from app.db.session import get_db
from app.api.dependencies import get_current_active_character # app.api.dependencies
from app.commands.command_args import CommandContext # app.commands.command_args

# Import handler modules
from app.commands import movement_parser
from app.commands import inventory_parser
from app.commands import social_parser
from app.commands import debug_parser
from app.commands import meta_parser
# from app.commands import combat_parser 
from app.commands import interaction_parser

import logging
logger = logging.getLogger(__name__)


router = APIRouter()

# Define the type for our handler functions
CommandHandler = Callable[[CommandContext], Awaitable[schemas.CommandResponse]] # If handlers are async
# Or if synchronous: CommandHandler = Callable[[CommandContext], schemas.CommandResponse]
# Let's assume handlers can be async for future flexibility, even if current ones are not.

COMMAND_REGISTRY: Dict[str, CommandHandler] = {
    # Movement and Perception
    "look": movement_parser.handle_look,
    "l": movement_parser.handle_look,
    "north": movement_parser.handle_move,
    "n": movement_parser.handle_move,
    "south": movement_parser.handle_move,
    "s": movement_parser.handle_move,
    "east": movement_parser.handle_move,
    "e": movement_parser.handle_move,   
    "west": movement_parser.handle_move,
    "w": movement_parser.handle_move,
    "up": movement_parser.handle_move,
    "u": movement_parser.handle_move,
    "down": movement_parser.handle_move,
    "d": movement_parser.handle_move,
    "go": movement_parser.handle_move, # "go north" will be handled by move knowing original command

    # Inventory Management
    "inventory": inventory_parser.handle_inventory,
    "i": inventory_parser.handle_inventory,
    "equip": inventory_parser.handle_equip,
    "eq": inventory_parser.handle_equip,
    "unequip": inventory_parser.handle_unequip,
    "uneq": inventory_parser.handle_unequip,
    "drop": inventory_parser.handle_drop,
    "get": inventory_parser.handle_get,
    "take": inventory_parser.handle_get,

    # Combat >>> moved to websockets
    # "attack": combat_parser.handle_attack, 
    # "atk": combat_parser.handle_attack,    
    # "kill": combat_parser.handle_attack,    

    # interactions
    "unlock": interaction_parser.handle_unlock,
    "search": interaction_parser.handle_search,    
    "examine": interaction_parser.handle_search,
    "ex": interaction_parser.handle_search, # Alias for examine
    "exa": interaction_parser.handle_search,

    # Social
    "fart": social_parser.handle_fart,

    # Debug
    "giveme": debug_parser.handle_giveme,
    "spawnmob": debug_parser.handle_spawnmob,
    "set_hp": debug_parser.handle_set_hp,       # <<< NEW
    "mod_xp": debug_parser.handle_mod_xp,       # <<< NEW
    "set_level": debug_parser.handle_set_level, # <<< NEW
    "setmoney": debug_parser.handle_set_money,     # <<< NEW
    "addmoney": debug_parser.handle_add_money, 

    # Meta
    "score": meta_parser.handle_score, # <<< ADDED
    "sc": meta_parser.handle_score, # <<< ADDED
    "skills": meta_parser.handle_skills,     # <<< NEW
    "sk": meta_parser.handle_skills,     # <<< NEW
    "traits": meta_parser.handle_traits,     # <<< NEW
    "tr": meta_parser.handle_traits,     # <<< NEW
    "status": meta_parser.handle_score, # Alias for score
    "st": meta_parser.handle_score, # Alias for score
    "help": meta_parser.handle_help,
    "?": meta_parser.handle_help,

    # Social
    "say": social_parser.handle_say,
    "'": social_parser.handle_say, # Common alias for say
    "emote": social_parser.handle_emote,
    ":": social_parser.handle_emote, # Common alias for emote
    "ooc": social_parser.handle_ooc,
    "fart": social_parser.handle_fart,
}

@router.post("", response_model=schemas.CommandResponse)
async def process_command_for_character(
    payload: schemas.CommandRequest = Body(...),
    db: Session = Depends(get_db),
    active_character: models.Character = Depends(get_current_active_character)
):
    original_command_text = payload.command.strip()
    if not original_command_text:
        return schemas.CommandResponse(message_to_player="Please type a command.")

    command_parts = original_command_text.split()
    command_verb = command_parts[0].lower()
    args = command_parts[1:]
    # target_of_verb = " ".join(args) # Potential target string

    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    if not current_room_orm:
        return schemas.CommandResponse(message_to_player="CRITICAL ERROR: Character in void.")
    current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)

    logger.info(f"[COMMAND_ENDPOINT] DB Session ID: {id(db)}")
    context = CommandContext(
        db=db, active_character=active_character, current_room_orm=current_room_orm,
        current_room_schema=current_room_schema, original_command=original_command_text,
        command_verb=command_verb, args=args
    )

    # 1. Check standard command registry first
    handler = COMMAND_REGISTRY.get(command_verb)
    if handler:
        return await handler(context)
    
    # 2. If not in standard registry, check for interactable action verbs
    if current_room_orm.interactables:
        target_interactable_name_or_id_from_args = " ".join(args).lower()
        for interactable_dict in current_room_orm.interactables:
            try:
                interactable = schemas.InteractableDetail(**interactable_dict)
                # Check if interactable is visible to this character
                is_visible = not interactable.is_hidden or active_character.id in interactable.revealed_to_char_ids
                
                if is_visible and command_verb == interactable.action_verb.lower():
                    # Potential match! Now check if the args specify this interactable.
                    # Player might type "pull lever" or "pull rusty_lever" or just "pull" if only one thing is pullable.
                    # This needs a robust target resolution for interactables.
                    
                    # Simple match: if args match id_tag or part of the name, or if no args and it's the only one with this verb
                    matches_this_interactable = False
                    if not target_interactable_name_or_id_from_args: 
                        # Check if this is the *only* visible interactable with this action_verb
                        count_with_verb = 0
                        for other_i_dict in current_room_orm.interactables:
                            other_i = schemas.InteractableDetail(**other_i_dict)
                            other_is_visible = not other_i.is_hidden or active_character.id in other_i.revealed_to_char_ids
                            if other_is_visible and other_i.action_verb.lower() == command_verb:
                                count_with_verb += 1
                        if count_with_verb == 1:
                            matches_this_interactable = True
                    elif interactable.id_tag.lower() == target_interactable_name_or_id_from_args or \
                         target_interactable_name_or_id_from_args in interactable.name.lower():
                        matches_this_interactable = True

                    if matches_this_interactable:
                        # Pass the specific interactable to the handler context or directly
                        return await interaction_parser.handle_contextual_interactable_action(context, interactable)
                        
            except Exception as e_parse_interactable:
                print(f"ERROR: Could not parse interactable in room {current_room_orm.id} for contextual command: {e_parse_interactable}. Data: {interactable_dict}")
                continue # Skip this malformed interactable

    # 3. If still not found, default to unknown command or combat check
    if command_verb in ["attack", "atk", "kill", "kil", "ki", "k", "use"]: # "use" also goes to WS
            return schemas.CommandResponse(
            room_data=current_room_schema,
            message_to_player=f"Actions like '{command_verb}' are handled in real-time. (Use game interface / WebSocket)"
        )
    return schemas.CommandResponse(
        room_data=current_room_schema,
        message_to_player=f"I don't understand the command: '{original_command_text}'. Type 'help' or '?'."
    )
--- END OF FILE backend/app/api/v1/endpoints/command.py ---

--- START OF FILE backend/app/commands/inventory_parser.py ---
# backend/app/commands/inventory_parser.py
from typing import Optional, List, Dict
import uuid 
import logging

from app import schemas, crud, models 
from .command_args import CommandContext 
from .utils import format_inventory_for_player_message 
from app.models.item import EQUIPMENT_SLOTS 

logger = logging.getLogger(__name__)

async def handle_inventory(context: CommandContext) -> schemas.CommandResponse:
    character_orm = context.active_character
    all_inv_items_orm = crud.crud_character_inventory.get_character_inventory(context.db, character_id=character_orm.id)
    
    # Use schemas.CharacterInventoryItem (from item.py) for pydantic conversion
    equipped_items_dict: Dict[str, schemas.CharacterInventoryItem] = {} 
    backpack_items_list: List[schemas.CharacterInventoryItem] = []

    for inv_item_orm in all_inv_items_orm:
        if not inv_item_orm.item: 
            logger.warning(f"Inventory item {inv_item_orm.id} missing item details for char {character_orm.id}")
            continue
        try:
            # Ensure from_orm can handle the nested 'item' which is already an ORM model
            item_schema = schemas.CharacterInventoryItem.from_orm(inv_item_orm)
            if inv_item_orm.equipped and inv_item_orm.equipped_slot:
                equipped_items_dict[inv_item_orm.equipped_slot] = item_schema
            else:
                backpack_items_list.append(item_schema)
        except Exception as e:
            logger.error(f"Pydantic from_orm failed for CharacterInventoryItem {inv_item_orm.id}: {e}", exc_info=True)
            
    inventory_display_data = schemas.CharacterInventoryDisplay(
        equipped_items=equipped_items_dict,
        backpack_items=backpack_items_list,
        platinum=character_orm.platinum_coins,
        gold=character_orm.gold_coins,
        silver=character_orm.silver_coins,
        copper=character_orm.copper_coins
    )
    message_to_player = format_inventory_for_player_message(inventory_display_data)
    return schemas.CommandResponse(
        room_data=context.current_room_schema, 
        message_to_player=message_to_player
    )


# backend/app/commands/inventory_parser.py
from typing import Optional, List, Dict
import uuid 
import logging

from app import schemas, crud, models 
from .command_args import CommandContext 
from .utils import format_inventory_for_player_message 
from app.models.item import EQUIPMENT_SLOTS 

logger = logging.getLogger(__name__)

# ... (handle_inventory, handle_unequip, handle_drop, handle_get would go here or in the full file) ...

async def handle_equip(context: CommandContext) -> schemas.CommandResponse:
    logger.info(f"[HANDLER_EQUIP] Char: {context.active_character.name}, Command: '{context.original_command}'")
    logger.info(f"[HANDLER_EQUIP] Context DB Session ID: {id(context.db)}")
    message_to_player: str
    preliminary_message: Optional[str] = None
    
    if not context.args:
        message_to_player = "Equip/Eq what? (e.g., 'equip Rusty Sword' or 'eq 1 main_hand')"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    item_ref_str: str = ""
    target_slot_arg: Optional[str] = None
    args_list = list(context.args) 

    if args_list:
        potential_slot_word = args_list[-1].lower()
        is_last_word_a_slot = False
        for slot_key_iter, slot_display_iter in EQUIPMENT_SLOTS.items():
            if potential_slot_word == slot_key_iter.lower() or \
               potential_slot_word == slot_display_iter.lower().replace(" ", ""):
                target_slot_arg = slot_key_iter 
                item_ref_str = " ".join(args_list[:-1]).strip()
                is_last_word_a_slot = True
                break
        if not is_last_word_a_slot:
            item_ref_str = " ".join(args_list).strip()
    
    if not item_ref_str: 
        message_to_player = "Equip what item?"
        if target_slot_arg: message_to_player = f"Equip what item to {EQUIPMENT_SLOTS.get(target_slot_arg, target_slot_arg)}?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    char_inventory_items_orm = context.active_character.inventory_items
    if char_inventory_items_orm is None: 
        logger.warning(f"Character {context.active_character.name} inventory_items not loaded in context. Re-fetching for equip handler.")
        char_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(context.db, character_id=context.active_character.id)

    temp_backpack_map: Dict[int, models.CharacterInventoryItem] = {}
    current_backpack_idx = 1
    unequipped_items_by_name: Dict[str, List[models.CharacterInventoryItem]] = {}

    for inv_item_orm in char_inventory_items_orm:
        if not inv_item_orm.equipped: # Only consider unequipped items for equipping
            temp_backpack_map[current_backpack_idx] = inv_item_orm
            current_backpack_idx += 1
            if inv_item_orm.item: 
                item_name_lower = inv_item_orm.item.name.lower()
                if item_name_lower not in unequipped_items_by_name:
                    unequipped_items_by_name[item_name_lower] = []
                unequipped_items_by_name[item_name_lower].append(inv_item_orm)

    found_inv_item_entry: Optional[models.CharacterInventoryItem] = None
    try:
        ref_num = int(item_ref_str)
        if ref_num in temp_backpack_map:
            found_inv_item_entry = temp_backpack_map[ref_num]
    except ValueError:
        if item_ref_str: 
            matching_items = unequipped_items_by_name.get(item_ref_str.lower())
            if matching_items:
                found_inv_item_entry = matching_items[0] 
                if len(matching_items) > 1 and found_inv_item_entry.item:
                    preliminary_message = f"(You have multiple unequipped '{found_inv_item_entry.item.name}'. Equipping one.)\n"
    
    if found_inv_item_entry and found_inv_item_entry.item:
        logger.info(f"[HANDLER_EQUIP] Found item to equip: {found_inv_item_entry.item.name} (InvEntry ID: {found_inv_item_entry.id}) for char {context.active_character.name}. Desired target slot: {target_slot_arg}")
        
        original_inv_item_id = found_inv_item_entry.id # Store ID for re-fetch

        # Call the CRUD function (ensure it's async if your CRUD can be, though typically they are sync)
        # Assuming equip_item_from_inventory is synchronous for now.
        equipped_item_orm, crud_message = crud.crud_character_inventory.equip_item_from_inventory(
            context.db, 
            character_obj=context.active_character, 
            inventory_item_id=original_inv_item_id, 
            target_slot=target_slot_arg
        )

        logger.info(f"[HANDLER_EQUIP] CRUD equip_item_from_inventory response: Message='{crud_message}', Returned ORM ID: {equipped_item_orm.id if equipped_item_orm else 'None'}")

        if equipped_item_orm and "Staged equipping" in crud_message: 
            message_to_player = (preliminary_message or "") + f"You equip the {found_inv_item_entry.item.name}."
            
            # --- DEBUGGING: FLUSH AND RE-FETCH ---
            try:
                logger.info(f"[HANDLER_EQUIP_DEBUG] Attempting to flush session. Dirty: {context.db.dirty}")
                context.db.flush() 
                logger.info(f"[HANDLER_EQUIP_DEBUG] Session flushed. Dirty: {context.db.dirty}, New: {context.db.new}, Deleted: {context.db.deleted}")

                refetched_inv_item = context.db.query(models.CharacterInventoryItem).filter(models.CharacterInventoryItem.id == original_inv_item_id).first()
                if refetched_inv_item:
                    logger.info(f"[HANDLER_EQUIP_DEBUG] Refetched item '{refetched_inv_item.item.name if refetched_inv_item.item else 'N/A'}' (ID: {original_inv_item_id}) state BEFORE commit: equipped={refetched_inv_item.equipped}, slot='{refetched_inv_item.equipped_slot}'")
                else:
                    logger.error(f"[HANDLER_EQUIP_DEBUG] FAILED to re-fetch item {original_inv_item_id} from session after flush!")
            except Exception as e_flush_debug:
                logger.error(f"[HANDLER_EQUIP_DEBUG] Error during flush/re-fetch debug: {e_flush_debug}", exc_info=True)
            # --- END DEBUGGING ---
            
            # --- EXPLICIT DEBUG TEMPORARY ---
            try:
                logger.info(f"[HANDLER_EQUIP_DEBUG] Attempting EXPLICIT COMMIT. Session Dirty: {context.db.dirty}")
                context.db.commit()
                logger.info(f"[HANDLER_EQUIP_DEBUG] EXPLICIT COMMIT successful.")
            except Exception as e_explicit_commit:
                logger.error(f"[HANDLER_EQUIP_DEBUG] EXPLICIT COMMIT FAILED: {e_explicit_commit}", exc_info=True)
                context.db.rollback()
                message_to_player = "Error equipping item (commit failed)." # Override success message
            # --- EXPLICIT DEBUG TEMPORARY ---

            logger.info(f"[HANDLER_EQUIP] Equip reported as successful for {found_inv_item_entry.item.name}. Final session state before return: Dirty: {context.db.dirty}, New: {context.db.new}, Deleted: {context.db.deleted}")
        else: 
            message_to_player = (preliminary_message or "") + crud_message 
            logger.warning(f"[HANDLER_EQUIP] Equip failed or bad message from CRUD for '{found_inv_item_entry.item.name if found_inv_item_entry.item else 'Item??'}': {crud_message}")
    else:
        message_to_player = f"You don't have an unequipped item matching '{item_ref_str}'."
        logger.info(f"[HANDLER_EQUIP] Item not found in unequipped inventory for ref: '{item_ref_str}'")
        
    # The actual commit happens when this HTTP request handler returns, via FastAPI's DB session middleware.
    return schemas.CommandResponse(
        room_data=context.current_room_schema, 
        message_to_player=message_to_player
    )


async def handle_unequip(context: CommandContext) -> schemas.CommandResponse:
    message_to_player: str
    preliminary_message: Optional[str] = None
    target_to_unequip_str = " ".join(context.args).strip()

    if not target_to_unequip_str:
        message_to_player = "Unequip/Uneq what? (e.g. 'unequip main_hand' or 'unequip Rusty Sword')"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    char_inventory_items_orm = context.active_character.inventory_items
    if char_inventory_items_orm is None: 
        logger.warning(f"Character {context.active_character.name} inventory_items not loaded. Re-fetching.")
        char_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(context.db, character_id=context.active_character.id)

    found_inv_item_entry: Optional[models.CharacterInventoryItem] = None
    
    for slot_key_iter, slot_display_iter in EQUIPMENT_SLOTS.items():
        # Compare against canonical key and cleaned display name (e.g. "finger1" vs "Finger 1")
        if target_to_unequip_str.lower() == slot_key_iter.lower() or \
           target_to_unequip_str.lower() == slot_display_iter.lower().replace(" ", ""):
            for inv_item in char_inventory_items_orm:
                if inv_item.equipped and inv_item.equipped_slot == slot_key_iter:
                    found_inv_item_entry = inv_item
                    break
            if found_inv_item_entry: break 
    
    if not found_inv_item_entry:
        equipped_items_by_name: Dict[str, List[models.CharacterInventoryItem]] = {}
        for inv_item in char_inventory_items_orm:
            if inv_item.equipped and inv_item.item:
                item_name_lower = inv_item.item.name.lower()
                if item_name_lower not in equipped_items_by_name: 
                    equipped_items_by_name[item_name_lower] = []
                equipped_items_by_name[item_name_lower].append(inv_item)
        
        matching_equipped_items = equipped_items_by_name.get(target_to_unequip_str.lower())
        if matching_equipped_items:
            found_inv_item_entry = matching_equipped_items[0] 
            if len(matching_equipped_items) > 1 and found_inv_item_entry.item :
                 preliminary_message = f"(Multiple items named '{found_inv_item_entry.item.name}' are equipped. Unequipping one from slot {found_inv_item_entry.equipped_slot}.)\n"

    if found_inv_item_entry and found_inv_item_entry.item:
        unequipped_item_orm, crud_message = crud.crud_character_inventory.unequip_item_to_inventory(
            context.db, 
            character_obj=context.active_character, 
            inventory_item_id=found_inv_item_entry.id
        )
        if unequipped_item_orm and "Staged unequipping" in crud_message:
             message_to_player = (preliminary_message or "") + f"You unequip the {found_inv_item_entry.item.name}."
        else:
            message_to_player = (preliminary_message or "") + crud_message
    else:
        message_to_player = f"You don't have an item equipped matching '{target_to_unequip_str}'."
    
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_drop(context: CommandContext) -> schemas.CommandResponse:
    message_to_player: str
    preliminary_message: Optional[str] = None
    item_ref_to_drop = " ".join(context.args).strip()

    if not item_ref_to_drop:
        message_to_player = "Drop what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    char_inventory_orm = context.active_character.inventory_items
    if char_inventory_orm is None: 
        char_inventory_orm = crud.crud_character_inventory.get_character_inventory(context.db, character_id=context.active_character.id)
    
    temp_backpack_map: Dict[int, models.CharacterInventoryItem] = {}
    current_backpack_idx = 1
    backpack_items_by_name_lower: Dict[str, List[models.CharacterInventoryItem]] = {}
    for inv_item_orm in char_inventory_orm:
        if not inv_item_orm.equipped:
            temp_backpack_map[current_backpack_idx] = inv_item_orm
            current_backpack_idx += 1
            if inv_item_orm.item:
                item_name_lower = inv_item_orm.item.name.lower()
                if item_name_lower not in backpack_items_by_name_lower: backpack_items_by_name_lower[item_name_lower] = []
                backpack_items_by_name_lower[item_name_lower].append(inv_item_orm)

    item_to_drop_instance: Optional[models.CharacterInventoryItem] = None
    try:
        ref_num = int(item_ref_to_drop)
        if ref_num in temp_backpack_map: item_to_drop_instance = temp_backpack_map[ref_num]
    except ValueError:
        if item_ref_to_drop:
            matching_items = backpack_items_by_name_lower.get(item_ref_to_drop.lower())
            if matching_items:
                item_to_drop_instance = matching_items[0]
                if len(matching_items) > 1 and item_to_drop_instance.item: 
                    preliminary_message = f"(Dropping one of multiple '{item_to_drop_instance.item.name}'.)\n"
    
    if not item_to_drop_instance or not item_to_drop_instance.item: # Ensure item is loaded
        message_to_player = f"You don't have '{item_ref_to_drop}' in your backpack."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # remove_item_from_character_inventory uses inventory_item_id
    _, removal_msg = crud.crud_character_inventory.remove_item_from_character_inventory(
        context.db, inventory_item_id=item_to_drop_instance.id, quantity_to_remove=item_to_drop_instance.quantity
    )
    if "Error" in removal_msg or "Cannot" in removal_msg or "not found" in removal_msg : 
        message_to_player = (preliminary_message or "") + removal_msg # Add preliminary if it existed
    else:
        # add_item_to_room does not commit
        _, drop_msg_room = crud.crud_room_item.add_item_to_room(
            context.db, room_id=context.current_room_orm.id, item_id=item_to_drop_instance.item_id,
            quantity=item_to_drop_instance.quantity, dropped_by_character_id=context.active_character.id
        )
        message_to_player = (preliminary_message or "") + f"You drop {item_to_drop_instance.item.name}."
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_get(context: CommandContext) -> schemas.CommandResponse:
    message_to_player: str
    preliminary_message: Optional[str] = None
    item_ref_to_get = " ".join(context.args).strip()

    if not item_ref_to_get:
        message_to_player = "Get what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
    
    temp_ground_map: Dict[int, models.RoomItemInstance] = {}
    current_ground_idx = 1
    ground_items_by_name_lower: Dict[str, List[models.RoomItemInstance]] = {}
    for room_item_inst_orm in items_on_ground_orm:
        temp_ground_map[current_ground_idx] = room_item_inst_orm
        current_ground_idx += 1
        if room_item_inst_orm.item:
            item_name_lower = room_item_inst_orm.item.name.lower()
            if item_name_lower not in ground_items_by_name_lower: ground_items_by_name_lower[item_name_lower] = []
            ground_items_by_name_lower[item_name_lower].append(room_item_inst_orm)

    item_to_get_instance: Optional[models.RoomItemInstance] = None
    try:
        ref_num = int(item_ref_to_get)
        if ref_num in temp_ground_map: item_to_get_instance = temp_ground_map[ref_num]
    except ValueError:
        if item_ref_to_get:
            matching_items = ground_items_by_name_lower.get(item_ref_to_get.lower())
            if matching_items:
                item_to_get_instance = matching_items[0]
                if len(matching_items) > 1 and item_to_get_instance.item: 
                    preliminary_message = f"(Getting one of multiple '{item_to_get_instance.item.name}'.)\n"
    
    if not item_to_get_instance or not item_to_get_instance.item:
        message_to_player = f"No '{item_ref_to_get}' on the ground here."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # remove_item_from_room uses room_item_instance_id
    _, removal_msg = crud.crud_room_item.remove_item_from_room(
        context.db, room_item_instance_id=item_to_get_instance.id, quantity_to_remove=item_to_get_instance.quantity
    )
    if "Error" in removal_msg or "not found" in removal_msg: 
        message_to_player = (preliminary_message or "") + removal_msg
    else:
        # add_item_to_character_inventory now correctly expects character_obj
        _, add_msg_inv = crud.crud_character_inventory.add_item_to_character_inventory(
            context.db, 
            character_obj=context.active_character, 
            item_id=item_to_get_instance.item_id,
            quantity=item_to_get_instance.quantity
        )
        if "Error" in add_msg_inv or "Cannot" in add_msg_inv:
            message_to_player = (preliminary_message or "") + f"You pick up {item_to_get_instance.item.name}, but {add_msg_inv.lower().replace('staged addition of', 'could not add to inventory:')}"
            logger.error(f"Failed to add item {item_to_get_instance.item.name} to char {context.active_character.name} inv after picking up. Item was REMOVED from room. Re-dropping not yet implemented.")
            # TODO: Implement re-drop logic if add_item_to_character_inventory fails.
            # This would involve calling crud.crud_room_item.add_item_to_room again.
        else:
            message_to_player = (preliminary_message or "") + f"You pick up {item_to_get_instance.item.name}."
            
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/inventory_parser.py ---

--- START OF FILE backend/app/ws_command_parsers/ws_movement_parser.py ---
# backend/app/ws_command_parsers/ws_movement_parser.py (NEW FILE)
import uuid
import logging
from typing import Optional, List
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.game_logic import combat # For combat.send_combat_log, combat.active_combats etc.
from app.websocket_manager import connection_manager
from app.commands.utils import (
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message
)
from app.schemas.common_structures import ExitDetail # For lock checks

logger = logging.getLogger(__name__) # Ensure logger is initialized

# This was _handle_websocket_move_if_not_in_combat
async def attempt_player_move(
    db: Session,
    player: models.Player,
    character_state: models.Character,
    command_verb: str, 
    command_args_str: str 
):
    message_to_player_on_fail: Optional[str] = None
    moved_successfully = False
    target_room_orm_for_move: Optional[models.Room] = None
    
    direction_map = {
        "n": "north", "north": "north", "s": "south", "south": "south",
        "e": "east", "east": "east", "w": "west", "west": "west",
        "u": "up", "up": "up", "d": "down", "down": "down"
    }
    raw_direction_input = ""
    if command_verb == "go":
        if command_args_str: raw_direction_input = command_args_str.split(" ", 1)[0].lower()
        else:
            # Get current room schema for fail message if "go" has no args
            room_for_go_fail = crud.crud_room.get_room_by_id(db, character_state.current_room_id)
            schema_for_go_fail = schemas.RoomInDB.from_orm(room_for_go_fail) if room_for_go_fail else None
            await combat.send_combat_log(player.id, ["Go where?"], room_data=schema_for_go_fail); return
    else: raw_direction_input = command_verb.lower()

    target_direction_canonical = direction_map.get(raw_direction_input)
    
    logger.info(f"[MOVE_ATTEMPT] Char: {character_state.name}, Raw Dir: '{raw_direction_input}', Canon Dir: '{target_direction_canonical}'")

    current_room_orm_before_move = crud.crud_room.get_room_by_id(db, room_id=character_state.current_room_id)
    current_room_schema_for_fail = schemas.RoomInDB.from_orm(current_room_orm_before_move) if current_room_orm_before_move else None

    if not target_direction_canonical:
        logger.warning(f"[MOVE_FAIL] Invalid raw direction: '{raw_direction_input}' for char {character_state.name}")
        await combat.send_combat_log(player.id, [f"'{raw_direction_input}' is not a recognized direction."], room_data=current_room_schema_for_fail); return

    old_room_id = character_state.current_room_id
     
    if current_room_orm_before_move:
        current_exits_on_orm = current_room_orm_before_move.exits # This is a JSONB field from the DB
        logger.info(f"[MOVE_INFO] Current Room: '{current_room_orm_before_move.name}' (ID: {old_room_id}) for char {character_state.name}")
        logger.info(f"[MOVE_INFO] Raw exits data from DB for current room: {current_exits_on_orm}") # LOG THE RAW JSONB

        # Ensure current_exits_on_orm is a dict, as expected by .get()
        if not isinstance(current_exits_on_orm, dict):
            logger.error(f"[MOVE_FAIL] Exits data for room '{current_room_orm_before_move.name}' is not a dictionary! Type: {type(current_exits_on_orm)}. Data: {current_exits_on_orm}")
            message_to_player_on_fail = "The exits from this room are mysteriously obscured."
        elif target_direction_canonical in current_exits_on_orm:
            exit_data_from_db_json = current_exits_on_orm.get(target_direction_canonical)
            logger.info(f"[MOVE_INFO] Found exit data for direction '{target_direction_canonical}': {exit_data_from_db_json}")
            
            exit_detail_model: Optional[ExitDetail] = None
            if isinstance(exit_data_from_db_json, dict):
                try: 
                    exit_detail_model = ExitDetail(**exit_data_from_db_json)
                    logger.info(f"[MOVE_INFO] Parsed ExitDetail: target_room_id='{exit_detail_model.target_room_id}' (Type: {type(exit_detail_model.target_room_id)}), is_locked='{exit_detail_model.is_locked}'")
                except Exception as e_parse:
                    logger.error(f"[MOVE_FAIL] Pydantic parse error for ExitDetail (dir: '{target_direction_canonical}', room: '{current_room_orm_before_move.name}'): {e_parse}. Data from DB: {exit_data_from_db_json}", exc_info=True)
                    message_to_player_on_fail = "The exit in that direction appears to be malformed."
            else: 
                message_to_player_on_fail = "The fabric of reality wavers at that exit. (Malformed exit data structure)"
                logger.error(f"[MOVE_FAIL] Malformed exit data structure for dir '{target_direction_canonical}' in room '{current_room_orm_before_move.name}'. Expected dict, got {type(exit_data_from_db_json)}. Data: {exit_data_from_db_json}")

            if exit_detail_model:
                if exit_detail_model.is_locked: 
                    message_to_player_on_fail = exit_detail_model.description_when_locked or "That way is locked."
                    logger.info(f"[MOVE_INFO] Exit '{target_direction_canonical}' is locked. Desc: '{message_to_player_on_fail}'")
                else:
                    # Target room ID should be a UUID object after Pydantic parsing
                    target_room_uuid_to_fetch = exit_detail_model.target_room_id 
                    logger.info(f"[MOVE_INFO] Exit unlocked. Attempting to fetch target room with UUID: {target_room_uuid_to_fetch}")
                    potential_target_room_orm = crud.crud_room.get_room_by_id(db, room_id=target_room_uuid_to_fetch)
                    if potential_target_room_orm: 
                        target_room_orm_for_move = potential_target_room_orm
                        moved_successfully = True
                        logger.info(f"[MOVE_SUCCESS] Char '{character_state.name}' resolved target room '{target_room_orm_for_move.name}' (ID: {target_room_orm_for_move.id})")
                    else: 
                        message_to_player_on_fail = "The path ahead seems to vanish into nothingness."
                        logger.error(f"[MOVE_FAIL] Target room ID '{target_room_uuid_to_fetch}' (from exit '{target_direction_canonical}' in room '{current_room_orm_before_move.name}') NOT FOUND in DB.")
        else: 
            message_to_player_on_fail = "You can't go that way."
            logger.info(f"[MOVE_INFO] Direction '{target_direction_canonical}' not found in exits for room '{current_room_orm_before_move.name}'. Available exits: {list(current_exits_on_orm.keys()) if isinstance(current_exits_on_orm, dict) else 'N/A'}")
    else: 
        message_to_player_on_fail = "Error: Your current location is undefined."
        logger.error(f"[MOVE_CRITICAL] Character {character_state.name} (ID: {character_state.id}) has invalid current_room_id: {old_room_id} or room ORM not found.")

    if moved_successfully and target_room_orm_for_move:
        logger.info(f"[MOVE_COMMIT] Updating char room from {old_room_id} to {target_room_orm_for_move.id}")
        crud.crud_character.update_character_room(db, character_id=character_state.id, new_room_id=target_room_orm_for_move.id)
        # The commit for this update_character_room is handled by the main websocket_router loop after all command processing.

        new_room_schema = schemas.RoomInDB.from_orm(target_room_orm_for_move)
        
        # Broadcast departure (omitting for brevity, assume this part is fine if move succeeds)
        # ...
        # Broadcast arrival (omitting for brevity)
        # ...
        
        # Send new room details to the moving player (omitting formatting for brevity)
        # ...
        arrival_message_parts: List[str] = ["You arrive."] # Simplified message for now
        items_in_new_room = crud.crud_room_item.get_items_in_room(db, room_id=target_room_orm_for_move.id)
        ground_items_text, _ = format_room_items_for_player_message(items_in_new_room)
        if ground_items_text: arrival_message_parts.append(ground_items_text)
        # ... (mobs, other chars)
        final_arrival_message_str = "\n".join(filter(None, arrival_message_parts)).strip()

        await combat.send_combat_log(player.id, [final_arrival_message_str] if final_arrival_message_str else [], room_data=new_room_schema)
    else: 
        logger.warning(f"[MOVE_FINAL_FAIL] Move failed for char {character_state.name}. Reason: {message_to_player_on_fail if message_to_player_on_fail else 'Unknown'}")
        await combat.send_combat_log(player.id, [message_to_player_on_fail] if message_to_player_on_fail else ["You cannot move that way."], room_data=current_room_schema_for_fail)


async def handle_ws_movement(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_schema: schemas.RoomInDB, # Pass schema for fail messages
    verb: str,
    args_str: str
):
    is_in_active_combats = current_char_state.id in combat.active_combats
    targets_for_char = combat.active_combats.get(current_char_state.id) if is_in_active_combats else None
    condition_to_block = is_in_active_combats and bool(targets_for_char)

    if condition_to_block:
        await combat.send_combat_log(
            player.id, ["You cannot move while in combat! Try 'flee <direction>' or 'flee'."],
            room_data=current_room_schema, transient=True 
        )
        return

    # If "go", verb is "go", args_str is direction. If "n", verb is "n", args_str is empty.
    # attempt_player_move handles this.
    await attempt_player_move(db, player, current_char_state, verb, args_str)


async def handle_ws_flee(
    db: Session, # db might not be needed if only manipulating combat state dicts
    player: models.Player,
    current_char_state: models.Character,
    current_room_schema: schemas.RoomInDB,
    args_str: str
):
    if current_char_state.id in combat.active_combats and combat.active_combats.get(current_char_state.id):
        flee_direction_arg = args_str.split(" ", 1)[0].lower() if args_str else "random"
        canonical_flee_dir = "random"
        if flee_direction_arg != "random":
            canonical_flee_dir = combat.direction_map.get(flee_direction_arg, flee_direction_arg)
            if canonical_flee_dir not in combat.direction_map.values():
                await combat.send_combat_log(player.id, [f"Invalid flee direction '{flee_direction_arg}'. Try 'flee' or 'flee <direction>'."], room_data=current_room_schema, transient=True)
                return 
        combat.character_queued_actions[current_char_state.id] = f"flee {canonical_flee_dir}"
        await combat.send_combat_log(player.id, [f"You prepare to flee {canonical_flee_dir if canonical_flee_dir != 'random' else '...'}"])
    else:
        await combat.send_combat_log(player.id, ["You are not in combat."], room_data=current_room_schema, transient=True)
--- END OF FILE backend/app/ws_command_parsers/ws_movement_parser.py ---

--- START OF FILE backend/app/seeds/items.json ---

[
  {
    "name": "Rusty Sword",
    "description": "A short sword, pitted with rust. Better than nothing.",
    "item_type": "weapon",
    "slot": "main_hand",
    "properties": { "damage": "1d6", "damage_type": "slashing", "weapon_type": "sword" },
    "weight": 3.0, "value": 5, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Cloth Tunic",
    "description": "Simple, patched-up clothing.",
    "item_type": "armor", "slot": "torso",
    "properties": { "armor_class_bonus": 1 },
    "weight": 1.0, "value": 2, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Wooden Shield",
    "description": "A basic round wooden shield.",
    "item_type": "armor", "slot": "off_hand",
    "properties": { "armor_class_bonus": 2, "item_subtype": "shield" },
    "weight": 5.0, "value": 8, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Dagger",
    "description": "A small, easily concealable dagger.",
    "item_type": "weapon", "slot": "main_hand",
    "properties": { "damage": "1d4", "damage_type": "piercing", "weapon_type": "dagger", "finesse": true },
    "weight": 1.0, "value": 2, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Archive Key Alpha",
    "description": "A small, intricately carved metal key. Sector 42.",
    "item_type": "key", "slot": null,
    "properties": { "item_tag": "archive_key_alpha" },
    "weight": 0.1, "value": 0, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Basic Healing Draught",
    "description": "A common herbal brew that knits minor wounds.",
    "item_type": "potion", "slot": "consumable",
    "properties": { "effect_type": "heal_direct", "heal_amount_dice": "2d4", "heal_amount_bonus": 2, "cooldown_group": "potion", "cooldown_seconds": 30 },
    "weight": 0.5, "value": 25, "stackable": true, "max_stack_size": 5
  },
  {
    "name": "Lockpicks",
    "description": "A set of fine tools for bypassing simple locks.",
    "item_type": "tool", "slot": null,
    "properties": { "item_tag": "basic_lockpicks", "provides_skill_bonus": { "skill_id_tag": "pick_lock_basic", "bonus_amount": 2 } },
    "weight": 0.2, "value": 50, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Rat Tail",
    "description": "A long, scaly rat tail. Gross.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "rat_tail_junk" },
    "weight": 0.1, "value": 1, "stackable": true, "max_stack_size": 20
  },
  {
    "name": "Cracked Tooth",
    "description": "A small, cracked animal tooth.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "cracked_tooth_junk" },
    "weight": 0.05, "value": 0, "stackable": true, "max_stack_size": 50
  },
  {
    "name": "Beast Pelt (Small)",
    "description": "The pelt of a small, furry creature. Could be useful.",
    "item_type": "crafting_material", "slot": null,
    "properties": { "item_tag": "pelt_small_beast" },
    "weight": 0.5, "value": 3, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Animal Bone",
    "description": "A sturdy animal bone, perhaps from a leg or rib.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "animal_bone_generic" },
    "weight": 0.3, "value": 0, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Old Boot",
    "description": "A single, waterlogged leather boot. Seen better days.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "old_boot_junk" },
    "weight": 1.0, "value": 0, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Rusty Tin Can",
    "description": "An old, rusty tin can. Empty, of course.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "rusty_can_junk" },
    "weight": 0.2, "value": 0, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Goblin Ear",
    "description": "A severed goblin ear. A common, if gruesome, trophy.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "goblin_ear_trophy" },
    "weight": 0.1, "value": 2, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Crude Dagger Scrap",
    "description": "A piece of a crudely made goblin dagger, broken and useless.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "crude_dagger_scrap" },
    "weight": 0.3, "value": 1, "stackable": true, "max_stack_size": 5
  },
  {
    "name": "Torn Pouch",
    "description": "A small leather pouch, torn and empty.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "torn_pouch_junk" },
    "weight": 0.1, "value": 0, "stackable": false, "max_stack_size": 1
  }

]
--- END OF FILE backend/app/seeds/items.json ---

--- START OF FILE backend/app/seeds/mob_templates.json ---
[
  {
    "name": "Giant Rat",
    "description": "A rodent of unusual size, its fur matted and its eyes glinting with a feral hunger.",
    "level": 1,
    "base_health": 12,
    "base_mana": 0,
    "base_attack": "1d4",
    "base_defense": 11,
    "xp_value": 5,
    "attack_speed_secs": 2.5,
    "aggro_radius": 4,
    "roam_radius": 3,
    "dialogue_lines": ["*Squeak!*", "Hisss...", "*Chitters angrily*"],
    "faction_tags": ["vermin", "beast", "neutral_critter"],
    "loot_table_tags": ["vermin_common", "small_beast_parts", "tier1_trash"],
    "special_abilities": [],
    "currency_drop": {
        "c_min": 1, "c_max": 5, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Goblin Scout",
    "description": "A small, wiry goblin with shifty eyes and a crude spear. Looks like it would rather be anywhere else.",
    "level": 2,
    "base_health": 18,
    "base_mana": 5,
    "base_attack": "1d6",
    "base_defense": 13,
    "xp_value": 15,
    "attack_speed_secs": 3.0,
    "aggro_radius": 7,
    "roam_radius": 5,
    "dialogue_lines": ["Sneaky sneaky!", "You see shiny?", "Me take that!", "Yark! Intruder!"],
    "faction_tags": ["goblinoid", "scout", "hostile_humanoid"],
    "loot_table_tags": ["goblin_common", "crude_gear", "tier1_basic"],
    "special_abilities": ["evasive_maneuver_passive"],
    "currency_drop": {
        "c_min": 5, "c_max": 15, "s_chance": 10, "s_min": 1, "s_max": 2, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Security Drone MK I",
    "description": "A hovering metallic drone, its single optical sensor glowing ominously. It emits a low whirring sound.",
    "level": 3,
    "base_health": 25,
    "base_mana": 0,
    "base_attack": "2d4", 
    "base_defense": 14,
    "xp_value": 25,
    "attack_speed_secs": 2.0,
    "aggro_radius": 10,
    "roam_radius": 0, 
    "faction_tags": ["construct", "security", "neutral_guard"],
    "loot_table_tags": ["construct_parts_common", "tech_scrap", "tier1_tech"],
    "special_abilities": ["self_repair_protocol_passive", "arc_discharge_active"],
    "currency_drop": {
        "c_min": 0, "c_max": 0, "s_chance": 20, "s_min": 1, "s_max": 5, "g_chance": 5, "g_min": 1, "g_max": 1, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Forest Spider",
    "description": "A large, hairy spider with too many eyes. It scuttles menacingly.",
    "level": 2,
    "base_health": 15,
    "base_mana": 10,
    "base_attack": "1d6",
    "base_defense": 12,
    "xp_value": 12,
    "attack_speed_secs": 2.8,
    "aggro_radius": 6,
    "roam_radius": 4,
    "dialogue_lines": ["*Hiss*", "*Clicking mandibles*"],
    "faction_tags": ["arachnid", "beast", "hostile_critter"],
    "loot_table_tags": ["spider_parts", "tier1_beast_loot"],
    "special_abilities": ["poison_bite_active", "web_shot_utility"],
    "currency_drop": {
        "c_min": 2, "c_max": 8, "s_chance": 5, "s_min": 1, "s_max": 1, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Lost Soul",
    "description": "A shimmering, translucent figure that wails mournfully. It seems trapped between worlds.",
    "level": 4,
    "base_health": 30,
    "base_mana": 20,
    "base_attack": "1d8", 
    "base_defense": 10, 
    "xp_value": 35,
    "attack_speed_secs": 3.5,
    "aggro_radius": 5,
    "roam_radius": 2,
    "dialogue_lines": ["Why...?", "So cold...", "Lost... forever..."],
    "faction_tags": ["undead", "spirit", "neutral_ethereal"],
    "loot_table_tags": ["ectoplasm", "spirit_essence", "tier2_ethereal"],
    "special_abilities": ["ethereal_form_passive", "chilling_touch_active"],
    "properties": {"damage_type_override": "cold"},
    "currency_drop": {
        "c_min": 0, "c_max": 0, "s_chance": 15, "s_min": 3, "s_max": 7, "g_chance": 2, "g_min": 1, "g_max": 1, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Dust Devil",
    "description": "A small whirlwind of sand and grit, animated by some unknown force.",
    "level": 3,
    "base_health": 22,
    "base_mana": 0,
    "base_attack": "1d6",
    "base_defense": 15,
    "xp_value": 20,
    "attack_speed_secs": 2.2,
    "aggro_radius": 6,
    "roam_radius": 6,
    "dialogue_lines": ["*Whirls angrily*", "*Grinding noises*"],
    "faction_tags": ["elemental", "air_elemental", "neutral_elemental"],
    "loot_table_tags": ["elemental_mote_air", "tier1_elemental"],
    "special_abilities": ["sand_blast_active", "evasion_aura_passive"],
    "currency_drop": {
        "c_min": 10, "c_max": 25, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Bandit Thug",
    "description": "A burly human with a scarred face and a mean-looking club. Smells of stale ale and desperation.",
    "level": 4,
    "base_health": 35,
    "base_mana": 0,
    "base_attack": "1d8",
    "base_defense": 12,
    "xp_value": 30,
    "attack_speed_secs": 3.2,
    "aggro_radius": 8,
    "roam_radius": 3,
    "dialogue_lines": ["Your money or your life!", "Stand and deliver!", "Shouldn't have come here!"],
    "faction_tags": ["humanoid", "bandit", "hostile_humanoid"],
    "loot_table_tags": ["bandit_gear", "stolen_goods_common", "tier2_humanoid"],
    "special_abilities": ["intimidating_shout_active"],
    "currency_drop": {
        "c_min": 15, "c_max": 40, "s_chance": 25, "s_min": 2, "s_max": 5, "g_chance": 5, "g_min": 1, "g_max": 2, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Cave Bat Swarm",
    "description": "A disorienting cloud of screeching bats, their tiny teeth glinting.",
    "level": 3,
    "base_health": 20, 
    "base_mana": 0,
    "base_attack": "1d3", 
    "base_defense": 14,
    "xp_value": 18,
    "attack_speed_secs": 1.5, 
    "aggro_radius": 5,
    "roam_radius": 2,
    "dialogue_lines": ["*High-pitched screeches*"],
    "faction_tags": ["beast", "swarm", "hostile_critter"],
    "loot_table_tags": ["bat_parts", "tier1_swarm_remains"],
    "special_abilities": ["disorienting_flutter_passive", "multi_attack_swarm_passive"],
    "properties": {"is_swarm": true, "swarm_attacks_count": 3},
    "currency_drop": {
        "c_min": 3, "c_max": 10, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Animated Armor",
    "description": "An empty suit of plate armor that moves with an eerie, clanking grace. No one appears to be inside.",
    "level": 5,
    "base_health": 45,
    "base_mana": 0,
    "base_attack": "1d10",
    "base_defense": 18,
    "xp_value": 50,
    "attack_speed_secs": 3.8,
    "aggro_radius": 6,
    "roam_radius": 0,
    "dialogue_lines": ["*Clank*", "*Scrape*", "*Whirr*"],
    "faction_tags": ["construct", "guardian", "neutral_guard"],
    "loot_table_tags": ["construct_parts_rare", "enchanted_metal_shards", "tier2_construct"],
    "special_abilities": ["damage_resistance_physical_passive", "magic_immunity_partial_passive"],
    "currency_drop": {
        "c_min": 0, "c_max": 0, "s_chance": 30, "s_min": 5, "s_max": 10, "g_chance": 10, "g_min": 1, "g_max": 3, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Dire Wolf",
    "description": "A massive wolf with fur as dark as night and eyes that burn with a primal fury. Its growl is a promise of pain.",
    "level": 6,
    "base_health": 60,
    "base_mana": 10,
    "base_attack": "2d6",
    "base_defense": 15,
    "xp_value": 75,
    "attack_speed_secs": 3.0,
    "aggro_radius": 9,
    "roam_radius": 7,
    "dialogue_lines": ["*Snarl*", "*Deep Growl*", "*Howl*"],
    "faction_tags": ["beast", "canine", "predator", "hostile_alpha"],
    "loot_table_tags": ["dire_wolf_pelt", "large_beast_trophy", "tier3_beast_loot"],
    "special_abilities": ["pack_tactics_passive", "powerful_bite_active", "howl_buff_aura_active"],
    "currency_drop": {
        "c_min": 0, "c_max": 0, "s_chance": 5, "s_min": 10, "s_max": 20, "g_chance": 1, "g_min": 1, "g_max": 2, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  }
]
--- END OF FILE backend/app/seeds/mob_templates.json ---

--- START OF FILE backend/app/seeds/character_classes.json ---
[
  {
    "name": "Warrior",
    "description": "A stalwart fighter, skilled in the arts of melee combat and enduring hardship. Warriors excel at both dealing and absorbing damage on the front lines.",
    "base_stat_modifiers": {"strength": 2, "constitution": 1, "intelligence": -1, "charisma": -1},
    "starting_health_bonus": 10,
    "starting_mana_bonus": -5,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch"],
            "2": ["power_attack_melee"],
            "3": ["shield_bash_active"],
            "5": ["cleave_melee_active"]
        },
        "core_traits_by_level": {
            "1": ["tough_hide"],
            "2": ["weapon_focus_swords_passive"],
            "4": ["improved_vitality_passive"]
        }
    },
    "starting_equipment_refs": ["Rusty Sword", "Wooden Shield", "Cloth Tunic"],
    "playstyle_tags": ["melee", "tank", "physical_dps", "durable"],
    "stat_gains_per_level": {
        "hp": 6, 
        "mp": 1, 
        "base_attack_bonus": 0.75
    }
  },
  {
    "name": "Swindler",
    "description": "A cunning rogue who relies on wit, agility, and a sharp blade. Swindlers are masters of stealth, deception, and exploiting weaknesses.",
    "base_stat_modifiers": {"dexterity": 2, "luck": 1, "strength": -1, "wisdom": -1},
    "starting_health_bonus": -5,
    "starting_mana_bonus": 5,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch", "pick_lock_basic"],
            "2": ["backstab_melee_active"],
            "4": ["hide_in_shadows_utility"]
        },
        "core_traits_by_level": {
            "1": ["nimble_fingers_passive"],
            "3": ["opportunist_passive"],
            "5": ["evasion_expert_passive"]
        }
    },
    "starting_equipment_refs": ["Dagger", "Lockpicks", "Cloth Tunic"],
    "playstyle_tags": ["melee", "stealth", "utility", "debuff", "skill_monkey"],
    "stat_gains_per_level": {
        "hp": 4, 
        "mp": 2, 
        "base_attack_bonus": 0.5 
    }
  },
  {
    "name": "Acolyte",
    "description": "A devout follower of a divine power, wielding faith as both shield and weapon. Acolytes can mend wounds, bolster allies, and smite the unholy.",
    "base_stat_modifiers": {"wisdom": 2, "charisma": 1, "dexterity": -1, "strength": -1},
    "starting_health_bonus": 0,
    "starting_mana_bonus": 10,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["minor_heal_active", "bless_buff_active"],
            "3": ["smite_evil_active"],
            "5": ["turn_undead_active"]
        },
        "core_traits_by_level": {
            "1": ["divine_fortitude_passive"],
            "2": ["healing_touch_improved_passive"],
            "4": ["divine_guidance_passive"]
        }
    },
    "starting_equipment_refs": ["Wooden Mace", "Holy Symbol", "Cloth Robes"],
    "playstyle_tags": ["caster", "healer", "support", "divine", "anti_undead"],
    "stat_gains_per_level": {
        "hp": 3, 
        "mp": 3, 
        "base_attack_bonus": 0.33 
    }
  },
  {
    "name": "Hedge Wizard",
    "description": "A self-taught practitioner of the arcane arts, drawing power from raw talent and forbidden lore. Hedge Wizards command elemental forces and subtle illusions.",
    "base_stat_modifiers": {"intelligence": 2, "wisdom": 1, "constitution": -1, "strength": -1},
    "starting_health_bonus": -5,
    "starting_mana_bonus": 15,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["magic_missile_active", "light_cantrip_utility"],
            "3": ["fireball_small_active"],
            "5": ["invisibility_short_utility"]
        },
        "core_traits_by_level": {
            "1": ["arcane_attunement_passive"],
            "2": ["spell_penetration_minor_passive"],
            "4": ["elemental_focus_fire_passive"]
        }
    },
    "starting_equipment_refs": ["Quarterstaff", "Spellbook (Blank)", "Cloth Robes"],
    "playstyle_tags": ["caster", "arcane", "elemental_dps", "utility_magic", "glass_cannon"],
    "stat_gains_per_level": {
        "hp": 2, 
        "mp": 4, 
        "base_attack_bonus": 0.33
    }
  },
  {
    "name": "Adventurer",
    "description": "A jack-of-all-trades, master of none. Ready for anything, prepared for nothing. The path of the Adventurer is one of versatility and adaptability.",
    "base_stat_modifiers": {}, 
    "starting_health_bonus": 0,
    "starting_mana_bonus": 0,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch"],
            "2": ["first_aid_basic_utility"] 
        },
        "core_traits_by_level": {
            "1": ["jack_of_all_trades_xp_bonus_passive"],
            "3": ["hardy_survivor_passive"]
        }
    },
    "starting_equipment_refs": ["Dagger", "Cloth Tunic", "Basic Healing Draught"],
    "playstyle_tags": ["versatile", "generalist", "beginner_friendly"],
    "stat_gains_per_level": {
        "hp": 4, 
        "mp": 2, 
        "base_attack_bonus": 0.5
    }
  }
]
--- END OF FILE backend/app/seeds/character_classes.json ---

--- START OF FILE backend/app/seeds/skills.json ---
[
  {
    "skill_id_tag": "basic_punch",
    "name": "Basic Punch",
    "description": "A simple, untrained punch. It's better than harsh language. Usually.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {"mana_cost": 0, "damage_dice_override": "1d2", "attack_bonus_add": 0, "damage_bonus_add": 0, "uses_strength_for_bonus": true},
    "requirements_data": {"min_level": 1},
    "cooldown": 0
  },
  {
    "skill_id_tag": "power_attack_melee",
    "name": "Power Attack",
    "description": "A forceful melee attack that is harder to land but deals more damage with your equipped weapon.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 5, 
        "attack_roll_modifier": -2,
        "damage_modifier_flat": 3,
        "uses_equipped_weapon": true 
    },
    "requirements_data": {"min_level": 2, "required_stats": {"strength": 12}},
    "cooldown": 2
  },
  {
    "skill_id_tag": "pick_lock_basic",
    "name": "Pick Lock (Basic)",
    "description": "Attempt to pick a simple lock on a door or container. Requires lockpicks.",
    "skill_type": "UTILITY_OOC",
    "target_type": "DOOR", 
    "effects_data": {
        "check_attribute": "dexterity", 
        "base_dc_override_for_skill": null,
        "requires_item_tag_equipped_or_inventory": "basic_lockpicks"
    },
    "requirements_data": {"min_level": 1},
    "cooldown": 10 
  },
  {
    "skill_id_tag": "shield_bash_active",
    "name": "Shield Bash",
    "description": "Slam your shield into an opponent, potentially dazing them.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 8,
        "damage_dice_override": "1d4",
        "attack_bonus_add": 0,
        "damage_bonus_add_from_stat": "strength",
        "status_effect_apply": {"effect_tag": "dazed", "duration_rounds": 1, "chance_percent": 30},
        "requires_item_type_equipped": "shield"
    },
    "requirements_data": {"min_level": 3, "required_stats": {"strength": 13}},
    "cooldown": 3
  },
  {
    "skill_id_tag": "cleave_melee_active",
    "name": "Cleave",
    "description": "Swing your weapon in a wide arc, hitting an additional nearby enemy if one is present.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 10,
        "uses_equipped_weapon": true,
        "aoe_targets_additional": 1, 
        "aoe_shape": "arc_front"
    },
    "requirements_data": {"min_level": 5, "required_stats": {"strength": 14}},
    "cooldown": 4
  },
  {
    "skill_id_tag": "backstab_melee_active",
    "name": "Backstab",
    "description": "Exploit an opponent's distraction for a devastating attack. Requires stealth or target to be unaware.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 7,
        "damage_multiplier": 2.0, 
        "uses_equipped_weapon": true,
        "requires_condition": ["target_unaware", "user_stealthed"] 
    },
    "requirements_data": {"min_level": 2, "required_stats": {"dexterity": 13}},
    "cooldown": 1
  },
  {
    "skill_id_tag": "hide_in_shadows_utility",
    "name": "Hide in Shadows",
    "description": "Attempt to melt into the shadows, becoming harder to detect.",
    "skill_type": "UTILITY_OOC", 
    "target_type": "SELF",
    "effects_data": {
        "mana_cost": 5,
        "status_effect_apply": {"effect_tag": "stealthed", "duration_seconds": 60, "check_vs_perception_dc": 10}
    },
    "requirements_data": {"min_level": 4, "required_stats": {"dexterity": 14}},
    "cooldown": 30
  },
  {
    "skill_id_tag": "minor_heal_active",
    "name": "Minor Heal",
    "description": "A weak divine spell that mends minor wounds.",
    "skill_type": "COMBAT_ACTIVE", 
    "target_type": "FRIENDLY_CHAR_OR_SELF",
    "effects_data": {"mana_cost": 6, "heal_dice": "1d6", "heal_bonus_from_stat": "wisdom"},
    "requirements_data": {"min_level": 1},
    "cooldown": 1
  },
  {
    "skill_id_tag": "bless_buff_active",
    "name": "Bless",
    "description": "Invoke divine favor upon an ally, improving their combat prowess.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "FRIENDLY_CHAR_OR_SELF",
    "effects_data": {
        "mana_cost": 10,
        "status_effect_apply": {"effect_tag": "blessed_buff", "duration_rounds": 5, "bonuses": {"attack_roll": 1, "damage_roll": 1}}
    },
    "requirements_data": {"min_level": 1, "required_stats": {"wisdom": 12}},
    "cooldown": 0
  },
  {
    "skill_id_tag": "magic_missile_active",
    "name": "Magic Missile",
    "description": "Launch a missile of magical energy that unerringly strikes its target.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {"mana_cost": 4, "damage_dice_override": "1d4+1", "damage_type": "force", "always_hits": true},
    "requirements_data": {"min_level": 1},
    "cooldown": 0
  },
  {
    "skill_id_tag": "light_cantrip_utility",
    "name": "Light",
    "description": "Create a hovering light source that illuminates the area.",
    "skill_type": "UTILITY_OOC",
    "target_type": "SELF",
    "effects_data": {"mana_cost": 2, "status_effect_apply": {"effect_tag": "magical_light", "duration_seconds": 300}},
    "requirements_data": {"min_level": 1},
    "cooldown": 5
  },
  {
    "skill_id_tag": "first_aid_basic_utility",
    "name": "Basic First Aid",
    "description": "Apply basic bandaging to stop bleeding and slightly mend wounds outside of combat.",
    "skill_type": "UTILITY_OOC",
    "target_type": "SELF", 
    "effects_data": {"heal_amount_fixed": 5, "cooldown_seconds": 60, "requires_item_tag_consumed": "bandages_basic", "consume_chance": 75},
    "requirements_data": {"min_level": 2},
    "cooldown": 60
  }
]
--- END OF FILE backend/app/seeds/skills.json ---

--- START OF FILE backend/app/seeds/traits.json ---
[
  {
    "trait_id_tag": "tough_hide",
    "name": "Tough Hide",
    "description": "Your skin is naturally resilient, granting a small bonus to your Armor Class.",
    "trait_type": "PASSIVE", 
    "effects_data": {"ac_bonus_natural": 1}
  },
  {
    "trait_id_tag": "weapon_focus_swords_passive",
    "name": "Weapon Focus (Swords)",
    "description": "You are more accurate when wielding swords.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_bonus": {"condition_item_type_equipped": "sword", "attack_bonus": 1}}
  },
  {
    "trait_id_tag": "improved_vitality_passive",
    "name": "Improved Vitality",
    "description": "You gain more health points per level.",
    "trait_type": "PASSIVE",
    "effects_data": {"hp_gain_per_level_bonus": 1}
  },
  {
    "trait_id_tag": "nimble_fingers_passive",
    "name": "Nimble Fingers",
    "description": "You are adept at tasks requiring fine motor skills, such as picking locks.",
    "trait_type": "PASSIVE",
    "effects_data": {"skill_check_bonus": {"skill_type_tags": ["lockpicking", "disarm_trap"], "bonus_amount": 2}}
  },
  {
    "trait_id_tag": "opportunist_passive",
    "name": "Opportunist",
    "description": "You deal extra damage against distracted or flanked opponents.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_damage_bonus_flat": {"condition_target_status": ["dazed", "stunned", "flanked"], "damage_bonus": 2}}
  },
  {
    "trait_id_tag": "evasion_expert_passive",
    "name": "Evasion Expert",
    "description": "You are skilled at avoiding area attacks.",
    "trait_type": "PASSIVE",
    "effects_data": {"save_bonus_vs_aoe_type": {"effect_type_tags": ["area_effect", "trap_damage"], "bonus_amount": 2}}
  },
  {
    "trait_id_tag": "divine_fortitude_passive",
    "name": "Divine Fortitude",
    "description": "Your faith grants you enhanced resilience to negative effects.",
    "trait_type": "PASSIVE",
    "effects_data": {"save_bonus_vs_negative_status": {"status_tags": ["disease", "poison", "curse"], "bonus_amount": 1}}
  },
  {
    "trait_id_tag": "healing_touch_improved_passive",
    "name": "Improved Healing Touch",
    "description": "Your healing spells are more potent.",
    "trait_type": "PASSIVE",
    "effects_data": {"healing_spell_potency_bonus_flat": 2}
  },
  {
    "trait_id_tag": "divine_guidance_passive",
    "name": "Divine Guidance",
    "description": "Your connection to the divine enhances your wisdom.",
    "trait_type": "PASSIVE",
    "effects_data": {"stat_bonus_permanent": {"wisdom": 1}}
  },
  {
    "trait_id_tag": "arcane_attunement_passive",
    "name": "Arcane Attunement",
    "description": "You have a greater pool of magical energy.",
    "trait_type": "PASSIVE",
    "effects_data": {"max_mana_bonus_flat": 10}
  },
  {
    "trait_id_tag": "spell_penetration_minor_passive",
    "name": "Minor Spell Penetration",
    "description": "Your offensive spells are slightly more effective against resistant foes.",
    "trait_type": "PASSIVE",
    "effects_data": {"spell_penetration_value": 1}
  },
  {
    "trait_id_tag": "elemental_focus_fire_passive",
    "name": "Elemental Focus (Fire)",
    "description": "Your fire-based spells deal more damage.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_damage_bonus_percent": {"spell_damage_type": "fire", "bonus_percent": 10}}
  },
  {
    "trait_id_tag": "jack_of_all_trades_xp_bonus_passive",
    "name": "Jack of All Trades",
    "description": "You learn quickly from a variety of experiences, gaining a small bonus to all experience earned.",
    "trait_type": "PASSIVE",
    "effects_data": {"xp_gain_modifier_percent": 3}
  },
  {
    "trait_id_tag": "hardy_survivor_passive",
    "name": "Hardy Survivor",
    "description": "Years of adventuring have made you tougher, granting a small bonus to your maximum health.",
    "trait_type": "PASSIVE",
    "effects_data": {"max_health_bonus_flat": 5}
  }
]
--- END OF FILE backend/app/seeds/traits.json ---

--- START OF FILE backend/app/seeds/rooms_z0.json ---
[
  {
    "unique_tag": "central_hub_0_0_0",
    "data": {
      "name": "Central Processing Unit (CPU)",
      "description": "The air hums. Corridors branch off. [DYNAMIC_EXIT_EAST]. A faint inscription reads 'Sector 0,0,0'. This appears to be some kind of nexus or entry point.",
      "x": 0, "y": 0, "z": 0,
      "room_type": "standard",
      "interactables": [
        {
          "id_tag": "cpu_east_lever",
          "name": "a sturdy metal lever",
          "description": "A heavy metal lever is set into the wall, currently in the 'up' position.",
          "action_verb": "pull",
          "on_interact_effect": {
            "type": "toggle_exit_lock",
            "target_exit_direction": "east",
            "message_success_self": "You pull the lever down with a CLUNK. You hear a mechanism engage nearby.",
            "message_success_others": "{character_name} pulls the lever. A distant clunk is heard."
          }
        }
      ]
    }
  },
  {
    "unique_tag": "east_storage_1_0_0",
    "data": {
      "name": "Secure Storage Vault Epsilon",
      "description": "Dust motes dance in the dim light. Shelves line the walls, mostly empty. Panel E-1. [DYNAMIC_EXIT_WEST]",
      "x": 1, "y": 0, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "outskirts_gate_0_1_0",
    "data": {
      "name": "Dilapidated Northern Gate",
      "description": "A crumbling stone archway marks what might have once been a northern exit from the central complex. The path beyond is overgrown and disappears into a tangle of thorny bushes.",
      "x": 0, "y": 1, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "beginner_path_0_2_0",
    "data": {
      "name": "Overgrown Path",
      "description": "Thorny bushes and grasping weeds choke this narrow path. The air is damp and smells of decay. Small creatures skitter in the undergrowth.",
      "x": 0, "y": 2, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "ruined_shack_clearing_0_3_0",
    "data": {
      "name": "Ruined Shack Clearing",
      "description": "The path opens into a small clearing where the remains of a wooden shack slowly rot. A rusty water pump stands askew nearby.",
      "x": 0, "y": 3, "z": 0,
      "room_type": "standard",
      "interactables": [
        {
          "id_tag": "shack_pump_handle",
          "name": "a rusty pump handle",
          "description": "The handle of the old water pump is stiff but might still move.",
          "action_verb": "pump",
          "on_interact_effect": {
            "type": "custom_event",
            "message_success_self": "You work the pump handle. After a few groaning protests, a trickle of brackish water sputters out.",
            "message_success_others": "{character_name} works the pump handle, producing a trickle of murky water."
          }
        }
      ]
    }
  },
  {
    "unique_tag": "shack_interior_0_4_0",
    "data": {
      "name": "Inside Ruined Shack",
      "description": "The interior of the shack is damp and filled with cobwebs. Most of the roof has caved in, offering a view of the sky. A tattered mat lies in one corner.",
      "x": 0, "y": 4, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "thorn_thicket_west_m1_3_0",
    "data": {
      "name": "Thorny Thicket (West)",
      "description": "An almost impassable thicket of thorny vines blocks easy passage further west. You can hear buzzing insects.",
      "x": -1, "y": 3, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "thorn_thicket_east_1_3_0",
    "data": {
      "name": "Thorny Thicket (East)",
      "description": "The thorny vines are particularly dense here, scraping at your clothes as you push through.",
      "x": 1, "y": 3, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "rat_infested_cellar_1_4_0",
    "data": {
      "name": "Rat-Infested Cellar Entrance",
      "description": "A collapsed section of ground near the eastern thicket reveals a dark opening leading down into what might be a cellar. It stinks of vermin. [DYNAMIC_EXIT_EAST_CELLAR_DOOR]",
      "x": 1, "y": 4, "z": 0,
      "room_type": "dungeon_entrance"
    }
  },
  {
    "unique_tag": "deep_cellar_main_2_4_0",
    "data": {
      "name": "Deep Cellar - Main Chamber",
      "description": "This small, damp cellar chamber is filled with refuse and the gnawed bones of small animals. The air is heavy with the stench of rats.",
      "x": 2, "y": 4, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "deep_cellar_nest_2_5_0",
    "data": {
      "name": "Deep Cellar - Rat Nest",
      "description": "A particularly rank corner of the cellar, piled high with shredded cloth and filth. This is clearly a nest for something unpleasant.",
      "x": 2, "y": 5, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "goblin_lookout_0_5_0",
    "data": {
      "name": "Goblin Lookout Point",
      "description": "North of the ruined shack, the path climbs slightly to a rocky outcrop. Crude goblin symbols are daubed on the rocks.",
      "x": 0, "y": 5, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "goblin_trail_m1_5_0",
    "data": {
      "name": "Goblin Trail West",
      "description": "A crudely marked trail leads west from the lookout, littered with discarded bones and scraps of leather.",
      "x": -1, "y": 5, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "goblin_camp_m2_5_0",
    "data": {
      "name": "Small Goblin Camp",
      "description": "A small, messy encampment is hidden here, with a poorly tended fire pit and a few crude hide tents. [DYNAMIC_EXIT_WEST_CAVE]",
      "x": -2, "y": 5, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "goblin_cave_entrance_m3_5_0",
    "data": {
      "name": "Goblin Cave Entrance",
      "description": "A narrow opening in the rocks, reeking of goblin filth, leads into a dark cave.",
      "x": -3, "y": 5, "z": 0,
      "room_type": "dungeon_entrance"
    }
  },
  {
    "unique_tag": "goblin_cave_storage_m3_6_0",
    "data": {
      "name": "Goblin Cave - Storage Nook",
      "description": "This small nook in the cave is piled with stolen junk and rotting food.",
      "x": -3, "y": 6, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "path_to_woods_0_6_0",
    "data": {
      "name": "Path to the Whispering Woods",
      "description": "The overgrown path continues north from the goblin lookout, gradually becoming overshadowed by larger, darker trees. The air grows cooler.",
      "x": 0, "y": 6, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_edge_0_7_0",
    "data": {
      "name": "Edge of the Whispering Woods",
      "description": "You stand at the verge of a dark and ancient forest. Twisted trees loom, their branches like skeletal fingers. The sounds of the outskirts fade behind you.",
      "x": 0, "y": 7, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_gloomy_trail_0_8_0",
    "data": {
      "name": "Gloomy Trail",
      "description": "A barely discernible trail winds deeper into the woods. Sunlight struggles to penetrate the thick canopy above.",
      "x": 0, "y": 8, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_wolf_den_clearing_m1_8_0",
    "data": {
      "name": "Wolf Den Clearing",
      "description": "The trail opens into a small clearing. The ground is paw-printed, and a low growl emanates from a shadowed cleft in some rocks to the west.",
      "x": -1, "y": 8, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "wolf_den_cave_m2_8_0",
    "data": {
      "name": "Inside the Wolf Den",
      "description": "A shallow cave, littered with bones and smelling strongly of wet fur. This is undoubtedly a wolf den.",
      "x": -2, "y": 8, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_ancient_oak_0_9_0",
    "data": {
      "name": "Ancient Oak",
      "description": "A colossal, ancient oak tree dominates this part of the woods. Its gnarled branches are draped with moss, and its roots heave up the earth.",
      "x": 0, "y": 9, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_spider_lair_1_9_0",
    "data": {
      "name": "Spider-Infested Grove",
      "description": "Thick, sticky webs hang between the trees here, glistening with dew. The silence is broken only by the rustling of something large in the higher branches.",
      "x": 1, "y": 9, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_broodmother_web_1_10_0",
    "data": {
      "name": "Broodmother's Web",
      "description": "A massive, funnel-shaped web fills a hollow between several large trees. The air is thick with the smell of decay and the chitinous clicking of many legs.",
      "x": 1, "y": 10, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_hidden_shrine_m1_9_0",
    "data": {
      "name": "Hidden Forest Shrine",
      "description": "Tucked away behind a curtain of ivy to the west of the ancient oak, you find a small, moss-covered stone shrine, seemingly forgotten by time. [DYNAMIC_EXIT_WEST_SHRINE_NICHE]",
      "x": -1, "y": 9, "z": 0,
      "room_type": "sanctuary"
    }
  },
  {
    "unique_tag": "woods_shrine_niche_m2_9_0",
    "data": {
      "name": "Shrine Niche",
      "description": "A small alcove within the hidden shrine. A faint, almost imperceptible humming emanates from the stone.",
      "x": -2, "y": 9, "z": 0,
      "room_type": "puzzle"
    }
  },
  {
    "unique_tag": "woods_path_to_mine_0_10_0",
    "data": {
      "name": "Path to the Old Mine",
      "description": "The trail grows rockier and begins to ascend slightly, heading towards a cliff face visible through the trees to the north.",
      "x": 0, "y": 10, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_entrance_0_11_0",
    "data": {
      "name": "Old Mine Entrance",
      "description": "A dark, foreboding mine entrance gapes in the cliffside. Rotting timbers support the opening, and the air smells of damp earth and something metallic. [DYNAMIC_EXIT_NORTH_MINE_GATE]",
      "x": 0, "y": 11, "z": 0,
      "room_type": "dungeon_entrance"
    }
  },
  {
    "unique_tag": "mine_entry_tunnel_0_12_0",
    "data": {
      "name": "Mine Entry Tunnel",
      "description": "The tunnel is dark and supported by creaking wooden beams. Water drips from the ceiling, and the sound of skittering echoes from deeper within.",
      "x": 0, "y": 12, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_foremans_office_m1_12_0",
    "data": {
      "name": "Foreman's Office (Ruined)",
      "description": "A small, caved-in chamber off the main tunnel. A rickety desk and a broken chair are all that remain of what might have been an office.",
      "x": -1, "y": 12, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_shaft_junction_0_13_0",
    "data": {
      "name": "Mine Shaft Junction",
      "description": "The tunnel opens into a larger area where several mine shafts converge. Most are collapsed, but one leads east, and another continues deeper north.",
      "x": 0, "y": 13, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_east_vein_1_13_0",
    "data": {
      "name": "East Vein Tunnel",
      "description": "This narrow tunnel follows a vein of some glittering, unfamiliar ore. The air is stale.",
      "x": 1, "y": 13, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_east_dead_end_2_13_0",
    "data": {
      "name": "East Vein - Dead End",
      "description": "The tunnel ends abruptly in a rockfall. It seems this vein was worked out or abandoned.",
      "x": 2, "y": 13, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_deep_shaft_0_14_0",
    "data": {
      "name": "Deep Mine Shaft",
      "description": "This shaft descends steeply into darkness. The air is noticeably colder, and an unnerving silence hangs in the air.",
      "x": 0, "y": 14, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_undead_chamber_0_15_0",
    "data": {
      "name": "Undead Miners' Chamber",
      "description": "This large cavern is littered with broken mining tools and the skeletal remains of miners, still clad in tattered work clothes. A chilling aura pervades the room.",
      "x": 0, "y": 15, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "bridge_to_sanctum_0_16_0",
    "data": {
      "name": "Crumbling Stone Bridge",
      "description": "North of the deepest part of the mine, a natural chasm is spanned by a dangerously weathered stone bridge. Far below, you can hear the faint sound of rushing water. The air feels charged.",
      "x": 0, "y": 16, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_gatehouse_0_17_0",
    "data": {
      "name": "Sanctum Gatehouse",
      "description": "Beyond the bridge stands a formidable stone gatehouse, its portcullis rusted shut. Strange symbols are carved above the archway. [DYNAMIC_EXIT_NORTH_SANCTUM_PORTCULLIS]",
      "x": 0, "y": 17, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_courtyard_0_18_0",
    "data": {
      "name": "Corrupted Sanctum Courtyard",
      "description": "The flagstones of this courtyard are cracked and overgrown with sickly weeds. Defaced statues stand in alcoves, and an oppressive atmosphere hangs heavy.",
      "x": 0, "y": 18, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_west_wing_m1_18_0",
    "data": {
      "name": "Sanctum - West Wing Antechamber",
      "description": "A once-grand antechamber, now fallen into ruin. Tapestries hang in tatters, and dust coats every surface.",
      "x": -1, "y": 18, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_library_m2_18_0",
    "data": {
      "name": "Sanctum Library (Desecrated)",
      "description": "Bookshelves line the walls, their contents mostly burned or torn. Pages skitter across the floor in the draft. A large, rune-covered lectern stands in the center. [DYNAMIC_EXIT_WEST_SECRET_PASSAGE]",
      "x": -2, "y": 18, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_secret_study_m3_18_0",
    "data": {
      "name": "Sanctum Secret Study",
      "description": "A hidden study, remarkably preserved. Books on dark arts and forbidden lore line the shelves. A single, guttering candle illuminates a desk.",
      "x": -3, "y": 18, "z": 0,
      "room_type": "puzzle"
    }
  },
  {
    "unique_tag": "sanctum_east_wing_1_18_0",
    "data": {
      "name": "Sanctum - East Wing Hallway",
      "description": "This hallway echoes with an unsettling silence. Doors leading off it are mostly broken or hanging from single hinges.",
      "x": 1, "y": 18, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_barracks_1_19_0",
    "data": {
      "name": "Sanctum Barracks (Haunted)",
      "description": "Rotting bunks line the walls of this former barracks. The air is icy cold, and a palpable sense of dread fills the room.",
      "x": 1, "y": 19, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_main_hall_0_19_0",
    "data": {
      "name": "Sanctum Main Hall",
      "description": "A vast, domed hall that must have once been breathtaking. Now, rubble litters the floor, and ominous shadows dance in the dim light filtering from cracks in the dome.",
      "x": 0, "y": 19, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_altar_chamber_0_20_0",
    "data": {
      "name": "Sanctum Altar Chamber",
      "description": "At the northernmost end of the sanctum lies a raised dais upon which a massive, dark stone altar stands. The air crackles with a malevolent energy. [DYNAMIC_EXIT_NORTH_ALTAR_BARRIER]",
      "x": 0, "y": 20, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_inner_sanctum_0_21_0",
    "data": {
      "name": "Inner Sanctum",
      "description": "Beyond the altar, this chamber hums with concentrated dark power. Disturbing runes cover every surface, glowing faintly.",
      "x": 0, "y": 21, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "south_corridor_0_m1_0",
    "data": {
      "name": "South Maintenance Tunnel",
      "description": "Dimly lit and smelling faintly of burnt coffee. A heavy iron door blocks the way further south. Panel S-1. [DYNAMIC_EXIT_SOUTH_ARCHIVE]",
      "x": 0, "y": -1, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "deep_archive_0_m2_0",
    "data": {
      "name": "Deep Archive Sector 42",
      "description": "Ancient, whirring machinery fills this chamber. It feels important. Panel S-2. [DYNAMIC_EXIT_NORTH_ARCHIVE]",
      "x": 0, "y": -2, "z": 0,
      "room_type": "puzzle"
    }
  },
  {
    "unique_tag": "west_corridor_m1_0_0",
    "data": {
      "name": "West Logic Gate Array",
      "description": "To the west, a series of humming conduits. Panel W-1.",
      "x": -1, "y": 0, "z": 0,
      "room_type": "standard"
    }
  }
]
--- END OF FILE backend/app/seeds/rooms_z0.json ---

--- START OF FILE backend/app/seeds/exits_z0.json ---
[
  {
    "source_tag": "central_hub_0_0_0", "direction": "east", "target_tag": "east_storage_1_0_0",
    "details": {
      "is_locked": true, "lock_id_tag": "cpu_east_door_lock",
      "description_when_locked": "A heavy blast door to the east is sealed tight. The nearby lever might control it.",
      "description_when_unlocked": "The heavy blast door to the east stands open."
    }
  },
  {
    "source_tag": "east_storage_1_0_0", "direction": "west", "target_tag": "central_hub_0_0_0",
    "details": {
      "is_locked": true, "lock_id_tag": "cpu_east_door_lock",
      "description_when_locked": "The blast door to the west is sealed. It seems to be controlled from the other side.",
      "description_when_unlocked": "The blast door to the west is open."
    }
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "north", "target_tag": "outskirts_gate_0_1_0", "details": {}
  },
  {
    "source_tag": "outskirts_gate_0_1_0", "direction": "south", "target_tag": "central_hub_0_0_0", "details": {}
  },
  {
    "source_tag": "outskirts_gate_0_1_0", "direction": "north", "target_tag": "beginner_path_0_2_0", "details": {}
  },
  {
    "source_tag": "beginner_path_0_2_0", "direction": "south", "target_tag": "outskirts_gate_0_1_0", "details": {}
  },
  {
    "source_tag": "beginner_path_0_2_0", "direction": "north", "target_tag": "ruined_shack_clearing_0_3_0", "details": {}
  },
  {
    "source_tag": "ruined_shack_clearing_0_3_0", "direction": "south", "target_tag": "beginner_path_0_2_0", "details": {}
  },
  {
    "source_tag": "ruined_shack_clearing_0_3_0", "direction": "north", "target_tag": "shack_interior_0_4_0", "details": {}
  },
  {
    "source_tag": "shack_interior_0_4_0", "direction": "south", "target_tag": "ruined_shack_clearing_0_3_0", "details": {}
  },
  {
    "source_tag": "ruined_shack_clearing_0_3_0", "direction": "west", "target_tag": "thorn_thicket_west_m1_3_0", "details": {}
  },
  {
    "source_tag": "thorn_thicket_west_m1_3_0", "direction": "east", "target_tag": "ruined_shack_clearing_0_3_0", "details": {}
  },
  {
    "source_tag": "ruined_shack_clearing_0_3_0", "direction": "east", "target_tag": "thorn_thicket_east_1_3_0", "details": {}
  },
  {
    "source_tag": "thorn_thicket_east_1_3_0", "direction": "west", "target_tag": "ruined_shack_clearing_0_3_0", "details": {}
  },
  {
    "source_tag": "thorn_thicket_east_1_3_0", "direction": "north", "target_tag": "rat_infested_cellar_1_4_0", "details": {}
  },
  {
    "source_tag": "rat_infested_cellar_1_4_0", "direction": "south", "target_tag": "thorn_thicket_east_1_3_0", "details": {}
  },
  {
    "source_tag": "rat_infested_cellar_1_4_0", "direction": "east", "target_tag": "deep_cellar_main_2_4_0",
    "details": { "is_locked": false, "lock_id_tag": "cellar_door_east",
                 "description_when_locked": "A rickety wooden door to the east is barred from the other side.",
                 "description_when_unlocked": "The rickety wooden door to the east is slightly ajar." }
  },
  {
    "source_tag": "deep_cellar_main_2_4_0", "direction": "west", "target_tag": "rat_infested_cellar_1_4_0",
    "details": { "is_locked": false, "lock_id_tag": "cellar_door_east",
                 "description_when_locked": "The wooden door to the west is barred.",
                 "description_when_unlocked": "The wooden door to the west stands open." }
  },
  {
    "source_tag": "deep_cellar_main_2_4_0", "direction": "north", "target_tag": "deep_cellar_nest_2_5_0", "details": {}
  },
  {
    "source_tag": "deep_cellar_nest_2_5_0", "direction": "south", "target_tag": "deep_cellar_main_2_4_0", "details": {}
  },
  {
    "source_tag": "shack_interior_0_4_0", "direction": "north", "target_tag": "goblin_lookout_0_5_0", "details": {}
  },
  {
    "source_tag": "goblin_lookout_0_5_0", "direction": "south", "target_tag": "shack_interior_0_4_0", "details": {}
  },
  {
    "source_tag": "goblin_lookout_0_5_0", "direction": "west", "target_tag": "goblin_trail_m1_5_0", "details": {}
  },
  {
    "source_tag": "goblin_trail_m1_5_0", "direction": "east", "target_tag": "goblin_lookout_0_5_0", "details": {}
  },
  {
    "source_tag": "goblin_trail_m1_5_0", "direction": "west", "target_tag": "goblin_camp_m2_5_0", "details": {}
  },
  {
    "source_tag": "goblin_camp_m2_5_0", "direction": "east", "target_tag": "goblin_trail_m1_5_0", "details": {}
  },
  {
    "source_tag": "goblin_camp_m2_5_0", "direction": "west", "target_tag": "goblin_cave_entrance_m3_5_0",
    "details": { "is_locked": true, "lock_id_tag": "goblin_cave_flap", "key_item_tag_opens": "crude_goblin_key",
                 "description_when_locked": "A grimy hide flap covers the cave entrance to the west, tied shut.",
                 "description_when_unlocked": "The hide flap to the west is open, revealing a dark cave." }
  },
  {
    "source_tag": "goblin_cave_entrance_m3_5_0", "direction": "east", "target_tag": "goblin_camp_m2_5_0",
    "details": { "is_locked": true, "lock_id_tag": "goblin_cave_flap",
                 "description_when_locked": "The hide flap to the east is secured from the other side.",
                 "description_when_unlocked": "The hide flap to the east is open." }
  },
  {
    "source_tag": "goblin_cave_entrance_m3_5_0", "direction": "north", "target_tag": "goblin_cave_storage_m3_6_0", "details": {}
  },
  {
    "source_tag": "goblin_cave_storage_m3_6_0", "direction": "south", "target_tag": "goblin_cave_entrance_m3_5_0", "details": {}
  },
  {
    "source_tag": "goblin_lookout_0_5_0", "direction": "north", "target_tag": "path_to_woods_0_6_0", "details": {}
  },
  {
    "source_tag": "path_to_woods_0_6_0", "direction": "south", "target_tag": "goblin_lookout_0_5_0", "details": {}
  },
  {
    "source_tag": "path_to_woods_0_6_0", "direction": "north", "target_tag": "woods_edge_0_7_0", "details": {}
  },
  {
    "source_tag": "woods_edge_0_7_0", "direction": "south", "target_tag": "path_to_woods_0_6_0", "details": {}
  },
  {
    "source_tag": "woods_edge_0_7_0", "direction": "north", "target_tag": "woods_gloomy_trail_0_8_0", "details": {}
  },
  {
    "source_tag": "woods_gloomy_trail_0_8_0", "direction": "south", "target_tag": "woods_edge_0_7_0", "details": {}
  },
  {
    "source_tag": "woods_gloomy_trail_0_8_0", "direction": "west", "target_tag": "woods_wolf_den_clearing_m1_8_0", "details": {}
  },
  {
    "source_tag": "woods_wolf_den_clearing_m1_8_0", "direction": "east", "target_tag": "woods_gloomy_trail_0_8_0", "details": {}
  },
  {
    "source_tag": "woods_wolf_den_clearing_m1_8_0", "direction": "west", "target_tag": "wolf_den_cave_m2_8_0", "details": {}
  },
  {
    "source_tag": "wolf_den_cave_m2_8_0", "direction": "east", "target_tag": "woods_wolf_den_clearing_m1_8_0", "details": {}
  },
  {
    "source_tag": "woods_gloomy_trail_0_8_0", "direction": "north", "target_tag": "woods_ancient_oak_0_9_0", "details": {}
  },
  {
    "source_tag": "woods_ancient_oak_0_9_0", "direction": "south", "target_tag": "woods_gloomy_trail_0_8_0", "details": {}
  },
  {
    "source_tag": "woods_ancient_oak_0_9_0", "direction": "east", "target_tag": "woods_spider_lair_1_9_0", "details": {}
  },
  {
    "source_tag": "woods_spider_lair_1_9_0", "direction": "west", "target_tag": "woods_ancient_oak_0_9_0", "details": {}
  },
  {
    "source_tag": "woods_spider_lair_1_9_0", "direction": "north", "target_tag": "woods_broodmother_web_1_10_0", "details": {}
  },
  {
    "source_tag": "woods_broodmother_web_1_10_0", "direction": "south", "target_tag": "woods_spider_lair_1_9_0", "details": {}
  },
  {
    "source_tag": "woods_ancient_oak_0_9_0", "direction": "west", "target_tag": "woods_hidden_shrine_m1_9_0", "details": {}
  },
  {
    "source_tag": "woods_hidden_shrine_m1_9_0", "direction": "east", "target_tag": "woods_ancient_oak_0_9_0", "details": {}
  },
  {
    "source_tag": "woods_hidden_shrine_m1_9_0", "direction": "west", "target_tag": "woods_shrine_niche_m2_9_0",
    "details": { "is_locked": true, "lock_id_tag": "shrine_niche_seal",
                 "description_when_locked": "A faint shimmering barrier blocks the niche to the west.",
                 "description_when_unlocked": "The shimmering barrier to the west has dissipated." }
  },
  {
    "source_tag": "woods_shrine_niche_m2_9_0", "direction": "east", "target_tag": "woods_hidden_shrine_m1_9_0",
    "details": { "is_locked": true, "lock_id_tag": "shrine_niche_seal",
                 "description_when_locked": "The way east is blocked by a shimmering barrier.",
                 "description_when_unlocked": "The way east is clear." }
  },
  {
    "source_tag": "woods_ancient_oak_0_9_0", "direction": "north", "target_tag": "woods_path_to_mine_0_10_0", "details": {}
  },
  {
    "source_tag": "woods_path_to_mine_0_10_0", "direction": "south", "target_tag": "woods_ancient_oak_0_9_0", "details": {}
  },
  {
    "source_tag": "woods_path_to_mine_0_10_0", "direction": "north", "target_tag": "mine_entrance_0_11_0", "details": {}
  },
  {
    "source_tag": "mine_entrance_0_11_0", "direction": "south", "target_tag": "woods_path_to_mine_0_10_0", "details": {}
  },
  {
    "source_tag": "mine_entrance_0_11_0", "direction": "north", "target_tag": "mine_entry_tunnel_0_12_0",
    "details": { "is_locked": true, "lock_id_tag": "mine_gate_lock", "key_item_tag_opens": "foremans_mine_key",
                 "description_when_locked": "A heavy iron gate, rusted shut, blocks the mine entrance to the north.",
                 "description_when_unlocked": "The rusted iron gate to the north stands ajar." }
  },
  {
    "source_tag": "mine_entry_tunnel_0_12_0", "direction": "south", "target_tag": "mine_entrance_0_11_0",
    "details": { "is_locked": true, "lock_id_tag": "mine_gate_lock",
                 "description_when_locked": "The iron gate to the south is locked from this side.",
                 "description_when_unlocked": "The iron gate to the south is open." }
  },
  {
    "source_tag": "mine_entry_tunnel_0_12_0", "direction": "west", "target_tag": "mine_foremans_office_m1_12_0", "details": {}
  },
  {
    "source_tag": "mine_foremans_office_m1_12_0", "direction": "east", "target_tag": "mine_entry_tunnel_0_12_0", "details": {}
  },
  {
    "source_tag": "mine_entry_tunnel_0_12_0", "direction": "north", "target_tag": "mine_shaft_junction_0_13_0", "details": {}
  },
  {
    "source_tag": "mine_shaft_junction_0_13_0", "direction": "south", "target_tag": "mine_entry_tunnel_0_12_0", "details": {}
  },
  {
    "source_tag": "mine_shaft_junction_0_13_0", "direction": "east", "target_tag": "mine_east_vein_1_13_0", "details": {}
  },
  {
    "source_tag": "mine_east_vein_1_13_0", "direction": "west", "target_tag": "mine_shaft_junction_0_13_0", "details": {}
  },
  {
    "source_tag": "mine_east_vein_1_13_0", "direction": "east", "target_tag": "mine_east_dead_end_2_13_0", "details": {}
  },
  {
    "source_tag": "mine_east_dead_end_2_13_0", "direction": "west", "target_tag": "mine_east_vein_1_13_0", "details": {}
  },
  {
    "source_tag": "mine_shaft_junction_0_13_0", "direction": "north", "target_tag": "mine_deep_shaft_0_14_0", "details": {}
  },
  {
    "source_tag": "mine_deep_shaft_0_14_0", "direction": "south", "target_tag": "mine_shaft_junction_0_13_0", "details": {}
  },
  {
    "source_tag": "mine_deep_shaft_0_14_0", "direction": "north", "target_tag": "mine_undead_chamber_0_15_0", "details": {}
  },
  {
    "source_tag": "mine_undead_chamber_0_15_0", "direction": "south", "target_tag": "mine_deep_shaft_0_14_0", "details": {}
  },
  {
    "source_tag": "mine_undead_chamber_0_15_0", "direction": "north", "target_tag": "bridge_to_sanctum_0_16_0", "details": {}
  },
  {
    "source_tag": "bridge_to_sanctum_0_16_0", "direction": "south", "target_tag": "mine_undead_chamber_0_15_0", "details": {}
  },
  {
    "source_tag": "bridge_to_sanctum_0_16_0", "direction": "north", "target_tag": "sanctum_gatehouse_0_17_0", "details": {}
  },
  {
    "source_tag": "sanctum_gatehouse_0_17_0", "direction": "south", "target_tag": "bridge_to_sanctum_0_16_0", "details": {}
  },
  {
    "source_tag": "sanctum_gatehouse_0_17_0", "direction": "north", "target_tag": "sanctum_courtyard_0_18_0",
    "details": { "is_locked": true, "lock_id_tag": "sanctum_portcullis_lock", "key_item_tag_opens": "ornate_sanctum_key",
                 "description_when_locked": "A massive iron portcullis blocks the way north. It looks incredibly heavy.",
                 "description_when_unlocked": "The massive iron portcullis to the north has been raised." }
  },
  {
    "source_tag": "sanctum_courtyard_0_18_0", "direction": "south", "target_tag": "sanctum_gatehouse_0_17_0",
    "details": { "is_locked": true, "lock_id_tag": "sanctum_portcullis_lock",
                 "description_when_locked": "The portcullis to the south is down, blocking the way.",
                 "description_when_unlocked": "The portcullis to the south is raised." }
  },
  {
    "source_tag": "sanctum_courtyard_0_18_0", "direction": "west", "target_tag": "sanctum_west_wing_m1_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_west_wing_m1_18_0", "direction": "east", "target_tag": "sanctum_courtyard_0_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_west_wing_m1_18_0", "direction": "west", "target_tag": "sanctum_library_m2_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_library_m2_18_0", "direction": "east", "target_tag": "sanctum_west_wing_m1_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_library_m2_18_0", "direction": "west", "target_tag": "sanctum_secret_study_m3_18_0",
    "details": { "is_locked": true, "lock_id_tag": "library_secret_passage",
                 "description_when_locked": "One of the bookshelves to the west looks like it might move, but it's firmly in place.",
                 "description_when_unlocked": "A section of the western bookshelf has slid aside, revealing a passage."}
  },
  {
    "source_tag": "sanctum_secret_study_m3_18_0", "direction": "east", "target_tag": "sanctum_library_m2_18_0",
    "details": { "is_locked": true, "lock_id_tag": "library_secret_passage",
                 "description_when_locked": "The passage to the east is hidden behind a bookshelf.",
                 "description_when_unlocked": "The passage to the east is open."}
  },
  {
    "source_tag": "sanctum_courtyard_0_18_0", "direction": "east", "target_tag": "sanctum_east_wing_1_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_east_wing_1_18_0", "direction": "west", "target_tag": "sanctum_courtyard_0_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_east_wing_1_18_0", "direction": "north", "target_tag": "sanctum_barracks_1_19_0", "details": {}
  },
  {
    "source_tag": "sanctum_barracks_1_19_0", "direction": "south", "target_tag": "sanctum_east_wing_1_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_courtyard_0_18_0", "direction": "north", "target_tag": "sanctum_main_hall_0_19_0", "details": {}
  },
  {
    "source_tag": "sanctum_main_hall_0_19_0", "direction": "south", "target_tag": "sanctum_courtyard_0_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_main_hall_0_19_0", "direction": "north", "target_tag": "sanctum_altar_chamber_0_20_0", "details": {}
  },
  {
    "source_tag": "sanctum_altar_chamber_0_20_0", "direction": "south", "target_tag": "sanctum_main_hall_0_19_0", "details": {}
  },
  {
    "source_tag": "sanctum_altar_chamber_0_20_0", "direction": "north", "target_tag": "sanctum_inner_sanctum_0_21_0",
    "details": { "is_locked": true, "lock_id_tag": "altar_barrier_seal",
                 "description_when_locked": "A crackling barrier of dark energy blocks passage further north beyond the altar.",
                 "description_when_unlocked": "The dark energy barrier to the north has faded." }
  },
  {
    "source_tag": "sanctum_inner_sanctum_0_21_0", "direction": "south", "target_tag": "sanctum_altar_chamber_0_20_0",
    "details": { "is_locked": true, "lock_id_tag": "altar_barrier_seal",
                 "description_when_locked": "The way south is blocked by a crackling energy barrier.",
                 "description_when_unlocked": "The way south is clear." }
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "south", "target_tag": "south_corridor_0_m1_0", "details": {}
  },
  {
    "source_tag": "south_corridor_0_m1_0", "direction": "north", "target_tag": "central_hub_0_0_0", "details": {}
  },
  {
    "source_tag": "south_corridor_0_m1_0", "direction": "south", "target_tag": "deep_archive_0_m2_0",
    "details": { "is_locked": true, "lock_id_tag": "deep_archive_key_lock", "key_item_tag_opens": "archive_key_alpha",
                 "description_when_locked": "A formidable iron door blocks passage south. It has a complex keyhole.",
                 "description_when_unlocked": "The formidable iron door to the south is unlocked.",
                 "skill_to_pick": {"skill_id_tag": "pick_lock_basic", "dc": 18} }
  },
  {
    "source_tag": "deep_archive_0_m2_0", "direction": "north", "target_tag": "south_corridor_0_m1_0",
    "details": { "is_locked": true, "lock_id_tag": "deep_archive_key_lock", "key_item_tag_opens": "archive_key_alpha",
                 "description_when_locked": "The iron door to the north is locked from this side too.",
                 "description_when_unlocked": "The iron door to the north is open.",
                 "skill_to_pick": {"skill_id_tag": "pick_lock_basic", "dc": 18} }
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "west", "target_tag": "west_corridor_m1_0_0", "details": {}
  },
  {
    "source_tag": "west_corridor_m1_0_0", "direction": "east", "target_tag": "central_hub_0_0_0", "details": {}
  }
]
--- END OF FILE backend/app/seeds/exits_z0.json ---

--- START OF FILE frontend/src/main.js ---
// frontend/src/main.js
import { UI } from './ui.js';
import { API } from './api.js';
import { WebSocketService } from './websocket.js';
import { MapDisplay } from './map.js';
import { gameState, saveSession, loadSession, clearSession, updateGameState } from './state.js';

export function handleWebSocketMessage(serverData) {
    let charVitals = null; 

    if (serverData.type === "welcome_package" && serverData.character_vitals) charVitals = serverData.character_vitals;
    else if (serverData.type === "combat_update" && serverData.character_vitals) charVitals = serverData.character_vitals;
    else if (serverData.type === "vitals_update") charVitals = serverData; 

    if (charVitals) {
        UI.updatePlayerVitals(
            charVitals.current_hp, charVitals.max_hp,
            charVitals.current_mp, charVitals.max_mp,
            charVitals.current_xp, charVitals.next_level_xp
        );
        UI.updateCharacterInfoBar(gameState.selectedCharacterName, gameState.selectedCharacterClass, charVitals.level);
        if (charVitals.platinum !== undefined) { 
            UI.updateCurrencyDisplay(charVitals.platinum, charVitals.gold, charVitals.silver, charVitals.copper);
        }
    }

    switch (serverData.type) {
        case "welcome_package":
            if (serverData.log && serverData.log.length > 0) UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            if (serverData.room_data) {
                const currentRoom = serverData.room_data;
                UI.updateGameDisplay(currentRoom);
                UI.updateExitsDisplay(currentRoom);
                updateGameState({ displayedRoomId: currentRoom.id });
                // Pass currentRoom data for immediate title/highlight and to determine target Z
                MapDisplay.fetchAndDrawMap(currentRoom); 
            }
            break;
        case "combat_update": 
            if (serverData.room_data) {
                const currentRoom = serverData.room_data; 
                const movedRoom = gameState.displayedRoomId !== currentRoom.id;
                const zLevelChanged = MapDisplay.currentZLevel !== currentRoom.z;
                
                UI.updateGameDisplay(currentRoom); 
                UI.updateExitsDisplay(currentRoom);
                updateGameState({ displayedRoomId: currentRoom.id });

                if (movedRoom || zLevelChanged || !MapDisplay.mapDataCache[currentRoom.z]) {
                    // console.log(`Map update triggered: moved=${movedRoom}, zChanged=${zLevelChanged}, notCached=${!MapDisplay.mapDataCache[currentRoom.z]}`);
                    MapDisplay.fetchAndDrawMap(currentRoom);
                } else {
                    MapDisplay.redrawMapForCurrentRoom(currentRoom.id, currentRoom);
                }
            }
            if (serverData.log && serverData.log.length > 0) UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            updateGameState({ isInCombat: !serverData.combat_over });
            break;
        case "vitals_update": break;
        case "ooc_message": UI.appendToOutput(serverData.message, { styleClass: "ooc-chat-message" }); break;
        case "game_event": if (serverData.message) UI.appendToOutput(serverData.message, { styleClass: "game-message" }); break;
        default:
            if (serverData.message) UI.appendToOutput(`GS (${serverData.type}): ${serverData.message}`, { styleClass: "game-message" });
            else UI.appendToOutput(`GS (unparsed type: ${serverData.type}): ${JSON.stringify(serverData)}`, { styleClass: "game-message" });
            break;
    }
}

// ... (startLoginProcess, promptForPassword, etc. remain largely unchanged from previous correct version) ...
// Make sure they call UI.showAppropriateView() AFTER updateGameState loginState changes.

async function startLoginProcess() {
    clearSession(); 
    updateGameState({ loginState: 'PROMPT_USER' }); 
    WebSocketService.close();
    MapDisplay.clearMap(); 
    MapDisplay.currentMapDisplayData = null; // Clear current display data
    MapDisplay.currentZLevel = 0; // Reset Z
    MapDisplay.drawMap();  
    UI.showAppropriateView(); 
    UI.clearOutput();
    UI.appendToOutput("Welcome to The Unholy MUD of Tron & Allen1.");
    UI.appendToOutput("Version: Refactored & Ready to Rumble!"); 
    UI.appendToOutput("-------------------------------------------------");
    UI.appendToOutput("Username (or type 'new' to register): ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Enter username or 'new'");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function promptForPassword() {
    updateGameState({ loginState: 'PROMPT_PASSWORD' });
    UI.showAppropriateView(); 
    UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true });
    UI.setInputCommandPlaceholder("Enter password");
    UI.setInputCommandType('password');
    UI.focusCommandInput();
}

async function promptForRegistrationUsername() {
    updateGameState({ loginState: 'REGISTER_PROMPT_USER' });
    UI.showAppropriateView(); 
    UI.appendToOutput("Registering new user.");
    UI.appendToOutput("Desired username: ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Enter desired username");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function promptForRegistrationPassword() {
    updateGameState({ loginState: 'REGISTER_PROMPT_PASSWORD' });
    UI.showAppropriateView(); 
    UI.appendToOutput("Desired password (min 8 chars): ", { isPrompt: true, noNewLineBefore: true });
    UI.setInputCommandPlaceholder("Enter desired password");
    UI.setInputCommandType('password');
    UI.focusCommandInput();
}

async function displayCharacterSelection() {
    updateGameState({ loginState: 'CHAR_SELECT_PROMPT' });
    UI.showAppropriateView(); 
    if (!gameState.currentAuthToken) {
        UI.appendToOutput("! Authentication token missing. Please log in.", { styleClass: 'error-message-inline' });
        handleLogout(); return;
    }
    UI.appendToOutput("\nFetching character list...");
    try {
        const characters = await API.fetchCharacters();
        updateGameState({ availableCharacters: characters });
        UI.appendToOutput("\n--- Character Selection ---");
        if (characters.length === 0) UI.appendToOutput("No characters found for your account.");
        else {
            UI.appendToOutput("Your characters:");
            characters.forEach((char, index) => UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${char.name}</span> (<span class="char-class">${char.class_name}</span> - Lvl ${char.level})</span>`));
        }
        UI.appendToOutput("Enter character # to play, or type 'new' to create one: ", { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter # or 'new'");
    } catch (error) {
        UI.appendToOutput(`! Error fetching characters: ${error.message}`, { styleClass: 'error-message-inline' });
        if (error.response && error.response.status === 401) handleLogout();
        else startLoginProcess(); 
    }
    UI.focusCommandInput();
}

async function promptForNewCharacterName() {
    updateGameState({ loginState: 'CHAR_CREATE_PROMPT_NAME', tempCharName: '' });
    UI.showAppropriateView(); 
    UI.appendToOutput("\n--- New Character Creation ---");
    UI.appendToOutput("Enter character name: ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Character Name (3-50 chars)");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function displayClassSelection() {
    updateGameState({ loginState: 'CHAR_CREATE_PROMPT_CLASS' });
    UI.showAppropriateView(); 
    UI.appendToOutput(`\nFetching available classes for ${gameState.tempCharName}...`);
    try {
        const classes = await API.fetchAvailableClasses();
        updateGameState({ availableClasses: classes });
        if (classes.length === 0) {
            UI.appendToOutput("! No character classes available. Defaulting to 'Adventurer'.", { styleClass: 'error-message-inline' });
            updateGameState({ tempCharClassName: 'Adventurer' });
            await createCharacterWithSelectedClass(); return;
        }
        UI.appendToOutput("Available Classes:");
        classes.forEach((charClass, index) => UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${charClass.name}</span> - <span class="char-class-desc">${charClass.description || 'A mysterious path.'}</span></span>`));
        UI.appendToOutput(`Select class for '${gameState.tempCharName}' by number: `, { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter class #");
    } catch (error) {
        UI.appendToOutput(`! Error fetching classes: ${error.message}. Defaulting to 'Adventurer'.`, { styleClass: 'error-message-inline' });
        updateGameState({ tempCharClassName: 'Adventurer' });
        await createCharacterWithSelectedClass();
    }
    UI.focusCommandInput();
}

async function createCharacterWithSelectedClass() {
    const charName = gameState.tempCharName;
    const charClassName = gameState.tempCharClassName || "Adventurer";
    UI.appendToOutput(`\nCreating ${charName} the ${charClassName}...`);
    try {
        await API.createCharacter(charName, charClassName);
        UI.appendToOutput("Character created successfully!");
        await displayCharacterSelection(); 
    } catch (error) {
        UI.appendToOutput(`! Error creating character: ${error.data?.detail || error.message}`, { styleClass: 'error-message-inline' });
        await displayCharacterSelection(); 
    }
}

async function selectCharacterAndStartGame(character) {
    UI.appendToOutput(`\nSelecting character: ${character.name}...`);
    try {
        const initialRoomData = await API.selectCharacterOnBackend(character.id);
        saveSession(gameState.currentAuthToken, character.id, character.name, character.class_name || 'Adventurer');
        await enterGameModeWithCharacter(character, initialRoomData);
    } catch (error) {
        UI.appendToOutput(`! Error selecting character: ${error.message}`, { styleClass: 'error-message-inline' });
        await displayCharacterSelection();
    }
}

async function enterGameModeWithCharacter(character, initialRoomDataFromHttpSelect) {
    updateGameState({
        selectedCharacterId: character.id,
        selectedCharacterName: character.name,
        selectedCharacterClass: character.class_name || 'Adventurer',
        loginState: 'IN_GAME' 
    });
    UI.showAppropriateView(); 
    
    UI.updateCharacterInfoBar(character.name, character.class_name, character.level); 
    UI.updateCurrencyDisplay(character.platinum_coins || 0, character.gold_coins || 0, character.silver_coins || 0, character.copper_coins || 0); 

    UI.clearOutput();
    UI.appendToOutput(`Playing as: <span class="char-name">${character.name}</span>, the <span class="char-class">${character.class_name || 'Adventurer'}</span> (Lvl ${character.level || 1})`);
    UI.setInputCommandPlaceholder("Type command...");
    UI.setInputCommandType('text');

    // Pass initialRoomData to fetchAndDrawMap. It will use its Z to fetch if not cached.
    MapDisplay.fetchAndDrawMap(initialRoomDataFromHttpSelect); 
    
    WebSocketService.connect(); 
    UI.focusCommandInput();
}

function handleLogout() {
    WebSocketService.close();
    MapDisplay.clearMap();
    MapDisplay.currentMapDisplayData = null; // Also clear this on logout
    MapDisplay.currentZLevel = 0;
    clearSession(); 
    startLoginProcess(); 
}

async function handleHttpCommandResponse(responseData, originalCommand) {
    if (responseData.message_to_player) UI.appendToOutput(responseData.message_to_player, { styleClass: 'game-message' });
    if (responseData.room_data) {
        const currentRoom = responseData.room_data; 
        const cmdClean = originalCommand.toLowerCase().trim();
        const isLook = cmdClean.startsWith("look") || cmdClean === "l"; 
        const movedRoom = gameState.displayedRoomId !== currentRoom.id;
        const zLevelChanged = MapDisplay.currentZLevel !== currentRoom.z;

        if (isLook || movedRoom) UI.updateGameDisplay(currentRoom);
        UI.updateExitsDisplay(currentRoom);
        updateGameState({ displayedRoomId: currentRoom.id });
        
        if (movedRoom || zLevelChanged || !MapDisplay.mapDataCache[currentRoom.z]) {
            MapDisplay.fetchAndDrawMap(currentRoom); 
        } else {
            MapDisplay.redrawMapForCurrentRoom(currentRoom.id, currentRoom);
        }
    }
}

async function handleInputSubmission() {
    const commandInputEl = UI.getCommandInput();
    if (!commandInputEl) return;
    const inputText = commandInputEl.value.trim();
    let echoText = inputText;
    let echoOptions = { isPrompt: false };

    if (gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
        echoText = '*'.repeat(inputText.length || 8);
        echoOptions.noNewLineBefore = true;
    } else if (gameState.loginState === 'IN_GAME' && inputText) {
        echoText = `> ${inputText}`;
    } else if (inputText) { 
        echoOptions.noNewLineBefore = true; 
    }

    if (inputText || gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
        UI.appendToOutput(echoText, echoOptions);
    }
    commandInputEl.value = '';

    try {
        switch (gameState.loginState) {
            case 'PROMPT_USER':
                if (inputText.toLowerCase() === 'new') await promptForRegistrationUsername();
                else if (inputText) { updateGameState({ tempUsername: inputText }); await promptForPassword(); }
                else { UI.appendToOutput("Username (or 'new'): ", { isPrompt: true, noNewLineBefore: true }); UI.focusCommandInput(); } 
                break;
            case 'PROMPT_PASSWORD':
                UI.appendToOutput("\nAttempting login...");
                const loginData = await API.loginUser(gameState.tempUsername, inputText);
                saveSession(loginData.access_token, null, null, null); 
                UI.appendToOutput("Login successful!");
                UI.setInputCommandType('text');
                await displayCharacterSelection();
                break;
            case 'REGISTER_PROMPT_USER':
                if (inputText) { updateGameState({ tempUsername: inputText }); await promptForRegistrationPassword(); }
                else { UI.appendToOutput("Desired username: ", { isPrompt: true, noNewLineBefore: true }); UI.focusCommandInput(); }
                break;
            case 'REGISTER_PROMPT_PASSWORD':
                updateGameState({ tempPassword: inputText });
                UI.appendToOutput("\nAttempting registration...");
                await API.registerUser(gameState.tempUsername, gameState.tempPassword);
                UI.appendToOutput("Registration successful!");
                UI.appendToOutput(`Now, please log in as '${gameState.tempUsername}'.`);
                updateGameState({ loginState: 'PROMPT_PASSWORD' }); 
                UI.showAppropriateView(); 
                UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true });
                UI.setInputCommandPlaceholder("Enter password");
                UI.setInputCommandType('password');
                UI.focusCommandInput(); 
                break;
            case 'CHAR_SELECT_PROMPT':
                if (inputText.toLowerCase() === 'new') await promptForNewCharacterName();
                else {
                    const charIndex = parseInt(inputText, 10) - 1;
                    if (gameState.availableCharacters && charIndex >= 0 && charIndex < gameState.availableCharacters.length) {
                        await selectCharacterAndStartGame(gameState.availableCharacters[charIndex]);
                    } else {
                        UI.appendToOutput("! Invalid selection.", { styleClass: 'error-message-inline' });
                        UI.appendToOutput("Enter character #, or 'new': ", { isPrompt: true, noNewLineBefore: true });
                        UI.focusCommandInput();
                    }
                }
                break;
            case 'CHAR_CREATE_PROMPT_NAME':
                if (!inputText || inputText.length < 3 || inputText.length > 50) {
                    UI.appendToOutput("! Invalid name (3-50 chars). Name: ", { isPrompt: true, styleClass: 'error-message-inline', noNewLineBefore: true });
                    UI.focusCommandInput(); break;
                }
                updateGameState({ tempCharName: inputText });
                await displayClassSelection();
                break;
            case 'CHAR_CREATE_PROMPT_CLASS':
                const classIndex = parseInt(inputText, 10) - 1;
                if (gameState.availableClasses && classIndex >= 0 && classIndex < gameState.availableClasses.length) {
                    const selectedClass = gameState.availableClasses[classIndex];
                    updateGameState({ tempCharClassName: selectedClass.name });
                    await createCharacterWithSelectedClass();
                } else {
                    UI.appendToOutput("! Invalid class selection. Please enter a valid number.", { styleClass: 'error-message-inline' });
                    UI.appendToOutput(`Select class for ${gameState.tempCharName} by number: `, { isPrompt: true, noNewLineBefore: true });
                    UI.focusCommandInput();
                }
                break;
            case 'IN_GAME':
                if (!inputText) { UI.focusCommandInput(); break; } 
                const lowerInputText = inputText.toLowerCase();
                const commandVerb = lowerInputText.split(" ")[0];

                if (commandVerb === "logout") { handleLogout(); break; }

                const webSocketHandledVerbs = ["attack","atk","kill","k","flee","look","l","rest","use","skill","cast","get","take","unlock","search","examine","pull","push","turn","pry","activate","n","s","e","w","north","south","east","west","up","down","u","d","go"];
                if (webSocketHandledVerbs.includes(commandVerb)) {
                    WebSocketService.sendMessage({ type: "command", command_text: inputText });
                } else {
                    const httpOkayVerbs = ["spawnmob","mod_xp","set_hp","help","ooc","say","score","inventory","i","skills","traits","status","st","sc","sk","tr","?","equip","unequip","wear","remove","eq"];
                    if (httpOkayVerbs.includes(commandVerb)) {
                        const httpResponse = await API.sendHttpCommand(inputText);
                        handleHttpCommandResponse(httpResponse, inputText);
                    } else {
                        UI.appendToOutput(`Unrecognized command: '${inputText}'. Try 'help'.`);
                    }
                }
                break;
            default:
                UI.appendToOutput("! System error: Unknown login state.", { styleClass: 'error-message-inline' });
                startLoginProcess();
        }
    } catch (error) {
        console.error("Error during input submission:", error);
        UI.appendToOutput(`\n! Error: ${error.data?.detail || error.message || 'An unknown error occurred.'}`, { styleClass: 'error-message-inline' });
        if (gameState.loginState === 'PROMPT_PASSWORD') await promptForPassword();
        else if (gameState.loginState.includes('CHAR_')) await displayCharacterSelection();
        else if (gameState.loginState.includes('REGISTER_')) await promptForRegistrationUsername();
    }
}

async function attemptSessionResume() {
    if (loadSession() && gameState.currentAuthToken && gameState.selectedCharacterId) {
        UI.clearOutput(); 
        UI.appendToOutput("Attempting to resume session...");
        try {
            // For resume, we don't call selectCharacterOnBackend as the session token implies selection.
            // We directly construct a partial character and enter game mode.
            // enterGameModeWithCharacter will then call MapDisplay.fetchAndDrawMap(null)
            // and the WebSocket welcome_package will provide the definitive current room.
            UI.appendToOutput(`Resumed session as ${gameState.selectedCharacterName}.`);
            const resumedCharacter = { 
                id: gameState.selectedCharacterId,
                name: gameState.selectedCharacterName,
                class_name: gameState.selectedCharacterClass,
                level: 1, 
                platinum_coins: 0, gold_coins: 0, silver_coins: 0, copper_coins: 0 
            };
            await enterGameModeWithCharacter(resumedCharacter, null); // Pass null for initialRoomData
            return true;
        } catch (error) { // This catch might not be hit if error is in async enterGameMode calls
            UI.appendToOutput(`! Session resume failed: ${error.data?.detail || error.message}. Please log in.`, { styleClass: 'error-message-inline' });
            clearSession(); 
        }
    }
    return false;
}

document.addEventListener('DOMContentLoaded', async () => {
    if (!UI.initializeElements()) return; 
    MapDisplay.initialize();

    const commandInputEl = UI.getCommandInput();
    if (commandInputEl) {
        commandInputEl.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleInputSubmission();
            }
        });
    } else {
        console.error("Command input not found during DOMContentLoaded setup. Input will not work.");
    }

    if (!(await attemptSessionResume())) {
        startLoginProcess();
    }
});
--- END OF FILE frontend/src/main.js ---

--- START OF FILE frontend/src/websocket.js ---
// frontend/src/websocket.js
import { WS_PROTOCOL, WS_HOST } from './config.js';
import { gameState, updateGameState } from './state.js';
import { UI } from './ui.js';
// Import GameLogic or main app event handlers if WS messages need to trigger complex game logic
import { handleWebSocketMessage } from './main.js'; // Assuming handleWebSocketMessage will be in main.js

export const WebSocketService = {
    connect: function () {
        if (!gameState.currentAuthToken || !gameState.selectedCharacterId) {
            UI.appendToOutput("! Cannot connect WebSocket: Missing token or character ID.", { styleClass: "error-message-inline" });
            return;
        }
        if (gameState.gameSocket && gameState.gameSocket.readyState === WebSocket.OPEN) {
            console.log("WebSocket already open.");
            return;
        }

        const wsUrl = `${WS_PROTOCOL}//${WS_HOST}/ws?token=${gameState.currentAuthToken}&character_id=${gameState.selectedCharacterId}`;
        UI.appendToOutput("Connecting to game server...");
        console.log("Attempting WS connection to:", wsUrl);
        
        const socket = new WebSocket(wsUrl); // Use local var first

        socket.onopen = function (event) {
            console.log("WebSocket connection established.");
            updateGameState({ gameSocket: socket }); // Store the successfully opened socket
            // Optionally send a "client_ready" or similar message if backend expects one
        };

        socket.onmessage = function (event) {
            try {
                const serverData = JSON.parse(event.data);
                console.log("WS RCV:", serverData);
                handleWebSocketMessage(serverData); // Delegate to main handler
            } catch (e) {
                console.error("Error parsing WebSocket message or processing:", e);
                UI.appendToOutput(`GS (unparsed): ${event.data}`, { styleClass: "game-message" });
            }
        };

        socket.onerror = function (event) {
            console.error("WebSocket error observed:", event);
            UI.appendToOutput("! WebSocket connection error.", { styleClass: "error-message-inline" });
            updateGameState({ gameSocket: null, isInCombat: false });
        };

        socket.onclose = function (event) {
            console.log("WebSocket connection closed:", event.code, event.reason);
            UI.appendToOutput(`! Game server connection closed. (Code: ${event.code} ${event.reason || ''})`.trim(), { styleClass: "game-message" });
            updateGameState({ gameSocket: null, isInCombat: false });
        };
    },

    sendMessage: function (payloadObject) {
        if (gameState.gameSocket && gameState.gameSocket.readyState === WebSocket.OPEN) {
            gameState.gameSocket.send(JSON.stringify(payloadObject));
        } else {
            UI.appendToOutput("! Cannot send command: Not connected to game server.", { styleClass: "error-message-inline" });
        }
    },

    close: function () {
        if (gameState.gameSocket) {
            if (gameState.gameSocket.readyState === WebSocket.OPEN || gameState.gameSocket.readyState === WebSocket.CONNECTING) {
                gameState.gameSocket.close();
            }
        }
        updateGameState({ gameSocket: null }); // Ensure it's nulled out in global state
    }
};
--- END OF FILE frontend/src/websocket.js ---

--- START OF FILE frontend/src/map.js ---
// frontend/src/map.js
import { API } from './api.js';
import { gameState } from './state.js';
import { UI } from './ui.js'; 

const SVG_NS = "http://www.w3.org/2000/svg";

export const MapDisplay = {
    svgElement: null, mapContentGroup: null, 
    mapDataCache: {}, currentZLevelForView: 0, currentMapDisplayData: null, 
    currentRoomHighlightColor: 'rgba(255, 255, 0, 0.7)', defaultRoomColor: 'rgba(0, 128, 0, 0.3)',
    connectionLineColor: 'rgba(0, 192, 0, 0.6)', roomStrokeColor: 'rgba(0,50,0,0.8)',
    TILE_SIZE_BASE: 24, currentZoomLevel: 1.0, MIN_ZOOM_LEVEL: 0.2, MAX_ZOOM_LEVEL: 3.0, ZOOM_INCREMENT_FACTOR: 1.15,
    mapTranslateX: 0, mapTranslateY: 0, isPanning: false, lastPanX: 0, lastPanY: 0,
    zoomButtonsContainer: null, mapViewportElement: null,
    minGameY: 0, maxGameY: 0, 

    // Room Type Icons (Emojis)
    roomTypeIcons: {
        sanctuary: 'âœ¨', // Sparkles
        shop: 'ðŸ’°',      // Money Bag
        trainer: 'ðŸ’ª',   // Flexed Biceps
        puzzle: 'ðŸ§©',    // Puzzle Piece
        boss_lair: 'ðŸ’€', // Skull (assuming you add 'boss_lair' type)
        dungeon_entrance: 'ðŸšª', // Door
        // standard rooms won't have an icon by default
    },
    iconColor: 'rgba(220, 220, 255, 0.9)', // Light lavender/blue for icons
    iconFontSizeMultiplier: 0.6, // Relative to TILE_SIZE_BASE for icon text

    initialize: function() { /* UNCHANGED from previous - it was correct */
        this.svgElement = document.getElementById('map-svg');
        this.mapViewportElement = document.getElementById('map-viewport');
        if (!this.svgElement || !this.mapViewportElement) { console.error("CRITICAL: Map SVG element or viewport not found!"); return; }
        this.mapContentGroup = document.createElementNS(SVG_NS, "g"); this.mapContentGroup.id = "map-content-group";
        this.svgElement.appendChild(this.mapContentGroup); 
        this.resizeSVG(); window.addEventListener('resize', () => this.resizeSVG());
        if (this.mapViewportElement) { 
            this.zoomButtonsContainer = document.createElement('div');
            this.zoomButtonsContainer.style.position = 'absolute'; this.zoomButtonsContainer.style.top = '5px'; 
            this.zoomButtonsContainer.style.right = '5px'; this.zoomButtonsContainer.style.zIndex = '1001'; 
            const zoomInButton = document.createElement('button'); zoomInButton.textContent = '+'; zoomInButton.title = 'Zoom In';
            this._styleZoomButton(zoomInButton); zoomInButton.addEventListener('click', (e) => { e.stopPropagation(); this.zoomIn(); });
            const zoomOutButton = document.createElement('button'); zoomOutButton.textContent = '-'; zoomOutButton.title = 'Zoom Out';
            this._styleZoomButton(zoomOutButton); zoomOutButton.addEventListener('click', (e) => { e.stopPropagation(); this.zoomOut(); });
            this.zoomButtonsContainer.appendChild(zoomInButton); this.zoomButtonsContainer.appendChild(zoomOutButton);
            this.mapViewportElement.appendChild(this.zoomButtonsContainer); 
            this.mapViewportElement.addEventListener('wheel', (event) => this.handleMouseWheelZoom(event), { passive: false });
            this.mapViewportElement.addEventListener('mousedown', (event) => this.handlePanStart(event));
            this.mapViewportElement.addEventListener('mousemove', (event) => this.handlePanMove(event));
            this.mapViewportElement.addEventListener('mouseup', () => this.handlePanEnd()); 
            this.mapViewportElement.addEventListener('mouseleave', () => this.handlePanEnd()); 
            this.mapViewportElement.style.cursor = 'grab'; 
        }
    },
    _styleZoomButton: function(button) { /* UNCHANGED */ 
        button.style.background = '#333'; button.style.color = '#0f0'; button.style.border = '1px solid #0f0';
        button.style.padding = '2px 6px'; button.style.margin = '2px'; button.style.cursor = 'pointer';
        button.style.fontFamily = 'monospace'; button.style.fontSize = '14px'; button.style.minWidth = '25px';
    },
    handlePanStart: function(event) { /* UNCHANGED */ 
        if (event.button !== 0) return; this.isPanning = true; this.lastPanX = event.clientX; this.lastPanY = event.clientY;
        this.mapViewportElement.style.cursor = 'grabbing'; event.preventDefault();
    },
    handlePanMove: function(event) { /* UNCHANGED */ 
        if (!this.isPanning) return; const dx = event.clientX - this.lastPanX; const dy = event.clientY - this.lastPanY;
        this.mapTranslateX += dx; this.mapTranslateY += dy; this.lastPanX = event.clientX; this.lastPanY = event.clientY;
        this.applyTransform();
    },
    handlePanEnd: function() { /* UNCHANGED */ 
        if (this.isPanning) { this.isPanning = false; this.mapViewportElement.style.cursor = 'grab'; }
    },
    applyTransform: function() { /* UNCHANGED */ 
        if (!this.mapContentGroup) return;
        this.mapContentGroup.setAttribute('transform', `translate(${this.mapTranslateX}, ${this.mapTranslateY}) scale(${this.currentZoomLevel})`);
    },
    
    updateCenteringAndZoom: function(forceRecenter = false, roomToCenterData = null) { /* UNCHANGED from previous - it was correctly calling UI.updateMapTitleBar */
        if (!this.mapViewportElement) return; 
        const svgWidth = this.mapViewportElement.clientWidth; const svgHeight = this.mapViewportElement.clientHeight;
        let currentRoomForTitle = roomToCenterData; 
        let zLevelForTitle = this.currentZLevelForView; 
        if (!currentRoomForTitle && this.currentMapDisplayData && this.currentMapDisplayData.rooms?.length > 0) {
            const currentRoomId = this.currentMapDisplayData.current_room_id || gameState.displayedRoomId;
            currentRoomForTitle = currentRoomId ? this.currentMapDisplayData.rooms.find(r => r.id === currentRoomId) : null;
            if (!currentRoomForTitle) currentRoomForTitle = this.currentMapDisplayData.rooms[0];
        }
        if(currentRoomForTitle) zLevelForTitle = currentRoomForTitle.z; 
        UI.updateMapTitleBar(currentRoomForTitle?.x, currentRoomForTitle?.y, zLevelForTitle);
        // Placeholder for Zone update
        UI.updateMapZoneBar(this.currentMapDisplayData?.zone_name, this.currentMapDisplayData?.zone_levels);


        if (!this.currentMapDisplayData || !this.currentMapDisplayData.rooms?.length === 0) {
            this.mapTranslateX = svgWidth / 2; this.mapTranslateY = svgHeight / 2; this.applyTransform(); return;
        }
        let roomToActuallyCenter = roomToCenterData; 
        if (!roomToActuallyCenter) { 
            const currentRoomId = this.currentMapDisplayData.current_room_id || gameState.displayedRoomId;
            roomToActuallyCenter = currentRoomId ? this.currentMapDisplayData.rooms.find(r => r.id === currentRoomId) : null;
            if (!roomToActuallyCenter && this.currentMapDisplayData.rooms.length > 0) roomToActuallyCenter = this.currentMapDisplayData.rooms[0];
        }
        if (forceRecenter && roomToActuallyCenter) {
            const gameYForCentering = this.maxGameY - roomToActuallyCenter.y;
            const targetCenterX_mapCoords = roomToActuallyCenter.x * this.TILE_SIZE_BASE + this.TILE_SIZE_BASE / 2;
            const targetCenterY_mapCoords = gameYForCentering * this.TILE_SIZE_BASE + this.TILE_SIZE_BASE / 2;
            this.mapTranslateX = (svgWidth / 2) - (targetCenterX_mapCoords * this.currentZoomLevel);
            this.mapTranslateY = (svgHeight / 2) - (targetCenterY_mapCoords * this.currentZoomLevel);
        }
        this.applyTransform();
    },
    zoomIn: function() { /* UNCHANGED */ 
        if (!this.mapViewportElement) return; const newZoomLevel = this.currentZoomLevel * this.ZOOM_INCREMENT_FACTOR;
        if (newZoomLevel <= this.MAX_ZOOM_LEVEL) {
            const oldZoom = this.currentZoomLevel; this.currentZoomLevel = newZoomLevel;
            const svgCenterX = this.mapViewportElement.clientWidth / 2; const svgCenterY = this.mapViewportElement.clientHeight / 2;
            const mapXAtCenter = (svgCenterX - this.mapTranslateX) / oldZoom; const mapYAtCenter = (svgCenterY - this.mapTranslateY) / oldZoom;
            this.mapTranslateX = svgCenterX - mapXAtCenter * this.currentZoomLevel; this.mapTranslateY = svgCenterY - mapYAtCenter * this.currentZoomLevel;
            this.applyTransform();
        }
    },
    zoomOut: function() { /* UNCHANGED */ 
        if (!this.mapViewportElement) return; const newZoomLevel = this.currentZoomLevel / this.ZOOM_INCREMENT_FACTOR;
        if (newZoomLevel >= this.MIN_ZOOM_LEVEL) {
            const oldZoom = this.currentZoomLevel; this.currentZoomLevel = newZoomLevel;
            const svgCenterX = this.mapViewportElement.clientWidth / 2; const svgCenterY = this.mapViewportElement.clientHeight / 2;
            const mapXAtCenter = (svgCenterX - this.mapTranslateX) / oldZoom; const mapYAtCenter = (svgCenterY - this.mapTranslateY) / oldZoom;
            this.mapTranslateX = svgCenterX - mapXAtCenter * this.currentZoomLevel; this.mapTranslateY = svgCenterY - mapYAtCenter * this.currentZoomLevel;
            this.applyTransform();
        }
    },
    handleMouseWheelZoom: function(event) { /* UNCHANGED */ 
        event.preventDefault(); event.stopPropagation(); 
        if (event.deltaY < 0) this.zoomIn(); else if (event.deltaY > 0) this.zoomOut();
    },
    resizeSVG: function() { /* UNCHANGED */ this.updateCenteringAndZoom(true); },

    fetchAndDrawMap: async function(currentRoomContext = null) { /* UNCHANGED from previous version that fixed z_level property */
        const targetZLevel = currentRoomContext ? currentRoomContext.z : this.currentZLevelForView;
        this.currentZLevelForView = targetZLevel; 
        if (this.mapDataCache[targetZLevel]) {
            this.currentMapDisplayData = this.mapDataCache[targetZLevel];
            if (currentRoomContext && this.currentMapDisplayData) {
                this.currentMapDisplayData.current_room_id = currentRoomContext.id;
                this.currentMapDisplayData.current_z_level = targetZLevel;
            }
            this.calculateMinMaxY(); this.drawMap(true, currentRoomContext); return;
        }
        if (!gameState.currentAuthToken || !gameState.selectedCharacterId) {
            this.clearMap(); this.currentMapDisplayData = null; this.drawMap(false, currentRoomContext); return;
        }
        try {
            const fetchedData = await API.fetchMapData(); 
            const actualFetchedZ = fetchedData.z_level; 
            if (fetchedData && fetchedData.rooms && typeof actualFetchedZ === 'number') {
                if (actualFetchedZ !== targetZLevel) this.currentZLevelForView = actualFetchedZ; 
                this.mapDataCache[actualFetchedZ] = { ...fetchedData, current_z_level: actualFetchedZ };
                if (currentRoomContext && currentRoomContext.z === actualFetchedZ) this.mapDataCache[actualFetchedZ].current_room_id = currentRoomContext.id;
            } else {
                this.mapDataCache[targetZLevel] = { rooms: [], current_room_id: currentRoomContext?.id, current_z_level: targetZLevel };
            }
            this.currentMapDisplayData = this.mapDataCache[this.currentZLevelForView]; 
            this.calculateMinMaxY();
            const roomContextForDraw = (currentRoomContext && currentRoomContext.z === this.currentZLevelForView) ? currentRoomContext : null;
            this.drawMap(true, roomContextForDraw); 
        } catch (error) {
            console.error(`Error during fetchAndDrawMap for Z=${targetZLevel}:`, error);
            this.mapDataCache[targetZLevel] = { rooms: [], current_room_id: currentRoomContext?.id, current_z_level: targetZLevel };
            this.currentMapDisplayData = this.mapDataCache[targetZLevel];
            this.clearMap(); this.drawMap(false, currentRoomContext);
        }
    },
    calculateMinMaxY: function() { /* UNCHANGED */
        this.minGameY = Infinity; this.maxGameY = -Infinity;
        if (this.currentMapDisplayData?.rooms?.length > 0) {
            this.currentMapDisplayData.rooms.forEach(room => {
                this.minGameY = Math.min(this.minGameY, room.y); this.maxGameY = Math.max(this.maxGameY, room.y);
            });
        } else { this.minGameY = 0; this.maxGameY = 0; }
    },
    redrawMapForCurrentRoom: function(newRoomId, newRoomFullData = null) { /* UNCHANGED from previous version with corrected syntax */
        if (!newRoomFullData) { this.fetchAndDrawMap(null); return; }
        if (newRoomFullData.z !== this.currentZLevelForView || !this.mapDataCache[newRoomFullData.z]) {
            this.fetchAndDrawMap(newRoomFullData); return;
        }
        this.currentMapDisplayData = this.mapDataCache[newRoomFullData.z];
        if (this.currentMapDisplayData) {
            this.currentMapDisplayData.current_room_id = newRoomId;
            if (this.minGameY === Infinity) this.calculateMinMaxY();
        }
        this.drawMap(true, newRoomFullData); 
    },
    clearMap: function() { /* UNCHANGED */
        if (!this.mapContentGroup) return;
        while (this.mapContentGroup.firstChild) this.mapContentGroup.removeChild(this.mapContentGroup.firstChild);
    },

    drawMap: function(forceRecenterOnDraw = false, specificRoomDataForTitleAndCenter = null) {
        this.clearMap(); 
        const noMapTextId = "no-map-data-text-svg";
        const existingNoMapTextElement = this.svgElement ? this.svgElement.querySelector(`#${noMapTextId}`) : null;
        if (existingNoMapTextElement) this.svgElement.removeChild(existingNoMapTextElement);

        let displayData = this.currentMapDisplayData;
        let roomForTitleAndHighlight = specificRoomDataForTitleAndCenter;

        if (!roomForTitleAndHighlight && displayData && displayData.current_room_id) {
            roomForTitleAndHighlight = displayData.rooms?.find(r => r.id === displayData.current_room_id);
        }
        if (!roomForTitleAndHighlight && displayData && displayData.rooms?.length > 0) {
             roomForTitleAndHighlight = displayData.rooms[0]; 
        }

        const zForTitle = roomForTitleAndHighlight?.z ?? displayData?.current_z_level ?? this.currentZLevelForView;

        if (!displayData || !displayData.rooms || displayData.rooms.length === 0 || !this.mapContentGroup) {
            if (this.svgElement) { 
                const textElement = document.createElementNS(SVG_NS, "text"); textElement.id = noMapTextId;
                textElement.setAttribute("x", "50%"); textElement.setAttribute("y", "50%");
                textElement.setAttribute("text-anchor", "middle"); textElement.setAttribute("dominant-baseline", "middle");
                textElement.setAttribute("fill", this.roomStrokeColor || "#0f0"); 
                textElement.setAttribute("font-size", "12"); 
                textElement.style.fontFamily = "monospace"; textElement.textContent = "No map data available.";
                this.svgElement.appendChild(textElement);
            }
            UI.updateMapTitleBar(roomForTitleAndHighlight?.x, roomForTitleAndHighlight?.y, zForTitle);
            // Update Zone Bar with placeholder or actual data if available from displayData
            UI.updateMapZoneBar(displayData?.zone_name, displayData?.zone_levels);
            this.updateCenteringAndZoom(true, roomForTitleAndHighlight); 
            return;
        }
        
        UI.updateMapTitleBar(roomForTitleAndHighlight?.x, roomForTitleAndHighlight?.y, zForTitle);
        // Update Zone Bar
        UI.updateMapZoneBar(displayData?.zone_name, displayData?.zone_levels);


        const rooms = displayData.rooms;
        const currentRoomIdToHighlight = roomForTitleAndHighlight?.id || displayData.current_room_id || gameState.displayedRoomId;
        
        if ((this.minGameY === Infinity || this.maxGameY === -Infinity) && displayData?.rooms?.length > 0) {
             this.calculateMinMaxY(); 
        }

        rooms.forEach(room => { /* Drawing lines - UNCHANGED */
            const gameDrawY = this.maxGameY - room.y; 
            if (room.exits) {
                Object.values(room.exits).forEach(exit_info_or_id => {
                    let targetRoomId;
                    if (typeof exit_info_or_id === 'string') targetRoomId = exit_info_or_id;
                    else if (typeof exit_info_or_id === 'object' && exit_info_or_id.target_room_id) targetRoomId = exit_info_or_id.target_room_id;
                    if (targetRoomId) {
                        const targetRoom = rooms.find(r => r.id === targetRoomId);
                        if (targetRoom) {
                            const targetGameDrawY = this.maxGameY - targetRoom.y; 
                            const line = document.createElementNS(SVG_NS, "line");
                            line.setAttribute("x1", room.x * this.TILE_SIZE_BASE + this.TILE_SIZE_BASE / 2);
                            line.setAttribute("y1", gameDrawY * this.TILE_SIZE_BASE + this.TILE_SIZE_BASE / 2); 
                            line.setAttribute("x2", targetRoom.x * this.TILE_SIZE_BASE + this.TILE_SIZE_BASE / 2);
                            line.setAttribute("y2", targetGameDrawY * this.TILE_SIZE_BASE + this.TILE_SIZE_BASE / 2); 
                            line.setAttribute("stroke", this.connectionLineColor); line.setAttribute("stroke-width", "1.5"); 
                            this.mapContentGroup.appendChild(line);
                        }
                    }
                });
            }
        });
        rooms.forEach(room => { // Drawing room rects AND ICONS
            const gameDrawY = this.maxGameY - room.y; 
            const rect = document.createElementNS(SVG_NS, "rect");
            rect.setAttribute("x", room.x * this.TILE_SIZE_BASE); 
            rect.setAttribute("y", gameDrawY * this.TILE_SIZE_BASE); 
            rect.setAttribute("width", this.TILE_SIZE_BASE); 
            rect.setAttribute("height", this.TILE_SIZE_BASE);
            rect.setAttribute("fill", room.id === currentRoomIdToHighlight ? this.currentRoomHighlightColor : this.defaultRoomColor);
            rect.setAttribute("stroke", this.roomStrokeColor); 
            rect.setAttribute("stroke-width", "1"); 
            this.mapContentGroup.appendChild(rect);

            // NEW: Draw room type icon
            const iconChar = this.roomTypeIcons[room.room_type];
            if (iconChar) {
                const iconText = document.createElementNS(SVG_NS, "text");
                iconText.setAttribute("x", room.x * this.TILE_SIZE_BASE + this.TILE_SIZE_BASE / 2);
                iconText.setAttribute("y", gameDrawY * this.TILE_SIZE_BASE + this.TILE_SIZE_BASE / 2);
                iconText.setAttribute("font-family", "monospace"); // Or a font known to have good emoji support
                iconText.setAttribute("font-size", `${this.TILE_SIZE_BASE * this.iconFontSizeMultiplier}`);
                iconText.setAttribute("fill", this.iconColor);
                iconText.setAttribute("text-anchor", "middle");
                iconText.setAttribute("dominant-baseline", "central"); // Vertically center emoji better
                iconText.style.pointerEvents = "none";
                iconText.textContent = iconChar;
                this.mapContentGroup.appendChild(iconText);
            }
        });
        
        this.updateCenteringAndZoom(forceRecenterOnDraw || !this.isPanning, roomForTitleAndHighlight); 
    }
};
--- END OF FILE frontend/src/map.js ---

--- START OF FILE frontend/src/ui.js ---
// frontend/src/ui.js
import { gameState } from './state.js';

export const UI = {
    // Existing elements
    outputElement: null,
    commandInputElement: null,
    promptTextElement: null,
    characterNameElement: null,
    characterClassElement: null,
    characterLevelElement: null,
    exitsTextElement: null,
    playerHpBar: null,
    playerHpText: null,
    playerMpBar: null,
    playerMpText: null,
    playerXpBar: null,
    playerXpText: null,
    currencyPlatinumElement: null,
    currencyGoldElement: null,
    currencySilverElement: null,
    currencyCopperElement: null,
    copyOutputButton: null,

    // Map related UI elements
    mapTitleBarElement: null,
    mapTitleTextElement: null,
    mapCoordsTextElement: null,
    mapZLevelValueElement: null,    // NEW for Z-level display
    mapZoneNameTextElement: null,   // NEW for Zone Name
    mapZoneLevelsTextElement: null, // NEW for Zone Levels

    // View state control
    gameViewElements: [],
    inputPromptLineElement: null,

    initializeElements: function () {
        this.outputElement = document.getElementById('output');
        this.commandInputElement = document.getElementById('commandInput');
        this.promptTextElement = document.getElementById('prompt-text');
        this.inputPromptLineElement = document.getElementById('input-prompt-line');

        this.characterNameElement = document.getElementById('char-info-name');
        this.characterClassElement = document.getElementById('char-info-class');
        this.characterLevelElement = document.getElementById('char-info-level');

        this.exitsTextElement = document.getElementById('exits-text');

        this.playerHpBar = document.getElementById('player-hp-bar');
        this.playerHpText = document.getElementById('player-hp-text');
        this.playerMpBar = document.getElementById('player-mp-bar');
        this.playerMpText = document.getElementById('player-mp-text');
        this.playerXpBar = document.getElementById('player-xp-bar');
        this.playerXpText = document.getElementById('player-xp-text');

        this.currencyPlatinumElement = document.querySelector('#currency-display-container .currency.platinum');
        this.currencyGoldElement = document.querySelector('#currency-display-container .currency.gold');
        this.currencySilverElement = document.querySelector('#currency-display-container .currency.silver');
        this.currencyCopperElement = document.querySelector('#currency-display-container .currency.copper');

        this.copyOutputButton = document.getElementById('copy-output-button');
        if (this.copyOutputButton) {
            this.copyOutputButton.addEventListener('click', () => this.copyOutputToClipboard());
        }

        this.mapTitleBarElement = document.getElementById('map-title-bar');
        this.mapTitleTextElement = document.getElementById('map-title-text');
        this.mapCoordsTextElement = document.getElementById('map-coords-text');

        // NEW elements for Z-level and Zone
        this.mapZLevelValueElement = document.getElementById('map-z-level-value');
        this.mapZoneNameTextElement = document.getElementById('map-zone-name-text');
        this.mapZoneLevelsTextElement = document.getElementById('map-zone-levels-text');


        this.gameViewElements = [
            document.getElementById('character-info-bar'),
            document.getElementById('bottom-info-bar'),
            document.getElementById('vitals-monitor'),
            document.getElementById('map-column'),
        ];

        if (!this.outputElement || !this.commandInputElement || !this.characterNameElement ||
            !this.mapTitleBarElement || !this.inputPromptLineElement || !this.mapZLevelValueElement ||
            !this.mapZoneNameTextElement || !this.mapZoneLevelsTextElement) { // Added new elements to check
            console.error("Fatal Error: Essential UI elements not found. The application cannot start.");
            document.body.innerHTML = "Error: UI elements missing. Please check console.";
            return false;
        }
        return true;
    },

    showAppropriateView: function () {
        const isGameActive = gameState.loginState === 'IN_GAME';
        this.gameViewElements.forEach(el => {
            if (el) {
                let currentDisplay = 'block';
                if (el.id === 'vitals-monitor' || el.id === 'bottom-info-bar' || el.id === 'character-info-bar' || el.id === 'map-column') {
                    currentDisplay = 'flex';
                }
                el.style.display = isGameActive ? currentDisplay : 'none';
            }
        });

        if (this.inputPromptLineElement) {
            const showInputPromptLine = gameState.loginState === 'IN_GAME' ||
                gameState.loginState === 'CHAR_SELECT_PROMPT' ||
                gameState.loginState === 'CHAR_CREATE_PROMPT_NAME' ||
                gameState.loginState === 'CHAR_CREATE_PROMPT_CLASS' ||
                gameState.loginState === 'PROMPT_USER' ||
                gameState.loginState === 'PROMPT_PASSWORD' ||
                gameState.loginState === 'REGISTER_PROMPT_USER' ||
                gameState.loginState === 'REGISTER_PROMPT_PASSWORD';
            this.inputPromptLineElement.style.display = showInputPromptLine ? 'flex' : 'none';
        }
    },

    clearOutput: function () { /* Unchanged */ if (this.outputElement) this.outputElement.innerHTML = ''; },
    appendToOutput: function (message, options = {}) { /* Unchanged */
        if (!this.outputElement) return; const { styleClass = '' } = options;
        const lineElement = document.createElement('div');
        if (styleClass) lineElement.classList.add(styleClass);
        lineElement.innerHTML = message;
        this.outputElement.insertBefore(lineElement, this.outputElement.firstChild);
        this.outputElement.scrollTop = 0;
    },
    updateCharacterInfoBar: function (name, className, level) { /* Unchanged */
        if (this.characterNameElement) this.characterNameElement.textContent = name || 'Unknown';
        if (this.characterClassElement) this.characterClassElement.textContent = className || 'Adventurer';
        if (this.characterLevelElement) this.characterLevelElement.textContent = (level !== undefined && level !== null) ? String(level) : '1';
    },

    updateMapTitleBar: function (x, y, z) { // Removed zoneName from here, handled by updateMapZoneBar
        if (this.mapCoordsTextElement) {
            if (x !== undefined && y !== undefined && z !== undefined) {
                this.mapCoordsTextElement.textContent = `${x}, ${y}, ${z}`;
            } else if (z !== undefined) {
                this.mapCoordsTextElement.textContent = `?, ?, ${z}`;
            } else {
                this.mapCoordsTextElement.textContent = "?, ?, ?";
            }
        }
        // Update Z-Level display box separately
        if (this.mapZLevelValueElement) {
            this.mapZLevelValueElement.textContent = (z !== undefined && z !== null) ? String(z) : "-";
        }
    },

    // NEW function for Zone Bar
    updateMapZoneBar: function (zoneName, zoneLevels) {
        if (this.mapZoneNameTextElement) {
            this.mapZoneNameTextElement.textContent = zoneName || "[Unknown Zone]";
        }
        if (this.mapZoneLevelsTextElement) {
            this.mapZoneLevelsTextElement.textContent = zoneLevels || "[Lvl ?-?]";
        }
    },

    updatePlayerVitals: function (currentHp, maxHp, currentMp, maxMp, currentXp, nextLevelXp) { /* Unchanged */
        if (this.playerHpBar && this.playerHpText) {
            const hpPercent = maxHp > 0 ? (currentHp / maxHp) * 100 : 0;
            this.playerHpBar.style.width = `${Math.max(0, Math.min(100, hpPercent))}%`;
            this.playerHpText.textContent = `${currentHp} / ${maxHp}`;
        }
        if (this.playerMpBar && this.playerMpText) {
            const mpPercent = maxMp > 0 ? (currentMp / maxMp) * 100 : 0;
            this.playerMpBar.style.width = `${Math.max(0, Math.min(100, mpPercent))}%`;
            this.playerMpText.textContent = `${currentMp} / ${maxMp}`;
        }
        if (this.playerXpBar && this.playerXpText) {
            const xpPercent = nextLevelXp > 0 && nextLevelXp !== -1 ? (currentXp / nextLevelXp) * 100 : (nextLevelXp === -1 ? 100 : 0);
            const displayNextLevelXp = (nextLevelXp === -1) ? "MAX" : nextLevelXp;
            this.playerXpBar.style.width = `${Math.max(0, Math.min(100, xpPercent))}%`;
            this.playerXpText.textContent = `${currentXp} / ${displayNextLevelXp}`;
        }
    },
    updateExitsDisplay: function (roomData) { /* Unchanged */
        if (this.exitsTextElement && roomData && roomData.exits) {
            const exitNames = Object.keys(roomData.exits).map(dir => dir.toUpperCase());
            this.exitsTextElement.textContent = exitNames.length > 0 ? exitNames.join(' | ') : 'None';
        } else if (this.exitsTextElement) { this.exitsTextElement.textContent = 'Unknown'; }
    },
    updateCurrencyDisplay: function (platinum, gold, silver, copper) { /* Unchanged */
        if (this.currencyPlatinumElement) this.currencyPlatinumElement.textContent = `${platinum || 0}p`;
        if (this.currencyGoldElement) this.currencyGoldElement.textContent = `${gold || 0}g`;
        if (this.currencySilverElement) this.currencySilverElement.textContent = `${silver || 0}s`;
        if (this.currencyCopperElement) this.currencyCopperElement.textContent = `${copper || 0}c`;
    },
    updateGameDisplay: function (roomData) { /* Unchanged */
        if (!roomData) return; let lines = [];
        lines.push(`<span class="room-name-header">--- ${roomData.name || 'Unknown Room'} ---</span>`);
        lines.push(roomData.description || 'An empty space.');
        if (roomData.dynamic_description_additions?.length > 0) roomData.dynamic_description_additions.forEach(line => lines.push(line));
        if (roomData.items_on_ground?.length > 0) {
            lines.push("You see here:");
            roomData.items_on_ground.forEach(item => lines.push(`  <span class="inv-item-name">${item.item_template.name}</span>${item.quantity > 1 ? ' (x' + item.quantity + ')' : ''}`));
        }
        if (roomData.mobs_in_room?.length > 0) {
            lines.push("Also here:");
            roomData.mobs_in_room.forEach((mob, index) => lines.push(`  ${index + 1}. <span class="inv-item-name">${mob.mob_template.name}</span>`));
        }
        if (roomData.other_characters?.length > 0) {
            lines.push("Others here:");
            roomData.other_characters.forEach(char => lines.push(`  <span class="char-name">${char.name}</span>`));
        }
        this.appendToOutput(lines.join('\n'), { styleClass: "game-message" });
    },
    getCommandInput: function () { return this.commandInputElement; },
    setInputCommandPlaceholder: function (text) { if (this.commandInputElement) this.commandInputElement.placeholder = text; },
    setInputCommandType: function (type) { if (this.commandInputElement) this.commandInputElement.type = type; },
    focusCommandInput: function () { if (this.commandInputElement) this.commandInputElement.focus(); },
    copyOutputToClipboard: function () { /* Unchanged */
        if (!this.outputElement) return; const textToCopy = this.outputElement.innerText || this.outputElement.textContent;
        navigator.clipboard.writeText(textToCopy)
            .then(() => this.appendToOutput("Log copied to clipboard.", { styleClass: "system-message-inline" }))
            .catch(err => { console.error('Failed to copy output: ', err); this.appendToOutput("! Failed to copy log.", { styleClass: "error-message-inline" }); });
    }
};
--- END OF FILE frontend/src/ui.js ---

--- START OF FILE frontend/src/state.js ---
// frontend/src/state.js

// Initial game state structure
const initialGameState = {
    currentAuthToken: null,
    selectedCharacterId: null,
    selectedCharacterName: null,
    selectedCharacterClass: null, // Added for potential use
    loginState: 'INIT', // e.g., INIT, PROMPT_USER, PROMPT_PASSWORD, CHAR_SELECT, IN_GAME
    tempUsername: '',
    tempPassword: '',
    tempCharName: '',
    availableCharacters: [],
    availableClasses: [],
    tempCharClassName: '', 
    displayedRoomId: null,
    gameSocket: null,
    isInCombat: false,
};

// The reactive gameState object
export const gameState = { ...initialGameState }; // Shallow copy to start

// --- LocalStorage Keys ---
const AUTH_TOKEN_KEY = 'llmudAuthToken';
const CHAR_ID_KEY = 'llmudSelectedCharId';
const CHAR_NAME_KEY = 'llmudSelectedCharName';
const CHAR_CLASS_KEY = 'llmudSelectedCharClass';

// --- Session Persistence Functions ---
export function saveSession(token, charId, charName, charClass) {
    if (token) localStorage.setItem(AUTH_TOKEN_KEY, token);
    if (charId) localStorage.setItem(CHAR_ID_KEY, charId);
    if (charName) localStorage.setItem(CHAR_NAME_KEY, charName);
    if (charClass) localStorage.setItem(CHAR_CLASS_KEY, charClass);

    gameState.currentAuthToken = token;
    gameState.selectedCharacterId = charId;
    gameState.selectedCharacterName = charName;
    gameState.selectedCharacterClass = charClass;
}

export function loadSession() {
    const token = localStorage.getItem(AUTH_TOKEN_KEY);
    const charId = localStorage.getItem(CHAR_ID_KEY);
    const charName = localStorage.getItem(CHAR_NAME_KEY);
    const charClass = localStorage.getItem(CHAR_CLASS_KEY);

    if (token && charId && charName) {
        gameState.currentAuthToken = token;
        gameState.selectedCharacterId = charId;
        gameState.selectedCharacterName = charName;
        gameState.selectedCharacterClass = charClass;
        return true; // Session data found
    }
    return false; // No session data
}

export function clearSession() {
    localStorage.removeItem(AUTH_TOKEN_KEY);
    localStorage.removeItem(CHAR_ID_KEY);
    localStorage.removeItem(CHAR_NAME_KEY);
    localStorage.removeItem(CHAR_CLASS_KEY);

    // Reset gameState to initial values
    Object.assign(gameState, initialGameState);
}

// Function to update a part of the game state
export function updateGameState(newStatePart) {
    Object.assign(gameState, newStatePart);
    // Potentially add logging or event emission here if needed for reactivity in a larger app
    // console.log("GameState updated:", gameState);
}
--- END OF FILE frontend/src/state.js ---

--- START OF FILE frontend/src/api.js ---
// frontend/src/api.js
import { API_BASE_URL } from './config.js';
import { gameState } from './state.js'; // To access currentAuthToken

async function fetchData(endpoint, options = {}) {
    const headers = new Headers(options.headers || {});
    if (gameState.currentAuthToken) {
        headers.set('Authorization', `Bearer ${gameState.currentAuthToken}`);
    }
    if (options.body && !(options.body instanceof URLSearchParams) && typeof options.body === 'object') {
        headers.set('Content-Type', 'application/json');
        options.body = JSON.stringify(options.body);
    } else if (options.body && options.body instanceof URLSearchParams) {
        headers.set('Content-Type', 'application/x-www-form-urlencoded');
    }
    options.headers = headers;

    const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
    const data = await response.json(); // Assume all responses are JSON for now
    if (!response.ok) {
        const error = new Error(data.detail || `HTTP error! status: ${response.status}`);
        error.response = response; // Attach response for more detailed error handling
        error.data = data;         // Attach parsed error data
        throw error;
    }
    return data;
}

export const API = {
    loginUser: function (username, password) {
        return fetchData('/users/login', {
            method: 'POST',
            body: new URLSearchParams({ username, password })
        });
    },
    registerUser: function (username, password) {
        return fetchData('/users/register', {
            method: 'POST',
            body: { username, password } // Will be stringified by fetchData
        });
    },
    fetchCharacters: function () {
        return fetchData('/character/mine');
    },
    createCharacter: function (name, className) {
        return fetchData('/character/create', {
            method: 'POST',
            body: { name: name, class_name: className }
        });
    },
    selectCharacterOnBackend: function (characterId) {
        return fetchData(`/character/${characterId}/select`, { method: 'POST' });
    },
    sendHttpCommand: function (commandText) { // Made this non-async, returns promise
        return fetchData('/command', {
            method: 'POST',
            body: { command: commandText }
        });
    },
    fetchMapData: function () {
        return fetchData('/map/level_data');
    },
    fetchAvailableClasses: function() { // <<< NEW FUNCTION
        return fetchData('/classes'); // Endpoint defined in backend router
    }
};
--- END OF FILE frontend/src/api.js ---

--- START OF FILE frontend/src/index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Unholy MUD of Tron & Allen1</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header class="header-text">
        <h1>Legend of the Solar Dragon's Tradewar</h1>
        <h2>2002 Barrels of Food Fight</h2>
        <h3>Over a Usurped Pit of Devastation (Alpha)</h3>
        <p class="subtitle">(UMGTWOTRDBSREUPPDX_TPSC for short, obviously)</p>
    </header>

    <div class="game-area-wrapper">
        <div class="mud-container">
            <!-- ... (mud container contents unchanged) ... -->
            <div id="character-info-bar">
                <span id="char-info-name">Character Name</span>
                <span class="char-info-separator">|</span>
                <span id="char-info-class">Class</span>
                <span class="char-info-separator">|</span>
                <span>Level: <span id="char-info-level">1</span></span>
            </div>
            <div id="output" class="terminal-output"></div>
            <button id="copy-output-button" title="Copy output to clipboard">Copy Log</button>
            <div id="bottom-info-bar">
                <div id="exits-display-container">
                    <b>Exits:</b> <span id="exits-text"></span>
                </div>
                <div id="currency-display-container">
                    <span class="currency platinum">0p</span>
                    <span class="currency gold">0g</span>
                    <span class="currency silver">0s</span>
                    <span class="currency copper">0c</span>
                </div>
            </div>
            <div id="vitals-monitor">
                <div class="vital-bar-container">
                    <span class="vital-label">HP:</span>
                    <div class="vital-bar-outer" id="hp-bar-outer">
                        <div class="vital-bar-inner" id="player-hp-bar" style="width: 100%; background-color: #d9534f;">
                        </div>
                        <span class="vital-bar-text" id="player-hp-text">100 / 100</span>
                    </div>
                </div>
                <div class="vital-bar-container">
                    <span class="vital-label">MP:</span>
                    <div class="vital-bar-outer" id="mp-bar-outer">
                        <div class="vital-bar-inner" id="player-mp-bar" style="width: 100%; background-color: #5bc0de;">
                        </div>
                        <span class="vital-bar-text" id="player-mp-text">50 / 50</span>
                    </div>
                </div>
                <div class="vital-bar-container">
                    <span class="vital-label">XP:</span>
                    <div class="vital-bar-outer" id="xp-bar-outer">
                        <div class="vital-bar-inner" id="player-xp-bar" style="width: 0%; background-color: #f0ad4e;">
                        </div>
                        <span class="vital-bar-text" id="player-xp-text">0 / 100</span>
                    </div>
                </div>
            </div>
            <div id="input-prompt-line" class="terminal-input-line">
                <span id="prompt-text">> </span>
                <input type="text" id="commandInput" class="terminal-input" name="mud_command_line" autofocus
                    autocomplete="off">
            </div>
        </div>

        <div id="map-column">
            <div id="map-title-bar">
                <span id="map-title-text">Map</span>
                <span class="map-title-separator">|</span>
                <span id="map-coords-label">Coords:</span>
                <span id="map-coords-text">?, ?, ?</span>
            </div>
            <div id="map-viewport">
                <!-- NEW Z-LEVEL DISPLAY BOX -->
                <div id="map-z-level-box">
                    <span class="z-level-label">Level</span>
                    <span id="map-z-level-value">-99</span>
                </div>
                <svg id="map-svg" width="100%" height="100%"></svg>
            </div>
            <!-- NEW ZONE DISPLAY BAR -->
            <div id="map-zone-bar">
                <span class="zone-label">Zone:</span>
                <span id="map-zone-name-text">[Zone Name Placeholder]</span>
                <span id="map-zone-levels-text">[Lvl ?-?]</span>
            </div>
        </div>
    </div>

    <script type="module" src="main.js"></script>
</body>

</html>
--- END OF FILE frontend/src/index.html ---

--- START OF FILE frontend/src/style.css ---
body {
    background-color: #000;
    color: #00ff00;
    font-family: 'Courier New', Courier, monospace;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 10px;
    box-sizing: border-box;
}

#map-column {
    display: none;
    flex-direction: column;
    margin-left: 15px;
    width: 350px;
    height: 350px;
    flex-shrink: 0;
}

#map-title-bar {
    background-color: #111;
    color: #00dd00;
    padding: 6px 10px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    border: 1px solid #005500;
    border-bottom: 1px solid #005500;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#map-title-bar span {
    margin: 0 3px;
}

.map-title-separator {
    color: #007700;
    font-weight: bold;
}

#map-title-text {
    font-weight: bold;
    color: #ffffff;
}

#map-coords-label {
    color: #bbbbbb;
}

#map-coords-text {
    font-weight: bold;
}

#map-viewport {
    /* height: 228px; /* Will be adjusted if Zone display is added below */
    flex-grow: 1;
    /* Allow viewport to take remaining space in map-column */
    border: 1px solid #00cc00;
    border-top: none;
    background-color: #080808;
    overflow: hidden;
    box-shadow: 0 0 10px #00cc00;
    position: relative;
    /* Crucial for absolute positioning of Z-level and zoom buttons */
}

/* NEW: Z-Level Display Box */
#map-z-level-box {
    position: absolute;
    top: 5px;
    left: 5px;
    background-color: rgba(10, 10, 10, 0.8);
    border: 1px solid #007700;
    padding: 3px 5px;
    color: #00ff00;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.8em;
    text-align: center;
    z-index: 1000;
    /* Below zoom buttons if they overlap, adjust as needed */
    width: auto;
    /* Fit content */
    min-width: 40px;
    /* Ensure some base width */
}

#map-z-level-box .z-level-label {
    display: block;
    font-size: 0.85em;
    /* Smaller "Level" text */
    color: #00aa00;
    margin-bottom: 1px;
}

#map-z-level-value {
    display: block;
    font-size: 1.3em;
    /* Larger Z number */
    font-weight: bold;
    line-height: 1;
}

/* NEW: Zone Display Bar (Placeholder) */
#map-zone-bar {
    background-color: #111;
    /* Match title bar */
    color: #00dd00;
    padding: 4px 10px;
    /* Slightly less padding */
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.85em;
    /* Slightly smaller */
    border: 1px solid #005500;
    border-top: none;
    /* Connects to map-viewport border */
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#map-zone-bar .zone-label {
    color: #bbbbbb;
}

#map-zone-name-text {
    font-weight: bold;
    color: #ffffff;
}

#map-zone-levels-text {
    color: #00cc88;
}

.char-class-desc {
    font-style: italic;
    color: #999;
}

.header-text {
    text-align: center;
    margin-bottom: 20px;
}

.header-text h1 {
    margin: 0 0 5px 0;
    font-size: 1.8em;
    line-height: 1.2;
}

.header-text p {
    margin: 0;
    font-size: 0.9em;
    color: #00cc00;
}

.game-area-wrapper {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    width: 100%;
    max-width: 1200px;
}

.mud-container {
    position: relative;
    width: 100%;
    max-width: 900px;
    display: flex;
    flex-direction: column;
    border: 1px solid #005500;
}

#copy-output-button {
    position: absolute;
    top: 35px;
    right: 5px;
    padding: 8px 12px;
    background-color: #333;
    color: #0f0;
    border: 1px solid #0f0;
    border-radius: 4px;
    cursor: pointer;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    z-index: 100;
}

#copy-output-button:hover {
    background-color: #444;
}

#copy-output-button:active {
    background-color: #222;
}

.terminal-output {
    flex-grow: 1;
    height: 70vh;
    overflow-y: scroll;
    background-color: #030303;
    padding: 10px;
    box-sizing: border-box;
    white-space: pre-wrap;
    line-height: 1.4;
    border-bottom: 1px solid #005500;
    display: flex;
    flex-direction: column-reverse;
}

.terminal-output>div {}

.terminal-input-line {
    display: flex;
    align-items: center;
    background-color: #030303;
    padding: 8px 10px;
}

#prompt-text {
    margin-right: 8px;
    color: #00dd00;
}

.terminal-input {
    scrollbar-width: thin;
    scrollbar-color: #005500 #080808;
    flex-grow: 1;
    background-color: transparent;
    border: none;
    color: #00ff00;
    font-family: inherit;
    font-size: 1em;
    outline: none;
    padding: 0;
}

.terminal-output::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

.terminal-output::-webkit-scrollbar-track {
    background: #080808;
}

.terminal-output::-webkit-scrollbar-thumb {
    background-color: #005500;
    border-radius: 5px;
    border: 2px solid #030303;
}

.terminal-output::-webkit-scrollbar-thumb:hover {
    background-color: #007700;
}

.terminal-output::-webkit-scrollbar-corner {
    background: #030303;
}

#vitals-monitor {
    display: none;
    flex-direction: row;
    justify-content: space-around;
    align-items: center;
    padding: 5px 8px;
    background-color: #1a1a1a;
    border-bottom: 1px solid #333;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    margin-bottom: 5px;
    height: auto;
}

.vital-bar-container {
    display: flex;
    align-items: center;
    flex-grow: 1;
    margin-right: 10px;
}

.vital-bar-container:last-child {
    margin-right: 0;
}

.vital-label {
    color: #bbb;
    margin-right: 5px;
    font-size: 0.85em;
}

.vital-bar-outer {
    flex-grow: 1;
    height: 16px;
    background-color: #333;
    border: 1px solid #555;
    border-radius: 3px;
    position: relative;
    overflow: hidden;
}

.vital-bar-inner {
    height: 100%;
    transition: width 0.3s ease-out;
    border-radius: 2px;
}

.vital-bar-text {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    color: #ffffff;
    font-size: 0.75em;
    font-weight: bold;
    text-shadow: 1px 1px 1px #000000;
    white-space: nowrap;
}

.char-list-item {
    margin-left: 20px;
}

.char-list-item .char-index {
    color: #ffff00;
}

.char-list-item .char-name {
    color: #00ff00;
}

.char-list-item .char-class {
    color: #00aaaa;
}

.room-name-header {
    color: #ffff00;
    font-weight: bold;
    margin-top: 1em;
    margin-bottom: 0.5em;
}

.error-message-inline {
    color: #ff4444;
    font-style: italic;
}

.game-message {
    color: #cccccc;
    display: block;
}

.system-message-inline {
    color: #00aa00;
    font-style: italic;
}

.inv-slot-name {
    color: #00ffff;
    font-weight: bold;
}

.inv-backpack-number {
    color: #ffff00;
}

.inv-item-name {
    color: #00ff00;
}

.inv-item-qty {
    color: #aaaaaa;
}

.inv-section-header {
    color: #f0f0f0;
    font-weight: bold;
}

.char-name {
    color: #00ff00;
}

.combat-success {
    color: #33cc33;
    font-weight: bold;
}

.combat-miss {
    color: #ff9933;
}

.combat-hit {
    color: #ffff00;
    font-weight: bold;
}

.combat-crit {
    color: #ff9900;
    font-weight: bold;
}

.combat-hp {
    color: #ffdddd;
}

.combat-death {
    color: #ff3333;
    font-weight: bold;
    font-style: italic;
}

.combat-hit-player {
    color: #ff6666;
    font-weight: bold;
}

.combat-crit-player {
    color: #cc0000;
    font-weight: bold;
}

.ooc-chat-message {
    color: #9999ff;
    font-style: italic;
}

#input-prompt-line {
    display: flex;
    align-items: center;
    padding: 0 8px;
}

#character-info-bar {
    display: none;
    background-color: #111;
    color: #00dd00;
    padding: 6px 10px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    border-bottom: 1px solid #005500;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#character-info-bar span {
    margin: 0 5px;
}

.char-info-separator {
    color: #007700;
    font-weight: bold;
}

#char-info-name {
    font-weight: bold;
    color: #ffffff;
}

#char-info-class {
    font-style: italic;
    color: #00ffdd;
}

#char-info-level {
    font-weight: bold;
}

#bottom-info-bar {
    display: none; /* Should be display: flex; when active */
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 10px;
    background-color: #181818;
    border-top: 1px solid #005500;
    border-bottom: 1px solid #005500;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    color: #00cc00;
    margin-bottom: 5px;
}

#exits-display-container {
    flex-basis: 60%;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#exits-display-container b {
    color: #bbb;
}

#exits-text {
    color: #00dd00;
}

#currency-display-container {
    flex-basis: 35%;
    text-align: right;
    white-space: nowrap;
}

.currency {
    margin-left: 10px;
    font-weight: bold;
}

.currency.gold {
    color: #FFD700;
}

.currency.silver {
    color: #C0C0C0;
}

.currency.copper {
    color: #B87333;
}

.currency.platinum {
    color: #e5e4e2;
}

.terminal-line {}

.room-description {}
--- END OF FILE frontend/src/style.css ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
