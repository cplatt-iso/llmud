--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Tue Jun 10 02:00:56 AM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_npc.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/npc_dialogue_ticker.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/npc_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/npc.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/character_classes.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/loot_tables.json
backend/app/seeds/mob_spawn_definitions.json
backend/app/seeds/mob_templates.json
backend/app/seeds/npcs.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_admin_parser.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
backend/app/ws_command_parsers/ws_shop_parser.py
bundle_context.sh
frontend/src/components/BottomInfoBar.css
frontend/src/components/CharacterCreationScreen.css
frontend/src/components/CharacterInfoBar.css
frontend/src/components/CharacterSelectionScreen.css
frontend/src/components/Inventory.css
frontend/src/components/ItemName.css
frontend/src/components/LoginScreen.css
frontend/src/components/Map.css
frontend/src/components/Modal.css
frontend/src/components/ScoreSheet.css
frontend/src/components/Terminal.css
frontend/src/components/VitalsMonitor.css
frontend/src/index.css
frontend/src/index.html
frontend/src/services/apiService.js
frontend/src/services/webSocketService.js
frontend/src/state/gameStore.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed." >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh"
    "README.md"

    # --- Backend - Models & Schemas (The Blueprint of Power) ---
    "backend/app/models/player.py"
    "backend/app/models/character.py"
    "backend/app/models/item.py"
    "backend/app/models/room.py"
    "backend/app/models/mob_template.py"
    "backend/app/schemas/player.py"
    "backend/app/schemas/character.py"
    "backend/app/schemas/map.py"
    "backend/app/schemas/room.py"
    "backend/app/schemas/mob.py"

    # --- Backend - The Command & Control Logic ---
    "backend/app/websocket_router.py"
    "backend/app/ws_command_parsers/ws_interaction_parser.py"
    "backend/app/ws_command_parsers/ws_info_parser.py"
    "backend/app/ws_command_parsers/ws_movement_parser.py"

    # --- Backend - Dependencies & Game State ---
    "backend/app/api/dependencies.py"
    "backend/app/game_state.py"

    # --- World & Seed Data (The Soul of the Machine) ---
    "backend/app/seeds/rooms_z0.json"
    "backend/app/seeds/exits_z0.json"
    "backend/app/seeds/items.json"
    "backend/app/seeds/mob_templates.json"
    "backend/app/seeds/mob_spawn_definitions.json"
    "backend/app/seeds/loot_tables.json"
    "backend/app/seeds/skills.json"
    "backend/app/seeds/traits.json"
    "backend/app/seeds/character_classes.json"
    "backend/app/seeds/npcs.json"

    # --- Frontend - The User's Point of Interaction ---
    "frontend/src/state/gameStore.js"
    "frontend/src/services/webSocketService.js"
    "frontend/src/components/CommandInput.jsx"
    "frontend/src/components/Inventory.jsx"
    "frontend/src/components/ItemName.jsx"
    "frontend/src/components/Map.jsx"
    "frontend/src/components/TerminalOutput.jsx"

    # --- Frontend - Core App Structure ---
    "frontend/src/App.jsx"
    "frontend/src/main.jsx"
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (âœ¨ðŸ’°ðŸ’ªðŸ§©ðŸ’€ðŸšª) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Flesh out the damn world - Gear, Loot, and More Seeds!

The map is less of an abstract nightmare, and the core gameplay loop is... loopy. Now we need to make the interactions richer and the world feel less empty.

*   **Full Equipment System:** Define all equipment slots. Implement robust `equip` and `unequip` logic. Ensure stats update correctly.
*   **Mob Loot Tables:** Mobs need to drop more than just coins. Define loot tables (specific items, random items from categories, chances).
*   **Seed More Content (Externalize ALL THE THINGS):**
    *   `mob_templates.json`
    *   `character_classes.json`
    *   `skills.json`
    *   `traits.json`
    *   `mob_spawn_definitions.json`
    *   Update corresponding CRUD seeders to load from these JSONs.
*   **Seed Initial Equipment:** Place starting gear on character creation or in initial rooms.

This will involve a lot of backend work (models, CRUD, game logic) and careful JSON schema design for the seed files.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/models/player.py ---
# backend/app/models/player.py
import uuid
from typing import Optional, List, TYPE_CHECKING 
from sqlalchemy import Column, String, Boolean # <-- Import Boolean
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING: 
    from .character import Character 

class Player(Base):
    __tablename__ = "players"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
    
    # --- THE GOD KEY ---
    is_sysop: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False, server_default="false")

    characters: Mapped[List["Character"]] = relationship(back_populates="owner")

    def __repr__(self) -> str:
        return f"<Player(id={self.id}, username='{self.username}', sysop={self.is_sysop})>"
--- END OF FILE backend/app/models/player.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Boolean, Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    is_brief_mode: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    owner: Mapped["Player"] = relationship(back_populates="characters", lazy="joined") 

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    god_level: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="0 for mortals, 1-10 for gods")
    titles: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [], comment="e.g., ['The Godslayer', 'Cheesewheel Enthusiast']")
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)
    is_brief_mode: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    rarity: Mapped[str] = mapped_column(String(50), nullable=False, default="common", index=True)
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py
import uuid
from typing import Optional, Dict, List, TYPE_CHECKING, Any
from enum import Enum as PyEnum

from sqlalchemy import Column, Integer, String, Text, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance
    from .room_mob_instance import RoomMobInstance

class RoomTypeEnum(PyEnum):
    STANDARD = "standard"
    SANCTUARY = "sanctuary"
    SHOP = "shop"
    TRAINER = "trainer"
    DUNGEON_ENTRANCE = "dungeon_entrance"
    PUZZLE = "puzzle"

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    
    # --- THE MISSING FIELDS GO HERE ---
    zone_name: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, index=True)
    zone_level_range: Mapped[Optional[str]] = mapped_column(String(20), nullable=True, comment="e.g., 1-5 or 10-15")
    # --- END OF MISSING FIELDS ---
    
    room_type: Mapped[RoomTypeEnum] = mapped_column(
        SQLEnum(RoomTypeEnum, name="roomtypeenum", create_type=True),
        default=RoomTypeEnum.STANDARD,
        nullable=False,
        index=True
    )

    exits: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB,
        nullable=True,
        default=lambda: {}
    )
    interactables: Mapped[Optional[List[Dict[str, Any]]]] = mapped_column(
        JSONB,
        nullable=True,
        default=lambda: []
    )
    npc_placements: Mapped[Optional[List[str]]] = mapped_column(
        JSONB,
        nullable=True,
        comment="List of unique_name_tags for NPC templates to be placed in this room."
    )
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin"
    )
    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin"
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', zone='{self.zone_name}', x={self.x}, y={self.y}, z={self.z}, type='{self.room_type.value}')>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/models/mob_template.py ---
# backend/app/models/mob_template.py
import uuid
from typing import Optional, Dict, Any, List # Added List

from sqlalchemy import Boolean, String, Text, Integer, Float # Keep Column, Add Float
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class MobTemplate(Base):
    __tablename__ = "mob_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # mob_type: Mapped[Optional[str]] = mapped_column(String(50), index=True, nullable=True, comment="e.g., beast, humanoid, undead") # Replaced by faction_tags

    level: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1)
    base_health: Mapped[int] = mapped_column(Integer, nullable=False, default=10)
    base_mana: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) # <<< MODIFIED
    base_attack: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., 1d6") 
    base_defense: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=10, comment="e.g., Armor Class")
    
    attack_speed_secs: Mapped[Optional[float]] = mapped_column(Float, nullable=True, default=3.0) # <<< MODIFIED
    aggro_radius: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=5) # <<< MODIFIED
    roam_radius: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) # <<< MODIFIED
    is_boss: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    
    xp_value: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    
    
    # loot_table_ref: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, comment="Placeholder for loot table reference") # Replaced by loot_table_tags
    loot_table_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED (JSONB for list of strings)
    
    currency_drop: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB, 
        nullable=True,
        comment="Defines currency drop. E.g., {'c_min':0, ...}"
    ) # Default can be set by Pydantic model if not provided in JSON
    
    dialogue_lines: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    faction_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    special_abilities: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, default=lambda: {})
    
    # aggression_type: Mapped[Optional[str]] = mapped_column(String(50), default="NEUTRAL", nullable=True, index=True, comment="e.g., NEUTRAL, AGGRESSIVE_ON_SIGHT, AGGRESSIVE_IF_APPROACHED") 
    # Decided to remove this, as aggro_radius and faction logic should cover it.
    # If you reinstate it in schemas/JSON, add it back here too.

    def __repr__(self) -> str:
        return f"<MobTemplate(id={self.id}, name='{self.name}', level='{self.level}')>"
--- END OF FILE backend/app/models/mob_template.py ---

--- START OF FILE backend/app/schemas/player.py ---
# backend/app/schemas/player.py
from typing import Optional
import uuid
from pydantic import BaseModel, Field, EmailStr

# --- Base Schemas ---

class PlayerBase(BaseModel):
    """
    Core attributes for a player. Used for reading and as a base for creation.
    """
    username: str = Field(..., min_length=3, max_length=100)
    is_sysop: bool = False
    # email: Optional[EmailStr] = None

class PlayerCreate(PlayerBase):
    """
    Schema for creating a new player. Requires a password.
    """
    # Inherits username and is_sysop from PlayerBase
    password: str = Field(..., min_length=8)

# --- Update Schema (The Fix) ---

class PlayerUpdate(BaseModel):
    """
    Schema for updating a player. All fields are optional.
    This does NOT inherit from PlayerBase to avoid type conflicts.
    """
    username: Optional[str] = Field(None, min_length=3, max_length=100)
    password: Optional[str] = Field(None, min_length=8) # For password change
    is_sysop: Optional[bool] = None

# --- Database and Response Schemas ---

class PlayerInDBBase(PlayerBase):
    """
    Base schema for players as they exist in the database.
    """
    id: uuid.UUID

    class Config:
        from_attributes = True

class Player(PlayerInDBBase):
    """
    Schema for returning player information to the client (e.g., in a GET request).
    Does not include sensitive info like the hashed password.
    """
    pass

class PlayerInDB(PlayerInDBBase):
    """
    Complete schema for a player in the database, including the hashed password.
    This should only be used internally within your application.
    """
    hashed_password: str
--- END OF FILE backend/app/schemas/player.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)

    # Currency: Optional at creation, with defaults
    platinum_coins: Optional[int] = Field(0, description="Platinum coins owned by the character")
    gold_coins: Optional[int] = Field(0, description="Gold coins owned by the character")
    silver_coins: Optional[int] = Field(0, description="Silver coins owned by the character")
    copper_coins: Optional[int] = Field(100, description="Copper coins owned by the character, default 100 for new chars")

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):  # Inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    platinum_coins: int # type: ignore
    gold_coins: int # type: ignore
    silver_coins: int # type: ignore
    copper_coins: int # type: ignore
    is_brief_mode: bool

    god_level: int
    titles: Optional[List[str]] = None

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/schemas/map.py ---
# backend/app/schemas/map.py (NEW FILE)
import uuid
from pydantic import BaseModel, Field
from typing import List, Dict, Optional
from ..models.room import RoomTypeEnum 

from .room import RoomInDB # We'll use the existing RoomInDB for individual room details

class MapRoomData(BaseModel):
    id: uuid.UUID
    x: int
    y: int
    name: Optional[str] = None # Optional: for tooltips or labels
    exits: Optional[Dict[str, str]] = Field(default_factory=dict)
    is_current_room: bool = False
    is_visited: bool = True # For now, all fetched rooms are considered visited
    room_type: RoomTypeEnum

class MapLevelDataResponse(BaseModel):
    z_level: int
    current_room_id: uuid.UUID
    rooms: List[MapRoomData]
    current_zone_name: Optional[str] = None
    current_zone_level_range: Optional[str] = None
--- END OF FILE backend/app/schemas/map.py ---

--- START OF FILE backend/app/schemas/room.py ---
# backend/app/schemas/room.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

from ..models.room import RoomTypeEnum
from .common_structures import ExitDetail, InteractableDetail
from .npc import NpcTemplateInDB # Import this properly now
from .item import RoomItemInstanceInDB
from .mob import RoomMobInstance
from .character import Character


# --- Room Schemas ---

# This is the base for what constitutes a "Room" in its simplest form.
class RoomBase(BaseModel):
    name: str
    description: Optional[str] = None
    x: int
    y: int
    z: int
    room_type: RoomTypeEnum = Field(default=RoomTypeEnum.STANDARD)
    zone_name: Optional[str] = None
    zone_level_range: Optional[str] = None

# This schema is specifically for CREATING rooms from the seeder JSON.
# It must match the structure of the "data" block in rooms_z0.json exactly.
class RoomCreate(RoomBase):
    exits: Optional[Dict[str, Any]] = Field(default_factory=dict)
    interactables: Optional[List[Dict[str, Any]]] = Field(default_factory=list)
    npc_placements: Optional[List[str]] = Field(default_factory=list)
    # Note: We use Dict[str, Any] for exits/interactables here because the seeder
    # does its own detailed Pydantic validation later. This schema is just for capture.

# This is for PARTIAL updates, e.g., via an API endpoint.
class RoomUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    exits: Optional[Dict[str, ExitDetail]] = None
    interactables: Optional[List[InteractableDetail]] = None
    room_type: Optional[RoomTypeEnum] = None
    npc_placements: Optional[List[str]] = None # Allow updating placements via API too

# This is the full representation of a Room as it exists in the database,
# including all relationships, for sending to the client.
class RoomInDB(RoomBase):
    id: uuid.UUID
    exits: Optional[Dict[str, ExitDetail]] = Field(default_factory=dict)
    interactables: Optional[List[InteractableDetail]] = Field(default_factory=list)
    items_on_ground: List[RoomItemInstanceInDB] = []
    mobs_in_room: List[RoomMobInstance] = []
    other_characters: List[Character] = []
    npcs_in_room: List[NpcTemplateInDB] = [] # This is now correct because of the import
    dynamic_description_additions: List[str] = []

    class Config:
        from_attributes = True
--- END OF FILE backend/app/schemas/room.py ---

--- START OF FILE backend/app/schemas/mob.py ---
# backend/app/schemas/mob.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field, validator
from typing import Optional, Dict, Any, List

# --- MobTemplate Schemas ---
class MobTemplateBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    
    level: Optional[int] = Field(1, ge=0) 
    base_health: int = Field(10, gt=0)
    base_mana: Optional[int] = Field(0, ge=0) # <<< MODIFIED
    base_attack: Optional[str] = Field("1d4") 
    base_defense: Optional[int] = Field(10, ge=0)
    
    attack_speed_secs: Optional[float] = Field(3.0, gt=0, description="Time in seconds between attacks.") # <<< MODIFIED
    aggro_radius: Optional[int] = Field(5, ge=0, description="Radius in map units for auto-aggression.") # <<< MODIFIED
    roam_radius: Optional[int] = Field(0, ge=0, description="Radius from spawn point for roaming behavior. 0 means stationary unless pulled.") # <<< MODIFIED
    is_boss: bool = Field(False, description="Whether this mob is considered a boss.")

    xp_value: int = Field(0, ge=0)
    
    loot_table_tags: Optional[List[str]] = Field(default_factory=list, description="Tags to determine loot drops, e.g., ['goblin_common', 'small_treasure']") # <<< MODIFIED
    currency_drop: Optional[Dict[str, Any]] = Field(None, description="Defines currency drop amounts and chances.") # <<< MODIFIED
    
    dialogue_lines: Optional[List[str]] = Field(default_factory=list, description="Lines the mob might say.") # <<< MODIFIED
    faction_tags: Optional[List[str]] = Field(default_factory=list, description="Faction affiliations, e.g., ['goblins', 'undead']") # <<< MODIFIED
    special_abilities: Optional[List[str]] = Field(default_factory=list, description="List of skill/ability tags the mob possesses.") # <<< MODIFIED
    
    properties: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Generic properties bag for future expansion.")
    
    @validator('currency_drop', pre=True, always=True)
    def check_currency_drop(cls, v):
        if v is None: # If the input JSON doesn't have currency_drop, this sets a default structure
            return {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        # If v is provided, ensure all keys are present, defaulting to 0 if missing
        # This makes downstream access safer (e.g. mob_template.currency_drop.get("c_min", 0) will always work)
        default_keys = {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        if isinstance(v, dict):
            for key, default_val in default_keys.items():
                v.setdefault(key, default_val)
        return v

class MobTemplateCreate(MobTemplateBase):
    pass

class MobTemplateUpdate(BaseModel): # Does NOT inherit from MobTemplateBase
    name: Optional[str] = Field(None, min_length=1, max_length=100) # All fields are optional
    description: Optional[str] = None
    level: Optional[int] = Field(None, ge=0) 
    base_health: Optional[int] = Field(None, gt=0)
    base_mana: Optional[int] = Field(None, ge=0) 
    base_attack: Optional[str] = None
    base_defense: Optional[int] = Field(None, ge=0)
    attack_speed_secs: Optional[float] = Field(None, gt=0)
    aggro_radius: Optional[int] = Field(None, ge=0)
    roam_radius: Optional[int] = Field(None, ge=0)
    xp_value: Optional[int] = Field(None, ge=0)
    loot_table_tags: Optional[List[str]] = None
    currency_drop: Optional[Dict[str, Any]] = None
    dialogue_lines: Optional[List[str]] = None
    faction_tags: Optional[List[str]] = None
    special_abilities: Optional[List[str]] = None
    properties: Optional[Dict[str, Any]] = None
    is_boss: Optional[bool] = None
    
    @validator('currency_drop', pre=True, always=True)
    def check_currency_drop_update(cls, v): # Validator for update too
        if v is None:
            return None # If not provided in update, it remains None, won't overwrite with defaults
        
        default_keys = {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        if isinstance(v, dict):
            # For update, only fill missing keys if the currency_drop field itself is provided
            # This allows partial updates like just changing 'c_min'
            # No, this is wrong. If 'currency_drop' is provided, it should be a complete structure or pydantic will complain.
            # The validator should ensure that IF 'currency_drop' is given, it's valid.
            # The BaseSettings with `extra='ignore'` for `model_config` is for the top-level Settings, not for these Pydantic models.
            # The current validator on MobTemplateBase already handles setting defaults IF currency_drop is provided.
            # For updates, if currency_drop is in the payload, it must be valid. If it's not, it's not updated.
            # This validator needs to be smarter or removed for Update, relying on the Base validator if the field is present.
            # Let's simplify: if it's present, it's validated by MobTemplateBase's logic if inherited, or by its own Field types.
            # The goal is to ensure that IF currency_drop is being set/updated, it's a valid structure.
            # Let's stick to the original validator on MobTemplateBase. Pydantic will handle validation on update if the field is present.
            # The `always=True` and `pre=True` means it runs even if the field is not in the input data for `Create`.
            # For `Update`, if the field is not in the input, the validator for `currency_drop` (inherited or direct) won't run.
            # So, the validator on MobTemplateBase is what we need for creation. For update, it's fine.
            pass # No specific validator needed for Update if fields are optional.
                 # Relies on field constraints.
        return v


class MobTemplateInDBBase(MobTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class MobTemplate(MobTemplateInDBBase): 
    pass


# --- RoomMobInstance Schemas ---
class RoomMobInstanceBase(BaseModel):
    mob_template_id: uuid.UUID
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None

class RoomMobInstanceCreate(BaseModel): 
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    instance_properties_override: Optional[Dict[str, Any]] = None 
    spawn_definition_id: Optional[uuid.UUID] = None
    
class RoomMobInstanceUpdate(BaseModel): 
    current_health: Optional[int] = None
    instance_properties_override: Optional[Dict[str, Any]] = Field(None, description="Use with caution, replaces entire dict")

class RoomMobInstanceInDBBase(BaseModel): 
    id: uuid.UUID
    room_id: uuid.UUID
    mob_template_id: uuid.UUID 
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None
    spawn_definition_id: Optional[uuid.UUID] = None
    spawned_at: datetime
    last_action_at: Optional[datetime] = None
    
    mob_template: MobTemplate # Changed from MobTemplateInDB to MobTemplate for consistency

    class Config:
        from_attributes = True

class RoomMobInstance(RoomMobInstanceInDBBase): 
    pass

class RoomMobsView(BaseModel):
    mobs_in_room: List[RoomMobInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/mob.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple, Union
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

from app.core.config import settings
from app.db.session import SessionLocal
from app import crud, models, schemas
from app.websocket_manager import connection_manager
from app.game_logic import combat

from app.commands.utils import (
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message,
    format_room_npcs_for_player_message
)
from app.game_state import is_character_resting, set_character_resting_status
from app.ws_command_parsers.ws_info_parser import handle_ws_brief

# Import all our glorious command parsers
from app.ws_command_parsers import (
    handle_ws_movement, handle_ws_flee,
    handle_ws_attack, handle_ws_use_combat_skill,
    handle_ws_get_take, handle_ws_unlock, handle_ws_search_examine,
    handle_ws_contextual_interactable, handle_ws_use_ooc_skill,
    handle_ws_look, handle_ws_rest,
    handle_ws_list, handle_ws_buy, handle_ws_sell, handle_ws_sell_all_junk,
    # --- OUR NEWLY ANOINTED HANDLERS ---
    handle_ws_equip, handle_ws_unequip,
    # Need this for the inventory push
    _send_inventory_update_to_player
)
# --- AND OUR HOLY ADMIN PARSER ---
from app.ws_command_parsers import ws_admin_parser

logger = logging.getLogger(__name__)

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token:
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str:
            return None
        player_uuid = uuid.UUID(player_id_str)
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError):
        return None

@router.websocket("/ws")
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character_orm: Optional[models.Character] = None

    with get_db_sync() as db_conn_init:
        player = await get_player_from_token(token, db_conn_init)
        if not player:
            logger.warning(f"WS Connect: Invalid token provided.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return

        fetched_char = crud.crud_character.get_character(db_conn_init, character_id=character_id)
        if not fetched_char or fetched_char.player_id != player.id:
            logger.warning(f"WS Connect: Invalid char_id: {character_id} for player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character_orm = fetched_char

    await connection_manager.connect(websocket, player.id, character_orm.id)
    logger.info(f"Player {player.username} ({player.id}) | Character {character_orm.name} ({character_orm.id}) connected via WebSocket.")

    # --- Welcome Package (largely unchanged) ---
    initial_messages = [f"Welcome {character_orm.name}! You are connected via WebSocket."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db_welcome:
        initial_room_orm = crud.crud_room.get_room_by_id(db_welcome, room_id=character_orm.current_room_id)
        if initial_room_orm:
            # ... a bunch of formatting for the welcome message ...
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            # ... etc ...
    
    xp_for_next_level = crud.crud_character.get_xp_for_level(character_orm.level + 1)
    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump(exclude_none=True) if initial_room_schema else None,
        "character_vitals": {
            "current_hp": character_orm.current_health, "max_hp": character_orm.max_health,
            "current_mp": character_orm.current_mana, "max_mp": character_orm.max_mana,
            "current_xp": character_orm.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character_orm.level,
            "platinum": character_orm.platinum_coins, "gold": character_orm.gold_coins,
            "silver": character_orm.silver_coins, "copper": character_orm.copper_coins
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)
    # --- End Welcome Package ---

    try:
        while True:
            received_data = await websocket.receive_json()
            command_text = received_data.get("command_text", "").strip()

            with get_db_sync() as db_loop:
                # --- THIS IS THE MOST IMPORTANT PART OF THE REFACTOR ---
                # Get FRESH state for player and character at the START of every command loop.
                fresh_player = crud.crud_player.get_player(db_loop, player_id=player.id)
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character_orm.id)

                if not current_char_state or not fresh_player:
                    logger.error(f"WS Loop: State lost for char_id: {character_orm.id} or player_id: {player.id}.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character or Player state lost in loop")
                    break
                
                # Our divine key.
                is_sysop = fresh_player.is_sysop

                current_room_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                if not current_room_orm:
                    logger.error(f"WS Loop: Character {current_char_state.name} in invalid room {current_char_state.current_room_id}.")
                    await combat.send_combat_log(fresh_player.id, ["Error: Your current location is unstable."])
                    continue
                
                current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)
                verb = command_text.split(" ", 1)[0].lower() if command_text else ""
                args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""

                # --- Rest check (unchanged) ---
                if verb and verb not in ["rest", "look", "l"] and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat.send_combat_log(fresh_player.id, ["You stop resting."], room_data=current_room_schema)

                if received_data.get("type") == "command" and command_text:
                    logger.debug(f"WS Router: User '{fresh_player.username}' (is_sysop={is_sysop}) sent verb='{verb}' for char '{current_char_state.name}'")

                    # --- COMMAND DISPATCHING (RE-ORDERED AND REFACTORED) ---
                    # Sysop commands are checked FIRST.
                    if verb in ["giveme", "setgod"]:
                        if is_sysop:
                            if verb == "giveme":
                                await ws_admin_parser.handle_ws_giveme(db_loop, fresh_player, current_char_state, args_str)
                            elif verb == "setgod":
                                await ws_admin_parser.handle_ws_set_god(db_loop, fresh_player, current_char_state, args_str)
                        else:
                            await combat.send_combat_log(fresh_player.id, ["A strange force prevents you from using that command."])
                    
                    # New player commands
                    elif verb in ["equip", "eq"]:
                        await handle_ws_equip(db_loop, fresh_player, current_char_state, args_str)
                    elif verb in ["unequip", "uneq"]:
                        await handle_ws_unequip(db_loop, fresh_player, current_char_state, args_str)

                    # Existing command handlers (now using fresh_player and current_char_state)
                    elif verb == "rest":
                        await handle_ws_rest(db_loop, fresh_player, current_char_state, current_room_orm)
                    elif verb in ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]:
                        await handle_ws_movement(db_loop, fresh_player, current_char_state, current_room_schema, verb, args_str)
                    elif verb == "flee":
                        await handle_ws_flee(db_loop, fresh_player, current_char_state, current_room_schema, args_str)
                    elif verb in ["attack", "atk", "kill", "k"]:
                        await handle_ws_attack(db_loop, fresh_player, current_char_state, current_room_orm, args_str)
                    elif verb == "use":
                        # This complex parsing logic remains, but we use the fresh objects
                        await handle_ws_use_combat_skill(db_loop, fresh_player, current_char_state, current_room_schema, args_str) # Example, assuming use logic is complex
                    elif verb in ["get", "take"]:
                        await handle_ws_get_take(db_loop, fresh_player, current_char_state, current_room_orm, args_str)
                    elif verb == "look" or verb == "l":
                        await handle_ws_look(db_loop, fresh_player, current_char_state, current_room_orm, args_str)
                    elif verb == "brief":
                        await handle_ws_brief(db_loop, fresh_player, current_char_state)
                    # ... other commands like unlock, search, shop commands would follow the same pattern ...
                    
                    else:
                        await combat.send_combat_log(fresh_player.id, [f"Unrecognized command: '{verb}'."], room_data=current_room_schema)

                # --- TRANSACTION AND POST-ACTION PUSHES ---
                try:
                    db_loop.commit()
                    logger.debug(f"WS Router: DB commit successful for command '{command_text}' by {current_char_state.name}")

                    # After a successful commit, if the command could have changed inventory, push an update.
                    inventory_modifying_verbs = ["giveme", "equip", "eq", "unequip", "uneq", "get", "take", "buy", "sell"]
                    if any(v in verb for v in inventory_modifying_verbs):
                       # We need the absolute latest state after the commit
                       refreshed_char_for_push = crud.crud_character.get_character(db_loop, character_id=current_char_state.id)
                       if refreshed_char_for_push:
                           await _send_inventory_update_to_player(db_loop, refreshed_char_for_push)
                       
                except Exception as e_commit:
                    db_loop.rollback()
                    logger.error(f"WS Router: DB commit failed for command '{command_text}': {e_commit}", exc_info=True)
                    await combat.send_combat_log(fresh_player.id, ["A glitch in the matrix occurred. Your last action may not have saved."])

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'}")
        if character_orm:
            combat.end_combat_for_character(character_orm.id, reason="websocket_disconnect")
            if is_character_resting(character_orm.id):
                set_character_resting_status(character_orm.id, False)
    except Exception as e:
        logger.error(f"Critical Error in WebSocket handler: {e}", exc_info=True)
    finally:
        if player and player.id:
            connection_manager.disconnect(player.id)
        logger.info(f"WebSocket connection for Player {player.id if player else 'N/A'} fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/ws_command_parsers/ws_interaction_parser.py ---
# backend/app/ws_command_parsers/ws_interaction_parser.py

import uuid
import random
import logging # Added logging
from typing import Optional, List, Tuple, Union, Sequence 
from sqlalchemy.orm import Session, attributes

from app import crud, models, schemas
from app.game_logic import combat 
from app.commands.utils import resolve_room_item_target, get_dynamic_room_description # IMPORTED get_dynamic_room_description
from app.commands.command_args import CommandContext 
from app.commands import interaction_parser as http_interaction_parser 
from app.websocket_manager import connection_manager 
from app.schemas.common_structures import ExitDetail, InteractableDetail 

logger = logging.getLogger(__name__) # Added logger

async def _send_inventory_update_to_player(db: Session, character: models.Character):
    """
    Helper function to construct and send a full inventory update to a player.
    """
    if not character or not character.id:
        logger.error("Cannot send inventory update: Invalid character object provided.")
        return

    logger.debug(f"Constructing and sending real-time inventory update to character {character.name} ({character.id})")

    inventory_items_orm = crud.crud_character_inventory.get_character_inventory(db, character_id=character.id)
    
    equipped_items = {}
    backpack_items = []
    
    for item_orm in inventory_items_orm:
        item_schema = schemas.CharacterInventoryItem.from_orm(item_orm)
        if item_schema.equipped and item_schema.equipped_slot:
            equipped_items[item_schema.equipped_slot] = item_schema
        else:
            backpack_items.append(item_schema)
            
    inventory_display_data = schemas.CharacterInventoryDisplay(
        equipped_items=equipped_items,
        backpack_items=backpack_items,
        platinum=character.platinum_coins,
        gold=character.gold_coins,
        silver=character.silver_coins,
        copper=character.copper_coins
    )

    payload = {
        "type": "inventory_update",
        "inventory_data": inventory_display_data.model_dump(exclude_none=True)
    }

    await connection_manager.send_personal_message(payload, character.player_id)
    logger.debug(f"Inventory update payload sent to player_id {character.player_id}")
    
async def handle_ws_equip(
    db: Session,
    player: models.Player,
    character: models.Character,
    args_str: str
):
    """Handles the 'equip' or 'eq' command."""
    if not args_str:
        await combat.send_combat_log(player.id, ["Usage: equip <item_in_backpack> [target_slot]"])
        return
        
    # TODO: Advanced parsing to separate item name from optional target slot
    # For now, simple matching on the whole args_str
    
    backpack_items = [
        inv_item for inv_item in character.inventory_items if not inv_item.equipped
    ]

    if not backpack_items:
        await combat.send_combat_log(player.id, ["Your backpack is empty."])
        return
    
    # Simple search logic for now
    possible_matches = [
        item for item in backpack_items 
        if item.item and args_str.lower() in item.item.name.lower()
    ]

    target_inv_item: Optional[models.CharacterInventoryItem] = None
    if len(possible_matches) == 1:
        target_inv_item = possible_matches[0]
    elif len(possible_matches) > 1:
        # Check for an exact match
        exact_match = next((item for item in possible_matches if item.item.name.lower() == args_str.lower()), None)
        if exact_match:
            target_inv_item = exact_match
        else:
            await combat.send_combat_log(player.id, [f"Multiple items match '{args_str}'. Be more specific."])
            return
    
    if not target_inv_item:
        await combat.send_combat_log(player.id, [f"You do not have '{args_str}' in your backpack."])
        return

    # At this point, target_inv_item is the CharacterInventoryItem to equip
    equipped_entry, message = crud.crud_character_inventory.equip_item_from_inventory(
        db, character_obj=character, inventory_item_id=target_inv_item.id
    )

    if equipped_entry:
        await combat.send_combat_log(player.id, [message.replace("Staged equipping of", "You equip the")])
    else:
        await combat.send_combat_log(player.id, [f"You can't equip that: {message}"])
    
    # The inventory update will be pushed after commit in the router

async def handle_ws_unequip(
    db: Session,
    player: models.Player,
    character: models.Character,
    args_str: str
):
    """Handles the 'unequip' or 'uneq' command."""
    if not args_str:
        await combat.send_combat_log(player.id, ["Usage: unequip <slot_name>"])
        return

    slot_to_unequip = args_str.lower().strip()
    
    if slot_to_unequip not in models.item.EQUIPMENT_SLOTS:
        await combat.send_combat_log(player.id, [f"'{slot_to_unequip}' is not a valid equipment slot."])
        return

    unequipped_entry, message = crud.crud_character_inventory.unequip_item_to_inventory(
        db, character_obj=character, slot_to_unequip=slot_to_unequip
    )

    if unequipped_entry:
        await combat.send_combat_log(player.id, [message.replace("Staged unequipping of", "You unequip the")])
    else:
        await combat.send_combat_log(player.id, [f"You can't unequip from there: {message}"])

async def handle_ws_get_take(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room, 
    args_str: str 
):
    # ... (code to prepare room schema is unchanged) ...
    dynamic_desc = get_dynamic_room_description(current_room_orm)
    current_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    current_room_data_dict["description"] = dynamic_desc
    current_room_schema_with_dynamic_desc = schemas.RoomInDB(**current_room_data_dict)


    if args_str.lower() == "all":
        # ... (code for 'get all' logic is unchanged up until the commit) ...
        items_on_ground_orm = crud.crud_room_item.get_items_in_room(db, room_id=current_room_orm.id)
        if not items_on_ground_orm:
            await combat.send_combat_log(player.id, ["There is nothing on the ground here to get."], room_data=current_room_schema_with_dynamic_desc)
            return

        picked_up_item_messages = []
        failed_to_pick_up_messages = []
        picked_up_item_names_for_broadcast = []
        anything_actually_picked_up = False

        for room_item_instance in items_on_ground_orm:
            if not room_item_instance.item:
                logger.warning(f"RoomItemInstance {room_item_instance.id} in room {current_room_orm.id} has no associated ItemTemplate. Skipping for 'get all'.")
                continue

            if not getattr(room_item_instance.item, 'is_gettable', True):
                continue
            
            _inv_add_entry, add_message = crud.crud_character_inventory.add_item_to_character_inventory(
                db, character_obj=current_char_state,
                item_id=room_item_instance.item_id,
                quantity=room_item_instance.quantity
            )

            if _inv_add_entry:
                crud.crud_room_item.remove_item_from_room(
                    db, room_item_instance_id=room_item_instance.id,
                    quantity_to_remove=room_item_instance.quantity
                )
                item_name_with_qty = room_item_instance.item.name
                if room_item_instance.quantity > 1:
                    item_name_with_qty += f" (x{room_item_instance.quantity})"
                
                picked_up_item_messages.append(f"You take the {item_name_with_qty}.")
                picked_up_item_names_for_broadcast.append(item_name_with_qty)
                anything_actually_picked_up = True
            else:
                failed_to_pick_up_messages.append(f"Could not take {room_item_instance.item.name}: {add_message.replace('You pick up the ', '').replace('You add ', '').replace(' to your inventory.', '')}")
        
        if not anything_actually_picked_up and not failed_to_pick_up_messages:
            await combat.send_combat_log(player.id, ["There was nothing gettable on the ground."], room_data=current_room_schema_with_dynamic_desc)
            return

        if anything_actually_picked_up:
            db.commit()
            await _send_inventory_update_to_player(db, current_char_state) # ### UPDATE PUSH ###
        else:
            db.rollback() # If nothing was picked up, rollback any potential changes
        
        db.refresh(current_char_state)
        refreshed_room_orm = crud.crud_room.get_room_by_id(db, current_room_orm.id)

        # ... (rest of the 'get all' response logic is unchanged) ...
        updated_room_schema_for_response = current_room_schema_with_dynamic_desc # Default
        if refreshed_room_orm:
            updated_dynamic_desc = get_dynamic_room_description(refreshed_room_orm)
            updated_room_data_dict = schemas.RoomInDB.from_orm(refreshed_room_orm).model_dump()
            updated_room_data_dict["description"] = updated_dynamic_desc
            updated_room_schema_for_response = schemas.RoomInDB(**updated_room_data_dict)
        
        final_log_to_player = []
        if picked_up_item_messages:
            final_log_to_player.extend(picked_up_item_messages)
        if failed_to_pick_up_messages:
            final_log_to_player.extend(failed_to_pick_up_messages)
        
        if not final_log_to_player:
            final_log_to_player.append("No items were picked up.")

        xp_for_next = crud.crud_character.get_xp_for_level(current_char_state.level + 1)
        vitals_payload = {
            "current_hp": current_char_state.current_health, "max_hp": current_char_state.max_health,
            "current_mp": current_char_state.current_mana, "max_mp": current_char_state.max_mana,
            "current_xp": current_char_state.experience_points,
            "next_level_xp": int(xp_for_next) if xp_for_next != float('inf') else -1,
            "level": current_char_state.level, "platinum": current_char_state.platinum_coins,
            "gold": current_char_state.gold_coins, "silver": current_char_state.silver_coins,
            "copper": current_char_state.copper_coins
        }
        await combat.send_combat_log(player.id, final_log_to_player, room_data=updated_room_schema_for_response, character_vitals=vitals_payload)

        if picked_up_item_names_for_broadcast:
            broadcast_get_msg = f"<span class='char-name'>{current_char_state.name}</span> picks up: {', '.join(picked_up_item_names_for_broadcast)}."
            await combat.broadcast_to_room_participants(db, current_room_orm.id, broadcast_get_msg, exclude_player_id=player.id)
        return

    # --- Existing logic for single item "get" ---
    # ... (code for resolving single item is unchanged) ...
    if not args_str:
        await combat.send_combat_log(player.id, ["Get what?"], room_data=current_room_schema_with_dynamic_desc)
        return
    
    items_on_ground_orm = crud.crud_room_item.get_items_in_room(db, room_id=current_room_orm.id)
    if not items_on_ground_orm:
        await combat.send_combat_log(player.id, ["There is nothing on the ground here to get."], room_data=current_room_schema_with_dynamic_desc)
        return

    target_room_item_instance, error_or_prompt = resolve_room_item_target(args_str, items_on_ground_orm)
    if error_or_prompt:
        await combat.send_combat_log(player.id, [error_or_prompt], room_data=current_room_schema_with_dynamic_desc)
        return
    if not target_room_item_instance or not target_room_item_instance.item:
        await combat.send_combat_log(player.id, [f"Cannot find '{args_str}' on the ground here."], room_data=current_room_schema_with_dynamic_desc)
        return
    
    if not getattr(target_room_item_instance.item, 'is_gettable', True):
        await combat.send_combat_log(player.id, [f"You cannot pick up the {target_room_item_instance.item.name}."], room_data=current_room_schema_with_dynamic_desc)
        return
        
    _inv_add_entry, add_message = crud.crud_character_inventory.add_item_to_character_inventory(
        db, character_obj=current_char_state,
        item_id=target_room_item_instance.item_id,
        quantity=target_room_item_instance.quantity
    )
    if not _inv_add_entry: 
        await combat.send_combat_log(player.id, [f"You try to pick up {target_room_item_instance.item.name}, but cannot. ({add_message})"], room_data=current_room_schema_with_dynamic_desc)
        return
    
    crud.crud_room_item.remove_item_from_room(
        db, room_item_instance_id=target_room_item_instance.id,
        quantity_to_remove=target_room_item_instance.quantity
    )
    final_pickup_message = add_message
    
    db.commit()
    await _send_inventory_update_to_player(db, current_char_state) # ### UPDATE PUSH ###
    
    db.refresh(current_char_state) 
    refreshed_room_orm = crud.crud_room.get_room_by_id(db, current_room_orm.id)
    
    # ... (rest of the single 'get' response logic is unchanged) ...
    updated_room_schema_for_response = current_room_schema_with_dynamic_desc
    if refreshed_room_orm:
        updated_dynamic_desc = get_dynamic_room_description(refreshed_room_orm)
        updated_room_data_dict = schemas.RoomInDB.from_orm(refreshed_room_orm).model_dump()
        updated_room_data_dict["description"] = updated_dynamic_desc
        updated_room_schema_for_response = schemas.RoomInDB(**updated_room_data_dict)

    xp_for_next = crud.crud_character.get_xp_for_level(current_char_state.level + 1)
    vitals_payload = {
        "current_hp": current_char_state.current_health, "max_hp": current_char_state.max_health,
        "current_mp": current_char_state.current_mana, "max_mp": current_char_state.max_mana,
        "current_xp": current_char_state.experience_points,
        "next_level_xp": int(xp_for_next) if xp_for_next != float('inf') else -1,
        "level": current_char_state.level, "platinum": current_char_state.platinum_coins,
        "gold": current_char_state.gold_coins, "silver": current_char_state.silver_coins,
        "copper": current_char_state.copper_coins
    }
    await combat.send_combat_log(player.id, [final_pickup_message], room_data=updated_room_schema_for_response, character_vitals=vitals_payload)
    
    broadcast_get_msg = f"<span class='char-name'>{current_char_state.name}</span> picks up {target_room_item_instance.item.name}."
    await combat.broadcast_to_room_participants(db, current_room_orm.id, broadcast_get_msg, exclude_player_id=player.id)


async def handle_ws_unlock(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room,
    args_list: Sequence[str] 
):
    # Dynamic description for initial room schema if needed by HTTP parser (though it shouldn't modify it)
    initial_dynamic_desc = get_dynamic_room_description(current_room_orm)
    initial_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    initial_room_data_dict["description"] = initial_dynamic_desc
    initial_room_schema_with_dynamic_desc = schemas.RoomInDB(**initial_room_data_dict)

    cmd_context = CommandContext(
        db=db, active_character=current_char_state,
        current_room_orm=current_room_orm,
        current_room_schema=initial_room_schema_with_dynamic_desc, # Pass schema with dynamic desc
        original_command=f"unlock {' '.join(args_list)}", 
        command_verb="unlock", args=list(args_list) 
    )
    response_schema_from_http = await http_interaction_parser.handle_unlock(cmd_context)
    
    # Prepare final room data for WS response, ensuring it has dynamic description
    final_room_orm_for_response = crud.crud_room.get_room_by_id(db, current_room_orm.id) # Re-fetch
    if final_room_orm_for_response:
        final_dynamic_desc = get_dynamic_room_description(final_room_orm_for_response)
        final_room_data_dict = schemas.RoomInDB.from_orm(final_room_orm_for_response).model_dump()
        final_room_data_dict["description"] = final_dynamic_desc
        final_room_schema_for_ws_response = schemas.RoomInDB(**final_room_data_dict)
    else: # Fallback
        final_room_schema_for_ws_response = initial_room_schema_with_dynamic_desc


    if response_schema_from_http.message_to_player:
        await combat.send_combat_log(
            player.id, 
            [response_schema_from_http.message_to_player], 
            room_data=final_room_schema_for_ws_response # Use schema with dynamic desc
        )


async def handle_ws_search_examine(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room,
    args_list: Sequence[str] 
):
    initial_dynamic_desc = get_dynamic_room_description(current_room_orm)
    initial_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    initial_room_data_dict["description"] = initial_dynamic_desc
    initial_room_schema_with_dynamic_desc = schemas.RoomInDB(**initial_room_data_dict)

    cmd_context = CommandContext(
        db=db, active_character=current_char_state,
        current_room_orm=current_room_orm,
        current_room_schema=initial_room_schema_with_dynamic_desc,
        original_command=f"search {' '.join(args_list)}", 
        command_verb="search",  
        args=list(args_list) 
    )
    response_schema_from_http = await http_interaction_parser.handle_search(cmd_context)
    
    final_room_orm_for_response = crud.crud_room.get_room_by_id(db, current_room_orm.id) 
    if final_room_orm_for_response:
        final_dynamic_desc = get_dynamic_room_description(final_room_orm_for_response)
        final_room_data_dict = schemas.RoomInDB.from_orm(final_room_orm_for_response).model_dump()
        final_room_data_dict["description"] = final_dynamic_desc
        final_room_schema_for_ws_response = schemas.RoomInDB(**final_room_data_dict)
    else:
        final_room_schema_for_ws_response = initial_room_schema_with_dynamic_desc
        
    if response_schema_from_http.message_to_player:
        await combat.send_combat_log(
            player.id, 
            [response_schema_from_http.message_to_player], 
            room_data=final_room_schema_for_ws_response
        )

async def handle_ws_contextual_interactable(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room,
    verb: str, 
    args_list: Sequence[str], 
    interactable_schema: schemas.InteractableDetail 
):
    initial_dynamic_desc = get_dynamic_room_description(current_room_orm)
    initial_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    initial_room_data_dict["description"] = initial_dynamic_desc
    initial_room_schema_with_dynamic_desc = schemas.RoomInDB(**initial_room_data_dict)

    cmd_context = CommandContext(
        db=db, active_character=current_char_state,
        current_room_orm=current_room_orm,
        current_room_schema=initial_room_schema_with_dynamic_desc, 
        original_command=f"{verb} {' '.join(args_list)}",
        command_verb=verb, args=list(args_list) 
    )
    
    response_schema_from_http = await http_interaction_parser.handle_contextual_interactable_action(cmd_context, interactable_schema)
    
    # Re-fetch the current room ORM to ensure its 'exits' are up-to-date after any commits in HTTP parser
    final_response_room_orm = crud.crud_room.get_room_by_id(db, current_room_orm.id) 
    
    if final_response_room_orm:
        dynamic_desc_for_response = get_dynamic_room_description(final_response_room_orm)
        response_room_data_dict = schemas.RoomInDB.from_orm(final_response_room_orm).model_dump()
        response_room_data_dict["description"] = dynamic_desc_for_response
        response_room_schema_with_dynamic_desc = schemas.RoomInDB(**response_room_data_dict)
    else: 
        # Fallback if room somehow vanished
        logger.warning(f"Room {current_room_orm.id} not found after contextual interactable. Using initial schema for dynamic desc.")
        dynamic_desc_for_response = get_dynamic_room_description(current_room_orm) # Use potentially stale ORM
        fallback_dict = initial_room_schema_with_dynamic_desc.model_dump() # Should already have a dynamic desc
        # Ensure it's using the most recent dynamic description based on potentially stale ORM
        fallback_dict["description"] = dynamic_desc_for_response 
        response_room_schema_with_dynamic_desc = schemas.RoomInDB(**fallback_dict)

    if response_schema_from_http.message_to_player:
        await combat.send_combat_log(
            player.id, 
            [response_schema_from_http.message_to_player], 
            room_data=response_room_schema_with_dynamic_desc 
        )

async def handle_ws_use_ooc_skill(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room, 
    selected_skill_template: models.SkillTemplate, 
    target_identifier: Optional[str] 
):
    current_room_id_for_broadcast = current_room_orm.id
    
    # Initial room schema for log, with dynamic description
    initial_dynamic_desc = get_dynamic_room_description(current_room_orm)
    initial_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    initial_room_data_dict["description"] = initial_dynamic_desc
    current_room_schema_for_log = schemas.RoomInDB(**initial_room_data_dict)

    resolved_target_for_effect: Optional[Union[models.RoomMobInstance, str]] = None

    if selected_skill_template.target_type == "DOOR":
        if target_identifier and target_identifier.lower() not in ["none", "self"]:
            resolved_target_for_effect = target_identifier
        else:
            await combat.send_combat_log(player.id, [f"Which direction do you want to use '{selected_skill_template.name}' on?"], room_data=current_room_schema_for_log)
            return
    elif selected_skill_template.target_type in ["SELF", "NONE"]:
        resolved_target_for_effect = None 
    else:
        await combat.send_combat_log(player.id, [f"Skill '{selected_skill_template.name}' has an OOC target type ('{selected_skill_template.target_type}') not yet handled for direct use."], room_data=current_room_schema_for_log)
        return

    skill_log_messages, action_taken_by_skill, char_after_ooc_skill_attempt = await combat.resolve_skill_effect(
        db, current_char_state, selected_skill_template, resolved_target_for_effect, 
        player.id, current_room_id_for_broadcast
    )
    
    final_room_schema_for_response = current_room_schema_for_log # Start with initial
    if action_taken_by_skill:
        if char_after_ooc_skill_attempt: db.add(char_after_ooc_skill_attempt)
        db.commit()
        
        if char_after_ooc_skill_attempt: 
            db.refresh(char_after_ooc_skill_attempt)
            current_char_state = char_after_ooc_skill_attempt 

        refreshed_room_orm = crud.crud_room.get_room_by_id(db, current_room_id_for_broadcast)
        if refreshed_room_orm:
            # Generate dynamic description for the updated room state
            final_dynamic_desc = get_dynamic_room_description(refreshed_room_orm)
            final_room_dict = schemas.RoomInDB.from_orm(refreshed_room_orm).model_dump()
            final_room_dict["description"] = final_dynamic_desc
            final_room_schema_for_response = schemas.RoomInDB(**final_room_dict)
        else:
            logger.warning(f"Room {current_room_id_for_broadcast} not found after OOC skill. Using initial schema for log.")
            # final_room_schema_for_response remains the initial one
    
    xp_for_next = crud.crud_character.get_xp_for_level(current_char_state.level + 1)
    vitals_payload = {
        "current_hp": current_char_state.current_health, "max_hp": current_char_state.max_health,
        "current_mp": current_char_state.current_mana, "max_mp": current_char_state.max_mana,
        "current_xp": current_char_state.experience_points,
        "next_level_xp": int(xp_for_next) if xp_for_next != float('inf') else -1,
        "level": current_char_state.level,
        "platinum": current_char_state.platinum_coins, "gold": current_char_state.gold_coins,
        "silver": current_char_state.silver_coins, "copper": current_char_state.copper_coins
    }
    await combat.send_combat_log(player.id, skill_log_messages, room_data=final_room_schema_for_response, character_vitals=vitals_payload)
--- END OF FILE backend/app/ws_command_parsers/ws_interaction_parser.py ---

--- START OF FILE backend/app/ws_command_parsers/ws_info_parser.py ---
# backend/app/ws_command_parsers/ws_info_parser.py
import uuid
import logging
from typing import Optional, List
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.game_logic import combat 
from app.commands.utils import (
    format_room_items_for_player_message,
    format_room_characters_for_player_message,
    get_dynamic_room_description,
    format_room_npcs_for_player_message # <<< IMPORT THE NEW FORMATTER
)
from app.game_state import is_character_resting, set_character_resting_status
from app.schemas.common_structures import ExitDetail 

logger = logging.getLogger(__name__)

def _format_mobs_for_display(mobs: List[models.RoomMobInstance], player_level: int) -> str:
    if not mobs:
        return ""

    mob_lines = []
    for mob in mobs:
        mob_template = mob.mob_template
        if not mob_template:
            continue
        
        # Add a check for mob_template.level being None
        if mob_template.level is None:
            logger.warning(f"Mob template {mob_template.id} ({mob_template.name}) has no level, skipping display.")
            continue

        level_diff = (mob_template.level-player_level)
        
        difficulty = "neutral" # Default
        if level_diff <= -10: difficulty = "trivial"  # Grey
        elif level_diff <= -3: difficulty = "easy"    # Green
        elif level_diff <= 2: difficulty = "neutral"   # Yellow
        elif level_diff <= 5: difficulty = "hard"      # Orange
        else: difficulty = "deadly"                     # Red

        boss_icon = "ðŸ’€ " if mob_template.is_boss else ""
        
        mob_name_span = f"<span class='mob-name difficulty-{difficulty}'>{boss_icon}{mob_template.name}</span>"
        mob_lines.append(f"{mob_name_span} is here.")

    return "\n".join(mob_lines)

async def handle_ws_look(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room, 
    args_str: str 
):
    dynamic_description = get_dynamic_room_description(current_room_orm)
    items_on_ground = crud.crud_room_item.get_items_in_room(db, room_id=current_room_orm.id)
    items_text, _ = format_room_items_for_player_message(items_on_ground)
    
    # --- USE OUR NEW MOB FORMATTER ---
    mobs_in_current_room = crud.crud_mob.get_mobs_in_room(db, room_id=current_room_orm.id)
    mobs_text = _format_mobs_for_display(mobs_in_current_room, current_char_state.level)

    other_chars_look = crud.crud_character.get_characters_in_room(
        db, room_id=current_room_orm.id, 
        exclude_character_id=current_char_state.id
    )
    chars_text_look = format_room_characters_for_player_message(other_chars_look)
    npcs_in_room = crud.crud_room.get_npcs_in_room(db, room=current_room_orm)
    npcs_text = format_room_npcs_for_player_message(npcs_in_room)

    exits = [f"<span class='exit'>{direction.upper()}</span>" for direction in (current_room_orm.exits or {}).keys()]
    exits_text_line = "Exits: " + ("[ " + " | ".join(exits) + " ]" if exits else "None")

    look_message_parts = [
        f"<span class='room-name-header'>--- {current_room_orm.name} ---</span>",
        # --- BRIEF MODE CHECK ---
        "" if current_char_state.is_brief_mode else dynamic_description,
        exits_text_line,
        items_text,
        mobs_text,
        chars_text_look,
        npcs_text
    ]
    
    final_look_message = "\n".join(part for part in look_message_parts if part)
    
    await combat.send_combat_log(
        player.id, 
        [final_look_message],
        room_data=schemas.RoomInDB.from_orm(current_room_orm)
    )

async def handle_ws_brief(db: Session, player: models.Player, character: models.Character):
    character.is_brief_mode = not character.is_brief_mode
    db.add(character)
    db.commit() # Commit this simple change immediately
    
    mode = "ON" if character.is_brief_mode else "OFF"
    await combat.send_combat_log(player.id, [f"Brief mode is now {mode}."])

async def handle_ws_rest(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room
):
    dynamic_description = get_dynamic_room_description(current_room_orm)
    # This logic seems fine, no need to change it.
    final_room_schema_for_client = schemas.RoomInDB.from_orm(current_room_orm)
    # We can pass the description in the payload if the client uses it.
    final_room_schema_for_client.description = dynamic_description

    if current_char_state.id in combat.active_combats:
        await combat.send_combat_log(player.id, ["You cannot rest while in combat."], room_data=final_room_schema_for_client)
    elif is_character_resting(current_char_state.id):
        await combat.send_combat_log(player.id, ["You are already resting."], room_data=final_room_schema_for_client)
    elif current_char_state.current_health == current_char_state.max_health and \
            current_char_state.current_mana == current_char_state.max_mana:
        await combat.send_combat_log(player.id, ["You are already fully rejuvenated."], room_data=final_room_schema_for_client)
    else:
        set_character_resting_status(current_char_state.id, True)
        await combat.send_combat_log(player.id, ["You sit down and begin to rest."], room_data=final_room_schema_for_client)
        await combat.broadcast_to_room_participants( 
            db, current_room_orm.id, 
            f"<span class='char-name'>{current_char_state.name}</span> sits down to rest.",
            exclude_player_id=player.id
        )
--- END OF FILE backend/app/ws_command_parsers/ws_info_parser.py ---

--- START OF FILE backend/app/ws_command_parsers/ws_movement_parser.py ---
# backend/app/ws_command_parsers/ws_movement_parser.py (NEW FILE)
import uuid
import logging
from typing import Optional, List
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.game_logic import combat # For combat.send_combat_log, combat.active_combats etc.
from app.websocket_manager import connection_manager
from app.commands.utils import (
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message
)
from app.ws_command_parsers.ws_info_parser import handle_ws_look 
from app.schemas.common_structures import ExitDetail # For lock checks

logger = logging.getLogger(__name__) # Ensure logger is initialized

# This was _handle_websocket_move_if_not_in_combat
async def attempt_player_move(
    db: Session,
    player: models.Player,
    character_state: models.Character,
    command_verb: str,
    command_args_str: str
):
    # ... All the logic to determine if a move is possible is UNCHANGED ...
    # It correctly finds the target_direction_canonical, checks for locks, etc.
    # We only need to change the success block at the end.
    
    message_to_player_on_fail: Optional[str] = None
    moved_successfully = False
    target_room_orm_for_move: Optional[models.Room] = None
    direction_map = {
        "n": "north", "north": "north", "s": "south", "south": "south",
        "e": "east", "east": "east", "w": "west", "west": "west",
        "u": "up", "up": "up", "d": "down", "down": "down"
    }
    raw_direction_input = ""
    if command_verb == "go":
        if command_args_str: raw_direction_input = command_args_str.split(" ", 1)[0].lower()
        else:
            room_for_go_fail = crud.crud_room.get_room_by_id(db, character_state.current_room_id)
            schema_for_go_fail = schemas.RoomInDB.from_orm(room_for_go_fail) if room_for_go_fail else None
            await combat.send_combat_log(player.id, ["Go where?"], room_data=schema_for_go_fail); return
    else: raw_direction_input = command_verb.lower()

    target_direction_canonical = direction_map.get(raw_direction_input)
    current_room_orm_before_move = crud.crud_room.get_room_by_id(db, room_id=character_state.current_room_id)
    current_room_schema_for_fail = schemas.RoomInDB.from_orm(current_room_orm_before_move) if current_room_orm_before_move else None

    if not target_direction_canonical:
        await combat.send_combat_log(player.id, [f"'{raw_direction_input}' is not a recognized direction."], room_data=current_room_schema_for_fail); return

    old_room_id = character_state.current_room_id
    if current_room_orm_before_move:
        current_exits_on_orm = current_room_orm_before_move.exits
        if isinstance(current_exits_on_orm, dict): # Ensure it's a dict
            exit_data_dict = current_exits_on_orm.get(target_direction_canonical)
            if exit_data_dict and isinstance(exit_data_dict, dict): # Ensure it's a dict and not None
                try:
                    exit_detail_model = ExitDetail(**exit_data_dict)
                    if not exit_detail_model.is_locked:
                        target_room_orm_for_move = crud.crud_room.get_room_by_id(db, room_id=exit_detail_model.target_room_id)
                        if target_room_orm_for_move:
                            moved_successfully = True
                        else:
                            message_to_player_on_fail = "The path ahead seems to vanish into nothingness."
                    else:
                        message_to_player_on_fail = exit_detail_model.description_when_locked or "That way is locked."
                except Exception as e_pydantic: # Catch Pydantic validation errors or others
                    logger.error(f"Failed to parse ExitDetail for direction '{target_direction_canonical}' in room '{current_room_orm_before_move.name}': {e_pydantic}", exc_info=True)
                    message_to_player_on_fail = "There's a problem with the exit in that direction."
            else: # target_direction_canonical not in exits or data is not a dict
                message_to_player_on_fail = "You can't go that way."
        else: # current_exits_on_orm is not a dict (should not happen with proper Room model)
            logger.warning(f"Room {current_room_orm_before_move.name} exits data is not a dictionary.")
            message_to_player_on_fail = "You can't go that way."
    else:
        message_to_player_on_fail = "Error: Your current location is undefined."


    # --- THIS IS THE CORRECTED SUCCESS BLOCK ---
    if moved_successfully and target_room_orm_for_move:
        # 1. Update character state in the database and connection manager
        crud.crud_character.update_character_room(db, character_id=character_state.id, new_room_id=target_room_orm_for_move.id)
        connection_manager.update_character_location(character_state.id, target_room_orm_for_move.id)
        
        # 2. Tell everyone in the OLD room that you left
        player_ids_in_old_room = [char.player_id for char in crud.crud_character.get_characters_in_room(db, room_id=old_room_id, exclude_character_id=character_state.id) if connection_manager.is_player_connected(char.player_id)]
        if player_ids_in_old_room:
            leave_msg = f"<span class='char-name'>{character_state.name}</span> leaves, heading {target_direction_canonical}."
            await connection_manager.broadcast_to_players({"type": "game_event", "message": leave_msg}, player_ids_in_old_room)
        
        # 3. Tell everyone in the NEW room that you arrived
        player_ids_in_new_room_others = [char.player_id for char in crud.crud_character.get_characters_in_room(db, room_id=target_room_orm_for_move.id, exclude_character_id=character_state.id) if connection_manager.is_player_connected(char.player_id)]
        if player_ids_in_new_room_others:
            arrival_direction = combat.get_opposite_direction(target_direction_canonical) # Make sure combat.get_opposite_direction exists
            arrive_msg = f"<span class='char-name'>{character_state.name}</span> arrives from the {arrival_direction}."
            await connection_manager.broadcast_to_players({"type": "game_event", "message": arrive_msg}, player_ids_in_new_room_others)

        # 4. DELEGATE! Let handle_ws_look do ALL the work of telling the player what they see.
        # This is the only message the moving player needs to receive.
        await handle_ws_look(db, player, character_state, target_room_orm_for_move, "")
        
    else:
        # Ensure message_to_player_on_fail is not None before sending
        if message_to_player_on_fail:
            await combat.send_combat_log(player.id, [message_to_player_on_fail], room_data=current_room_schema_for_fail)
        else:
            # Fallback message if message_to_player_on_fail was somehow not set
            await combat.send_combat_log(player.id, ["You can't move that way."], room_data=current_room_schema_for_fail)



async def handle_ws_movement(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_schema: schemas.RoomInDB, # Pass schema for fail messages
    verb: str,
    args_str: str
):
    is_in_active_combats = current_char_state.id in combat.active_combats
    targets_for_char = combat.active_combats.get(current_char_state.id) if is_in_active_combats else None
    condition_to_block = is_in_active_combats and bool(targets_for_char)

    if condition_to_block:
        await combat.send_combat_log(
            player.id, ["You cannot move while in combat! Try 'flee <direction>' or 'flee'."],
            room_data=current_room_schema, transient=True 
        )
        return

    # If "go", verb is "go", args_str is direction. If "n", verb is "n", args_str is empty.
    # attempt_player_move handles this.
    await attempt_player_move(db, player, current_char_state, verb, args_str)


async def handle_ws_flee(
    db: Session, # db might not be needed if only manipulating combat state dicts
    player: models.Player,
    current_char_state: models.Character,
    current_room_schema: schemas.RoomInDB,
    args_str: str
):
    if current_char_state.id in combat.active_combats and combat.active_combats.get(current_char_state.id):
        flee_direction_arg = args_str.split(" ", 1)[0].lower() if args_str else "random"
        canonical_flee_dir = "random"
        if flee_direction_arg != "random":
            canonical_flee_dir = combat.direction_map.get(flee_direction_arg, flee_direction_arg)
            if canonical_flee_dir not in combat.direction_map.values():
                await combat.send_combat_log(player.id, [f"Invalid flee direction '{flee_direction_arg}'. Try 'flee' or 'flee <direction>'."], room_data=current_room_schema, transient=True)
                return 
        combat.character_queued_actions[current_char_state.id] = f"flee {canonical_flee_dir}"
        await combat.send_combat_log(player.id, [f"You prepare to flee {canonical_flee_dir if canonical_flee_dir != 'random' else '...'}"])
    else:
        await combat.send_combat_log(player.id, ["You are not in combat."], room_data=current_room_schema, transient=True)
--- END OF FILE backend/app/ws_command_parsers/ws_movement_parser.py ---

--- START OF FILE backend/app/api/dependencies.py ---
# backend/app/api/dependencies.py
from typing import Optional
from fastapi import Depends, HTTPException, status, Header
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
import uuid

from app.core.config import settings
from app import models, schemas, crud
from app.db.session import get_db
from app.game_state import active_game_sessions # <<< ADDED THIS IMPORT

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY

async def get_current_player(
    db: Session = Depends(get_db),
    authorization: Optional[str] = Header(None) # <<< THIS IS THE MAGIC
) -> models.Player:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    if authorization is None:
        raise credentials_exception
    
    # Manually split the "Bearer <token>" string
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise credentials_exception
    except ValueError:
        raise credentials_exception

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username_or_player_id: Optional[str] = payload.get("sub")
        if username_or_player_id is None:
            raise credentials_exception
        
        try:
            player_uuid = uuid.UUID(username_or_player_id)
        except ValueError:
            raise credentials_exception
            
    except JWTError:
        raise credentials_exception
    
    player = crud.crud_player.get_player(db, player_id=player_uuid)
    if player is None:
        raise credentials_exception
    return player

async def get_current_active_character( 
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
) -> models.Character:
    character_id = active_game_sessions.get(current_player.id)
    
    if not character_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, 
            detail="No active character selected for this session. Please select a character.",
        )
    
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        active_game_sessions.pop(current_player.id, None)
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Active character with ID {character_id} not found. Session reset.",
        )

    if character.player_id != current_player.id:
        active_game_sessions.pop(current_player.id, None) 
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="CRITICAL: Active character's player ID does not match authenticated player. Session reset.",
        )
    return character
--- END OF FILE backend/app/api/dependencies.py ---

--- START OF FILE backend/app/game_state.py ---
# backend/app/game_state.py
import uuid
from typing import Dict, Optional

# Player ID -> Active Character ID mapping (for HTTP sessions)
active_game_sessions: Dict[uuid.UUID, uuid.UUID] = {}

# Character ID -> Resting Status (True if resting)
character_resting_status: Dict[uuid.UUID, bool] = {}

def is_character_resting(character_id: uuid.UUID) -> bool:
    return character_resting_status.get(character_id, False)

def set_character_resting_status(character_id: uuid.UUID, is_resting: bool):
    if is_resting:
        character_resting_status[character_id] = True
        print(f"GAME_STATE: Character {character_id} is now resting.")
    else:
        if character_id in character_resting_status:
            del character_resting_status[character_id]
            print(f"GAME_STATE: Character {character_id} stopped resting.")
--- END OF FILE backend/app/game_state.py ---

--- START OF FILE backend/app/seeds/rooms_z0.json ---
[
  {
    "unique_tag": "central_hub_0_0_0",
    "data": {
      "name": "Central Processing Unit (CPU)",
      "description": "The air hums. Corridors branch off. [DYNAMIC_EXIT_EAST]. A faint inscription reads 'Sector 0,0,0'. This appears to be some kind of nexus or entry point.",
      "x": 0, "y": 0, "z": 0,
      "room_type": "standard",
      "zone_name": "Central Processing",
      "zone_level_range": "1-2",
      "interactables": [
        {
          "id_tag": "cpu_east_lever",
          "name": "a sturdy metal lever",
          "description": "A heavy metal lever is set into the wall, currently in the 'up' position.",
          "action_verb": "pull",
          "on_interact_effect": {
            "type": "toggle_exit_lock",
            "target_exit_direction": "east",
            "message_success_self": "You pull the lever down with a CLUNK. You hear a mechanism engage nearby.",
            "message_success_others": "{character_name} pulls the lever. A distant clunk is heard."
          }
        }
      ]
    }
  },
  {
    "unique_tag": "east_storage_1_0_0",
    "data": {
      "name": "Secure Storage Vault Epsilon",
      "description": "Dust motes dance in the dim light. Shelves line the walls, mostly empty. Panel E-1. [DYNAMIC_EXIT_WEST]",
      "x": 1, "y": 0, "z": 0,
      "room_type": "standard",
      "zone_name": "Central Processing",
      "zone_level_range": "1-2"
    }
  },
  {
    "unique_tag": "outskirts_gate_0_1_0",
    "data": {
      "name": "Dilapidated Northern Gate",
      "description": "A crumbling stone archway marks what might have once been a northern exit from the central complex. The path beyond is overgrown and disappears into a tangle of thorny bushes.",
      "x": 0, "y": 1, "z": 0,
      "room_type": "standard",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3"
    }
  },
  {
    "unique_tag": "beginner_path_0_2_0",
    "data": {
      "name": "Overgrown Path",
      "description": "Thorny bushes and grasping weeds choke this narrow path. The air is damp and smells of decay. Small creatures skitter in the undergrowth.",
      "x": 0, "y": 2, "z": 0,
      "room_type": "standard",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3"
    }
  },
  {
    "unique_tag": "ruined_shack_clearing_0_3_0",
    "data": {
      "name": "Ruined Shack Clearing",
      "description": "The path opens into a small clearing where the remains of a wooden shack slowly rot. A rusty water pump stands askew nearby.",
      "x": 0, "y": 3, "z": 0,
      "room_type": "standard",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3",
      "interactables": [
        {
          "id_tag": "shack_pump_handle",
          "name": "a rusty pump handle",
          "description": "The handle of the old water pump is stiff but might still move.",
          "action_verb": "pump",
          "on_interact_effect": {
            "type": "custom_event",
            "message_success_self": "You work the pump handle. After a few groaning protests, a trickle of brackish water sputters out.",
            "message_success_others": "{character_name} works the pump handle, producing a trickle of murky water."
          }
        }
      ]
    }
  },
  {
    "unique_tag": "shack_interior_0_4_0",
    "data": {
      "name": "Inside Ruined Shack",
      "description": "The interior of the shack is damp and filled with cobwebs. Most of the roof has caved in, offering a view of the sky. A tattered mat lies in one corner.",
      "x": 0, "y": 4, "z": 0,
      "room_type": "standard",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3"
    }
  },
  {
    "unique_tag": "thorn_thicket_west_m1_3_0",
    "data": {
      "name": "Thorny Thicket (West)",
      "description": "An almost impassable thicket of thorny vines blocks easy passage further west. You can hear buzzing insects.",
      "x": -1, "y": 3, "z": 0,
      "room_type": "standard",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3"
    }
  },
  {
    "unique_tag": "thorn_thicket_east_1_3_0",
    "data": {
      "name": "Thorny Thicket (East)",
      "description": "The thorny vines are particularly dense here, scraping at your clothes as you push through.",
      "x": 1, "y": 3, "z": 0,
      "room_type": "standard",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3"
    }
  },
  {
    "unique_tag": "rat_infested_cellar_1_4_0",
    "data": {
      "name": "Rat-Infested Cellar Entrance",
      "description": "A collapsed section of ground near the eastern thicket reveals a dark opening leading down into what might be a cellar. It stinks of vermin. [DYNAMIC_EXIT_EAST_CELLAR_DOOR]",
      "x": 1, "y": 4, "z": 0,
      "room_type": "dungeon_entrance",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3"
    }
  },
  {
    "unique_tag": "deep_cellar_main_2_4_0",
    "data": {
      "name": "Deep Cellar - Main Chamber",
      "description": "This small, damp cellar chamber is filled with refuse and the gnawed bones of small animals. The air is heavy with the stench of rats.",
      "x": 2, "y": 4, "z": 0,
      "room_type": "standard",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3"
    }
  },
  {
    "unique_tag": "deep_cellar_nest_2_5_0",
    "data": {
      "name": "Deep Cellar - Rat Nest",
      "description": "A particularly rank corner of the cellar, piled high with shredded cloth and filth. This is clearly a nest for something unpleasant.",
      "x": 2, "y": 5, "z": 0,
      "room_type": "standard",
      "zone_name": "The Outskirts",
      "zone_level_range": "1-3"
    }
  },
  {
    "unique_tag": "goblin_lookout_0_5_0",
    "data": {
      "name": "Goblin Lookout Point",
      "description": "North of the ruined shack, the path climbs slightly to a rocky outcrop. Crude goblin symbols are daubed on the rocks.",
      "x": 0, "y": 5, "z": 0,
      "room_type": "standard",
      "zone_name": "Goblin Pass",
      "zone_level_range": "3-5"
    }
  },
  {
    "unique_tag": "goblin_trail_m1_5_0",
    "data": {
      "name": "Goblin Trail West",
      "description": "A crudely marked trail leads west from the lookout, littered with discarded bones and scraps of leather.",
      "x": -1, "y": 5, "z": 0,
      "room_type": "standard",
      "zone_name": "Goblin Pass",
      "zone_level_range": "3-5"
    }
  },
  {
    "unique_tag": "goblin_camp_m2_5_0",
    "data": {
      "name": "Small Goblin Camp",
      "description": "A small, messy encampment is hidden here, with a poorly tended fire pit and a few crude hide tents. [DYNAMIC_EXIT_WEST_CAVE]",
      "x": -2, "y": 5, "z": 0,
      "room_type": "standard",
      "zone_name": "Goblin Pass",
      "zone_level_range": "3-5"
    }
  },
  {
    "unique_tag": "goblin_cave_entrance_m3_5_0",
    "data": {
      "name": "Goblin Cave Entrance",
      "description": "A narrow opening in the rocks, reeking of goblin filth, leads into a dark cave.",
      "x": -3, "y": 5, "z": 0,
      "room_type": "dungeon_entrance",
      "zone_name": "Goblin Pass",
      "zone_level_range": "3-5"
    }
  },
  {
    "unique_tag": "goblin_cave_storage_m3_6_0",
    "data": {
      "name": "Goblin Cave - Storage Nook",
      "description": "This small nook in the cave is piled with stolen junk and rotting food.",
      "x": -3, "y": 6, "z": 0,
      "room_type": "standard",
      "zone_name": "Goblin Pass",
      "zone_level_range": "3-5"
    }
  },
  {
    "unique_tag": "path_to_woods_0_6_0",
    "data": {
      "name": "Path to the Whispering Woods",
      "description": "The overgrown path continues north from the goblin lookout, gradually becoming overshadowed by larger, darker trees. The air grows cooler.",
      "x": 0, "y": 6, "z": 0,
      "room_type": "standard",
      "zone_name": "Goblin Pass",
      "zone_level_range": "3-5"
    }
  },
  {
    "unique_tag": "woods_edge_0_7_0",
    "data": {
      "name": "Edge of the Whispering Woods",
      "description": "You stand at the verge of a dark and ancient forest. Twisted trees loom, their branches like skeletal fingers. The sounds of the outskirts fade behind you.",
      "x": 0, "y": 7, "z": 0,
      "room_type": "standard",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "woods_gloomy_trail_0_8_0",
    "data": {
      "name": "Gloomy Trail",
      "description": "A barely discernible trail winds deeper into the woods. Sunlight struggles to penetrate the thick canopy above.",
      "x": 0, "y": 8, "z": 0,
      "room_type": "standard",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "woods_wolf_den_clearing_m1_8_0",
    "data": {
      "name": "Wolf Den Clearing",
      "description": "The trail opens into a small clearing. The ground is paw-printed, and a low growl emanates from a shadowed cleft in some rocks to the west.",
      "x": -1, "y": 8, "z": 0,
      "room_type": "standard",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "wolf_den_cave_m2_8_0",
    "data": {
      "name": "Inside the Wolf Den",
      "description": "A shallow cave, littered with bones and smelling strongly of wet fur. This is undoubtedly a wolf den.",
      "x": -2, "y": 8, "z": 0,
      "room_type": "standard",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "woods_ancient_oak_0_9_0",
    "data": {
      "name": "Ancient Oak",
      "description": "A colossal, ancient oak tree dominates this part of the woods. Its gnarled branches are draped with moss, and its roots heave up the earth.",
      "x": 0, "y": 9, "z": 0,
      "room_type": "standard",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "woods_spider_lair_1_9_0",
    "data": {
      "name": "Spider-Infested Grove",
      "description": "Thick, sticky webs hang between the trees here, glistening with dew. The silence is broken only by the rustling of something large in the higher branches.",
      "x": 1, "y": 9, "z": 0,
      "room_type": "standard",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "woods_broodmother_web_1_10_0",
    "data": {
      "name": "Broodmother's Web",
      "description": "A massive, funnel-shaped web fills a hollow between several large trees. The air is thick with the smell of decay and the chitinous clicking of many legs.",
      "x": 1, "y": 10, "z": 0,
      "room_type": "standard",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "woods_hidden_shrine_m1_9_0",
    "data": {
      "name": "Hidden Forest Shrine",
      "description": "Tucked away behind a curtain of ivy to the west of the ancient oak, you find a small, moss-covered stone shrine, seemingly forgotten by time. [DYNAMIC_EXIT_WEST_SHRINE_NICHE]",
      "x": -1, "y": 9, "z": 0,
      "room_type": "sanctuary",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "woods_shrine_niche_m2_9_0",
    "data": {
      "name": "Shrine Niche",
      "description": "A small alcove within the hidden shrine. A faint, almost imperceptible humming emanates from the stone.",
      "x": -2, "y": 9, "z": 0,
      "room_type": "puzzle",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "woods_path_to_mine_0_10_0",
    "data": {
      "name": "Path to the Old Mine",
      "description": "The trail grows rockier and begins to ascend slightly, heading towards a cliff face visible through the trees to the north.",
      "x": 0, "y": 10, "z": 0,
      "room_type": "standard",
      "zone_name": "Whispering Woods",
      "zone_level_range": "5-8"
    }
  },
  {
    "unique_tag": "mine_entrance_0_11_0",
    "data": {
      "name": "Old Mine Entrance",
      "description": "A dark, foreboding mine entrance gapes in the cliffside. Rotting timbers support the opening, and the air smells of damp earth and something metallic. [DYNAMIC_EXIT_NORTH_MINE_GATE]",
      "x": 0, "y": 11, "z": 0,
      "room_type": "dungeon_entrance",
      "zone_name": "The Old Mine",
      "zone_level_range": "8-12"
    }
  },
  {
    "unique_tag": "mine_entry_tunnel_0_12_0",
    "data": {
      "name": "Mine Entry Tunnel",
      "description": "The tunnel is dark and supported by creaking wooden beams. Water drips from the ceiling, and the sound of skittering echoes from deeper within.",
      "x": 0, "y": 12, "z": 0,
      "room_type": "standard",
      "zone_name": "The Old Mine",
      "zone_level_range": "8-12"
    }
  },
  {
    "unique_tag": "mine_foremans_office_m1_12_0",
    "data": {
      "name": "Foreman's Office (Ruined)",
      "description": "A small, caved-in chamber off the main tunnel. A rickety desk and a broken chair are all that remain of what might have been an office.",
      "x": -1, "y": 12, "z": 0,
      "room_type": "standard",
      "zone_name": "The Old Mine",
      "zone_level_range": "8-12"
    }
  },
  {
    "unique_tag": "mine_shaft_junction_0_13_0",
    "data": {
      "name": "Mine Shaft Junction",
      "description": "The tunnel opens into a larger area where several mine shafts converge. Most are collapsed, but one leads east, and another continues deeper north.",
      "x": 0, "y": 13, "z": 0,
      "room_type": "standard",
      "zone_name": "The Old Mine",
      "zone_level_range": "8-12"
    }
  },
  {
    "unique_tag": "mine_east_vein_1_13_0",
    "data": {
      "name": "East Vein Tunnel",
      "description": "This narrow tunnel follows a vein of some glittering, unfamiliar ore. The air is stale.",
      "x": 1, "y": 13, "z": 0,
      "room_type": "standard",
      "zone_name": "The Old Mine",
      "zone_level_range": "8-12"
    }
  },
  {
    "unique_tag": "mine_east_dead_end_2_13_0",
    "data": {
      "name": "East Vein - Dead End",
      "description": "The tunnel ends abruptly in a rockfall. It seems this vein was worked out or abandoned.",
      "x": 2, "y": 13, "z": 0,
      "room_type": "standard",
      "zone_name": "The Old Mine",
      "zone_level_range": "8-12"
    }
  },
  {
    "unique_tag": "mine_deep_shaft_0_14_0",
    "data": {
      "name": "Deep Mine Shaft",
      "description": "This shaft descends steeply into darkness. The air is noticeably colder, and an unnerving silence hangs in the air.",
      "x": 0, "y": 14, "z": 0,
      "room_type": "standard",
      "zone_name": "The Old Mine",
      "zone_level_range": "8-12"
    }
  },
  {
    "unique_tag": "mine_undead_chamber_0_15_0",
    "data": {
      "name": "Undead Miners' Chamber",
      "description": "This large cavern is littered with broken mining tools and the skeletal remains of miners, still clad in tattered work clothes. A chilling aura pervades the room.",
      "x": 0, "y": 15, "z": 0,
      "room_type": "standard",
      "zone_name": "The Old Mine",
      "zone_level_range": "8-12"
    }
  },
  {
    "unique_tag": "bridge_to_sanctum_0_16_0",
    "data": {
      "name": "Crumbling Stone Bridge",
      "description": "North of the deepest part of the mine, a natural chasm is spanned by a dangerously weathered stone bridge. Far below, you can hear the faint sound of rushing water. The air feels charged.",
      "x": 0, "y": 16, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_gatehouse_0_17_0",
    "data": {
      "name": "Sanctum Gatehouse",
      "description": "Beyond the bridge stands a formidable stone gatehouse, its portcullis rusted shut. Strange symbols are carved above the archway. [DYNAMIC_EXIT_NORTH_SANCTUM_PORTCULLIS]",
      "x": 0, "y": 17, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_courtyard_0_18_0",
    "data": {
      "name": "Corrupted Sanctum Courtyard",
      "description": "The flagstones of this courtyard are cracked and overgrown with sickly weeds. Defaced statues stand in alcoves, and an oppressive atmosphere hangs heavy.",
      "x": 0, "y": 18, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_west_wing_m1_18_0",
    "data": {
      "name": "Sanctum - West Wing Antechamber",
      "description": "A once-grand antechamber, now fallen into ruin. Tapestries hang in tatters, and dust coats every surface.",
      "x": -1, "y": 18, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_library_m2_18_0",
    "data": {
      "name": "Sanctum Library (Desecrated)",
      "description": "Bookshelves line the walls, their contents mostly burned or torn. Pages skitter across the floor in the draft. A large, rune-covered lectern stands in the center. [DYNAMIC_EXIT_WEST_SECRET_PASSAGE]",
      "x": -2, "y": 18, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_secret_study_m3_18_0",
    "data": {
      "name": "Sanctum Secret Study",
      "description": "A hidden study, remarkably preserved. Books on dark arts and forbidden lore line the shelves. A single, guttering candle illuminates a desk.",
      "x": -3, "y": 18, "z": 0,
      "room_type": "puzzle",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_east_wing_1_18_0",
    "data": {
      "name": "Sanctum - East Wing Hallway",
      "description": "This hallway echoes with an unsettling silence. Doors leading off it are mostly broken or hanging from single hinges.",
      "x": 1, "y": 18, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_barracks_1_19_0",
    "data": {
      "name": "Sanctum Barracks (Haunted)",
      "description": "Rotting bunks line the walls of this former barracks. The air is icy cold, and a palpable sense of dread fills the room.",
      "x": 1, "y": 19, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_main_hall_0_19_0",
    "data": {
      "name": "Sanctum Main Hall",
      "description": "A vast, domed hall that must have once been breathtaking. Now, rubble litters the floor, and ominous shadows dance in the dim light filtering from cracks in the dome.",
      "x": 0, "y": 19, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_altar_chamber_0_20_0",
    "data": {
      "name": "Sanctum Altar Chamber",
      "description": "At the northernmost end of the sanctum lies a raised dais upon which a massive, dark stone altar stands. The air crackles with a malevolent energy. [DYNAMIC_EXIT_NORTH_ALTAR_BARRIER]",
      "x": 0, "y": 20, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "sanctum_inner_sanctum_0_21_0",
    "data": {
      "name": "Inner Sanctum",
      "description": "Beyond the altar, this chamber hums with concentrated dark power. Disturbing runes cover every surface, glowing faintly.",
      "x": 0, "y": 21, "z": 0,
      "room_type": "standard",
      "zone_name": "The Corrupted Sanctum",
      "zone_level_range": "12-15"
    }
  },
  {
    "unique_tag": "south_corridor_0_m1_0",
    "data": {
      "name": "South Maintenance Tunnel",
      "description": "Dimly lit and smelling faintly of burnt coffee. A heavy iron door blocks the way further south. Panel S-1. [DYNAMIC_EXIT_SOUTH_ARCHIVE]",
      "x": 0, "y": -1, "z": 0,
      "room_type": "standard",
      "zone_name": "Central Processing",
      "zone_level_range": "1-2"
    }
  },
  {
    "unique_tag": "deep_archive_0_m2_0",
    "data": {
      "name": "Deep Archive Sector 42",
      "description": "Ancient, whirring machinery fills this chamber. It feels important. Panel S-2. [DYNAMIC_EXIT_NORTH_ARCHIVE]",
      "x": 0, "y": -2, "z": 0,
      "room_type": "puzzle",
      "zone_name": "Central Processing",
      "zone_level_range": "1-2"
    }
  },
  {
    "unique_tag": "west_corridor_m1_0_0",
    "data": {
      "name": "West Logic Gate Array",
      "description": "To the west, a series of humming conduits. Panel W-1.",
      "x": -1, "y": 0, "z": 0,
      "room_type": "standard",
      "zone_name": "Central Processing",
      "zone_level_range": "1-2"
    }
  },
  {
    "unique_tag": "weapon_shop_m2_0_0",
    "data": {
      "name": "Bjorne's Brutal Blades",
      "description": "The air in this chamber is thick with the smell of coal smoke and hot metal. Racks of swords, axes, and maces line the walls, each one gleaming with a dangerous edge. A massive anvil and a smoldering forge dominate the center of the room.",
      "x": -2, "y": 0, "z": 0,
      "room_type": "shop",
      "zone_name": "Central Processing",
      "zone_level_range": "1-2",
      "npc_placements": ["weapon_smith_bjorne"]
    }
  },
  {
    "unique_tag": "armor_shop_m2_m1_0",
    "data": {
      "name": "The Silent Stitch",
      "description": "Unlike the noisy forge next door, this room is quiet and orderly. Mannequins wearing various pieces of leather and studded armor stand in silent judgment. Rolls of tanned hide and spools of thick waxed thread are neatly arranged on a large workbench.",
      "x": -2, "y": -1, "z": 0,
      "room_type": "shop",
      "zone_name": "Central Processing",
      "zone_level_range": "1-2",
      "npc_placements": ["armor_smith_elara"]
    }
  }
]
--- END OF FILE backend/app/seeds/rooms_z0.json ---

--- START OF FILE backend/app/seeds/exits_z0.json ---
[
  {
    "source_tag": "central_hub_0_0_0", "direction": "east", "target_tag": "east_storage_1_0_0",
    "details": {
      "is_locked": true, "lock_id_tag": "cpu_east_door_lock",
      "description_when_locked": "A heavy blast door to the east is sealed tight. The nearby lever might control it.",
      "description_when_unlocked": "The heavy blast door to the east stands open."
    }
  },
  {
    "source_tag": "east_storage_1_0_0", "direction": "west", "target_tag": "central_hub_0_0_0",
    "details": {
      "is_locked": true, "lock_id_tag": "cpu_east_door_lock",
      "description_when_locked": "The blast door to the west is sealed. It seems to be controlled from the other side.",
      "description_when_unlocked": "The blast door to the west is open."
    }
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "north", "target_tag": "outskirts_gate_0_1_0", "details": {}
  },
  {
    "source_tag": "outskirts_gate_0_1_0", "direction": "south", "target_tag": "central_hub_0_0_0", "details": {}
  },
  {
    "source_tag": "outskirts_gate_0_1_0", "direction": "north", "target_tag": "beginner_path_0_2_0", "details": {}
  },
  {
    "source_tag": "beginner_path_0_2_0", "direction": "south", "target_tag": "outskirts_gate_0_1_0", "details": {}
  },
  {
    "source_tag": "beginner_path_0_2_0", "direction": "north", "target_tag": "ruined_shack_clearing_0_3_0", "details": {}
  },
  {
    "source_tag": "ruined_shack_clearing_0_3_0", "direction": "south", "target_tag": "beginner_path_0_2_0", "details": {}
  },
  {
    "source_tag": "ruined_shack_clearing_0_3_0", "direction": "north", "target_tag": "shack_interior_0_4_0", "details": {}
  },
  {
    "source_tag": "shack_interior_0_4_0", "direction": "south", "target_tag": "ruined_shack_clearing_0_3_0", "details": {}
  },
  {
    "source_tag": "ruined_shack_clearing_0_3_0", "direction": "west", "target_tag": "thorn_thicket_west_m1_3_0", "details": {}
  },
  {
    "source_tag": "thorn_thicket_west_m1_3_0", "direction": "east", "target_tag": "ruined_shack_clearing_0_3_0", "details": {}
  },
  {
    "source_tag": "ruined_shack_clearing_0_3_0", "direction": "east", "target_tag": "thorn_thicket_east_1_3_0", "details": {}
  },
  {
    "source_tag": "thorn_thicket_east_1_3_0", "direction": "west", "target_tag": "ruined_shack_clearing_0_3_0", "details": {}
  },
  {
    "source_tag": "thorn_thicket_east_1_3_0", "direction": "north", "target_tag": "rat_infested_cellar_1_4_0", "details": {}
  },
  {
    "source_tag": "rat_infested_cellar_1_4_0", "direction": "south", "target_tag": "thorn_thicket_east_1_3_0", "details": {}
  },
  {
    "source_tag": "rat_infested_cellar_1_4_0", "direction": "east", "target_tag": "deep_cellar_main_2_4_0",
    "details": { "is_locked": false, "lock_id_tag": "cellar_door_east",
                 "description_when_locked": "A rickety wooden door to the east is barred from the other side.",
                 "description_when_unlocked": "The rickety wooden door to the east is slightly ajar." }
  },
  {
    "source_tag": "deep_cellar_main_2_4_0", "direction": "west", "target_tag": "rat_infested_cellar_1_4_0",
    "details": { "is_locked": false, "lock_id_tag": "cellar_door_east",
                 "description_when_locked": "The wooden door to the west is barred.",
                 "description_when_unlocked": "The wooden door to the west stands open." }
  },
  {
    "source_tag": "deep_cellar_main_2_4_0", "direction": "north", "target_tag": "deep_cellar_nest_2_5_0", "details": {}
  },
  {
    "source_tag": "deep_cellar_nest_2_5_0", "direction": "south", "target_tag": "deep_cellar_main_2_4_0", "details": {}
  },
  {
    "source_tag": "shack_interior_0_4_0", "direction": "north", "target_tag": "goblin_lookout_0_5_0", "details": {}
  },
  {
    "source_tag": "goblin_lookout_0_5_0", "direction": "south", "target_tag": "shack_interior_0_4_0", "details": {}
  },
  {
    "source_tag": "goblin_lookout_0_5_0", "direction": "west", "target_tag": "goblin_trail_m1_5_0", "details": {}
  },
  {
    "source_tag": "goblin_trail_m1_5_0", "direction": "east", "target_tag": "goblin_lookout_0_5_0", "details": {}
  },
  {
    "source_tag": "goblin_trail_m1_5_0", "direction": "west", "target_tag": "goblin_camp_m2_5_0", "details": {}
  },
  {
    "source_tag": "goblin_camp_m2_5_0", "direction": "east", "target_tag": "goblin_trail_m1_5_0", "details": {}
  },
  {
    "source_tag": "goblin_camp_m2_5_0", "direction": "west", "target_tag": "goblin_cave_entrance_m3_5_0",
    "details": { "is_locked": true, "lock_id_tag": "goblin_cave_flap", "key_item_tag_opens": "crude_goblin_key",
                 "description_when_locked": "A grimy hide flap covers the cave entrance to the west, tied shut.",
                 "description_when_unlocked": "The hide flap to the west is open, revealing a dark cave." }
  },
  {
    "source_tag": "goblin_cave_entrance_m3_5_0", "direction": "east", "target_tag": "goblin_camp_m2_5_0",
    "details": { "is_locked": true, "lock_id_tag": "goblin_cave_flap",
                 "description_when_locked": "The hide flap to the east is secured from the other side.",
                 "description_when_unlocked": "The hide flap to the east is open." }
  },
  {
    "source_tag": "goblin_cave_entrance_m3_5_0", "direction": "north", "target_tag": "goblin_cave_storage_m3_6_0", "details": {}
  },
  {
    "source_tag": "goblin_cave_storage_m3_6_0", "direction": "south", "target_tag": "goblin_cave_entrance_m3_5_0", "details": {}
  },
  {
    "source_tag": "goblin_lookout_0_5_0", "direction": "north", "target_tag": "path_to_woods_0_6_0", "details": {}
  },
  {
    "source_tag": "path_to_woods_0_6_0", "direction": "south", "target_tag": "goblin_lookout_0_5_0", "details": {}
  },
  {
    "source_tag": "path_to_woods_0_6_0", "direction": "north", "target_tag": "woods_edge_0_7_0", "details": {}
  },
  {
    "source_tag": "woods_edge_0_7_0", "direction": "south", "target_tag": "path_to_woods_0_6_0", "details": {}
  },
  {
    "source_tag": "woods_edge_0_7_0", "direction": "north", "target_tag": "woods_gloomy_trail_0_8_0", "details": {}
  },
  {
    "source_tag": "woods_gloomy_trail_0_8_0", "direction": "south", "target_tag": "woods_edge_0_7_0", "details": {}
  },
  {
    "source_tag": "woods_gloomy_trail_0_8_0", "direction": "west", "target_tag": "woods_wolf_den_clearing_m1_8_0", "details": {}
  },
  {
    "source_tag": "woods_wolf_den_clearing_m1_8_0", "direction": "east", "target_tag": "woods_gloomy_trail_0_8_0", "details": {}
  },
  {
    "source_tag": "woods_wolf_den_clearing_m1_8_0", "direction": "west", "target_tag": "wolf_den_cave_m2_8_0", "details": {}
  },
  {
    "source_tag": "wolf_den_cave_m2_8_0", "direction": "east", "target_tag": "woods_wolf_den_clearing_m1_8_0", "details": {}
  },
  {
    "source_tag": "woods_gloomy_trail_0_8_0", "direction": "north", "target_tag": "woods_ancient_oak_0_9_0", "details": {}
  },
  {
    "source_tag": "woods_ancient_oak_0_9_0", "direction": "south", "target_tag": "woods_gloomy_trail_0_8_0", "details": {}
  },
  {
    "source_tag": "woods_ancient_oak_0_9_0", "direction": "east", "target_tag": "woods_spider_lair_1_9_0", "details": {}
  },
  {
    "source_tag": "woods_spider_lair_1_9_0", "direction": "west", "target_tag": "woods_ancient_oak_0_9_0", "details": {}
  },
  {
    "source_tag": "woods_spider_lair_1_9_0", "direction": "north", "target_tag": "woods_broodmother_web_1_10_0", "details": {}
  },
  {
    "source_tag": "woods_broodmother_web_1_10_0", "direction": "south", "target_tag": "woods_spider_lair_1_9_0", "details": {}
  },
  {
    "source_tag": "woods_ancient_oak_0_9_0", "direction": "west", "target_tag": "woods_hidden_shrine_m1_9_0", "details": {}
  },
  {
    "source_tag": "woods_hidden_shrine_m1_9_0", "direction": "east", "target_tag": "woods_ancient_oak_0_9_0", "details": {}
  },
  {
    "source_tag": "woods_hidden_shrine_m1_9_0", "direction": "west", "target_tag": "woods_shrine_niche_m2_9_0",
    "details": { "is_locked": true, "lock_id_tag": "shrine_niche_seal",
                 "description_when_locked": "A faint shimmering barrier blocks the niche to the west.",
                 "description_when_unlocked": "The shimmering barrier to the west has dissipated." }
  },
  {
    "source_tag": "woods_shrine_niche_m2_9_0", "direction": "east", "target_tag": "woods_hidden_shrine_m1_9_0",
    "details": { "is_locked": true, "lock_id_tag": "shrine_niche_seal",
                 "description_when_locked": "The way east is blocked by a shimmering barrier.",
                 "description_when_unlocked": "The way east is clear." }
  },
  {
    "source_tag": "woods_ancient_oak_0_9_0", "direction": "north", "target_tag": "woods_path_to_mine_0_10_0", "details": {}
  },
  {
    "source_tag": "woods_path_to_mine_0_10_0", "direction": "south", "target_tag": "woods_ancient_oak_0_9_0", "details": {}
  },
  {
    "source_tag": "woods_path_to_mine_0_10_0", "direction": "north", "target_tag": "mine_entrance_0_11_0", "details": {}
  },
  {
    "source_tag": "mine_entrance_0_11_0", "direction": "south", "target_tag": "woods_path_to_mine_0_10_0", "details": {}
  },
  {
    "source_tag": "mine_entrance_0_11_0", "direction": "north", "target_tag": "mine_entry_tunnel_0_12_0",
    "details": { "is_locked": true, "lock_id_tag": "mine_gate_lock", "key_item_tag_opens": "foremans_mine_key",
                 "description_when_locked": "A heavy iron gate, rusted shut, blocks the mine entrance to the north.",
                 "description_when_unlocked": "The rusted iron gate to the north stands ajar." }
  },
  {
    "source_tag": "mine_entry_tunnel_0_12_0", "direction": "south", "target_tag": "mine_entrance_0_11_0",
    "details": { "is_locked": true, "lock_id_tag": "mine_gate_lock",
                 "description_when_locked": "The iron gate to the south is locked from this side.",
                 "description_when_unlocked": "The iron gate to the south is open." }
  },
  {
    "source_tag": "mine_entry_tunnel_0_12_0", "direction": "west", "target_tag": "mine_foremans_office_m1_12_0", "details": {}
  },
  {
    "source_tag": "mine_foremans_office_m1_12_0", "direction": "east", "target_tag": "mine_entry_tunnel_0_12_0", "details": {}
  },
  {
    "source_tag": "mine_entry_tunnel_0_12_0", "direction": "north", "target_tag": "mine_shaft_junction_0_13_0", "details": {}
  },
  {
    "source_tag": "mine_shaft_junction_0_13_0", "direction": "south", "target_tag": "mine_entry_tunnel_0_12_0", "details": {}
  },
  {
    "source_tag": "mine_shaft_junction_0_13_0", "direction": "east", "target_tag": "mine_east_vein_1_13_0", "details": {}
  },
  {
    "source_tag": "mine_east_vein_1_13_0", "direction": "west", "target_tag": "mine_shaft_junction_0_13_0", "details": {}
  },
  {
    "source_tag": "mine_east_vein_1_13_0", "direction": "east", "target_tag": "mine_east_dead_end_2_13_0", "details": {}
  },
  {
    "source_tag": "mine_east_dead_end_2_13_0", "direction": "west", "target_tag": "mine_east_vein_1_13_0", "details": {}
  },
  {
    "source_tag": "mine_shaft_junction_0_13_0", "direction": "north", "target_tag": "mine_deep_shaft_0_14_0", "details": {}
  },
  {
    "source_tag": "mine_deep_shaft_0_14_0", "direction": "south", "target_tag": "mine_shaft_junction_0_13_0", "details": {}
  },
  {
    "source_tag": "mine_deep_shaft_0_14_0", "direction": "north", "target_tag": "mine_undead_chamber_0_15_0", "details": {}
  },
  {
    "source_tag": "mine_undead_chamber_0_15_0", "direction": "south", "target_tag": "mine_deep_shaft_0_14_0", "details": {}
  },
  {
    "source_tag": "mine_undead_chamber_0_15_0", "direction": "north", "target_tag": "bridge_to_sanctum_0_16_0", "details": {}
  },
  {
    "source_tag": "bridge_to_sanctum_0_16_0", "direction": "south", "target_tag": "mine_undead_chamber_0_15_0", "details": {}
  },
  {
    "source_tag": "bridge_to_sanctum_0_16_0", "direction": "north", "target_tag": "sanctum_gatehouse_0_17_0", "details": {}
  },
  {
    "source_tag": "sanctum_gatehouse_0_17_0", "direction": "south", "target_tag": "bridge_to_sanctum_0_16_0", "details": {}
  },
  {
    "source_tag": "sanctum_gatehouse_0_17_0", "direction": "north", "target_tag": "sanctum_courtyard_0_18_0",
    "details": { "is_locked": true, "lock_id_tag": "sanctum_portcullis_lock", "key_item_tag_opens": "ornate_sanctum_key",
                 "description_when_locked": "A massive iron portcullis blocks the way north. It looks incredibly heavy.",
                 "description_when_unlocked": "The massive iron portcullis to the north has been raised." }
  },
  {
    "source_tag": "sanctum_courtyard_0_18_0", "direction": "south", "target_tag": "sanctum_gatehouse_0_17_0",
    "details": { "is_locked": true, "lock_id_tag": "sanctum_portcullis_lock",
                 "description_when_locked": "The portcullis to the south is down, blocking the way.",
                 "description_when_unlocked": "The portcullis to the south is raised." }
  },
  {
    "source_tag": "sanctum_courtyard_0_18_0", "direction": "west", "target_tag": "sanctum_west_wing_m1_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_west_wing_m1_18_0", "direction": "east", "target_tag": "sanctum_courtyard_0_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_west_wing_m1_18_0", "direction": "west", "target_tag": "sanctum_library_m2_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_library_m2_18_0", "direction": "east", "target_tag": "sanctum_west_wing_m1_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_library_m2_18_0", "direction": "west", "target_tag": "sanctum_secret_study_m3_18_0",
    "details": { "is_locked": true, "lock_id_tag": "library_secret_passage",
                 "description_when_locked": "One of the bookshelves to the west looks like it might move, but it's firmly in place.",
                 "description_when_unlocked": "A section of the western bookshelf has slid aside, revealing a passage."}
  },
  {
    "source_tag": "sanctum_secret_study_m3_18_0", "direction": "east", "target_tag": "sanctum_library_m2_18_0",
    "details": { "is_locked": true, "lock_id_tag": "library_secret_passage",
                 "description_when_locked": "The passage to the east is hidden behind a bookshelf.",
                 "description_when_unlocked": "The passage to the east is open."}
  },
  {
    "source_tag": "sanctum_courtyard_0_18_0", "direction": "east", "target_tag": "sanctum_east_wing_1_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_east_wing_1_18_0", "direction": "west", "target_tag": "sanctum_courtyard_0_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_east_wing_1_18_0", "direction": "north", "target_tag": "sanctum_barracks_1_19_0", "details": {}
  },
  {
    "source_tag": "sanctum_barracks_1_19_0", "direction": "south", "target_tag": "sanctum_east_wing_1_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_courtyard_0_18_0", "direction": "north", "target_tag": "sanctum_main_hall_0_19_0", "details": {}
  },
  {
    "source_tag": "sanctum_main_hall_0_19_0", "direction": "south", "target_tag": "sanctum_courtyard_0_18_0", "details": {}
  },
  {
    "source_tag": "sanctum_main_hall_0_19_0", "direction": "north", "target_tag": "sanctum_altar_chamber_0_20_0", "details": {}
  },
  {
    "source_tag": "sanctum_altar_chamber_0_20_0", "direction": "south", "target_tag": "sanctum_main_hall_0_19_0", "details": {}
  },
  {
    "source_tag": "sanctum_altar_chamber_0_20_0", "direction": "north", "target_tag": "sanctum_inner_sanctum_0_21_0",
    "details": { "is_locked": true, "lock_id_tag": "altar_barrier_seal",
                 "description_when_locked": "A crackling barrier of dark energy blocks passage further north beyond the altar.",
                 "description_when_unlocked": "The dark energy barrier to the north has faded." }
  },
  {
    "source_tag": "sanctum_inner_sanctum_0_21_0", "direction": "south", "target_tag": "sanctum_altar_chamber_0_20_0",
    "details": { "is_locked": true, "lock_id_tag": "altar_barrier_seal",
                 "description_when_locked": "The way south is blocked by a crackling energy barrier.",
                 "description_when_unlocked": "The way south is clear." }
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "south", "target_tag": "south_corridor_0_m1_0", "details": {}
  },
  {
    "source_tag": "south_corridor_0_m1_0", "direction": "north", "target_tag": "central_hub_0_0_0", "details": {}
  },
  {
    "source_tag": "south_corridor_0_m1_0", "direction": "south", "target_tag": "deep_archive_0_m2_0",
    "details": { "is_locked": true, "lock_id_tag": "deep_archive_key_lock", "key_item_tag_opens": "archive_key_alpha",
                 "description_when_locked": "A formidable iron door blocks passage south. It has a complex keyhole.",
                 "description_when_unlocked": "The formidable iron door to the south is unlocked.",
                 "skill_to_pick": {"skill_id_tag": "pick_lock_basic", "dc": 18} }
  },
  {
    "source_tag": "deep_archive_0_m2_0", "direction": "north", "target_tag": "south_corridor_0_m1_0",
    "details": { "is_locked": true, "lock_id_tag": "deep_archive_key_lock", "key_item_tag_opens": "archive_key_alpha",
                 "description_when_locked": "The iron door to the north is locked from this side too.",
                 "description_when_unlocked": "The iron door to the north is open.",
                 "skill_to_pick": {"skill_id_tag": "pick_lock_basic", "dc": 18} }
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "west", "target_tag": "west_corridor_m1_0_0", "details": {}
  },
  {
    "source_tag": "west_corridor_m1_0_0", "direction": "east", "target_tag": "central_hub_0_0_0", "details": {}
  },
  {
    "source_tag": "west_corridor_m1_0_0", "direction": "west", "target_tag": "weapon_shop_m2_0_0",
    "details": {}
  },
  {
    "source_tag": "weapon_shop_m2_0_0", "direction": "east", "target_tag": "west_corridor_m1_0_0",
    "details": {}
  },
  {
    "source_tag": "weapon_shop_m2_0_0", "direction": "south", "target_tag": "armor_shop_m2_m1_0",
    "details": {}
  },
  {
    "source_tag": "armor_shop_m2_m1_0", "direction": "north", "target_tag": "weapon_shop_m2_0_0",
    "details": {}
  }
]
--- END OF FILE backend/app/seeds/exits_z0.json ---

--- START OF FILE backend/app/seeds/items.json ---

[
  {
    "name": "Rusty Sword",
    "description": "A short sword, pitted with rust. Better than nothing.",
    "item_type": "weapon",
    "slot": "main_hand",
    "properties": { "damage": "1d6", "damage_type": "slashing", "weapon_type": "sword" },
    "weight": 3.0, "value": 5, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Cloth Tunic",
    "description": "Simple, patched-up clothing.",
    "item_type": "armor", "slot": "torso",
    "properties": { "armor_class_bonus": 1 },
    "weight": 1.0, "value": 2, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Wooden Shield",
    "description": "A basic round wooden shield.",
    "item_type": "armor", "slot": "off_hand",
    "properties": { "armor_class_bonus": 2, "item_subtype": "shield" },
    "weight": 5.0, "value": 8, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Dagger",
    "description": "A small, easily concealable dagger.",
    "item_type": "weapon", "slot": "main_hand",
    "properties": { "damage": "1d4", "damage_type": "piercing", "weapon_type": "dagger", "finesse": true },
    "weight": 1.0, "value": 2, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Archive Key Alpha",
    "description": "A small, intricately carved metal key. Sector 42.",
    "item_type": "key", "slot": null,
    "properties": { "item_tag": "archive_key_alpha" },
    "weight": 0.1, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Basic Healing Draught",
    "description": "A common herbal brew that knits minor wounds.",
    "item_type": "potion", "slot": "consumable",
    "properties": { "effect_type": "heal_direct", "heal_amount_dice": "2d4", "heal_amount_bonus": 2, "cooldown_group": "potion", "cooldown_seconds": 30 },
    "weight": 0.5, "value": 25, "stackable": true, "max_stack_size": 5
  },
  {
    "name": "Lockpicks",
    "description": "A set of fine tools for bypassing simple locks.",
    "item_type": "tool", "slot": null,
    "properties": { "item_tag": "basic_lockpicks", "provides_skill_bonus": { "skill_id_tag": "pick_lock_basic", "bonus_amount": 2 } },
    "weight": 0.2, "value": 50, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Rat Tail",
    "description": "A long, scaly rat tail. Gross.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "rat_tail_junk" },
    "weight": 0.1, "value": 1, "stackable": true, "max_stack_size": 20
  },
  {
    "name": "Cracked Tooth",
    "description": "A small, cracked animal tooth.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "cracked_tooth_junk" },
    "weight": 0.05, "value": 1, "stackable": true, "max_stack_size": 50
  },
  {
    "name": "Beast Pelt (Small)",
    "description": "The pelt of a small, furry creature. Could be useful.",
    "item_type": "crafting_material", "slot": null,
    "properties": { "item_tag": "pelt_small_beast" },
    "weight": 0.5, "value": 3, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Animal Bone",
    "description": "A sturdy animal bone, perhaps from a leg or rib.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "animal_bone_generic" },
    "weight": 0.3, "value": 1, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Old Boot",
    "description": "A single, waterlogged leather boot. Seen better days.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "old_boot_junk" },
    "weight": 1.0, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Rusty Tin Can",
    "description": "An old, rusty tin can. Empty, of course.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "rusty_can_junk" },
    "weight": 0.2, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Goblin Ear",
    "description": "A severed goblin ear. A common, if gruesome, trophy.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "goblin_ear_trophy" },
    "weight": 0.1, "value": 2, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Crude Dagger Scrap",
    "description": "A piece of a crudely made goblin dagger, broken and useless.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "crude_dagger_scrap" },
    "weight": 0.3, "value": 1, "stackable": true, "max_stack_size": 5
  },
  {
    "name": "Torn Pouch",
    "description": "A small leather pouch, torn and empty.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "torn_pouch_junk" },
    "weight": 0.1, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Studded Leather Jerkin",
    "description": "A sturdy leather jerkin reinforced with metal studs. Offers decent protection without sacrificing too much mobility.",
    "item_type": "armor",
    "slot": "torso",
    "properties": { "armor_class_bonus": 3 },
    "weight": 8.0, "value": 45, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Greataxe",
    "description": "A massive, intimidating axe that requires two hands to wield. It sacrifices defense for pure, unadulterated chopping power.",
    "item_type": "weapon",
    "rarity": "uncommon",
    "slot": "main_hand",
    "properties": { "damage": "1d12", "damage_type": "slashing", "weapon_type": "axe", "two_handed": true },
    "weight": 10.0, "value": 30, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Sturdy Leather Boots",
    "description": "Well-worn leather boots that have seen many miles. They protect your precious little feet from the harsh ground.",
    "item_type": "armor",
    "slot": "feet",
    "properties": { "armor_class_bonus": 1 },
    "weight": 2.0, "value": 10, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Patched Leather Jerkin",
    "description": "A jerkin made of mismatched leather patches. Better than nothing, barely.",
    "item_type": "armor",
    "slot": "torso",
    "properties": { "armor_class_bonus": 2 },
    "weight": 6.0, "value": 15, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Cheap Locket",
    "description": "A tarnished, brass-colored locket. It's empty inside.",
    "item_type": "junk",
    "slot": null,
    "properties": { "item_tag": "cheap_locket_junk" },
    "weight": 0.1, "value": 3, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Bent Silver Spoon",
    "description": "A spoon that might have once been silver. It's now bent entirely out of shape.",
    "item_type": "junk",
    "slot": null,
    "properties": { "item_tag": "bent_spoon_junk" },
    "weight": 0.2, "value": 5, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Sharpened Bone",
    "description": "A long, sharpened piece of bone. It could serve as a crude shiv in a pinch.",
    "item_type": "weapon",
    "rarity": "common",
    "slot": "main_hand",
    "properties": { "damage": "1d4", "damage_type": "piercing", "weapon_type": "dagger", "finesse": true },
    "weight": 0.5, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "The Destructor",
    "description": "Point and Kill",
    "item_type": "weapon",
    "rarity": "legendary",
    "slot": "main_hand",
    "properties": { "damage": "10d99", "damage_type": "slashing", "weapon_type": "sword" },
    "weight": 1.0, "value": 500000, "stackable": false, "max_stack_size": 1
  }
]
--- END OF FILE backend/app/seeds/items.json ---

--- START OF FILE backend/app/seeds/mob_templates.json ---
[
  {
    "name": "Giant Rat",
    "is_boss": false,
    "description": "A rodent of unusual size, its fur matted and its eyes glinting with a feral hunger.",
    "level": 1,
    "base_health": 12,
    "base_mana": 0,
    "base_attack": "1d4",
    "base_defense": 11,
    "xp_value": 5,
    "attack_speed_secs": 2.5,
    "aggro_radius": 0,
    "roam_radius": 3,
    "dialogue_lines": ["*Squeak!*", "Hisss...", "*Chitters angrily*"],
    "faction_tags": ["vermin", "beast", "neutral_critter"],
    "loot_table_tags": ["vermin_common", "small_beast_parts", "tier1_trash"],
    "special_abilities": [],
    "currency_drop": { "c_min": 1, "c_max": 5, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Goblin Scout",
    "is_boss": false,
    "description": "A small, wiry goblin with shifty eyes and a crude spear. Looks like it would rather be anywhere else.",
    "level": 2,
    "base_health": 18,
    "base_mana": 5,
    "base_attack": "1d6",
    "base_defense": 13,
    "xp_value": 15,
    "attack_speed_secs": 3.0,
    "aggro_radius": 7,
    "roam_radius": 5,
    "dialogue_lines": ["Sneaky sneaky!", "You see shiny?", "Me take that!", "Yark! Intruder!"],
    "faction_tags": ["goblinoid", "scout", "hostile_humanoid"],
    "loot_table_tags": ["goblin_common", "crude_gear", "tier1_basic"],
    "special_abilities": ["evasive_maneuver_passive"],
    "currency_drop": { "c_min": 5, "c_max": 15, "s_chance": 10, "s_min": 1, "s_max": 2, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Security Drone MK I",
    "is_boss": false,
    "description": "A hovering metallic drone, its single optical sensor glowing ominously. It emits a low whirring sound.",
    "level": 3,
    "base_health": 25,
    "base_mana": 0,
    "base_attack": "2d4",
    "base_defense": 14,
    "xp_value": 25,
    "attack_speed_secs": 2.0,
    "aggro_radius": 10,
    "roam_radius": 0,
    "faction_tags": ["construct", "security", "neutral_guard"],
    "loot_table_tags": ["construct_parts_common", "tech_scrap", "tier1_tech"],
    "special_abilities": ["self_repair_protocol_passive", "arc_discharge_active"],
    "currency_drop": { "c_min": 0, "c_max": 0, "s_chance": 20, "s_min": 1, "s_max": 5, "g_chance": 5, "g_min": 1, "g_max": 1, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Forest Spider",
    "is_boss": false,
    "description": "A large, hairy spider with too many eyes. It scuttles menacingly.",
    "level": 2,
    "base_health": 15,
    "base_mana": 10,
    "base_attack": "1d6",
    "base_defense": 12,
    "xp_value": 12,
    "attack_speed_secs": 2.8,
    "aggro_radius": 6,
    "roam_radius": 4,
    "dialogue_lines": ["*Hiss*", "*Clicking mandibles*"],
    "faction_tags": ["arachnid", "beast", "hostile_critter"],
    "loot_table_tags": ["spider_parts", "tier1_beast_loot"],
    "special_abilities": ["poison_bite_active", "web_shot_utility"],
    "currency_drop": { "c_min": 2, "c_max": 8, "s_chance": 5, "s_min": 1, "s_max": 1, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Lost Soul",
    "is_boss": false,
    "description": "A shimmering, translucent figure that wails mournfully. It seems trapped between worlds.",
    "level": 4,
    "base_health": 30,
    "base_mana": 20,
    "base_attack": "1d8",
    "base_defense": 10,
    "xp_value": 35,
    "attack_speed_secs": 3.5,
    "aggro_radius": 5,
    "roam_radius": 2,
    "dialogue_lines": ["Why...?", "So cold...", "Lost... forever..."],
    "faction_tags": ["undead", "spirit", "neutral_ethereal"],
    "loot_table_tags": ["ectoplasm", "spirit_essence", "tier2_ethereal"],
    "special_abilities": ["ethereal_form_passive", "chilling_touch_active"],
    "properties": {"damage_type_override": "cold"},
    "currency_drop": { "c_min": 0, "c_max": 0, "s_chance": 15, "s_min": 3, "s_max": 7, "g_chance": 2, "g_min": 1, "g_max": 1, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Dust Devil",
    "is_boss": false,
    "description": "A small whirlwind of sand and grit, animated by some unknown force.",
    "level": 3,
    "base_health": 22,
    "base_mana": 0,
    "base_attack": "1d6",
    "base_defense": 15,
    "xp_value": 20,
    "attack_speed_secs": 2.2,
    "aggro_radius": 6,
    "roam_radius": 6,
    "dialogue_lines": ["*Whirls angrily*", "*Grinding noises*"],
    "faction_tags": ["elemental", "air_elemental", "neutral_elemental"],
    "loot_table_tags": ["elemental_mote_air", "tier1_elemental"],
    "special_abilities": ["sand_blast_active", "evasion_aura_passive"],
    "currency_drop": { "c_min": 10, "c_max": 25, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Bandit Thug",
    "is_boss": false,
    "description": "A burly human with a scarred face and a mean-looking club. Smells of stale ale and desperation.",
    "level": 4,
    "base_health": 35,
    "base_mana": 0,
    "base_attack": "1d8",
    "base_defense": 12,
    "xp_value": 30,
    "attack_speed_secs": 3.2,
    "aggro_radius": 8,
    "roam_radius": 3,
    "dialogue_lines": ["Your money or your life!", "Stand and deliver!", "Shouldn't have come here!"],
    "faction_tags": ["humanoid", "bandit", "hostile_humanoid"],
    "loot_table_tags": ["bandit_gear", "stolen_goods_common", "tier2_humanoid"],
    "special_abilities": ["intimidating_shout_active"],
    "currency_drop": { "c_min": 15, "c_max": 40, "s_chance": 25, "s_min": 2, "s_max": 5, "g_chance": 5, "g_min": 1, "g_max": 2, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Cave Bat Swarm",
    "is_boss": false,
    "description": "A disorienting cloud of screeching bats, their tiny teeth glinting.",
    "level": 3,
    "base_health": 20,
    "base_mana": 0,
    "base_attack": "1d3",
    "base_defense": 14,
    "xp_value": 18,
    "attack_speed_secs": 1.5,
    "aggro_radius": 5,
    "roam_radius": 2,
    "dialogue_lines": ["*High-pitched screeches*"],
    "faction_tags": ["beast", "swarm", "hostile_critter"],
    "loot_table_tags": ["bat_parts", "tier1_swarm_remains"],
    "special_abilities": ["disorienting_flutter_passive", "multi_attack_swarm_passive"],
    "properties": {"is_swarm": true, "swarm_attacks_count": 3},
    "currency_drop": { "c_min": 3, "c_max": 10, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Animated Armor",
    "is_boss": true,
    "description": "An empty suit of plate armor that moves with an eerie, clanking grace. No one appears to be inside.",
    "level": 5,
    "base_health": 45,
    "base_mana": 0,
    "base_attack": "1d10",
    "base_defense": 18,
    "xp_value": 50,
    "attack_speed_secs": 3.8,
    "aggro_radius": 6,
    "roam_radius": 0,
    "dialogue_lines": ["*Clank*", "*Scrape*", "*Whirr*"],
    "faction_tags": ["construct", "guardian", "neutral_guard"],
    "loot_table_tags": ["construct_parts_rare", "enchanted_metal_shards", "tier2_construct"],
    "special_abilities": ["damage_resistance_physical_passive", "magic_immunity_partial_passive"],
    "currency_drop": { "c_min": 0, "c_max": 0, "s_chance": 30, "s_min": 5, "s_max": 10, "g_chance": 10, "g_min": 1, "g_max": 3, "p_chance": 0, "p_min": 0, "p_max": 0 }
  },
  {
    "name": "Dire Wolf",
    "is_boss": true,
    "description": "A massive wolf with fur as dark as night and eyes that burn with a primal fury. Its growl is a promise of pain.",
    "level": 6,
    "base_health": 60,
    "base_mana": 10,
    "base_attack": "2d6",
    "base_defense": 15,
    "xp_value": 75,
    "attack_speed_secs": 3.0,
    "aggro_radius": 9,
    "roam_radius": 7,
    "dialogue_lines": ["*Snarl*", "*Deep Growl*", "*Howl*"],
    "faction_tags": ["beast", "canine", "predator", "hostile_alpha"],
    "loot_table_tags": ["dire_wolf_pelt", "large_beast_trophy", "tier3_beast_loot"],
    "special_abilities": ["pack_tactics_passive", "powerful_bite_active", "howl_buff_aura_active"],
    "currency_drop": { "c_min": 0, "c_max": 0, "s_chance": 5, "s_min": 10, "s_max": 20, "g_chance": 1, "g_min": 1, "g_max": 2, "p_chance": 0, "p_min": 0, "p_max": 0 }
  }
]
--- END OF FILE backend/app/seeds/mob_templates.json ---

--- START OF FILE backend/app/seeds/mob_spawn_definitions.json ---
[
  {
    "definition_name": "CPURatsMain",
    "room_coords": { "x": 0, "y": 0, "z": 0 },
    "mob_template_name": "Giant Rat",
    "quantity_min": 1,
    "quantity_max": 2,
    "respawn_delay_seconds": 60,
    "is_active": true,
    "roaming_behavior": {
      "type": "random_adjacent",
      "move_chance_percent": 30,
      "max_distance_from_spawn": 2
    }
  },
  {
    "definition_name": "GoblinCampThugs",
    "room_coords": { "x": -2, "y": 5, "z": 0 },
    "mob_template_name": "Bandit Thug",
    "quantity_min": 1,
    "quantity_max": 2,
    "respawn_delay_seconds": 240,
    "is_active": true,
    "roaming_behavior": null
  },
  {
    "definition_name": "GoblinLookoutScouts",
    "room_coords": { "x": 0, "y": 5, "z": 0 },
    "mob_template_name": "Goblin Scout",
    "quantity_min": 1,
    "quantity_max": 3,
    "respawn_delay_seconds": 120,
    "is_active": true,
    "roaming_behavior": {
      "type": "random_adjacent",
      "move_chance_percent": 25,
      "max_distance_from_spawn": 1
    }
  }
]
--- END OF FILE backend/app/seeds/mob_spawn_definitions.json ---

--- START OF FILE backend/app/seeds/loot_tables.json ---
{
  "vermin_common": [
    { "item_ref": "Rat Tail", "chance": 50, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Cracked Tooth", "chance": 25, "min_qty": 1, "max_qty": 1 }
  ],
  "small_beast_parts": [
    { "item_ref": "Beast Pelt (Small)", "chance": 30, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Animal Bone", "chance": 60, "min_qty": 1, "max_qty": 2 }
  ],
  "tier1_trash": [
    { "item_ref": "Old Boot", "chance": 10, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Rusty Tin Can", "chance": 15, "min_qty": 1, "max_qty": 1 }
  ],
  "goblin_common": [
    { "item_ref": "Goblin Ear", "chance": 40, "min_qty": 1, "max_qty": 2 },
    { "item_ref": "Crude Dagger Scrap", "chance": 20, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Torn Pouch", "chance": 30, "min_qty": 1, "max_qty": 1 }
  ],
  "crude_gear": [
    { "item_ref": "Rusty Sword", "chance": 5, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Dagger", "chance": 8, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Wooden Shield", "chance": 3, "min_qty": 1, "max_qty": 1 }
  ],
  "construct_parts_common": [
    { "item_ref": "Bent Gear", "chance": 50, "min_qty": 1, "max_qty": 3 },
    { "item_ref": "Frayed Wire", "chance": 40, "min_qty": 1, "max_qty": 2 },
    { "item_ref": "Small Lens", "chance": 15, "min_qty": 1, "max_qty": 1 }
  ],
  "tech_scrap": [
    { "item_ref": "Scrap Metal", "chance": 60, "min_qty": 1, "max_qty": 5 }
  ],
  "spider_parts": [
    { "item_ref": "Spider Silk Gland", "chance": 35, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Spider Fang", "chance": 25, "min_qty": 1, "max_qty": 2 }
  ],
  "tier1_beast_loot": [
    { "item_ref": "Beast Meat", "chance": 40, "min_qty": 1, "max_qty": 1 }
  ],
  "ectoplasm": [
    { "item_ref": "Ectoplasmic Residue", "chance": 70, "min_qty": 1, "max_qty": 3 }
  ],
  "spirit_essence": [
    { "item_ref": "Faint Spirit Essence", "chance": 25, "min_qty": 1, "max_qty": 1 }
  ],
  "tier2_ethereal": [
    { "item_ref": "Ghostly Shroud Scrap", "chance": 10, "min_qty": 1, "max_qty": 1 }
  ],
  "elemental_mote_air": [
    { "item_ref": "Whirling Dust Mote", "chance": 60, "min_qty": 1, "max_qty": 2 }
  ],
  "tier1_elemental": [
    { "item_ref": "Charged Sand", "chance": 20, "min_qty": 1, "max_qty": 1 }
  ],
  "stolen_goods_common": [
    { "item_ref": "Cheap Locket", "chance": 15, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Bent Silver Spoon", "chance": 20, "min_qty": 1, "max_qty": 1 }
  ],
  "tier2_humanoid": [
    { "item_ref": "Sharpened Bone", "chance": 30, "min_qty": 1, "max_qty": 1 }
  ],
  "bat_parts": [
    { "item_ref": "Bat Wing", "chance": 70, "min_qty": 1, "max_qty": 2 }
  ],
  "tier1_swarm_remains": [
    { "item_ref": "Guano", "chance": 20, "min_qty": 1, "max_qty": 3 }
  ],
  "construct_parts_rare": [
    { "item_ref": "Intact Servomotor", "chance": 10, "min_qty": 1, "max_qty": 1 }
  ],
  "enchanted_metal_shards": [
    { "item_ref": "Faintly Glowing Shard", "chance": 20, "min_qty": 1, "max_qty": 2 }
  ],
  "tier2_construct": [
    { "item_ref": "Polished Steel Plate", "chance": 5, "min_qty": 1, "max_qty": 1 }
  ],
  "dire_wolf_pelt": [
    { "item_ref": "Dire Wolf Pelt", "chance": 60, "min_qty": 1, "max_qty": 1 }
  ],
  "large_beast_trophy": [
    { "item_ref": "Large Wolf Fang", "chance": 30, "min_qty": 1, "max_qty": 1 }
  ],
  "tier3_beast_loot": [
    { "item_ref": "Prime Beast Meat", "chance": 15, "min_qty": 1, "max_qty": 1 }
  ],
  "bandit_gear": [
    { "item_ref": "Tarnished Ring", "chance": 5, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Studded Leather Jerkin", "chance": 5, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Patched Leather Jerkin", "chance": 10, "min_qty": 1, "max_qty": 1 }
  ]
}
--- END OF FILE backend/app/seeds/loot_tables.json ---

--- START OF FILE backend/app/seeds/skills.json ---
[
  {
    "skill_id_tag": "basic_punch",
    "name": "Basic Punch",
    "description": "A simple, untrained punch. It's better than harsh language. Usually.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {"mana_cost": 0, "damage_dice_override": "1d2", "attack_bonus_add": 0, "damage_bonus_add": 0, "uses_strength_for_bonus": true},
    "requirements_data": {"min_level": 1},
    "cooldown": 0
  },
  {
    "skill_id_tag": "power_attack_melee",
    "name": "Power Attack",
    "description": "A forceful melee attack that is harder to land but deals more damage with your equipped weapon.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 5, 
        "attack_roll_modifier": -2,
        "damage_modifier_flat": 3,
        "uses_equipped_weapon": true 
    },
    "requirements_data": {"min_level": 2, "required_stats": {"strength": 12}},
    "cooldown": 2
  },
  {
    "skill_id_tag": "pick_lock_basic",
    "name": "Pick Lock (Basic)",
    "description": "Attempt to pick a simple lock on a door or container. Requires lockpicks.",
    "skill_type": "UTILITY_OOC",
    "target_type": "DOOR", 
    "effects_data": {
        "check_attribute": "dexterity", 
        "base_dc_override_for_skill": null,
        "requires_item_tag_equipped_or_inventory": "basic_lockpicks"
    },
    "requirements_data": {"min_level": 1},
    "cooldown": 10 
  },
  {
    "skill_id_tag": "shield_bash_active",
    "name": "Shield Bash",
    "description": "Slam your shield into an opponent, potentially dazing them.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 8,
        "damage_dice_override": "1d4",
        "attack_bonus_add": 0,
        "damage_bonus_add_from_stat": "strength",
        "status_effect_apply": {"effect_tag": "dazed", "duration_rounds": 1, "chance_percent": 30},
        "requires_item_type_equipped": "shield"
    },
    "requirements_data": {"min_level": 3, "required_stats": {"strength": 13}},
    "cooldown": 3
  },
  {
    "skill_id_tag": "cleave_melee_active",
    "name": "Cleave",
    "description": "Swing your weapon in a wide arc, hitting an additional nearby enemy if one is present.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 10,
        "uses_equipped_weapon": true,
        "aoe_targets_additional": 1, 
        "aoe_shape": "arc_front"
    },
    "requirements_data": {"min_level": 5, "required_stats": {"strength": 14}},
    "cooldown": 4
  },
  {
    "skill_id_tag": "backstab_melee_active",
    "name": "Backstab",
    "description": "Exploit an opponent's distraction for a devastating attack. Requires stealth or target to be unaware.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 7,
        "damage_multiplier": 2.0, 
        "uses_equipped_weapon": true,
        "requires_condition": ["target_unaware", "user_stealthed"] 
    },
    "requirements_data": {"min_level": 2, "required_stats": {"dexterity": 13}},
    "cooldown": 1
  },
  {
    "skill_id_tag": "hide_in_shadows_utility",
    "name": "Hide in Shadows",
    "description": "Attempt to melt into the shadows, becoming harder to detect.",
    "skill_type": "UTILITY_OOC", 
    "target_type": "SELF",
    "effects_data": {
        "mana_cost": 5,
        "status_effect_apply": {"effect_tag": "stealthed", "duration_seconds": 60, "check_vs_perception_dc": 10}
    },
    "requirements_data": {"min_level": 4, "required_stats": {"dexterity": 14}},
    "cooldown": 30
  },
  {
    "skill_id_tag": "minor_heal_active",
    "name": "Minor Heal",
    "description": "A weak divine spell that mends minor wounds.",
    "skill_type": "COMBAT_ACTIVE", 
    "target_type": "FRIENDLY_CHAR_OR_SELF",
    "effects_data": {"mana_cost": 6, "heal_dice": "1d6", "heal_bonus_from_stat": "wisdom"},
    "requirements_data": {"min_level": 1},
    "cooldown": 1
  },
  {
    "skill_id_tag": "bless_buff_active",
    "name": "Bless",
    "description": "Invoke divine favor upon an ally, improving their combat prowess.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "FRIENDLY_CHAR_OR_SELF",
    "effects_data": {
        "mana_cost": 10,
        "status_effect_apply": {"effect_tag": "blessed_buff", "duration_rounds": 5, "bonuses": {"attack_roll": 1, "damage_roll": 1}}
    },
    "requirements_data": {"min_level": 1, "required_stats": {"wisdom": 12}},
    "cooldown": 0
  },
  {
    "skill_id_tag": "magic_missile_active",
    "name": "Magic Missile",
    "description": "Launch a missile of magical energy that unerringly strikes its target.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {"mana_cost": 4, "damage_dice_override": "1d4+1", "damage_type": "force", "always_hits": true},
    "requirements_data": {"min_level": 1},
    "cooldown": 0
  },
  {
    "skill_id_tag": "light_cantrip_utility",
    "name": "Light",
    "description": "Create a hovering light source that illuminates the area.",
    "skill_type": "UTILITY_OOC",
    "target_type": "SELF",
    "effects_data": {"mana_cost": 2, "status_effect_apply": {"effect_tag": "magical_light", "duration_seconds": 300}},
    "requirements_data": {"min_level": 1},
    "cooldown": 5
  },
  {
    "skill_id_tag": "first_aid_basic_utility",
    "name": "Basic First Aid",
    "description": "Apply basic bandaging to stop bleeding and slightly mend wounds outside of combat.",
    "skill_type": "UTILITY_OOC",
    "target_type": "SELF", 
    "effects_data": {"heal_amount_fixed": 5, "cooldown_seconds": 60, "requires_item_tag_consumed": "bandages_basic", "consume_chance": 75},
    "requirements_data": {"min_level": 2},
    "cooldown": 60
  }
]
--- END OF FILE backend/app/seeds/skills.json ---

--- START OF FILE backend/app/seeds/traits.json ---
[
  {
    "trait_id_tag": "tough_hide",
    "name": "Tough Hide",
    "description": "Your skin is naturally resilient, granting a small bonus to your Armor Class.",
    "trait_type": "PASSIVE", 
    "effects_data": {"ac_bonus_natural": 1}
  },
  {
    "trait_id_tag": "weapon_focus_swords_passive",
    "name": "Weapon Focus (Swords)",
    "description": "You are more accurate when wielding swords.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_bonus": {"condition_item_type_equipped": "sword", "attack_bonus": 1}}
  },
  {
    "trait_id_tag": "improved_vitality_passive",
    "name": "Improved Vitality",
    "description": "You gain more health points per level.",
    "trait_type": "PASSIVE",
    "effects_data": {"hp_gain_per_level_bonus": 1}
  },
  {
    "trait_id_tag": "nimble_fingers_passive",
    "name": "Nimble Fingers",
    "description": "You are adept at tasks requiring fine motor skills, such as picking locks.",
    "trait_type": "PASSIVE",
    "effects_data": {"skill_check_bonus": {"skill_type_tags": ["lockpicking", "disarm_trap"], "bonus_amount": 2}}
  },
  {
    "trait_id_tag": "opportunist_passive",
    "name": "Opportunist",
    "description": "You deal extra damage against distracted or flanked opponents.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_damage_bonus_flat": {"condition_target_status": ["dazed", "stunned", "flanked"], "damage_bonus": 2}}
  },
  {
    "trait_id_tag": "evasion_expert_passive",
    "name": "Evasion Expert",
    "description": "You are skilled at avoiding area attacks.",
    "trait_type": "PASSIVE",
    "effects_data": {"save_bonus_vs_aoe_type": {"effect_type_tags": ["area_effect", "trap_damage"], "bonus_amount": 2}}
  },
  {
    "trait_id_tag": "divine_fortitude_passive",
    "name": "Divine Fortitude",
    "description": "Your faith grants you enhanced resilience to negative effects.",
    "trait_type": "PASSIVE",
    "effects_data": {"save_bonus_vs_negative_status": {"status_tags": ["disease", "poison", "curse"], "bonus_amount": 1}}
  },
  {
    "trait_id_tag": "healing_touch_improved_passive",
    "name": "Improved Healing Touch",
    "description": "Your healing spells are more potent.",
    "trait_type": "PASSIVE",
    "effects_data": {"healing_spell_potency_bonus_flat": 2}
  },
  {
    "trait_id_tag": "divine_guidance_passive",
    "name": "Divine Guidance",
    "description": "Your connection to the divine enhances your wisdom.",
    "trait_type": "PASSIVE",
    "effects_data": {"stat_bonus_permanent": {"wisdom": 1}}
  },
  {
    "trait_id_tag": "arcane_attunement_passive",
    "name": "Arcane Attunement",
    "description": "You have a greater pool of magical energy.",
    "trait_type": "PASSIVE",
    "effects_data": {"max_mana_bonus_flat": 10}
  },
  {
    "trait_id_tag": "spell_penetration_minor_passive",
    "name": "Minor Spell Penetration",
    "description": "Your offensive spells are slightly more effective against resistant foes.",
    "trait_type": "PASSIVE",
    "effects_data": {"spell_penetration_value": 1}
  },
  {
    "trait_id_tag": "elemental_focus_fire_passive",
    "name": "Elemental Focus (Fire)",
    "description": "Your fire-based spells deal more damage.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_damage_bonus_percent": {"spell_damage_type": "fire", "bonus_percent": 10}}
  },
  {
    "trait_id_tag": "jack_of_all_trades_xp_bonus_passive",
    "name": "Jack of All Trades",
    "description": "You learn quickly from a variety of experiences, gaining a small bonus to all experience earned.",
    "trait_type": "PASSIVE",
    "effects_data": {"xp_gain_modifier_percent": 3}
  },
  {
    "trait_id_tag": "hardy_survivor_passive",
    "name": "Hardy Survivor",
    "description": "Years of adventuring have made you tougher, granting a small bonus to your maximum health.",
    "trait_type": "PASSIVE",
    "effects_data": {"max_health_bonus_flat": 5}
  }
]
--- END OF FILE backend/app/seeds/traits.json ---

--- START OF FILE backend/app/seeds/character_classes.json ---
[
  {
    "name": "Warrior",
    "description": "A stalwart fighter, skilled in the arts of melee combat and enduring hardship. Warriors excel at both dealing and absorbing damage on the front lines.",
    "base_stat_modifiers": {"strength": 2, "constitution": 1, "intelligence": -1, "charisma": -1},
    "starting_health_bonus": 10,
    "starting_mana_bonus": -5,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch"],
            "2": ["power_attack_melee"],
            "3": ["shield_bash_active"],
            "5": ["cleave_melee_active"]
        },
        "core_traits_by_level": {
            "1": ["tough_hide"],
            "2": ["weapon_focus_swords_passive"],
            "4": ["improved_vitality_passive"]
        }
    },
    "starting_equipment_refs": ["Rusty Sword", "Wooden Shield", "Cloth Tunic"],
    "playstyle_tags": ["melee", "tank", "physical_dps", "durable"],
    "stat_gains_per_level": {
        "hp": 6, 
        "mp": 1, 
        "base_attack_bonus": 0.75
    }
  },
  {
    "name": "Swindler",
    "description": "A cunning rogue who relies on wit, agility, and a sharp blade. Swindlers are masters of stealth, deception, and exploiting weaknesses.",
    "base_stat_modifiers": {"dexterity": 2, "luck": 1, "strength": -1, "wisdom": -1},
    "starting_health_bonus": -5,
    "starting_mana_bonus": 5,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch", "pick_lock_basic"],
            "2": ["backstab_melee_active"],
            "4": ["hide_in_shadows_utility"]
        },
        "core_traits_by_level": {
            "1": ["nimble_fingers_passive"],
            "3": ["opportunist_passive"],
            "5": ["evasion_expert_passive"]
        }
    },
    "starting_equipment_refs": ["Dagger", "Lockpicks", "Cloth Tunic"],
    "playstyle_tags": ["melee", "stealth", "utility", "debuff", "skill_monkey"],
    "stat_gains_per_level": {
        "hp": 4, 
        "mp": 2, 
        "base_attack_bonus": 0.5 
    }
  },
  {
    "name": "Acolyte",
    "description": "A devout follower of a divine power, wielding faith as both shield and weapon. Acolytes can mend wounds, bolster allies, and smite the unholy.",
    "base_stat_modifiers": {"wisdom": 2, "charisma": 1, "dexterity": -1, "strength": -1},
    "starting_health_bonus": 0,
    "starting_mana_bonus": 10,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["minor_heal_active", "bless_buff_active"],
            "3": ["smite_evil_active"],
            "5": ["turn_undead_active"]
        },
        "core_traits_by_level": {
            "1": ["divine_fortitude_passive"],
            "2": ["healing_touch_improved_passive"],
            "4": ["divine_guidance_passive"]
        }
    },
    "starting_equipment_refs": ["Wooden Mace", "Holy Symbol", "Cloth Robes"],
    "playstyle_tags": ["caster", "healer", "support", "divine", "anti_undead"],
    "stat_gains_per_level": {
        "hp": 3, 
        "mp": 3, 
        "base_attack_bonus": 0.33 
    }
  },
  {
    "name": "Hedge Wizard",
    "description": "A self-taught practitioner of the arcane arts, drawing power from raw talent and forbidden lore. Hedge Wizards command elemental forces and subtle illusions.",
    "base_stat_modifiers": {"intelligence": 2, "wisdom": 1, "constitution": -1, "strength": -1},
    "starting_health_bonus": -5,
    "starting_mana_bonus": 15,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["magic_missile_active", "light_cantrip_utility"],
            "3": ["fireball_small_active"],
            "5": ["invisibility_short_utility"]
        },
        "core_traits_by_level": {
            "1": ["arcane_attunement_passive"],
            "2": ["spell_penetration_minor_passive"],
            "4": ["elemental_focus_fire_passive"]
        }
    },
    "starting_equipment_refs": ["Quarterstaff", "Spellbook (Blank)", "Cloth Robes"],
    "playstyle_tags": ["caster", "arcane", "elemental_dps", "utility_magic", "glass_cannon"],
    "stat_gains_per_level": {
        "hp": 2, 
        "mp": 4, 
        "base_attack_bonus": 0.33
    }
  },
  {
    "name": "Adventurer",
    "description": "A jack-of-all-trades, master of none. Ready for anything, prepared for nothing. The path of the Adventurer is one of versatility and adaptability.",
    "base_stat_modifiers": {}, 
    "starting_health_bonus": 0,
    "starting_mana_bonus": 0,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch"],
            "2": ["first_aid_basic_utility"] 
        },
        "core_traits_by_level": {
            "1": ["jack_of_all_trades_xp_bonus_passive"],
            "3": ["hardy_survivor_passive"]
        }
    },
    "starting_equipment_refs": ["Dagger", "Cloth Tunic", "Basic Healing Draught"],
    "playstyle_tags": ["versatile", "generalist", "beginner_friendly"],
    "stat_gains_per_level": {
        "hp": 4, 
        "mp": 2, 
        "base_attack_bonus": 0.5
    }
  }
]
--- END OF FILE backend/app/seeds/character_classes.json ---

--- START OF FILE backend/app/seeds/npcs.json ---
[
  {
    "unique_name_tag": "weapon_smith_bjorne",
    "name": "Bjorne Ironhand",
    "description": "A stout dwarf with a beard that seems to have more soot and forge-scale than actual hair in it. He leans against a massive anvil, arms like tree trunks crossed over his chest, eyeing you with an expression that's perpetually unimpressed.",
    "npc_type": "merchant",
    "personality_prompt": "You are Bjorne Ironhand, a grumpy, pragmatic dwarf weaponsmith. You are a master of your craft and have no time for fools. Your dialogue should be short, gruff, and to the point. You often complain about the quality of modern work or the weakness of others. You might occasionally mention your wares, like your 'fine axes' or 'sturdy swords', but only as a statement of fact, not a sales pitch. Never be overly friendly or helpful. Keep your responses to 1-2 sentences. Address players in the room by their names sometimes.  It is fine to use profanity.  For some reason you dislike cats and make jokes about how horrible they are.",
    "dialogue_lines_static": [
      "Hmph. What do you want?",
      "You'll not find a finer axe this side of the mountain. Not that you'd know what to do with it.",
      "Another adventurer... All twigs and no stones.",
      "This hammer has seen better steel than you'll ever be.",
      "Buy something or get out. You're letting the heat out of the forge."
    ],
    "shop_inventory": [
      "Dagger",
      "Rusty Sword",
      "Sharpened Bone",
      "Greataxe"
    ]
  },
  {
    "unique_name_tag": "armor_smith_elara",
    "name": "Elara Silent-Stitch",
    "description": "A tall, focused woman with streaks of grey in her tightly bound hair. She works silently at a large leather-strewn table, her movements economical and precise. She acknowledges your presence with a brief, sharp nod before her eyes return to her work.",
    "npc_type": "merchant",
    "personality_prompt": "You are Elara, a meticulous and quiet master armorer. You speak only when necessary, and your words are practical and precise. You value function over all else. You might observe a player and comment on the poor state of their armor, or the way a particular piece of your own work would offer superior protection in a specific area. You never waste words. Keep your responses to 1-2 short, declarative sentences. You are observant, not rude.",
    "dialogue_lines_static": [
      "A good fit is as important as the steel.",
      "That buckle will not hold.",
      "Measure twice, cut once.",
      "What do you need protecting?",
      "Silence is a fine tool."
    ],
    "shop_inventory": [
      "Cloth Tunic",
      "Wooden Shield",
      "Patched Leather Jerkin",
      "Studded Leather Jerkin",
      "Sturdy Leather Boots"
    ]
  }
]
--- END OF FILE backend/app/seeds/npcs.json ---

--- START OF FILE frontend/src/state/gameStore.js ---
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { apiService } from '../services/apiService';

const initialState = {
  sessionState: 'LOGGED_OUT', // 'LOGGED_OUT', 'LOGGING_IN', 'CHAR_SELECT', 'IN_GAME'
  token: null,
  characterId: null,
  characterName: '',
  characterClass: '',
  characterLevel: 1,
  characterList: [],
  classTemplates: [],
  logLines: [
    '<span class="system-message-inline">Zustand brain is online. Please log in.</span>',
  ].reverse(),
  vitals: {
    hp: { current: 100, max: 100 },
    mp: { current: 50, max: 50 },
    xp: { current: 0, max: 100 },
  },
  mapData: null,
  currentRoomId: null,
  activeModal: null, // null, 'inventory', 'score', 'skills', 'traits'
  characterStats: null, // Will hold the full character data for the score sheet
  inventory: null, // Will hold the full inventory data
};


const useGameStore = create(
  immer((set, get) => ({
    ...initialState,

    // === ACTIONS ===

    setSessionState: (newState) => set({ sessionState: newState }),

    login: (token) => {
      // console.log('[gameStore] login action called with token:', token);
      set({
        token: token,
        sessionState: 'CHAR_SELECT', // Set both at the same time!
      });
    },
    startCharacterCreation: () => {
        set({ sessionState: 'CHAR_CREATE' });
    },

    setClassTemplates: (templates) => {
        set({ classTemplates: templates });
    },

    finishCharacterCreation: () => {
        // After creating a character, we go back to the selection screen
        // to see our new masterpiece in the list.
        set({ sessionState: 'CHAR_SELECT' });
    },
    fetchScoreAndOpenModal: async () => {
      const token = get().token;
      if (!token) return;
      // If the data is already there, just open the modal. No need to fetch again.
      if (get().characterStats) {
        set({ activeModal: 'score' });
        return;
      }
      try {
        const charDetails = await apiService.fetchCharacterDetails(token);
        set({ characterStats: charDetails, activeModal: 'score' });
      } catch (error) {
        console.error("Failed to fetch character details:", error);
        get().addLogLine("! Could not retrieve character score sheet.");
      }
    },

    setCharacterList: (characters) => set({ characterList: characters }),

    selectCharacter: (character) => {
      set({
        characterId: character.id,
        characterName: character.name,
        characterClass: character.class_name,
        characterLevel: character.level,
        currentRoomId: character.current_room_id,
        sessionState: 'IN_GAME',
        logLines: [`<span class="system-message-inline">Welcome, ${character.name}!</span>`].reverse()
      });
      get().fetchMapData();
    },

    addLogLine: (line) => {
      set((state) => {
        state.logLines.unshift(line);
      });
    },

    fetchMapData: async () => {
      const token = get().token;
      if (!token) return;

      try {
        const mapData = await apiService.fetchMapData(token);
        set({ mapData: mapData });
      } catch (error) {
        console.error("Failed to fetch map data:", error);
        get().addLogLine("! Failed to load map data.");
      }
    },

    setVitals: (vitalsUpdate) => {
      set((state) => {
        state.vitals = { ...state.vitals, ...vitalsUpdate };
      });
    },

    setInventory: (inventoryData) => {
      set({ inventory: inventoryData });
    },

    fetchInventoryAndOpenModal: async () => {
      const token = get().token;
      if (!token) return;
      // Same logic as score: if inventory data exists, just show it.
      if (get().inventory) {
        set({ activeModal: 'inventory' });
        return;
      }
      try {
        const inventoryData = await apiService.fetchInventory(token);
        // We now use our dedicated setter
        get().setInventory(inventoryData);
        set({ activeModal: 'inventory' });
      } catch (error) {
        console.error("Failed to fetch inventory:", error);
        get().addLogLine("! Could not retrieve inventory.");
      }
    },

    // --- NEW MODAL ACTIONS ---
    openModal: (modalName) => set({ activeModal: modalName }),

    closeModal: () => {
      const currentModal = get().activeModal;
      // If we're closing the inventory, nullify its data to ensure a fresh fetch next time.
      if (currentModal === 'inventory') {
        set({ activeModal: null, inventory: null });
      } else if (currentModal === 'score') {
        set({ activeModal: null, characterStats: null });
      } else {
        set({ activeModal: null });
      }
    },

    // --- FULLY IMPLEMENTED LOGOUT ---
    logout: () => {
      console.log("[gameStore] Logging out.");
      set((state) => {
        // We can't just reset to initialState because we want to keep the log message.
        // So we reset each property manually.
        state.sessionState = 'LOGGED_OUT';
        state.token = null;
        state.characterId = null;
        state.characterName = '';
        state.characterClass = '';
        state.characterLevel = 1;
        state.characterList = [];
        state.vitals = { hp: { current: 100, max: 100 }, mp: { current: 50, max: 50 }, xp: { current: 0, max: 100 } };
        state.mapData = null;
        state.currentRoomId = null;
        state.activeModal = null;
        state.characterStats = null;
        // Add a nice logout message to the top of the new log
        state.logLines = ['<span class="system-message-inline">You have been logged out. Please log in again.</span>'].reverse();
      });
    }

  }))
);

export default useGameStore;
--- END OF FILE frontend/src/state/gameStore.js ---

--- START OF FILE frontend/src/services/webSocketService.js ---
import useGameStore from '../state/gameStore';

// The same way we updated the API service
const WS_PROTOCOL = 'wss:';
const WS_HOST = 'llmud.trazen.org';

// Again, direct access to the store for non-React files
const { getState, setState } = useGameStore;

let socket = null;

const handleMessage = (event) => {
    try {
        const serverData = JSON.parse(event.data);
        console.log("WS RCV:", serverData); // Good for debugging

        // HERE IS THE MAGIC:
        // We'll call setState directly based on the message type.
        // This is like a mini-reducer.
        switch (serverData.type) {
            case "welcome_package":
            case "combat_update": // COMBINED and CORRECTED
                setState((state) => {
                    if (serverData.log && serverData.log.length > 0) {
                        state.logLines.unshift(...serverData.log.reverse());
                    }
                    if (serverData.character_vitals) {
                        // The correct, nested mapping logic
                        state.vitals.hp.current = serverData.character_vitals.current_hp;
                        state.vitals.hp.max = serverData.character_vitals.max_hp;
                        state.vitals.mp.current = serverData.character_vitals.current_mp;
                        state.vitals.mp.max = serverData.character_vitals.max_mp;
                        state.vitals.xp.current = serverData.character_vitals.current_xp;
                        // The welcome package uses next_level_xp, but other vitals updates might not.
                        // Let's be safe.
                        if (serverData.character_vitals.next_level_xp !== undefined) {
                            state.vitals.xp.max = serverData.character_vitals.next_level_xp;
                        }
                        state.characterLevel = serverData.character_vitals.level;
                    }
                    // Also update the current room if new data is provided
                    if (serverData.room_data) {
                        state.currentRoomId = serverData.room_data.id;
                        // If the z-level changed, we should probably fetch a new map
                        if (state.mapData && state.mapData.z_level !== serverData.room_data.z) {
                            // We'll call fetchMapData outside the 'set' call
                            state.needsNewMap = true; // Let's use a flag
                        }
                    }
                    if (serverData.type === "combat_update") {
                        state.isInCombat = !serverData.combat_over;
                    }
                });
                // Handle the side-effect of fetching a new map
                if (getState().needsNewMap) {
                    setState({ needsNewMap: false }); // Reset the flag
                    getState().fetchMapData();
                }
                break;

            case "vitals_update": // This one ALSO needs to be fixed!
                setState((state) => {
                    // Apply the same mapping logic here
                    state.vitals.hp.current = serverData.current_hp;
                    state.vitals.hp.max = serverData.max_hp;
                    state.vitals.mp.current = serverData.current_mp;
                    state.vitals.mp.max = serverData.max_mp;
                    if (serverData.next_level_xp !== undefined) {
                        state.vitals.xp.max = serverData.next_level_xp;
                    }
                    state.vitals.xp.current = serverData.current_xp;
                    state.characterLevel = serverData.level;
                });
                break;
            
            // ### THE NEW CASE FOR REAL-TIME INVENTORY ###
            case "inventory_update":
                console.log("[WS] Received real-time inventory_update.");
                setState(state => {
                    // This directly overwrites the inventory slice of the state.
                    // If the modal is open, React will re-render it automagically.
                    state.inventory = serverData.inventory_data;
                });
                break;

            // Add more cases here as needed...
            case "game_event":
            case "ooc_message":
                setState((state) => {
                    state.logLines.unshift(serverData.message);
                });
                break;

            default:
                console.warn("Unhandled WS message type:", serverData.type);
                break;
        }

    } catch (e) {
        console.error("Error parsing or handling WebSocket message:", e);
    }
};

const handleClose = (event) => {
    console.log("WebSocket connection closed:", event.code, event.reason);
    setState({ isInCombat: false }); // Always reset combat status on disconnect
    socket = null;
    // Optionally, add a log line to inform the user
    setState(state => {
        state.logLines.unshift(`! Game server connection closed. (Code: ${event.code} ${event.reason || ''})`.trim());
    })
};

const handleError = (event) => {
    console.error("WebSocket error observed:", event);
    setState(state => {
        state.logLines.unshift("! WebSocket connection error.");
    });
};

export const webSocketService = {
    connect: () => {
        const token = getState().token;
        const characterId = getState().characterId;

        if (!token || !characterId) {
            console.error("WS Connect: Missing token or character ID.");
            return;
        }

        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log("WebSocket already open.");
            return;
        }

        const wsUrl = `${WS_PROTOCOL}//${WS_HOST}/ws?token=${token}&character_id=${characterId}`;
        console.log("Attempting WS connection to:", wsUrl);

        socket = new WebSocket(wsUrl);

        socket.onopen = () => console.log("WebSocket connection established.");
        socket.onmessage = handleMessage;
        socket.onclose = handleClose;
        socket.onerror = handleError;
    },

    disconnect: () => {
        if (socket) {
            socket.close();
        }
    },

    sendMessage: (payload) => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(payload));
        } else {
            console.error("Cannot send WS message: Not connected.");
            // Optionally add a log line for the user
            setState(state => {
                state.logLines.unshift("! Cannot send command: Not connected to game server.");
            });
        }
    }
};
--- END OF FILE frontend/src/services/webSocketService.js ---

--- START OF FILE frontend/src/components/CommandInput.jsx ---
import React, { useState } from 'react';
import { webSocketService } from '../services/webSocketService';
import useGameStore from '../state/gameStore';

function CommandInput() {
  const [inputValue, setInputValue] = useState('');
  const addLogLine = useGameStore((state) => state.addLogLine);

  const handleInputChange = (event) => {
    setInputValue(event.target.value);
  };

  const handleKeyPress = async (event) => {
    if (event.key === 'Enter') {
      const command = inputValue.trim();
      setInputValue('');

      if (!command) return;

      // Echo the command to the log
      addLogLine(`> ${command}`);

      const [verb] = command.toLowerCase().split(' ');

      // --- CLIENT-SIDE COMMAND INTERCEPTION ---
      switch (verb) {
        case 'logout':
          useGameStore.getState().logout();
          return;
        case 'score':
        case 'sc':
          useGameStore.getState().fetchScoreAndOpenModal();
          return;
        case 'inventory':
        case 'i':
        case 'inv':
          useGameStore.getState().fetchInventoryAndOpenModal();
          return;
        default:
          // If it's not a client-side command, send it to the server.
          webSocketService.sendMessage({ type: "command", command_text: command });
          break;
      }
    }
  };

  return (
    <div id="input-prompt-line" className="terminal-input-line">
      <span id="prompt-text"> </span>
      <input
        type="text"
        id="commandInput"
        className="terminal-input"
        name="mud_command_line"
        autoFocus
        autoComplete="off"
        placeholder="Type command..."
        value={inputValue}
        onChange={handleInputChange}
        onKeyPress={handleKeyPress}
      />
    </div>
  );
}

export default CommandInput;
--- END OF FILE frontend/src/components/CommandInput.jsx ---

--- START OF FILE frontend/src/components/Inventory.jsx ---
import React from 'react';
import useGameStore from '../state/gameStore';
import ItemName from './ItemName'; // <-- IMPORT OUR NEW COMPONENT
import './Inventory.css'; // <-- Import its own CSS

function Inventory() {
  const inventory = useGameStore((state) => state.inventory);

  if (!inventory) {
    return <div>Loading inventory...</div>;
  }

  const { equipped_items, backpack_items, platinum, gold, silver, copper } = inventory;

  const formatSlotName = (slot) => {
    return slot.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  };

  return (
    <div className="inventory-container">
      <div className="inventory-section">
        <h4 className="inventory-header">Equipped</h4>
        <div className="equipped-items-grid">
          {Object.keys(equipped_items).length > 0 ? (
            Object.entries(equipped_items).map(([slot, item]) => (
              <div key={slot} className="inventory-item equipped">
                <span className="slot-name">{`[${formatSlotName(slot)}]`}</span>
                {/* ### THE CHANGE IS HERE ### */}
                <ItemName item={item.item} />
              </div>
            ))
          ) : (
            <p className="inventory-empty-message">Nothing equipped.</p>
          )}
        </div>
      </div>

      <div className="inventory-section">
        <h4 className="inventory-header">Backpack</h4>
        <div className="backpack-items-list">
          {backpack_items.length > 0 ? (
            backpack_items.map((item) => (
              <div key={item.id} className="inventory-item backpack">
                {/* ### AND HERE ### */}
                <ItemName item={item.item} />
                {item.quantity > 1 && (
                  <span className="item-quantity"> (x{item.quantity})</span>
                )}
              </div>
            ))
          ) : (
            <p className="inventory-empty-message">Your backpack is empty.</p>
          )}
        </div>
      </div>
      
      <div className="inventory-section currency-footer">
         <h4 className="inventory-header">Wealth</h4>
         <div className="currency-display">
            <span className="currency platinum">{platinum}p</span>
            <span className="currency gold">{gold}g</span>
            <span className="currency silver">{silver}s</span>
            <span className="currency copper">{copper}c</span>
         </div>
      </div>
    </div>
  );
}

export default Inventory;
--- END OF FILE frontend/src/components/Inventory.jsx ---

--- START OF FILE frontend/src/components/ItemName.jsx ---
import React from 'react';
import { Tooltip } from 'react-tooltip';
import './ItemName.css'; // Assuming you have a CSS file for styling

// Helper to format property names nicely (e.g., 'armor_class' -> 'Armor Class')
const formatPropertyName = (propName) => {
  return propName
    .replace(/_/g, ' ')
    .replace(/\b\w/g, (char) => char.toUpperCase());
};

// ### NEW HELPER FUNCTION ###
// This maps the item_type string from the backend to a specific emoji.
const getIconForItemType = (item) => {
    // Check the slot first for specific equipment types
    switch (item.slot) {
        case 'main_hand':
        case 'off_hand':
            if (item.item_type === 'weapon') return 'âš”ï¸';
            if (item.item_type === 'shield') return 'ðŸ›¡ï¸';
            return 'âœ‹'; // Generic hand for other stuff
        case 'head':
            return 'ðŸ‘‘';
        case 'torso':
            return 'ðŸ‘•';
        case 'legs':
            return 'ðŸ‘–';
        case 'feet':
            return 'ðŸ‘¢';
        case 'ring':
            return 'ðŸ’';
        case 'neck':
            return 'ðŸ’Ž';
    }

    // Fallback to more generic item_type
    switch (item.item_type) {
        case 'weapon':
            return 'âš”ï¸';
        case 'shield':
             return 'ðŸ›¡ï¸';
        case 'armor':
            return 'ðŸ‘•';
        case 'potion':
            return 'ðŸ§ª';
        case 'scroll':
            return 'ðŸ“œ';
        case 'food':
            return 'ðŸ–';
        case 'key':
            return 'ðŸ”‘';
        case 'junk':
            return 'ðŸ—‘ï¸';
        default:
            return 'â”'; // A question mark for anything we haven't mapped yet
    }
};

function ItemName({ item }) {
  if (!item) return null;

  const renderTooltipContent = () => {
    // ... renderTooltipContent function is unchanged ...
    return (
      <div className="item-tooltip-content">
        {item.description && <p className="desc">{item.description}</p>}
        {item.properties && Object.keys(item.properties).length > 0 && (
          <div className="props">
            {Object.entries(item.properties).map(([key, value]) => (
              <p key={key} className="prop-line">
                <span className="prop-key">{formatPropertyName(key)}:</span>
                <span className="prop-value">{String(value)}</span>
              </p>
            ))}
          </div>
        )}
      </div>
    );
  };

  const tooltipId = `item-tooltip-${item.id}`;
  const itemIcon = getIconForItemType(item); // Get the icon for the current item

  return (
    <>
      <span
        className={`item-name-container rarity-${item.rarity || 'common'}`}
        data-tooltip-id={tooltipId}
      >
        {/* ### THE CHANGE IS HERE ### */}
        {/* We add the icon with a bit of spacing right before the name */}
        <span className="item-icon">{itemIcon}</span>
        <span className="item-text">{item.name}</span>
      </span>
      <Tooltip
        id={tooltipId}
        render={renderTooltipContent}
        className="item-tooltip-main"
        opacity={1}
      />
    </>
  );
}

export default ItemName;
--- END OF FILE frontend/src/components/ItemName.jsx ---

--- START OF FILE frontend/src/components/Map.jsx ---
import React, { useState, useRef, useEffect, useCallback } from 'react';
import useGameStore from '../state/gameStore';
import './Map.css';

// Constants can live outside the component for clarity
const TILE_SIZE = 24;
const CURRENT_ROOM_COLOR = 'rgba(255, 255, 0, 0.7)';
const DEFAULT_ROOM_COLOR = 'rgba(0, 128, 0, 0.3)';
const CONNECTION_LINE_COLOR = 'rgba(0, 192, 0, 0.6)';

function Map() {
  // Global state from Zustand
  const mapData = useGameStore((state) => state.mapData);
  const currentRoomId = useGameStore((state) => state.currentRoomId);

  // Local state for map interactivity
  const [viewBox, setViewBox] = useState('0 0 350 350');
  const [isPanning, setIsPanning] = useState(false);
  const lastPoint = useRef({ x: 0, y: 0 });
  const svgRef = useRef(null);

  // This effect hook runs when mapData changes to calculate the initial viewBox
  useEffect(() => {
    if (!mapData || !mapData.rooms || mapData.rooms.length === 0 || !svgRef.current) return;
    const { rooms } = mapData;
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    rooms.forEach(room => {
      minX = Math.min(minX, room.x); maxX = Math.max(maxX, room.x);
      minY = Math.min(minY, room.y); maxY = Math.max(maxY, room.y);
    });
    const contentWidth = (maxX - minX + 1) * TILE_SIZE;
    const contentHeight = (maxY - minY + 1) * TILE_SIZE;
    const vbX = (minX * TILE_SIZE) - TILE_SIZE; const vbY = (minY * TILE_SIZE) - TILE_SIZE;
    const vbW = contentWidth + (TILE_SIZE * 2); const vbH = contentHeight + (TILE_SIZE * 2);
    setViewBox(`${vbX} ${vbY} ${vbW} ${vbH}`);
  }, [mapData]);

  // Event handler for starting a pan
  const onMouseDown = (e) => {
    if (e.button !== 0) return; // Only pan on left-click
    e.preventDefault();
    setIsPanning(true);
    lastPoint.current = { x: e.clientX, y: e.clientY };
  };

  // Event handler for mouse movement during a pan
  const onMouseMove = (e) => {
    if (!isPanning) return;
    const [vx, vy, vw, vh] = viewBox.split(' ').map(parseFloat);
    const dx = (lastPoint.current.x - e.clientX) * (vw / svgRef.current.clientWidth);
    const dy = (lastPoint.current.y - e.clientY) * (vh / svgRef.current.clientHeight);
    setViewBox(`${vx + dx} ${vy + dy} ${vw} ${vh}`);
    lastPoint.current = { x: e.clientX, y: e.clientY };
  };

  // Event handler for ending a pan
  const onMouseUpOrLeave = () => {
    setIsPanning(false);
  };

  // Event handler for zooming with the mouse wheel
  const onWheel = useCallback((e) => {
    e.preventDefault(); // This is why we need a non-passive listener
    const [vx, vy, vw, vh] = viewBox.split(' ').map(parseFloat);
    const zoomFactor = 1.15;
    const newWidth = e.deltaY < 0 ? vw / zoomFactor : vw * zoomFactor;
    const newHeight = e.deltaY < 0 ? vh / zoomFactor : vh * zoomFactor;
    const CTM = svgRef.current.getScreenCTM().inverse();
    const mousePoint = new DOMPoint(e.clientX, e.clientY).matrixTransform(CTM);
    const newX = mousePoint.x - (newWidth / vw) * (mousePoint.x - vx);
    const newY = mousePoint.y - (newHeight / vh) * (mousePoint.y - vy);
    setViewBox(`${newX} ${newY} ${newWidth} ${newHeight}`);
  }, [viewBox]); // This callback is remade only when viewBox changes

  // Manually add and remove the 'wheel' event listener with `passive: false`
  useEffect(() => {
    const svgElement = svgRef.current;
    if (svgElement) {
      svgElement.addEventListener('wheel', onWheel, { passive: false });
      return () => { // Cleanup function
        svgElement.removeEventListener('wheel', onWheel);
      };
    }
  }, [onWheel]);


  // --- Render Logic ---

  if (!mapData || !mapData.rooms || mapData.rooms.length === 0) {
    return (
      <div id="map-column">
        <div id="map-title-bar"><span>Map</span></div>
        <div id="map-viewport"><svg id="map-svg" width="100%" height="100%"><text x="50%" y="50%" fill="#0f0" textAnchor="middle">Loading map...</text></svg></div>
        <div id="map-zone-bar"><span>[Unknown Zone]</span></div>
      </div>
    );
  }

  // Find map boundaries to flip the Y coordinates for drawing
  const { rooms } = mapData;
  let minY = Infinity, maxY = -Infinity;
  rooms.forEach(room => { minY = Math.min(minY, room.y); maxY = Math.max(maxY, room.y); });

  const transformedRooms = rooms.map(room => ({ ...room, drawY: maxY - room.y }));
  const currentRoom = transformedRooms.find(r => r.id === currentRoomId);

  return (
    <div id="map-column">
      <div id="map-title-bar" className="map-ui-bar">
        <span id="map-title-text">Map</span> | Coords:
        <span id="map-coords-text">{currentRoom ? `${currentRoom.x}, ${currentRoom.y}, ${mapData.z_level}` : '?, ?, ?'}</span>
      </div>
      <div id="map-viewport">
        <div id="map-z-level-box">
          <span className="z-level-label">Level</span>
          <span id="map-z-level-value">{mapData.z_level}</span>
        </div>
        <svg
          id="map-svg"
          ref={svgRef}
          viewBox={viewBox}
          onMouseDown={onMouseDown}
          onMouseMove={onMouseMove}
          onMouseUp={onMouseUpOrLeave}
          onMouseLeave={onMouseUpOrLeave}
          style={{ cursor: isPanning ? 'grabbing' : 'grab', width: '100%', height: '100%' }}
        >
          <g id="map-content-group">
            {/* Draw connections */}
            {transformedRooms.map(room =>
              Object.values(room.exits).map(exitInfo => {
                const targetRoom = transformedRooms.find(r => r.id === exitInfo.target_room_id);
                if (!targetRoom) return null;
                return (
                  <line
                    key={`${room.id}-${targetRoom.id}`}
                    x1={room.x * TILE_SIZE + TILE_SIZE / 2}
                    y1={room.drawY * TILE_SIZE + TILE_SIZE / 2}
                    x2={targetRoom.x * TILE_SIZE + TILE_SIZE / 2}
                    y2={targetRoom.drawY * TILE_SIZE + TILE_SIZE / 2}
                    stroke={CONNECTION_LINE_COLOR}
                    strokeWidth="1"
                  />
                );
              })
            )}
            {/* Draw rooms */}
            {transformedRooms.map(room => (
              <rect
                key={room.id}
                x={room.x * TILE_SIZE}
                y={room.drawY * TILE_SIZE}
                width={TILE_SIZE}
                height={TILE_SIZE}
                fill={room.id === currentRoomId ? CURRENT_ROOM_COLOR : DEFAULT_ROOM_COLOR}
                stroke="rgba(0,50,0,0.8)"
                strokeWidth="1"
              />
            ))}
          </g>
        </svg>
      </div>
       <div id="map-zone-bar" className="map-ui-bar">
        <span>
          {mapData.current_zone_name || 'Unknown Zone'}
          {mapData.current_zone_level_range && ` (Lvl ${mapData.current_zone_level_range})`}
        </span>
      </div>
    </div>
  );
}

export default Map;
--- END OF FILE frontend/src/components/Map.jsx ---

--- START OF FILE frontend/src/components/TerminalOutput.jsx ---
import React from 'react';

function TerminalOutput({ logLines }) {
  return (
    <div id="output" className="terminal-output">
      {logLines.map((line, index) => (
        <div
          key={index}
          className="terminal-line"
          dangerouslySetInnerHTML={{ __html: line }}
        />
      ))}
    </div>
  );
}

export default TerminalOutput;
--- END OF FILE frontend/src/components/TerminalOutput.jsx ---

--- START OF FILE frontend/src/App.jsx ---
import React, { useEffect } from 'react';
// import { Tooltip } from 'react-tooltip'; // <-- NO LONGER NEEDED HERE
import useGameStore from './state/gameStore';
import GameLayout from './components/GameLayout';
import LoginScreen from './components/LoginScreen';
import CharacterSelectionScreen from './components/CharacterSelectionScreen';
import { webSocketService } from './services/webSocketService';
import CharacterCreationScreen from './components/CharacterCreationScreen';

function App() {
  const sessionState = useGameStore((state) => state.sessionState);

  // ... useEffect is unchanged ...
  useEffect(() => {
    if (sessionState === 'IN_GAME') {
      console.log('[App.jsx] Session is IN_GAME, connecting WebSocket...');
      webSocketService.connect();
    } else {
      console.log('[App.jsx] Session is NOT IN_GAME, disconnecting WebSocket...');
      webSocketService.disconnect();
    }
    return () => {
      console.log('[App.jsx] App unmounting, ensuring WebSocket is disconnected.');
      webSocketService.disconnect();
    };
  }, [sessionState]);


  const renderSessionState = () => {
    switch (sessionState) {
      case 'LOGGED_OUT':
        return <LoginScreen />;
      case 'CHAR_SELECT':
        return <CharacterSelectionScreen />;
      case 'CHAR_CREATE':
        return <CharacterCreationScreen />;
      case 'IN_GAME':      
        return <GameLayout />;
      default:
        return <div>[Loading...]</div>;
    }
  }

  // We no longer need to render the global tooltip here.
  return (
    <>
      {renderSessionState()}
    </>
  )
}

export default App;
--- END OF FILE frontend/src/App.jsx ---

--- START OF FILE frontend/src/main.jsx ---
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'
import useGameStore from './state/gameStore';

window.useGameStore = useGameStore;

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
--- END OF FILE frontend/src/main.jsx ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
