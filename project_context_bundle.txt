--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Mon Jun  9 03:23:54 AM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_npc.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/npc_dialogue_ticker.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/npc_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/npc.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/character_classes.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/loot_tables.json
backend/app/seeds/mob_spawn_definitions.json
backend/app/seeds/mob_templates.json
backend/app/seeds/npcs.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
backend/app/ws_command_parsers/ws_shop_parser.py
bundle_context.sh
frontend/src/index.html
frontend/src/services/apiService.js
frontend/src/services/webSocketService.js
frontend/src/state/gameStore.js
frontend/src/style.css
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed." >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh"
    "README.md"

    # --- Backend - Key Frontend-Facing Files ---
    "backend/app/websocket_router.py"    # PRIMARY: Defines all WebSocket command handlers and data packages.
    "backend/app/api/v1/endpoints/user.py"   # For login/registration.
    "backend/app/api/v1/endpoints/character.py" # For char list/create/select.
    "backend/app/main.py"                # For general context.
    
    # --- Backend - Schemas (CRITICAL for knowing what data the frontend gets) ---
    "backend/app/schemas/character.py"
    "backend/app.schemas/room.py"
    "backend/app/schemas/item.py"
    "backend/app/schemas/map.py"
    "backend/app/schemas/command.py"

    # --- OLD Frontend (CRITICAL REFERENCE for porting to React) ---
    "frontend/src/main.js"      
    "frontend/src/ui.js"        
    "frontend/src/api.js"
    "frontend/src/websocket.js"
    "frontend/src/state.js"
    "frontend/src/map.js"
    "frontend/src/style.css"
    "frontend/src/index.html"

    # --- NEW Frontend (PLACEHOLDERS for the files we will create) ---
    # "frontend/src/App.jsx"
    # "frontend/src/main.jsx" # Vite's entry point
    # "frontend/src/components/Terminal.jsx"
    # "frontend/src/components/Map.jsx"
    # "frontend/src/state/gameStore.js" # Example for Zustand
    # "frontend/package.json" # To see dependencies
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (âœ¨ðŸ’°ðŸ’ªðŸ§©ðŸ’€ðŸšª) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Flesh out the damn world - Gear, Loot, and More Seeds!

The map is less of an abstract nightmare, and the core gameplay loop is... loopy. Now we need to make the interactions richer and the world feel less empty.

*   **Full Equipment System:** Define all equipment slots. Implement robust `equip` and `unequip` logic. Ensure stats update correctly.
*   **Mob Loot Tables:** Mobs need to drop more than just coins. Define loot tables (specific items, random items from categories, chances).
*   **Seed More Content (Externalize ALL THE THINGS):**
    *   `mob_templates.json`
    *   `character_classes.json`
    *   `skills.json`
    *   `traits.json`
    *   `mob_spawn_definitions.json`
    *   Update corresponding CRUD seeders to load from these JSONs.
*   **Seed Initial Equipment:** Place starting gear on character creation or in initial rooms.

This will involve a lot of backend work (models, CRUD, game logic) and careful JSON schema design for the seed files.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple, Union
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session # attributes removed as it's used in parsers now
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

from app.core.config import settings
from app.db.session import SessionLocal
from app import crud, models, schemas # Full app imports
from app.websocket_manager import connection_manager
from app.game_logic import combat # For access to combat.active_combats, combat.send_combat_log etc.

from app.commands.utils import ( # General utils
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message,
    format_room_npcs_for_player_message
    # resolve_mob_target is used within ws_combat_actions_parser
    # resolve_room_item_target is used within ws_interaction_parser
)
from app.game_state import is_character_resting, set_character_resting_status
# ExitDetail is used within ws_movement_parser.attempt_player_move

# Import the new WS command parsers
from app.ws_command_parsers import (
    handle_ws_movement, handle_ws_flee,
    handle_ws_attack, handle_ws_use_combat_skill,
    handle_ws_get_take, handle_ws_unlock, handle_ws_search_examine,
    handle_ws_contextual_interactable, handle_ws_use_ooc_skill,
    handle_ws_look, handle_ws_rest,
    handle_ws_list, handle_ws_buy, handle_ws_sell, handle_ws_sell_all_junk
)

logger = logging.getLogger(__name__)
# --- Logger setup print lines (can be removed once stable) ---
print(f"--- WEBSOCKET_ROUTER.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_ws = logger.getEffectiveLevel()
print(f"--- WEBSOCKET_ROUTER.PY: Effective log level for '{logger.name}' logger = {effective_level_ws} ({logging.getLevelName(effective_level_ws)}) ---", flush=True)
logger.info("--- WEBSOCKET_ROUTER.PY INFO LOG TEST: Module loaded (Post-Refactor) ---")
# --- End of logger setup print lines ---

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str) # Ensure player_id_str is a valid UUID string
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError): # Catch JWT errors and ValueError from UUID conversion
        return None

# _handle_websocket_move_if_not_in_combat has been moved to ws_movement_parser.attempt_player_move

@router.websocket("/ws") 
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character_orm: Optional[models.Character] = None # Renamed from 'character' to avoid confusion with character_id param

    with get_db_sync() as db_conn_init: 
        player = await get_player_from_token(token, db_conn_init)
        if not player:
            logger.warning(f"WS Connect: Invalid token for char_id: {character_id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return
        
        fetched_char = crud.crud_character.get_character(db_conn_init, character_id=character_id)
        if not fetched_char or fetched_char.player_id != player.id:
            logger.warning(f"WS Connect: Invalid char_id: {character_id} for player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character_orm = fetched_char # Assign to the correctly scoped variable
    
    await connection_manager.connect(websocket, player.id, character_orm.id)
    logger.info(f"Player {player.id} (Character {character_orm.name} - {character_orm.id}) connected via WebSocket.")
    
    # --- Welcome Package ---
    initial_messages = [f"Welcome {character_orm.name}! You are connected via WebSocket."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db_welcome: 
        initial_room_orm = crud.crud_room.get_room_by_id(db_welcome, room_id=character_orm.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.")
            items_on_ground = crud.crud_room_item.get_items_in_room(db_welcome, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: initial_messages.append(items_text)
            
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db_welcome, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: initial_messages.append(mobs_text)
            
            other_chars_in_room = crud.crud_character.get_characters_in_room(db_welcome, room_id=initial_room_orm.id, exclude_character_id=character_orm.id)
            chars_text_initial = format_room_characters_for_player_message(other_chars_in_room)
            if chars_text_initial: initial_messages.append(chars_text_initial)
    
            npcs_in_room_welcome = crud.crud_room.get_npcs_in_room(db_welcome, room=initial_room_orm)
            npcs_text_welcome = format_room_npcs_for_player_message(npcs_in_room_welcome)
            if npcs_text_welcome: initial_messages.append(npcs_text_welcome)

    xp_for_next_level = crud.crud_character.get_xp_for_level(character_orm.level + 1)
    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump(exclude_none=True) if initial_room_schema else None,
        "character_vitals": {
            "current_hp": character_orm.current_health, "max_hp": character_orm.max_health,
            "current_mp": character_orm.current_mana, "max_mp": character_orm.max_mana,
            "current_xp": character_orm.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character_orm.level,
            "platinum": character_orm.platinum_coins, "gold": character_orm.gold_coins,
            "silver": character_orm.silver_coins, "copper": character_orm.copper_coins
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)
    # --- End Welcome Package ---

    try:
        while True:
            received_data = await websocket.receive_json()
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            # It's crucial to get fresh state at the beginning of each command processing loop
            with get_db_sync() as db_loop: 
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character_orm.id)
                if not current_char_state: 
                    logger.error(f"WS Loop: Character state lost for char_id: {character_orm.id}.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost in loop")
                    break 
                
                current_room_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                if not current_room_orm:
                    logger.error(f"WS Loop: Character {current_char_state.name} in invalid room {current_char_state.current_room_id}.")
                    await combat.send_combat_log(player.id, ["Error: Your current location is unstable. Please relog or contact support."], combat_ended=True)
                    continue 

                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_orm)
                
                verb_for_rest_check = command_text.split(" ", 1)[0].lower() if command_text else ""
                
                non_breaking_verbs = [ # Commands that don't break resting
                    "rest", "look", "l", "score", "sc", "status", "st", 
                    "help", "?", "skills", "sk", "traits", "tr", 
                    "inventory", "i", "ooc", "say", "'", "emote", ":",
                    "list", "buy", "sell"
                ]
                
                if verb_for_rest_check and verb_for_rest_check not in non_breaking_verbs and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat.send_combat_log(player.id, ["You stop resting."], room_data=current_room_schema_for_command)

                if message_type == "command" and command_text:
                    verb = verb_for_rest_check 
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""
                    args_list = args_str.split() # For handlers that need a list

                    logger.debug(f"WS Router: Processing verb='{verb}', args='{args_str}' for char {current_char_state.name}")

                    # --- Command Dispatching ---
                    if verb == "rest":
                        await handle_ws_rest(db_loop, player, current_char_state, current_room_orm)
                    elif verb in ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]:
                        await handle_ws_movement(db_loop, player, current_char_state, current_room_schema_for_command, verb, args_str)
                    elif verb == "flee":
                        await handle_ws_flee(db_loop, player, current_char_state, current_room_schema_for_command, args_str)
                    elif verb in ["attack", "atk", "kill", "k"]:
                        await handle_ws_attack(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "use":
                        if not args_str: 
                            await combat.send_combat_log(player.id, ["Use what skill?"], room_data=current_room_schema_for_command); continue
                        
                        temp_args_list_for_skill_parse = args_str.split()
                        learned_skill_tags = current_char_state.learned_skills or []
                        if not learned_skill_tags: 
                            await combat.send_combat_log(player.id, ["You have no skills."], room_data=current_room_schema_for_command); continue

                        # Simplified skill name parsing (copied from previous) - THIS SHOULD BE A UTILITY
                        parsed_skill_template: Optional[models.SkillTemplate] = None
                        parsed_remaining_args: str = ""
                        possible_matches_temp: List[Tuple[models.SkillTemplate, str]] = []
                        for i in range(len(temp_args_list_for_skill_parse), 0, -1):
                            current_skill_input = " ".join(temp_args_list_for_skill_parse[:i]).lower()
                            potential_target_str = " ".join(temp_args_list_for_skill_parse[i:]).strip()
                            for skill_tag_loop in learned_skill_tags:
                                st_db = crud.crud_skill.get_skill_template_by_tag(db_loop, skill_id_tag=skill_tag_loop)
                                if not st_db: continue
                                if st_db.skill_id_tag.lower().startswith(current_skill_input) or st_db.name.lower().startswith(current_skill_input):
                                    if not any(em.id == st_db.id for em, _ in possible_matches_temp):
                                        possible_matches_temp.append((st_db, potential_target_str))
                            if possible_matches_temp and len(current_skill_input.split()) > 0: break
                        
                        if not possible_matches_temp: await combat.send_combat_log(player.id, [f"No skill matching '{temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else args_str}'."], room_data=current_room_schema_for_command); continue
                        elif len(possible_matches_temp) == 1: parsed_skill_template, parsed_remaining_args = possible_matches_temp[0]
                        else:
                            exact_match_s = None; s_input_first = temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else ""
                            for sm_t, sm_a in possible_matches_temp:
                                if sm_t.name.lower() == s_input_first or sm_t.skill_id_tag.lower() == s_input_first:
                                    exact_match_s = sm_t; parsed_remaining_args = sm_a; break
                            if exact_match_s: parsed_skill_template = exact_match_s
                            else: await combat.send_combat_log(player.id, [f"Multiple skills match. Specify: {', '.join(list(set([st.name for st, _ in possible_matches_temp])))}"], room_data=current_room_schema_for_command); continue
                        
                        if not parsed_skill_template: await combat.send_combat_log(player.id, ["Error selecting skill for 'use' command."], room_data=current_room_schema_for_command); continue

                        # Dispatch based on skill type
                        if parsed_skill_template.skill_type == "COMBAT_ACTIVE":
                            await handle_ws_use_combat_skill(db_loop, player, current_char_state, current_room_schema_for_command, args_str) # Pass original args_str for its own parsing
                        elif parsed_skill_template.skill_type == "UTILITY_OOC":
                            # parsed_remaining_args is the target for the OOC skill (e.g., direction string)
                            await handle_ws_use_ooc_skill(db_loop, player, current_char_state, current_room_orm, parsed_skill_template, parsed_remaining_args)
                        else:
                            await combat.send_combat_log(player.id, [f"Skill '{parsed_skill_template.name}' type ({parsed_skill_template.skill_type}) cannot be 'used' this way."], room_data=current_room_schema_for_command)
                    
                    elif verb in ["get", "take"]:
                        await handle_ws_get_take(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "unlock":
                        await handle_ws_unlock(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "search" or verb == "examine":
                        await handle_ws_search_examine(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "look" or verb == "l":
                        await handle_ws_look(db_loop, player, current_char_state, current_room_orm, args_str)
                    
                    # --- SHOP COMMANDS ---
                    elif verb == "list":
                        await handle_ws_list(db_loop, player, current_char_state, current_room_orm)
                    elif verb == "buy":
                        await handle_ws_buy(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "sell":
                        if args_str.lower() in ["all junk", "all trash"]:
                            await handle_ws_sell_all_junk(db_loop, player, current_char_state, current_room_orm)
                        else:
                            await handle_ws_sell(db_loop, player, current_char_state, current_room_orm, args_str)

                    else: # Fallback: Try contextual interactable actions
                        is_interactable_action_handled = False
                        if current_room_orm.interactables: # Check if list is not None and not empty
                            target_interactable_name_or_id = args_str.lower()
                            for interactable_dict_ws in current_room_orm.interactables:
                                try:
                                    interactable_obj_ws = schemas.InteractableDetail(**interactable_dict_ws) # Validate from DB data
                                    is_visible = not interactable_obj_ws.is_hidden or current_char_state.id in interactable_obj_ws.revealed_to_char_ids
                                    
                                    if is_visible and verb == interactable_obj_ws.action_verb.lower():
                                        matches_this_interactable = False
                                        if not target_interactable_name_or_id: # e.g. "pull"
                                            # Count how many pullable things are visible
                                            count_with_verb = 0
                                            for other_i_d in current_room_orm.interactables:
                                                other_i = schemas.InteractableDetail(**other_i_d)
                                                other_vis = not other_i.is_hidden or current_char_state.id in other_i.revealed_to_char_ids
                                                if other_vis and other_i.action_verb.lower() == verb:
                                                    count_with_verb +=1
                                            if count_with_verb == 1: matches_this_interactable = True
                                        elif interactable_obj_ws.id_tag.lower() == target_interactable_name_or_id or \
                                             target_interactable_name_or_id in interactable_obj_ws.name.lower():
                                            matches_this_interactable = True
                                        
                                        if matches_this_interactable:
                                            await handle_ws_contextual_interactable(db_loop, player, current_char_state, current_room_orm, verb, args_list, interactable_obj_ws)
                                            is_interactable_action_handled = True; break 
                                except Exception as e_parse_interactable_ws_ctx: 
                                    logger.error(f"WS: Error parsing interactable for contextual check: {e_parse_interactable_ws_ctx}. Data: {interactable_dict_ws}")
                        
                        if not is_interactable_action_handled:
                            # If not any of the above, it's an unknown command for WebSocket
                            await combat.send_combat_log(player.id, [f"Unrecognized command via WebSocket: '{command_text}'. Try 'help' (HTTP)."], room_data=current_room_schema_for_command)
                
                    try:
                        db_loop.commit() # Commit changes made by the handler
                        logger.debug(f"WS Router: DB commit successful for command '{command_text}' by {current_char_state.name}")
                    except Exception as e_commit:
                        db_loop.rollback()
                        logger.error(f"WS Router: DB commit failed for command '{command_text}' by {current_char_state.name}: {e_commit}", exc_info=True)
                        await combat.send_combat_log(player.id, ["A glitch in the matrix occurred. Your last action may not have saved."], room_data=current_room_schema_for_command) # Send error to player
                
                elif message_type != "command": 
                    await combat.send_combat_log(player.id, [f"Unrecognized message type: {message_type}."], room_data=current_room_schema_for_command)
                elif not command_text : # Empty command string for type "command"
                     await combat.send_combat_log(player.id, ["Empty command received."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'} (Character {character_orm.id if character_orm else 'N/A'})")
        if character_orm and character_orm.id: 
            combat.end_combat_for_character(character_orm.id, reason="websocket_disconnect_main_handler")
            if is_character_resting(character_orm.id):
                set_character_resting_status(character_orm.id, False)
    except Exception as e:
        err_player_id_str = str(player.id) if player else "Unknown Player"
        err_char_id_str = str(character_orm.id) if character_orm else "Unknown Character"
        logger.error(f"Critical Error in WebSocket handler for Player {err_player_id_str} (Character {err_char_id_str}): {e}", exc_info=True)
        try:
            # Attempt to send a generic error to the client before closing
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred. Please try reconnecting."})
        except Exception as send_err: 
            logger.error(f"Failed to send critical error to WebSocket for Player {err_player_id_str}: {send_err}")
    finally:
        if player and player.id: 
            connection_manager.disconnect(player.id) 
            if character_orm and character_orm.id and is_character_resting(character_orm.id): 
                set_character_resting_status(character_orm.id, False)
        char_id_log_final = str(character_orm.id) if character_orm else "N/A"
        player_id_log_final = str(player.id) if player else "N/A"
        logger.info(f"WebSocket connection for Player {player_id_log_final} (Character {char_id_log_final}) fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/api/v1/endpoints/user.py ---
# backend/app/api/v1/endpoints/user.py
from fastapi import APIRouter, Depends, HTTPException, status, Body, Form, Request # Added Body
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from typing import Any
from pydantic import BaseModel # Ensure BaseModel is imported
from datetime import timedelta # For token expiration

from app import schemas, crud, models # Import schemas, crud, models
from app.db.session import get_db
from app.core.security import verify_password, create_access_token # Import create_access_token
from app.core.config import settings # For ACCESS_TOKEN_EXPIRE_MINUTES
from app.api.dependencies import get_current_player # Add this import
import logging

logger = logging.getLogger(__name__)
router = APIRouter() 

class UserLoginRequest(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

@router.get("/debug-headers")
def debug_headers(request: Request):
    """
    A simple, unprotected endpoint to dump all received headers to the log.
    """
    header_log_message = "\n" + "="*50 + "\nHEADERS RECEIVED AT /debug-headers:\n"
    for name, value in request.headers.items():
        header_log_message += f"  {name}: {value}\n"
    header_log_message += "="*50
    logger.info(header_log_message) # Using INFO to make sure it prints
    
    return {"message": "Headers logged to backend console."}

@router.post("/login", response_model=Token)
def login_user_for_access_token(
    db: Session = Depends(get_db), 
    form_data: OAuth2PasswordRequestForm = Depends() 
) -> Any:
    try:
        player = crud.crud_player.get_player_by_username(db, username=form_data.username) 
        if not player or not verify_password(form_data.password, player.hashed_password): # type: ignore 
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            subject=str(player.id), expires_delta=access_token_expires
        )
        return Token(access_token=access_token, token_type="bearer")
    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error during login.")

@router.get("/me", response_model=schemas.Player) 
def read_users_me(
    current_player: models.Player = Depends(get_current_player) 
) -> Any:
    return current_player

@router.post("/register", response_model=schemas.Player, status_code=status.HTTP_201_CREATED)
def register_new_user(
    *,
    db: Session = Depends(get_db),
    player_in: schemas.PlayerCreate
) -> Any:
    try:
        existing_player = crud.crud_player.get_player_by_username(db, username=player_in.username)
        if existing_player:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="A player with this username already exists.",
            )
        player = crud.crud_player.create_player(db, player_in=player_in)
        return player
    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error during registration.")
--- END OF FILE backend/app/api/v1/endpoints/user.py ---

--- START OF FILE backend/app/api/v1/endpoints/character.py ---
# backend/app/api/v1/endpoints/character.py
from fastapi import APIRouter, Depends, HTTPException, status, Body, Request
from sqlalchemy.orm import Session
import uuid
from typing import Any, List

from .... import schemas, crud, models
from ....db.session import get_db
# from ....crud.crud_room import get_room_by_coords # No longer needed for this file directly if only used in create
from ....api.dependencies import get_current_player
from ....game_state import active_game_sessions # <<< ADDED THIS IMPORT
import logging

logger = logging.getLogger(__name__)
router = APIRouter()


@router.post("/create", response_model=schemas.Character, status_code=status.HTTP_201_CREATED)
def create_new_character_for_current_player(
    *,
    db: Session = Depends(get_db),
    character_payload: schemas.CharacterCreate = Body(...), # Contains name, optional class_name
    current_player: models.Player = Depends(get_current_player)
) -> Any:
    # ... (existing_character check remains the same) ...
    existing_character = crud.crud_character.get_character_by_name(db, name=character_payload.name)
    if existing_character:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"A character with the name '{character_payload.name}' already exists."
        )
    
    start_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0)
    if not start_room_orm:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Starting room not found. Cannot create character. Server misconfiguration."
        )
    
    # The character_payload (schemas.CharacterCreate) now passes name and class_name (optional)
    # to crud.crud_character.create_character.
    # The CRUD function handles looking up the class template and applying defaults/modifiers.
    character = crud.crud_character.create_character(
        db,
        character_in=character_payload, # Contains name and potentially class_name
        player_id=current_player.id,
        initial_room_id=start_room_orm.id
    )
    
    print(f"Character '{character.name}' (Class: {character.class_name}) created for player '{current_player.username}', starting in room '{start_room_orm.name}'.")
    return character # FastAPI will convert to schemas.Character


@router.get("/mine", response_model=List[schemas.Character])
def read_characters_for_current_player(
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
):
    """
    Retrieve all characters for the currently authenticated player.
    """ 
    characters = crud.crud_character.get_characters_by_player(db, player_id=current_player.id)
    return characters


@router.post("/{character_id}/select", response_model=schemas.RoomInDB) # <<< NEW ENDPOINT
def select_character_for_session(
    *,
    db: Session = Depends(get_db),
    character_id: uuid.UUID,
    current_player: models.Player = Depends(get_current_player)
) -> Any:
    """
    Selects a character to be the active character for the player's session.
    Returns the character's current room data.
    """
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Character with ID {character_id} not found."
        )
    
    if character.player_id != current_player.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Operation not permitted: This character does not belong to you."
        )

    # Set this character as active for the player's session
    active_game_sessions[current_player.id] = character.id
    
    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    if not current_room_orm:
        active_game_sessions.pop(current_player.id, None) # Clean up inconsistent state
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Character '{character.name}' (ID: {character.id}) is in an invalid room (ID: {character.current_room_id}). Data integrity error. Session not started."
        )
    
    print(f"Player '{current_player.username}' (ID: {current_player.id}) selected character '{character.name}' (ID: {character.id}).")
    print(f"Active sessions: {active_game_sessions}") # For debugging
    return current_room_orm # FastAPI will convert ORM to schemas.RoomInDB
--- END OF FILE backend/app/api/v1/endpoints/character.py ---

--- START OF FILE backend/app/main.py ---
# backend/app/main.py
import asyncio
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
import sys # For detailed print statements
from app.core.config import settings
import logging # Import logging
from fastapi.middleware.cors import CORSMiddleware 

# --- Setup Logging First ---
# This needs to happen before other modules that might use logging are imported,
# or at least before they try to log.
try:
    from app.core.logging_config import setup_logging
    setup_logging()
    print("--- MAIN.PY: setup_logging() CALLED (no exception caught) ---", flush=True)
except ImportError as e_log_setup:
    print(f"--- CRITICAL: main.py - FAILED to import or run setup_logging: {e_log_setup} ---", flush=True)
    sys.exit(1) # Exit if logging can't be set up, as it's crucial for debugging

logger = logging.getLogger(__name__) # Get a logger for this module

# --- Add these lines for immediate feedback on logger level ---
print(f"--- MAIN.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_main = logger.getEffectiveLevel()
print(f"--- MAIN.PY: Effective log level for 'app.main' logger = {effective_level_main} ({logging.getLevelName(effective_level_main)}) ---", flush=True)
logger.debug(f"--- MAIN.PY DEBUG LOG TEST: Top of file, Python version: {sys.version} ---") # Changed from logger.debug to ensure it prints if DEBUG is working
logger.info(f"--- MAIN.PY INFO LOG TEST: Top of file, Python version: {sys.version} ---")
# --- End of added lines ---

from app.api.v1.api_router import api_router as v1_api_router
logger.debug("--- main.py - Imported v1_api_router ---")
from app.websocket_router import router as ws_router
logger.debug("--- main.py - Imported ws_router ---")
from app.db.session import engine, get_db
logger.debug("--- main.py - Imported engine, get_db from app.db.session ---")
from app.db import base_class
logger.debug("--- main.py - Imported base_class from app.db ---")
from app.core.config import settings
logger.debug(f"--- main.py - Imported settings. Project Name: {settings.PROJECT_NAME} ---")
from app.crud.crud_room import seed_initial_world
logger.debug("--- main.py - Imported seed_initial_world ---")
from app.crud.crud_item import seed_initial_items 
logger.debug("--- main.py - Imported seed_initial_items ---")
from app.crud.crud_mob import seed_initial_mob_templates
logger.debug("--- main.py - Imported seed_initial_mob_templates ---")
from app.game_logic.combat import start_combat_ticker_task, stop_combat_ticker_task
logger.debug("--- main.py - Imported combat_manager tasks ---")
from app.crud.crud_character_class import seed_initial_character_class_templates 
logger.debug("--- main.py - Imported seed_initial_character_class_templates ---")
from app.crud.crud_skill import seed_initial_skill_templates 
logger.debug("--- main.py - Imported seed_initial_skill_templates ---")
from app.crud.crud_trait import seed_initial_trait_templates 
logger.debug("--- main.py - Imported seed_initial_trait_templates ---")
from app.game_logic.world_ticker import start_world_ticker_task, stop_world_ticker_task
logger.debug("--- main.py - Imported world_ticker tasks ---")
from app.crud.crud_mob_spawn_definition import seed_initial_mob_spawn_definitions 
logger.debug("--- main.py - Imported seed_initial_mob_spawn_definitions ---")
from app.crud.crud_npc import seed_initial_npc_templates
logger.debug("--- main.py - Imported seed_initial_npc_templates ---")
from app.game_logic.npc_dialogue_ticker import start_dialogue_ticker_task, stop_dialogue_ticker_task
logger.debug("--- main.py - Imported npc_dialogue_ticker shit ---")
logger.debug("--- main.py - About to call Base.metadata.create_all(bind=engine) ---")
try:
    base_class.Base.metadata.create_all(bind=engine)
    logger.info("--- main.py - Base.metadata.create_all(bind=engine) COMPLETED ---")
except Exception as e:
    logger.error(f"--- main.py - ERROR during Base.metadata.create_all: {e} ---", exc_info=True)
    # Depending on the severity, you might want to sys.exit() here

logger.debug("--- main.py - Creating FastAPI app instance ---")
app = FastAPI(title=settings.PROJECT_NAME)
logger.info("--- main.py - FastAPI app instance CREATED ---")

origins = [
    "http://localhost:5174",
    "http://192.168.88.115:5174",
    "https://llmud.trazen.org"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
def on_startup_sync():
    logger.info("--- main.py - START of on_startup_sync event ---")
    db: Session = next(get_db())
    logger.debug("--- main.py - on_startup_sync: Acquired DB session ---")
    try:
        logger.info("--- main.py - on_startup_sync: Running startup event: Seeding initial data... ---")
        
        # CORRECT ORDER:
        # 1. Seed items FIRST
        seed_initial_items(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_items COMPLETED ---")

        # 2. THEN seed the world (rooms/exits), which might place items
        seed_initial_world(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_world COMPLETED ---")
        
        # 3. THEN other things
        seed_initial_mob_templates(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_templates COMPLETED ---")

        seed_initial_npc_templates(db) # <<< ADD THIS LINE
        logger.debug("--- main.py - on_startup_sync: seed_initial_npc_templates COMPLETED ---")
        
        seed_initial_character_class_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_character_class_templates COMPLETED ---")
        
        seed_initial_skill_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_skill_templates COMPLETED ---")
        
        seed_initial_trait_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_trait_templates COMPLETED ---")
        
        seed_initial_mob_spawn_definitions(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_spawn_definitions COMPLETED ---")
        
        logger.info("--- main.py - on_startup_sync: Starting combat ticker... ---")
        start_combat_ticker_task()
        logger.debug("--- main.py - on_startup_sync: Combat ticker STARTED ---")      

        logger.info("--- main.py - on_startup_sync: Starting NPC dialogue ticker... ---")
        start_dialogue_ticker_task()        
        logger.info("--- main.py - on_startup_sync: Startup event processing FINISHED ---")

        logger.info("--- main.py - on_startup_sync: Starting world ticker... ---") 
        start_world_ticker_task()    
        logger.debug("--- main.py - on_startup_sync: World ticker STARTED ---")     
        logger.info("--- main.py - on_startup_sync: Startup event processing FINISHED ---")
    except Exception as e_startup:
        logger.error(f"--- main.py - ERROR during on_startup_sync: {e_startup} ---", exc_info=True)
    finally:
        logger.debug("--- main.py - on_startup_sync: Closing DB session ---")
        db.close()
        logger.debug("--- main.py - on_startup_sync: DB session CLOSED ---")
    logger.info("--- main.py - END of on_startup_sync event ---")

logger.debug("--- main.py - About to include v1_api_router ---")
app.include_router(v1_api_router, prefix=settings.API_V1_STR)
logger.debug("--- main.py - v1_api_router INCLUDED ---")

logger.debug("--- main.py - About to include ws_router ---")
app.include_router(ws_router)
logger.debug("--- main.py - ws_router INCLUDED ---")

@app.get("/")
async def root():
    logger.debug("--- main.py - GET / request received ---")
    return {"message": f"Welcome to {settings.PROJECT_NAME}. Now with a World Ticker humming in the background!"}

logger.info("--- main.py - FastAPI app instance configured. End of file. ---")
--- END OF FILE backend/app/main.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)

    # Currency: Optional at creation, with defaults
    platinum_coins: Optional[int] = Field(0, description="Platinum coins owned by the character")
    gold_coins: Optional[int] = Field(0, description="Gold coins owned by the character")
    silver_coins: Optional[int] = Field(0, description="Silver coins owned by the character")
    copper_coins: Optional[int] = Field(100, description="Copper coins owned by the character, default 100 for new chars")

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):  # Inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    platinum_coins: int # type: ignore
    gold_coins: int # type: ignore
    silver_coins: int # type: ignore
    copper_coins: int # type: ignore

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- CORE FILE NOT FOUND: backend/app.schemas/room.py ---

--- START OF FILE backend/app/schemas/item.py ---
# backend/app/schemas/item.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- Item Schemas ---
class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    item_type: str = Field(..., description="e.g., weapon, armor, potion, junk")
    slot: Optional[str] = Field(None, description="Primary equippable slot type, e.g., head, main_hand, consumable")
    properties: Optional[Dict[str, Any]] = Field(None, description="e.g., {'damage': '1d6', 'armor_class': 5}")
    weight: float = Field(0.0, ge=0)
    value: int = Field(0, ge=0)
    stackable: bool = False
    max_stack_size: Optional[int] = Field(1, ge=1)

class RoomItemInstanceBase(BaseModel):
    quantity: int
    item: 'Item' # Use the existing Item schema for the template details

class RoomItemInstanceInDB(RoomItemInstanceBase):
    id: uuid.UUID
    room_id: uuid.UUID
    item_id: uuid.UUID
    
    class Config:
        from_attributes = True
class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    item_type: Optional[str] = None
    slot: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    weight: Optional[float] = None
    value: Optional[int] = None
    stackable: Optional[bool] = None
    max_stack_size: Optional[int] = None

class ItemInDBBase(ItemBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class Item(ItemInDBBase): # For returning item info
    pass

class ItemInDB(ItemInDBBase): # More complete internal representation if needed
    pass


# --- CharacterInventoryItem Schemas ---
# This represents an item *instance* in a character's inventory

class CharacterInventoryItemBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    equipped: bool = False
    equipped_slot: Optional[str] = None # Actual character slot occupied if equipped

class CharacterInventoryItemCreate(CharacterInventoryItemBase):
    # character_id will be supplied by the service/path
    pass

class CharacterInventoryItemUpdate(BaseModel):
    quantity: Optional[int] = Field(None, ge=1)
    equipped: Optional[bool] = None
    equipped_slot: Optional[str] = None

class CharacterInventoryItemInDBBase(CharacterInventoryItemBase):
    id: uuid.UUID # The unique ID of this inventory entry
    character_id: uuid.UUID
    item: Item # Include full item details when displaying inventory

    class Config:
        from_attributes = True

class CharacterInventoryItem(CharacterInventoryItemInDBBase): # For returning to client
    pass


# --- Composite Schema for Displaying Full Inventory ---
class CharacterInventoryDisplay(BaseModel):
    equipped_items: Dict[str, CharacterInventoryItem] = Field(default_factory=dict, description="Items currently equipped, keyed by their equipped_slot")
    backpack_items: List[CharacterInventoryItem] = Field(default_factory=list, description="Items in inventory but not equipped")
    platinum: int = 0
    gold: int = 0
    silver: int = 0
    copper: int = 0
    # Add more fields like total_weight, currency later

class EquipRequest(BaseModel):
    target_slot: Optional[str] = Field(None, description="Optional: The specific character slot to equip the item to, e.g., 'finger_1'")
--- END OF FILE backend/app/schemas/item.py ---

--- START OF FILE backend/app/schemas/map.py ---
# backend/app/schemas/map.py (NEW FILE)
import uuid
from pydantic import BaseModel, Field
from typing import List, Dict, Optional

from .room import RoomInDB # We'll use the existing RoomInDB for individual room details

class MapRoomData(BaseModel):
    id: uuid.UUID
    x: int
    y: int
    name: Optional[str] = None # Optional: for tooltips or labels
    exits: Optional[Dict[str, str]] = Field(default_factory=dict)
    is_current_room: bool = False
    is_visited: bool = True # For now, all fetched rooms are considered visited

class MapLevelDataResponse(BaseModel):
    z_level: int
    current_room_id: Optional[uuid.UUID] = None
    rooms: List[MapRoomData] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/map.py ---

--- START OF FILE backend/app/schemas/command.py ---
# backend/app/schemas/command.py
from pydantic import BaseModel
from typing import Optional
from .room import RoomInDB

class CommandRequest(BaseModel):
    command: str

class CommandResponse(BaseModel):
    room_data: Optional[RoomInDB] = None
    message_to_player: Optional[str] = None
    combat_over: bool = False # True if combat resolved (death, flee)
    # Add other potential fields for game state updates if needed for HTTP path
--- END OF FILE backend/app/schemas/command.py ---

--- CORE FILE NOT FOUND: frontend/src/main.js ---

--- CORE FILE NOT FOUND: frontend/src/ui.js ---

--- CORE FILE NOT FOUND: frontend/src/api.js ---

--- CORE FILE NOT FOUND: frontend/src/websocket.js ---

--- CORE FILE NOT FOUND: frontend/src/state.js ---

--- CORE FILE NOT FOUND: frontend/src/map.js ---

--- START OF FILE frontend/src/style.css ---
body {
    background-color: #000;
    color: #00ff00;
    font-family: 'Courier New', Courier, monospace;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 10px;
    box-sizing: border-box;
}

#map-column {
    display: flex;
    flex-direction: column;
    margin-left: 15px;
    width: 350px;
    height: 350px;
    flex-shrink: 0;
}

#map-title-bar {
    background-color: #111;
    color: #00dd00;
    padding: 6px 10px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    border: 1px solid #005500;
    border-bottom: 1px solid #005500;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#map-title-bar span {
    margin: 0 3px;
}

.map-title-separator {
    color: #007700;
    font-weight: bold;
}

#map-title-text {
    font-weight: bold;
    color: #ffffff;
}

#map-coords-label {
    color: #bbbbbb;
}

#map-coords-text {
    font-weight: bold;
}

#map-viewport {
    /* height: 228px; /* Will be adjusted if Zone display is added below */
    flex-grow: 1;
    /* Allow viewport to take remaining space in map-column */
    border: 1px solid #00cc00;
    border-top: none;
    background-color: #080808;
    overflow: hidden;
    box-shadow: 0 0 10px #00cc00;
    position: relative;
    /* Crucial for absolute positioning of Z-level and zoom buttons */
}

/* NEW: Z-Level Display Box */
#map-z-level-box {
    position: absolute;
    top: 5px;
    left: 5px;
    background-color: rgba(10, 10, 10, 0.8);
    border: 1px solid #007700;
    padding: 3px 5px;
    color: #00ff00;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.8em;
    text-align: center;
    z-index: 1000;
    /* Below zoom buttons if they overlap, adjust as needed */
    width: auto;
    /* Fit content */
    min-width: 40px;
    /* Ensure some base width */
}

#map-z-level-box .z-level-label {
    display: block;
    font-size: 0.85em;
    /* Smaller "Level" text */
    color: #00aa00;
    margin-bottom: 1px;
}

#map-z-level-value {
    display: block;
    font-size: 1.3em;
    /* Larger Z number */
    font-weight: bold;
    line-height: 1;
}

/* NEW: Zone Display Bar (Placeholder) */
#map-zone-bar {
    background-color: #111;
    /* Match title bar */
    color: #00dd00;
    padding: 4px 10px;
    /* Slightly less padding */
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.85em;
    /* Slightly smaller */
    border: 1px solid #005500;
    border-top: none;
    /* Connects to map-viewport border */
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#map-zone-bar .zone-label {
    color: #bbbbbb;
}

#map-zone-name-text {
    font-weight: bold;
    color: #ffffff;
}

#map-zone-levels-text {
    color: #00cc88;
}

.char-class-desc {
    font-style: italic;
    color: #999;
}

.header-text {
    text-align: center;
    margin-bottom: 20px;
}

.header-text h1 {
    margin: 0 0 5px 0;
    font-size: 1.8em;
    line-height: 1.2;
}

.header-text p {
    margin: 0;
    font-size: 0.9em;
    color: #00cc00;
}

.game-area-wrapper {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    width: 100%;
    max-width: 1200px;
}

.mud-container {
    position: relative;
    width: 100%;
    max-width: 900px;
    display: flex;
    flex-direction: column;
    border: 1px solid #005500;
}

#copy-output-button {
    position: absolute;
    top: 35px;
    right: 5px;
    padding: 8px 12px;
    background-color: #333;
    color: #0f0;
    border: 1px solid #0f0;
    border-radius: 4px;
    cursor: pointer;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    z-index: 100;
}

#copy-output-button:hover {
    background-color: #444;
}

#copy-output-button:active {
    background-color: #222;
}

.terminal-output {
    flex-grow: 1;
    height: 70vh;
    overflow-y: scroll;
    background-color: #030303;
    padding: 10px;
    box-sizing: border-box;
    white-space: pre-wrap;
    line-height: 1.4;
    border-bottom: 1px solid #005500;
    display: flex;
    flex-direction: column-reverse;
}

.terminal-output>div {}

.terminal-input-line {
    display: flex;
    align-items: center;
    background-color: #030303;
    padding: 8px 10px;
}

#prompt-text {
    margin-right: 8px;
    color: #00dd00;
}

.terminal-input {
    scrollbar-width: thin;
    scrollbar-color: #005500 #080808;
    flex-grow: 1;
    background-color: transparent;
    border: none;
    color: #00ff00;
    font-family: inherit;
    font-size: 1em;
    outline: none;
    padding: 0;
}

.terminal-output::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

.terminal-output::-webkit-scrollbar-track {
    background: #080808;
}

.terminal-output::-webkit-scrollbar-thumb {
    background-color: #005500;
    border-radius: 5px;
    border: 2px solid #030303;
}

.terminal-output::-webkit-scrollbar-thumb:hover {
    background-color: #007700;
}

.terminal-output::-webkit-scrollbar-corner {
    background: #030303;
}

#vitals-monitor {
    display: flex;
    flex-direction: row;
    justify-content: space-around;
    align-items: center;
    padding: 5px 8px;
    background-color: #1a1a1a;
    border-bottom: 1px solid #333;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    margin-bottom: 5px;
    height: auto;
}

.vital-bar-container {
    display: flex;
    align-items: center;
    flex-grow: 1;
    margin-right: 10px;
}

.vital-bar-container:last-child {
    margin-right: 0;
}

.vital-label {
    color: #bbb;
    margin-right: 5px;
    font-size: 0.85em;
}

.vital-bar-outer {
    flex-grow: 1;
    height: 16px;
    background-color: #333;
    border: 1px solid #555;
    border-radius: 3px;
    position: relative;
    overflow: hidden;
}

.vital-bar-inner {
    height: 100%;
    transition: width 0.3s ease-out;
    border-radius: 2px;
}

.vital-bar-text {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    color: #ffffff;
    font-size: 0.75em;
    font-weight: bold;
    text-shadow: 1px 1px 1px #000000;
    white-space: nowrap;
}

.char-list-item {
    margin-left: 20px;
}

.char-list-item .char-index {
    color: #ffff00;
}

.char-list-item .char-name {
    color: #00ff00;
}

.char-list-item .char-class {
    color: #00aaaa;
}

.room-name-header {
    color: #ffff00;
    font-weight: bold;
    margin-top: 1em;
    margin-bottom: 0.5em;
}

.error-message-inline {
    color: #ff4444;
    font-style: italic;
}

.game-message {
    color: #cccccc;
    display: block;
}

.system-message-inline {
    color: #00aa00;
    font-style: italic;
}

.inv-slot-name {
    color: #00ffff;
    font-weight: bold;
}

.inv-backpack-number {
    color: #ffff00;
}

.inv-item-name {
    color: #00ff00;
}

.inv-item-qty {
    color: #aaaaaa;
}

.inv-section-header {
    color: #f0f0f0;
    font-weight: bold;
}

.char-name {
    color: #00ff00;
}

.combat-success {
    color: #33cc33;
    font-weight: bold;
}

.combat-miss {
    color: #ff9933;
}

.combat-hit {
    color: #ffff00;
    font-weight: bold;
}

.combat-crit {
    color: #ff9900;
    font-weight: bold;
}

.combat-hp {
    color: #ffdddd;
}

.combat-death {
    color: #ff3333;
    font-weight: bold;
    font-style: italic;
}

.combat-hit-player {
    color: #ff6666;
    font-weight: bold;
}

.combat-crit-player {
    color: #cc0000;
    font-weight: bold;
}

.ooc-chat-message {
    color: #9999ff;
    font-style: italic;
}

#input-prompt-line {
    display: flex;
    align-items: center;
    padding: 0 8px;
}

#character-info-bar {
    display: flex;
    background-color: #111;
    color: #00dd00;
    padding: 6px 10px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    border-bottom: 1px solid #005500;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#character-info-bar span {
    margin: 0 5px;
}

.char-info-separator {
    color: #007700;
    font-weight: bold;
}

#char-info-name {
    font-weight: bold;
    color: #ffffff;
}

#char-info-class {
    font-style: italic;
    color: #00ffdd;
}

#char-info-level {
    font-weight: bold;
}

#bottom-info-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 10px;
    background-color: #181818;
    border-top: 1px solid #005500;
    border-bottom: 1px solid #005500;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.9em;
    color: #00cc00;
    margin-bottom: 5px;
}

#exits-display-container {
    flex-basis: 60%;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#exits-display-container b {
    color: #bbb;
}

#exits-text {
    color: #00dd00;
}

#currency-display-container {
    flex-basis: 35%;
    text-align: right;
    white-space: nowrap;
}

.currency {
    margin-left: 10px;
    font-weight: bold;
}

.currency.gold {
    color: #FFD700;
}

.currency.silver {
    color: #C0C0C0;
}

.currency.copper {
    color: #B87333;
}

.currency.platinum {
    color: #e5e4e2;
}

.shop-box-border {
    color: var(--shop-border-color);
}
.shop-box-title {
    color: var(--shop-title-color);
    font-weight: bold;
}
.shop-item-number {
    color: var(--prompt-color);
}
.shop-item-name {
    color: var(--item-name-color);
}

.terminal-line {}

.room-description {}

/* Add this to the BOTTOM of style.css */

.login-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  padding: 20px;
}

.login-form {
  background-color: #111;
  border: 1px solid #005500;
  padding: 20px 30px;
  width: 100%;
  max-width: 400px;
  box-shadow: 0 0 15px #003300;
}

.login-form h2 {
  text-align: center;
  margin-top: 0;
  color: #ffff00;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  color: #00dd00;
}

.form-group input {
  width: 100%;
  padding: 8px;
  background-color: #030303;
  border: 1px solid #005500;
  color: #00ff00;
  font-family: inherit;
  box-sizing: border-box; /* Important */
}

.login-form button {
  width: 100%;
  padding: 10px;
  background-color: #005500;
  border: 1px solid #00ff00;
  color: #00ff00;
  font-family: inherit;
  font-size: 1.1em;
  cursor: pointer;
  transition: background-color 0.2s;
}

.login-form button:hover:not(:disabled) {
  background-color: #007700;
}

.login-form button:disabled {
  background-color: #333;
  border-color: #555;
  color: #777;
  cursor: not-allowed;
}

.error-message {
    color: #ff4444;
    background-color: rgba(255, 0, 0, 0.1);
    border: 1px solid #ff4444;
    padding: 10px;
    margin-bottom: 15px;
    text-align: center;
}

/* Character Selection Screen Styles */
.char-select-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 40px;
  color: #00ff00;
}

.char-select-container h2 {
    color: #ffff00;
}

.char-list {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 20px;
}

.char-card {
  background-color: #111;
  border: 1px solid #005500;
  padding: 15px 25px;
  min-width: 200px;
  text-align: center;
  cursor: pointer;
  transition: background-color 0.2s, box-shadow 0.2s;
}

.char-card:hover {
  background-color: #002c00;
  box-shadow: 0 0 10px #00ff00;
}

.char-card h3 {
  margin: 0 0 5px 0;
  color: #ffffff;
}

.char-card p {
  margin: 0;
  color: #00ddaa;
}

.loading-screen, .error-screen {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-size: 1.5em;
}
.error-screen {
    color: #ff4444;
}
--- END OF FILE frontend/src/style.css ---

--- START OF FILE frontend/src/index.html ---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Unholy MUD of Tron & Allen1 (React Edition)</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
--- END OF FILE frontend/src/index.html ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
