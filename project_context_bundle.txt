--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Tue Jun  3 07:30:07 PM UTC 2025

--- START OF FILE backend/app/main.py ---
# backend/app/main.py
import asyncio
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
import sys # For detailed print statements
from app.core.config import settings
import logging # Import logging

# --- Setup Logging First ---
# This needs to happen before other modules that might use logging are imported,
# or at least before they try to log.
try:
    from app.core.logging_config import setup_logging
    setup_logging()
    print("--- MAIN.PY: setup_logging() CALLED (no exception caught) ---", flush=True)
except ImportError as e_log_setup:
    print(f"--- CRITICAL: main.py - FAILED to import or run setup_logging: {e_log_setup} ---", flush=True)
    sys.exit(1) # Exit if logging can't be set up, as it's crucial for debugging

logger = logging.getLogger(__name__) # Get a logger for this module

# --- Add these lines for immediate feedback on logger level ---
print(f"--- MAIN.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_main = logger.getEffectiveLevel()
print(f"--- MAIN.PY: Effective log level for 'app.main' logger = {effective_level_main} ({logging.getLevelName(effective_level_main)}) ---", flush=True)
logger.debug(f"--- MAIN.PY DEBUG LOG TEST: Top of file, Python version: {sys.version} ---") # Changed from logger.debug to ensure it prints if DEBUG is working
logger.info(f"--- MAIN.PY INFO LOG TEST: Top of file, Python version: {sys.version} ---")
# --- End of added lines ---

from app.api.v1.api_router import api_router as v1_api_router
logger.debug("--- main.py - Imported v1_api_router ---")
from app.websocket_router import router as ws_router
logger.debug("--- main.py - Imported ws_router ---")
from app.db.session import engine, get_db
logger.debug("--- main.py - Imported engine, get_db from app.db.session ---")
from app.db import base_class
logger.debug("--- main.py - Imported base_class from app.db ---")
from app.core.config import settings
logger.debug(f"--- main.py - Imported settings. Project Name: {settings.PROJECT_NAME} ---")
from app.crud.crud_room import seed_initial_world
logger.debug("--- main.py - Imported seed_initial_world ---")
from app.crud.crud_item import seed_initial_items 
logger.debug("--- main.py - Imported seed_initial_items ---")
from app.crud.crud_mob import seed_initial_mob_templates
logger.debug("--- main.py - Imported seed_initial_mob_templates ---")
from app.game_logic.combat_manager import start_combat_ticker_task, stop_combat_ticker_task
logger.debug("--- main.py - Imported combat_manager tasks ---")
from app.crud.crud_character_class import seed_initial_character_class_templates 
logger.debug("--- main.py - Imported seed_initial_character_class_templates ---")
from app.crud.crud_skill import seed_initial_skill_templates 
logger.debug("--- main.py - Imported seed_initial_skill_templates ---")
from app.crud.crud_trait import seed_initial_trait_templates 
logger.debug("--- main.py - Imported seed_initial_trait_templates ---")
from app.game_logic.world_ticker import start_world_ticker_task, stop_world_ticker_task
logger.debug("--- main.py - Imported world_ticker tasks ---")
from app.crud.crud_mob_spawn_definition import seed_initial_mob_spawn_definitions 
logger.debug("--- main.py - Imported seed_initial_mob_spawn_definitions ---")

logger.debug("--- main.py - About to call Base.metadata.create_all(bind=engine) ---")
try:
    base_class.Base.metadata.create_all(bind=engine)
    logger.info("--- main.py - Base.metadata.create_all(bind=engine) COMPLETED ---")
except Exception as e:
    logger.error(f"--- main.py - ERROR during Base.metadata.create_all: {e} ---", exc_info=True)
    # Depending on the severity, you might want to sys.exit() here

logger.debug("--- main.py - Creating FastAPI app instance ---")
app = FastAPI(title=settings.PROJECT_NAME)
logger.info("--- main.py - FastAPI app instance CREATED ---")

@app.on_event("startup")
def on_startup_sync(): # Renamed to avoid clash if we make it async later
    logger.info("--- main.py - START of on_startup_sync event ---")
    db: Session = next(get_db())
    logger.debug("--- main.py - on_startup_sync: Acquired DB session ---")
    try:
        logger.info("--- main.py - on_startup_sync: Running startup event: Seeding initial world... ---")
        seed_initial_world(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_world COMPLETED ---")
        seed_initial_mob_templates(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_templates COMPLETED ---")
        seed_initial_items(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_items COMPLETED ---")
        seed_initial_character_class_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_character_class_templates COMPLETED ---")
        seed_initial_skill_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_skill_templates COMPLETED ---")
        seed_initial_trait_templates(db) # Make sure this is imported if you uncomment it
        logger.debug("--- main.py - on_startup_sync: seed_initial_trait_templates COMPLETED ---")
        seed_initial_mob_spawn_definitions(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_spawn_definitions COMPLETED ---")
        
        logger.info("--- main.py - on_startup_sync: Starting combat ticker... ---")
        start_combat_ticker_task()
        logger.debug("--- main.py - on_startup_sync: Combat ticker STARTED ---")      

        logger.info("--- main.py - on_startup_sync: Starting world ticker... ---") 
        start_world_ticker_task()    
        logger.debug("--- main.py - on_startup_sync: World ticker STARTED ---")     
        logger.info("--- main.py - on_startup_sync: Startup event processing FINISHED ---")
    except Exception as e_startup:
        logger.error(f"--- main.py - ERROR during on_startup_sync: {e_startup} ---", exc_info=True)
    finally:
        logger.debug("--- main.py - on_startup_sync: Closing DB session ---")
        db.close()
        logger.debug("--- main.py - on_startup_sync: DB session CLOSED ---")
    logger.info("--- main.py - END of on_startup_sync event ---")

logger.debug("--- main.py - About to include v1_api_router ---")
app.include_router(v1_api_router, prefix=settings.API_V1_STR)
logger.debug("--- main.py - v1_api_router INCLUDED ---")

logger.debug("--- main.py - About to include ws_router ---")
app.include_router(ws_router)
logger.debug("--- main.py - ws_router INCLUDED ---")

@app.get("/")
async def root():
    logger.debug("--- main.py - GET / request received ---")
    return {"message": f"Welcome to {settings.PROJECT_NAME}. Now with a World Ticker humming in the background!"}

logger.info("--- main.py - FastAPI app instance configured. End of file. ---")
--- END OF FILE backend/app/main.py ---

--- START OF FILE backend/app/core/config.py ---
# backend/app/core/config.py
import os
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict

# Check if we're likely running in an Alembic 'env.py' context BEFORE settings are needed for DB connection
# This is a heuristic. Alembic sets 'alembic.version' in its context.
# A simpler heuristic: if a specific env var for alembic is set.
IS_ALEMBIC_ENV_PY_CONTEXT = os.getenv("ALEMBIC_ENV_PY_RUNNING") == "true"

class Settings(BaseSettings):
    PROJECT_NAME: str = "MUD Project - Backend"
    API_V1_STR: str = "/api/v1"
    
    DATABASE_URL: Optional[str] = "postgresql://dummy_user:dummy_password@dummy_host:5432/dummy_db" if IS_ALEMBIC_ENV_PY_CONTEXT else os.getenv("DATABASE_URL", "postgresql://user:password@db/llmud_db") # Added os.getenv for normal case
    SECRET_KEY: str = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7" # CHANGE THIS IN PRODUCTION!
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7 # Token expires in 7 days

    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO").upper() # Default to INFO

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8', extra='ignore')

settings = Settings() 

# After instantiation, if it was a dummy, ensure it's overridden if not in Alembic context
# and the real env var is available.
if IS_ALEMBIC_ENV_PY_CONTEXT and settings.DATABASE_URL is not None and "dummy_user" in settings.DATABASE_URL:
    # logger.info("Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.") # Can't use logger before setup
    print("INFO: Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.")
elif not IS_ALEMBIC_ENV_PY_CONTEXT and os.getenv("DATABASE_URL"):
    settings.DATABASE_URL = os.getenv("DATABASE_URL") # Ensure it's set from env if not in alembic context
elif not IS_ALEMBIC_ENV_PY_CONTEXT and not os.getenv("DATABASE_URL"):
    # This will have already failed in Settings() if '...' was used and no env var
    # logger.warning("DATABASE_URL not found in environment for normal app run!") # Can't use logger before setup
    print("WARNING: DATABASE_URL not found in environment for normal app run!")
--- END OF FILE backend/app/core/config.py ---

--- START OF FILE backend/app/core/security.py ---
# backend/app/core/security.py
from datetime import datetime, timedelta, timezone # Use timezone-aware datetimes
from typing import Optional, Any, Union
from jose import JWTError, jwt # Import from jose
from passlib.context import CryptContext

from ..core.config import settings # Import our settings instance

# Initialize CryptContext. We'll use bcrypt.
# "auto" will use the first scheme (bcrypt) for hashing new passwords
# and will also be able to verify passwords hashed with any scheme listed.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(subject: Union[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode = {"exp": expire, "sub": str(subject)} # "sub" is the standard claim for subject (e.g., player_id)
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
--- END OF FILE backend/app/core/security.py ---

--- START OF FILE backend/app/db/session.py ---
# backend/app/db/session.py
import time
from sqlalchemy import create_engine, exc
from sqlalchemy.orm import sessionmaker
from ..core.config import settings

if settings.DATABASE_URL is None:
    raise ValueError("DATABASE_URL is not set in the environment or configuration.")

MAX_RETRIES = 10
RETRY_DELAY = 5 # seconds

def create_db_engine_with_retries():
    for attempt in range(MAX_RETRIES):
        try:
            assert settings.DATABASE_URL is not None, "DATABASE_URL cannot be None"
            engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)
            # Try to establish a connection to check if DB is ready
            with engine.connect() as connection:
                print("Database connection successful.")
                return engine
        except exc.OperationalError as e:
            print(f"Database connection attempt {attempt + 1}/{MAX_RETRIES} failed: {e}")
            if attempt < MAX_RETRIES - 1:
                print(f"Retrying in {RETRY_DELAY} seconds...")
                time.sleep(RETRY_DELAY)
            else:
                print("Max retries reached. Could not connect to the database.")
                raise
    # This line should ideally not be reached if MAX_RETRIES > 0
    # but as a fallback or if MAX_RETRIES is 0:
    raise exc.OperationalError("Could not connect to database after multiple retries or no retries configured.", params=None, orig=None) # type: ignore


engine = create_db_engine_with_retries()

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    """
    FastAPI dependency that provides a database session.
    It ensures the session is closed after the request is finished.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
--- END OF FILE backend/app/db/session.py ---

--- START OF FILE backend/app/db/base_class.py ---
# backend/app/db/base_class.py
from sqlalchemy.orm import declarative_base
Base = declarative_base()
--- END OF FILE backend/app/db/base_class.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

# Import settings to check LOG_LEVEL if needed, though it should be set by main
from app.core.config import settings

from app.db.session import SessionLocal
from app import crud, models, schemas
from app.core.config import settings
from app.websocket_manager import connection_manager
from app.game_logic import combat_manager
from app.commands.utils import (
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message,
    resolve_mob_target
)
from app.game_state import is_character_resting, set_character_resting_status


logger = logging.getLogger(__name__)
# --- Add these lines for immediate feedback on logger level ---
print(f"--- WEBSOCKET_ROUTER.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True) # Check settings value at import time
effective_level_ws = logger.getEffectiveLevel()
print(f"--- WEBSOCKET_ROUTER.PY: Effective log level for '{logger.name}' logger = {effective_level_ws} ({logging.getLevelName(effective_level_ws)}) ---", flush=True)
logger.debug("--- WEBSOCKET_ROUTER.PY DEBUG LOG TEST: Module loaded ---")
logger.info("--- WEBSOCKET_ROUTER.PY INFO LOG TEST: Module loaded ---")
# --- End of added lines ---

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str)
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError):
        return None

async def _handle_websocket_move_if_not_in_combat(
    db: Session,
    player: models.Player,
    character_state: models.Character,
    command_verb: str, 
    command_args_str: str 
) -> None:
    """
    Handles actual movement logic IF THE PLAYER IS NOT IN COMBAT.
    Updates character location, broadcasts, and sends new room state.
    """
    message_to_player_on_move: Optional[str] = None # Not used here, as combat breaking msgs are handled before calling this
    moved_successfully = False
    target_room_orm_for_move: Optional[models.Room] = None
    
    direction_map = combat_manager.direction_map # Use shared map
    
    raw_direction_input = ""
    if command_verb == "go":
        if command_args_str:
            raw_direction_input = command_args_str.split(" ", 1)[0].lower()
        else:
            # This assumes current_room_schema_for_command is available or fetched
            room_schema = schemas.RoomInDB.from_orm(crud.crud_room.get_room_by_id(db, character_state.current_room_id)) if character_state.current_room_id else None
            await combat_manager.send_combat_log(player.id, ["Go where?"], room_data=room_schema)
            return
    else:
        raw_direction_input = command_verb.lower()

    target_direction_canonical = direction_map.get(raw_direction_input, raw_direction_input)

    current_room_schema_for_fail = schemas.RoomInDB.from_orm(crud.crud_room.get_room_by_id(db, character_state.current_room_id)) if character_state.current_room_id else None

    if target_direction_canonical not in direction_map.values():
        await combat_manager.send_combat_log(player.id, ["That's not a valid direction."], room_data=current_room_schema_for_fail)
        return

    old_room_id = character_state.current_room_id
    current_room_orm_before_move = crud.crud_room.get_room_by_id(db, room_id=old_room_id) 
    
    if current_room_orm_before_move:
        current_exits = current_room_orm_before_move.exits or {}
        if target_direction_canonical in current_exits:
            next_room_uuid_str = current_exits.get(target_direction_canonical)
            if next_room_uuid_str:
                try:
                    target_room_uuid = uuid.UUID(hex=next_room_uuid_str)
                    potential_target_room_orm = crud.crud_room.get_room_by_id(db, room_id=target_room_uuid)
                    if potential_target_room_orm:
                        target_room_orm_for_move = potential_target_room_orm
                        moved_successfully = True
                    else: message_to_player_on_move = "The path ahead seems to vanish."
                except ValueError: message_to_player_on_move = "The exit appears corrupted."
            else: message_to_player_on_move = "The way is unclear."
        else: message_to_player_on_move = "You can't go that way."
    else: message_to_player_on_move = "Error: Current room data not found."


    if moved_successfully and target_room_orm_for_move:
        crud.crud_character.update_character_room(db, character_id=character_state.id, new_room_id=target_room_orm_for_move.id)
        new_room_schema = schemas.RoomInDB.from_orm(target_room_orm_for_move)
        
        player_ids_in_old_room = [char.player_id for char in crud.crud_character.get_characters_in_room(db, room_id=old_room_id, exclude_character_id=character_state.id) if connection_manager.is_player_connected(char.player_id)]
        if player_ids_in_old_room:
            leave_msg = f"<span class='char-name'>{character_state.name}</span> leaves, heading {target_direction_canonical}."
            await connection_manager.broadcast_to_players({"type": "game_event", "message": leave_msg}, player_ids_in_old_room)

        player_ids_in_new_room_others = [char.player_id for char in crud.crud_character.get_characters_in_room(db, room_id=target_room_orm_for_move.id, exclude_character_id=character_state.id) if connection_manager.is_player_connected(char.player_id)]
        if player_ids_in_new_room_others:
            arrival_direction = combat_manager.get_opposite_direction(target_direction_canonical)
            arrive_msg = f"<span class='char-name'>{character_state.name}</span> arrives from the {arrival_direction}."
            await connection_manager.broadcast_to_players({"type": "game_event", "message": arrive_msg}, player_ids_in_new_room_others)
        
        arrival_message_parts: List[str] = []
        # message_to_player_on_move is for failure or pre-move messages; success is new room desc
        
        items_in_new_room = crud.crud_room_item.get_items_in_room(db, room_id=target_room_orm_for_move.id)
        ground_items_text, _ = format_room_items_for_player_message(items_in_new_room)
        if ground_items_text: arrival_message_parts.append(ground_items_text)
            
        mobs_in_new_room = crud.crud_mob.get_mobs_in_room(db, room_id=target_room_orm_for_move.id)
        mobs_text, _ = format_room_mobs_for_player_message(mobs_in_new_room)
        if mobs_text: arrival_message_parts.append(mobs_text)

        other_chars_in_new_room = crud.crud_character.get_characters_in_room(db, room_id=target_room_orm_for_move.id, exclude_character_id=character_state.id)
        chars_text_mover = format_room_characters_for_player_message(other_chars_in_new_room)
        if chars_text_mover: arrival_message_parts.append(chars_text_mover)
        
        final_arrival_message_str = "\n".join(filter(None, arrival_message_parts)).strip()
        
        await combat_manager.send_combat_log(player.id, [final_arrival_message_str] if final_arrival_message_str else [], room_data=new_room_schema, combat_ended=False)
    else: 
        await combat_manager.send_combat_log(player.id, [message_to_player_on_move] if message_to_player_on_move else ["You cannot move that way."], room_data=current_room_schema_for_fail, combat_ended=False)


@router.websocket("/ws") 
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character: Optional[models.Character] = None 

    with get_db_sync() as db: 
        player = await get_player_from_token(token, db)
        if not player:
            logger.warning(f"WebSocket connection attempt with invalid token for char_id: {character_id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return
        character_orm_initial = crud.crud_character.get_character(db, character_id=character_id)
        if not character_orm_initial or character_orm_initial.player_id != player.id:
            logger.warning(f"WebSocket connection attempt for invalid char_id: {character_id} by player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character = character_orm_initial 
    
    await connection_manager.connect(websocket, player.id, character.id)
    logger.info(f"Player {player.id} (Character {character.id}) connected via WebSocket.")
    
    initial_messages = [f"Welcome {character.name}! You are connected."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db: 
        initial_room_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.")
            items_on_ground = crud.crud_room_item.get_items_in_room(db, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: initial_messages.append(items_text)
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: initial_messages.append(mobs_text)
            other_chars_in_room = crud.crud_character.get_characters_in_room(db, room_id=initial_room_orm.id, exclude_character_id=character.id)
            chars_text_initial = format_room_characters_for_player_message(other_chars_in_room)
            if chars_text_initial: initial_messages.append(chars_text_initial)
    
    xp_for_next_level = crud.crud_character.get_xp_for_level(character.level + 1)

    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump() if initial_room_schema else None,
        "character_vitals": { # Nesting them under a key is good practice
            "current_hp": character.current_health,
            "max_hp": character.max_health,
            "current_mp": character.current_mana,
            "max_mp": character.max_mana,
            "current_xp": character.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character.level,
            "platinum": character.platinum_coins, # <<< NEW
            "gold": character.gold_coins,     # <<< NEW
            "silver": character.silver_coins, # <<< NEW
            "copper": character.copper_coins  # <<< NEW
            # For more advanced XP bar:
            # "xp_at_start_of_current_level": int(xp_at_start_of_current_level) if xp_at_start_of_current_level != float('inf') else 0,
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)


    try:
        while True:
            received_data = await websocket.receive_json()
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            with get_db_sync() as db_loop: 
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character.id)
                if not current_char_state: 
                    logger.error(f"Character state lost for char_id: {character.id} during WebSocket loop.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost")
                    break 
                
                current_room_for_command_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_for_command_orm) if current_room_for_command_orm else None

                logger.debug(f"WS command from Player {player.id} (Char {character.id}): '{command_text}' in room {current_char_state.current_room_id}")

                verb_for_rest_check = command_text.split(" ", 1)[0].lower() if command_text else ""
                
                non_breaking_verbs = [
                    "rest", "look", "l", "score", "sc", "status", "st", 
                    "help", "?", "skills", "sk", "traits", "tr", 
                    "inventory", "i", "ooc", "say", "'", "emote", ":" 
                ]
                movement_verbs = ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]

                if verb_for_rest_check and verb_for_rest_check not in non_breaking_verbs and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat_manager.send_combat_log(player.id, ["You stop resting."], room_data=current_room_schema_for_command)

                if message_type == "command" and command_text:
                    verb = verb_for_rest_check 
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""

                    # --- NEW DEBUG PRINT ---
                    logger.debug(f"ROUTER: Processing verb='{verb}', args='{args_str}'")

                    if verb == "rest":
                        if current_char_state.id in combat_manager.active_combats:
                            await combat_manager.send_combat_log(player.id, ["You cannot rest while in combat."], room_data=current_room_schema_for_command)
                        elif is_character_resting(current_char_state.id):
                            await combat_manager.send_combat_log(player.id, ["You are already resting."], room_data=current_room_schema_for_command)
                        elif current_char_state.current_health == current_char_state.max_health and \
                             current_char_state.current_mana == current_char_state.max_mana:
                            await combat_manager.send_combat_log(player.id, ["You are already fully rejuvenated."], room_data=current_room_schema_for_command)
                        else:
                            set_character_resting_status(current_char_state.id, True)
                            await combat_manager.send_combat_log(player.id, ["You sit down and begin to rest."], room_data=current_room_schema_for_command)
                            if current_room_for_command_orm: 
                                await combat_manager._broadcast_combat_event( 
                                    db_loop, current_room_for_command_orm.id, player.id, 
                                    f"<span class='char-name'>{current_char_state.name}</span> sits down to rest."
                                )
                        continue # Assuming rest command should end processing for this message                    
                    elif verb in movement_verbs: # e.g., "n", "s", "e", "w", "u", "d", "go"
                        # --- NEW DEBUG PRINT ---
                        logger.debug(f"ROUTER: ENTERED movement_verbs block for verb='{verb}'")
                        # --- DEBUG PRINTS START (These are the ones you said were not printing) ---
                        logger.debug(f"MOVEMENT: CharID: {current_char_state.id}, Verb: '{verb}', Args: '{args_str}'")
                        is_in_active_combats = current_char_state.id in combat_manager.active_combats
                        logger.debug(f"MOVEMENT: Is CharID in active_combats? {is_in_active_combats}")
                        targets_for_char = None
                        if is_in_active_combats:
                            targets_for_char = combat_manager.active_combats.get(current_char_state.id)
                            logger.debug(f"MOVEMENT: Targets for char from active_combats: {targets_for_char}")
                        
                        condition_to_block = is_in_active_combats and bool(targets_for_char) # Explicitly check boolean of targets
                        logger.debug(f"MOVEMENT: Condition to block movement: {condition_to_block}")
                        # --- DEBUG PRINTS END ---

                        # Check for combat BEFORE attempting movement
                        if condition_to_block: # Use the debugged condition
                            logger.debug(f"MOVEMENT: BLOCKED movement for CharID: {current_char_state.id}") # DEBUG
                            current_room_for_msg = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                            room_schema_for_msg = schemas.RoomInDB.from_orm(current_room_for_msg) if current_room_for_msg else None
                            await combat_manager.send_combat_log(
                                player.id,
                                ["You cannot move while in combat! Try 'flee <direction>' or 'flee'."],
                                room_data=room_schema_for_msg,
                                transient=True 
                            )
                            continue # Skip movement logic
                        else:
                            logger.debug(f"MOVEMENT: ALLOWED movement for CharID: {current_char_state.id}") # DEBUG

                        # If "go", parse direction from args_str
                        direction_to_move_verb = verb 
                        direction_to_move_args = args_str

                        if verb == "go":
                            if not args_str:
                                current_room_for_msg = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                                room_schema_for_msg = schemas.RoomInDB.from_orm(current_room_for_msg) if current_room_for_msg else None
                                await combat_manager.send_combat_log(player.id, ["Go where?"], room_data=room_schema_for_msg, transient=True)
                                continue
                            # For "go", the verb is "go" and args_str is the direction
                        
                        # Player is NOT in combat, proceed with movement
                        await _handle_websocket_move_if_not_in_combat(
                            db_loop, player, current_char_state, direction_to_move_verb, direction_to_move_args
                        )
                        continue
                    
                    elif verb == "flee":
                        if current_char_state.id in combat_manager.active_combats and combat_manager.active_combats.get(current_char_state.id):
                            flee_direction_arg = args_str.split(" ", 1)[0].lower() if args_str else "random"
                            
                            canonical_flee_dir = "random"
                            if flee_direction_arg != "random":
                                canonical_flee_dir = combat_manager.direction_map.get(flee_direction_arg, flee_direction_arg)
                                if canonical_flee_dir not in combat_manager.direction_map.values():
                                    current_room_for_msg = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                                    room_schema_for_msg = schemas.RoomInDB.from_orm(current_room_for_msg) if current_room_for_msg else None
                                    await combat_manager.send_combat_log(player.id, [f"Invalid flee direction '{flee_direction_arg}'. Try 'flee' or 'flee <direction>'."], room_data=room_schema_for_msg, transient=True)
                                    continue 

                            combat_manager.character_queued_actions[current_char_state.id] = f"flee {canonical_flee_dir}"
                            await combat_manager.send_combat_log(player.id, [f"You prepare to flee {canonical_flee_dir if canonical_flee_dir != 'random' else '...'}"]) # No room_data needed, not a room state change yet
                        else:
                            current_room_for_msg = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                            room_schema_for_msg = schemas.RoomInDB.from_orm(current_room_for_msg) if current_room_for_msg else None
                            await combat_manager.send_combat_log(player.id, ["You are not in combat."], room_data=room_schema_for_msg, transient=True)
                        continue
                    elif verb in ["attack", "atk", "kill", "k"]:
                        if not args_str: 
                            await combat_manager.send_combat_log(player.id, ["Attack what?"], room_data=current_room_schema_for_command)
                        elif not current_room_for_command_orm: 
                             await combat_manager.send_combat_log(player.id, ["Error: Current room unknown for attack."], room_data=None)
                        else:
                            mobs_in_char_room = crud.crud_mob.get_mobs_in_room(db_loop, room_id=current_char_state.current_room_id)
                            if not mobs_in_char_room:
                                await combat_manager.send_combat_log(player.id, ["There is nothing here to attack."], room_data=current_room_schema_for_command)
                            else:
                                target_mob_instance, error_or_prompt = resolve_mob_target(args_str, mobs_in_char_room)
                                if error_or_prompt:
                                    await combat_manager.send_combat_log(player.id, [error_or_prompt], room_data=current_room_schema_for_command)
                                elif target_mob_instance:
                                    is_already_in_any_combat = current_char_state.id in combat_manager.active_combats
                                    is_already_targeting_this_specific_mob = False
                                    if is_already_in_any_combat and target_mob_instance.id in combat_manager.active_combats.get(current_char_state.id, set()):
                                        is_already_targeting_this_specific_mob = True
                                    if not is_already_in_any_combat:
                                        await combat_manager.initiate_combat_session(db_loop, player.id, current_char_state.id, current_char_state.name, target_mob_instance.id)
                                    elif not is_already_targeting_this_specific_mob: 
                                        combat_manager.active_combats.setdefault(current_char_state.id, set()).add(target_mob_instance.id)
                                        combat_manager.mob_targets[target_mob_instance.id] = current_char_state.id 
                                        combat_manager.character_queued_actions[current_char_state.id] = f"attack {target_mob_instance.id}"
                                        await combat_manager.send_combat_log(player.id, [f"You switch your attack to the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>!"], room_data=current_room_schema_for_command)
                                    else: 
                                        combat_manager.character_queued_actions[current_char_state.id] = f"attack {target_mob_instance.id}"
                    elif verb == "use": # Handle 'use <skill_name> [target_ref]'
                        if not args_str:
                            await combat_manager.send_combat_log(player.id, ["Use what skill? (And on whom/what, if applicable?)"], room_data=current_room_schema_for_command)
                            continue

                        args_list = args_str.split() # Define args_list from args_str

                        # Split input into potential skill name part and potential target part
                        # e.g., "ba giant rat" -> skill_input_part = "ba", potential_target_str = "giant rat"
                        # e.g., "basic punch" -> skill_input_part = "basic punch", potential_target_str = ""
                        # e.g., "ba"          -> skill_input_part = "ba", potential_target_str = ""
                        
                        # Try to intelligently split skill from target.
                        # This is a simple approach; more complex parsing might be needed for multi-word skill names AND multi-word targets.
                        # For now, we assume the first "word(s)" could be the skill, and the rest is the target.
                        # We'll iterate to find the longest skill name match.

                        learned_skill_tags = current_char_state.learned_skills or []
                        if not learned_skill_tags:
                            await combat_manager.send_combat_log(player.id, ["You haven't learned any skills."], room_data=current_room_schema_for_command)
                            continue

                        possible_skill_matches: List[Tuple[models.SkillTemplate, str]] = [] # (SkillTemplate, remaining_args_for_target)

                        for i in range(len(args_list), 0, -1): # Try matching 1 word, then 2 words, etc. from args_list for skill name
                            current_skill_input_part = " ".join(args_list[:i]).lower()
                            current_potential_target_str = " ".join(args_list[i:]).strip()

                            for skill_tag in learned_skill_tags:
                                skill_template_db = crud.crud_skill.get_skill_template_by_tag(db_loop, skill_id_tag=skill_tag)
                                if not skill_template_db:
                                    continue
                                
                                # Match against skill_id_tag OR player-facing name
                                if skill_template_db.skill_id_tag.lower().startswith(current_skill_input_part) or \
                                   skill_template_db.name.lower().startswith(current_skill_input_part):
                                    # Check if this exact skill_template is already found with a shorter target string (prefer longer skill match)
                                    already_found_better_match = False
                                    for existing_match, _ in possible_skill_matches:
                                        if existing_match.id == skill_template_db.id:
                                            already_found_better_match = True
                                            break
                                    if not already_found_better_match:
                                        possible_skill_matches.append((skill_template_db, current_potential_target_str))
                            
                            if possible_skill_matches and len(current_skill_input_part.split()) > 0 : # If we found matches with current_skill_input_part, break to prefer longer skill name matches
                                break # This prioritizes matching "basic punch" over "basic" if both are typed for "basic punch some target"


                        selected_skill_template: Optional[models.SkillTemplate] = None
                        remaining_args_for_target_str: str = ""

                        if not possible_skill_matches:
                            await combat_manager.send_combat_log(player.id, [f"No skill found matching '{args_list[0].lower() if args_list else args_str}'."], room_data=current_room_schema_for_command) # Added check for empty args_list
                            continue
                        elif len(possible_skill_matches) == 1:
                            selected_skill_template = possible_skill_matches[0][0]
                            remaining_args_for_target_str = possible_skill_matches[0][1]
                        else: # Multiple partial matches
                            # Refine matches: if an exact match for skill_input_part exists, prefer it.
                            exact_match_skill = None
                            skill_input_first_part_lower = args_list[0].lower() if args_list else "" # Added check for empty args_list
                            for sm_template, sm_target_args in possible_skill_matches:
                                if sm_template.name.lower() == skill_input_first_part_lower or sm_template.skill_id_tag.lower() == skill_input_first_part_lower:
                                    exact_match_skill = sm_template
                                    remaining_args_for_target_str = sm_target_args
                                    break
                            
                            if exact_match_skill:
                                selected_skill_template = exact_match_skill
                            else:
                                skill_names = list(set([st.name for st, _ in possible_skill_matches])) # Use set to avoid duplicates if tag and name both matched
                                await combat_manager.send_combat_log(player.id, [f"Multiple skills match. Be more specific: {', '.join(skill_names)}"], room_data=current_room_schema_for_command)
                                continue
                        
                        # At this point, selected_skill_template is the uniquely matched skill
                        target_mob_id_for_skill_queue: Optional[str] = "None" 
                        resolved_mob_target_for_skill: Optional[models.RoomMobInstance] = None

                        if selected_skill_template.target_type in ["ENEMY_MOB", "FRIENDLY_CHAR"]: # Skills requiring a mob/char target
                            mobs_in_char_room = crud.crud_mob.get_mobs_in_room(db_loop, room_id=current_char_state.current_room_id)
                            # TODO: Add other players to mobs_in_char_room if target_type can be FRIENDLY_CHAR

                            if remaining_args_for_target_str: # User specified a target string
                                resolved_mob_target_for_skill, error_or_prompt = resolve_mob_target(remaining_args_for_target_str, mobs_in_char_room)
                                if error_or_prompt:
                                    await combat_manager.send_combat_log(player.id, [error_or_prompt], room_data=current_room_schema_for_command)
                                    continue
                                if not resolved_mob_target_for_skill:
                                    await combat_manager.send_combat_log(player.id, [f"Could not find target '{remaining_args_for_target_str}'."], room_data=current_room_schema_for_command)
                                    continue
                                target_mob_id_for_skill_queue = str(resolved_mob_target_for_skill.id)
                            else: # No target specified by user for a skill that needs one
                                current_combat_targets = combat_manager.active_combats.get(current_char_state.id)
                                if current_combat_targets: # Character is in combat
                                    if len(current_combat_targets) == 1:
                                        implicit_target_id = list(current_combat_targets)[0]
                                        # Fetch mob instance to check health and for name in prep message
                                        resolved_mob_target_for_skill = crud.crud_mob.get_room_mob_instance(db_loop, room_mob_instance_id=implicit_target_id) # Changed to get_room_mob_instance
                                        if resolved_mob_target_for_skill and resolved_mob_target_for_skill.current_health > 0:
                                            target_mob_id_for_skill_queue = str(implicit_target_id)
                                        else:
                                            await combat_manager.send_combat_log(player.id, ["Your current combat target is invalid or already defeated."], room_data=current_room_schema_for_command)
                                            continue
                                    else: # In combat with multiple targets
                                        await combat_manager.send_combat_log(player.id, [f"The skill '{selected_skill_template.name}' requires a target. You are fighting multiple enemies, please specify one."], room_data=current_room_schema_for_command)
                                        continue
                                else: # Not in combat, no target specified, skill needs one
                                    await combat_manager.send_combat_log(player.id, [f"The skill '{selected_skill_template.name}' requires a target. Who do you want to use it on?"], room_data=current_room_schema_for_command)
                                    continue
                        
                        # --- Initiate combat if necessary (out of combat, valid target for skill, skill is offensive) ---
                        is_offensive_skill = selected_skill_template.skill_type == "COMBAT_ACTIVE" and selected_skill_template.target_type == "ENEMY_MOB" # Add more conditions if needed
                        
                        if is_offensive_skill and \
                           resolved_mob_target_for_skill and \
                           resolved_mob_target_for_skill.id not in combat_manager.active_combats.get(current_char_state.id, set()):
                            
                            await combat_manager.initiate_combat_session(
                                db_loop, player.id, current_char_state.id, current_char_state.name, resolved_mob_target_for_skill.id
                            )
                            # Combat is initiated, the skill will be queued against this target.

                        # --- Queue the skill action ---
                        combat_manager.character_queued_actions[current_char_state.id] = f"use_skill {selected_skill_template.skill_id_tag} {target_mob_id_for_skill_queue}"
                        
                        target_name_for_prep_msg = ""
                        if target_mob_id_for_skill_queue != "None":
                            # Try to get name from resolved_mob_target_for_skill if it was set (e.g. new target or implicit single combat target)
                            mob_for_name = resolved_mob_target_for_skill
                            if not mob_for_name and target_mob_id_for_skill_queue and target_mob_id_for_skill_queue.lower() != "none": # Added check for "none"
                                try:
                                    mob_for_name = crud.crud_mob.get_room_mob_instance(db_loop, room_mob_instance_id=uuid.UUID(target_mob_id_for_skill_queue)) # Changed to get_room_mob_instance
                                except ValueError: # Should not happen if ID is valid UUID string
                                    pass
                            if mob_for_name:
                                target_name_for_prep_msg = f" on <span class='inv-item-name'>{mob_for_name.mob_template.name}</span>"
                            else: # Fallback if name couldn't be fetched
                                target_name_for_prep_msg = " on the specified target"


                        await combat_manager.send_combat_log(
                            player.id,
                            [f"You prepare to use <span class='skill-name'>{selected_skill_template.name}</span>{target_name_for_prep_msg}."],
                            room_data=current_room_schema_for_command
                        )
                        continue # End of 'use' command processing for this message
                    # Remove or comment out the old 'use_skill' block that started with:
                    # elif command_verb == "use_skill": 
                    # (This was likely a direct command from HTTP or an older system)
                    elif verb == "flee":
                        if current_char_state.id in combat_manager.active_combats:
                            flee_direction_arg = args_str.split(" ", 1)[0].lower() if args_str else "random"
                            
                            # Validate flee_direction_arg against canonical directions or "random"
                            # combat_manager.direction_map includes short versions. We need canonical for the action string.
                            canonical_flee_dir = "random"
                            if flee_direction_arg != "random":
                                canonical_flee_dir = combat_manager.direction_map.get(flee_direction_arg, flee_direction_arg)
                                if canonical_flee_dir not in combat_manager.direction_map.values(): # Check against full direction names
                                    await combat_manager.send_combat_log(player.id, [f"Invalid flee direction '{flee_direction_arg}'. Try 'flee' or 'flee <direction>'."], room_data=current_room_schema_for_command)
                                    continue # Skip queueing invalid flee

                            combat_manager.character_queued_actions[current_char_state.id] = f"flee {canonical_flee_dir}"
                            await combat_manager.send_combat_log(player.id, ["You prepare to flee..."], room_data=current_room_schema_for_command)
                        else:
                            await combat_manager.send_combat_log(player.id, ["You are not in combat."], room_data=current_room_schema_for_command, transient=True)
                        continue
                    elif verb in ["look", "l"]: 
                        look_messages = []
                        if current_room_for_command_orm: 
                            items_on_ground = crud.crud_room_item.get_items_in_room(db_loop, current_room_for_command_orm.id)
                            items_text, _ = format_room_items_for_player_message(items_on_ground)
                            if items_text: look_messages.append(items_text)
                            mobs_in_current_room = crud.crud_mob.get_mobs_in_room(db_loop, current_room_for_command_orm.id)
                            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_current_room)
                            if mobs_text: look_messages.append(mobs_text)
                            other_chars_look = crud.crud_character.get_characters_in_room(db_loop, room_id=current_room_for_command_orm.id, exclude_character_id=current_char_state.id)
                            chars_text_look = format_room_characters_for_player_message(other_chars_look)
                            if chars_text_look: look_messages.append(chars_text_look)
                        await combat_manager.send_combat_log(player.id, look_messages, room_data=current_room_schema_for_command)
                        continue # Add this if missing
                    elif verb not in ["rest"] + movement_verbs + ["attack", "atk", "kill", "k", "flee", "look", "l"]:
                         await combat_manager.send_combat_log(
                            player.id, 
                            [f"Command '{verb}' not supported over WebSocket here. Try 'help' or HTTP commands."], 
                            room_data=current_room_schema_for_command
                        )
                elif message_type != "command": 
                    await combat_manager.send_combat_log(player.id, [f"Unrecognized message type: {message_type}."], room_data=current_room_schema_for_command)
                elif message_type == "command" and not command_text:
                     await combat_manager.send_combat_log(player.id, ["Empty command received."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'} (Character {character.id if character else 'N/A'})")
        if character and character.id: 
            combat_manager.end_combat_for_character(character.id, reason="websocket_disconnect")
            if is_character_resting(character.id):
                set_character_resting_status(character.id, False)
    except Exception as e:
        err_player_id = player.id if player else "Unknown Player"
        err_char_id = character.id if character else "Unknown Character"
        logger.error(f"Error in WebSocket for Player {err_player_id} (Character {err_char_id}): {e}", exc_info=True)
        try:
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred."})
        except Exception as send_err: # Catch error during sending error
            logger.error(f"Failed to send error to WebSocket for Player {err_player_id} (Character {err_char_id}): {send_err}")
    finally:
        if player and player.id: 
            connection_manager.disconnect(player.id) 
            if character and character.id and is_character_resting(character.id): 
                set_character_resting_status(character.id, False)
        char_id_for_log = character.id if character else "N/A"
        player_id_for_log = player.id if player else "N/A"
        logger.info(f"WebSocket connection for Player {player_id_for_log} (Character {char_id_for_log}) fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/websocket_manager.py ---
# backend/app/websocket_manager.py
import uuid
from typing import Dict, List, Optional
from fastapi import WebSocket
from fastapi.encoders import jsonable_encoder

class ConnectionManager:
    def __init__(self):
        # player_id -> WebSocket mapping
        self.active_player_connections: Dict[uuid.UUID, WebSocket] = {}
        # player_id -> active_character_id mapping (CRUCIAL for WS knowing context)
        self.player_active_characters: Dict[uuid.UUID, uuid.UUID] = {}

    async def connect(self, websocket: WebSocket, player_id: uuid.UUID, character_id: uuid.UUID):
        await websocket.accept()
        self.active_player_connections[player_id] = websocket
        self.player_active_characters[player_id] = character_id # Associate character with this WS connection
        print(f"Player {player_id} (Character {character_id}) connected via WebSocket.")

    def disconnect(self, player_id: uuid.UUID):
        if player_id in self.active_player_connections:
            del self.active_player_connections[player_id]
        if player_id in self.player_active_characters:
            del self.player_active_characters[player_id]
        print(f"Player {player_id} disconnected from WebSocket.")

    def get_character_id(self, player_id: uuid.UUID) -> Optional[uuid.UUID]:
        return self.player_active_characters.get(player_id)

    async def send_personal_message(self, message_payload: dict, player_id: uuid.UUID): # Expects a dict
        if player_id in self.active_player_connections:
            websocket = self.active_player_connections[player_id]
            try:
                encoded_payload = jsonable_encoder(message_payload) # <<< USE JSONABLE ENCODER
                await websocket.send_json(encoded_payload)
            except Exception as e:
                # Log the original payload to see what might have caused an issue
                # Be careful logging sensitive data in production
                print(f"Error sending WS message to {player_id}: {e} (Original payload structure might be an issue for encoding: {type(message_payload)})")
                # For more detailed debug, print keys and types of values in message_payload
                # for k, v in message_payload.items():
                #     print(f"DEBUG PAYLOAD: key='{k}', type='{type(v)}'")
                #     if k == 'room_data' and v is not None:
                #         for rk, rv in v.items() if isinstance(v, dict) else vars(v).items() if hasattr(v, '__dict__') else []:
                #              print(f"  RoomData Sub: key='{rk}', type='{type(rv)}'")


    async def broadcast_to_room(self, message: dict, room_id: uuid.UUID, db_session_getter, current_player_id_to_skip: Optional[uuid.UUID] = None):
        # This is more advanced: requires knowing which players/characters are in which room
        # For now, this is a placeholder for future room-based broadcasts
        # It would iterate through self.active_player_connections, get their char_id,
        # then query DB (via db_session_getter) for char's room_id.
        print(f"Placeholder: Broadcast to room {room_id}: {message}")
        # For a simple broadcast to all connected (not room specific):
        # for player_id, websocket in self.active_player_connections.items():
        #     if player_id != current_player_id_to_skip:
        #         try:
        #             await websocket.send_json(message)
        #         except Exception:
        #             pass # Handle send errors or disconnects

    async def broadcast_to_players(self, message_payload: dict, player_ids: List[uuid.UUID]):
        """Sends a message to a specific list of connected player_ids."""
        encoded_payload = jsonable_encoder(message_payload)
        for player_id in player_ids:
            if player_id in self.active_player_connections:
                websocket = self.active_player_connections[player_id]
                try:
                    await websocket.send_json(encoded_payload)
                except Exception as e:
                    print(f"Error broadcasting to player {player_id}: {e}")
                    # Handle any specific cleanup or logging here
    def is_player_connected(self, player_id: uuid.UUID) -> bool:
        return player_id in self.active_player_connections
    
    def get_all_active_player_ids(self) -> List[uuid.UUID]: # Helper
        return list(self.active_player_connections.keys())

# Global instance
connection_manager = ConnectionManager()
--- END OF FILE backend/app/websocket_manager.py ---

--- START OF FILE backend/app/game_logic/combat_manager.py ---
# backend/app/game_logic/combat_manager.py
from typing import Dict, List, Set, Optional, Any, Tuple
import asyncio # Ensure asyncio is imported
import random # Ensure random is imported
import uuid # Ensure uuid is imported
import logging # Import logging

from sqlalchemy.orm import Session, joinedload 

from app.db.session import SessionLocal 
from app import crud, models, schemas 
from app.websocket_manager import connection_manager as ws_manager # Ensure ws_manager is imported
from app.commands.utils import roll_dice, format_room_mobs_for_player_message, format_room_items_for_player_message 
from app.game_state import is_character_resting, set_character_resting_status 

logger = logging.getLogger(__name__) # Get a logger for this module

direction_map = {"n": "north", "s": "south", "e": "east", "w": "west", "u": "up", "d": "down"}


from contextlib import contextmanager
@contextmanager
def db_session_for_task_sync(): 
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

active_combats: Dict[uuid.UUID, Set[uuid.UUID]] = {} 
mob_targets: Dict[uuid.UUID, uuid.UUID] = {} 
character_queued_actions: Dict[uuid.UUID, Optional[str]] = {} 

COMBAT_ROUND_INTERVAL = 3.0

async def _handle_mob_death_loot_and_cleanup(
    db: Session,
    character: models.Character, 
    killed_mob_instance: models.RoomMobInstance,
    log_messages_list: List[str], 
    player_id: uuid.UUID, 
    current_room_id_for_broadcast: uuid.UUID
) -> models.Character: # Return type is just models.Character now
    mob_template = killed_mob_instance.mob_template 
    character_after_loot = character # Start with the incoming character

    logger.debug(f"LOOT: Handling death of {mob_template.name if mob_template else 'Unknown Mob'}")

    # 1. Award XP
    if mob_template and mob_template.xp_value > 0:
        logger.debug(f"LOOT: Awarding {mob_template.xp_value} XP.")
        updated_char_for_xp, xp_messages = crud.crud_character.add_experience(
            db, character_after_loot.id, mob_template.xp_value
        )
        if updated_char_for_xp:
            character_after_loot = updated_char_for_xp 
        log_messages_list.extend(xp_messages)
    elif not mob_template:
        logger.warning(f"LOOT: No mob_template found for killed_mob_instance {killed_mob_instance.id}")


    # 2. Award Currency
    platinum_dropped, gold_dropped, silver_dropped, copper_dropped = 0, 0, 0, 0

    if mob_template and mob_template.currency_drop: # Check if mob_template itself is not None
        cd = mob_template.currency_drop 
        logger.debug(f"LOOT: Mob has currency_drop definition: {cd}")
        
        copper_dropped = random.randint(cd.get("c_min", 0), cd.get("c_max", 0))
        
        if random.randint(1, 100) <= cd.get("s_chance", 0):
            silver_dropped = random.randint(cd.get("s_min", 0), cd.get("s_max", 0))
        if random.randint(1, 100) <= cd.get("g_chance", 0):
            gold_dropped = random.randint(cd.get("g_min", 0), cd.get("g_max", 0))
        if random.randint(1, 100) <= cd.get("p_chance", 0): # Assuming you added platinum (p_ fields)
            platinum_dropped = random.randint(cd.get("p_min", 0), cd.get("p_max", 0))
        
        logger.debug(f"LOOT: Rolled drops - P:{platinum_dropped}, G:{gold_dropped}, S:{silver_dropped}, C:{copper_dropped}")

    else:
        if not mob_template:
             logger.debug(f"LOOT: No mob_template, so no currency_drop check.")
        elif mob_template: # Check if mob_template exists before accessing its name
             logger.debug(f"LOOT: Mob template {mob_template.name} has no currency_drop definition.")
        else: # Should not happen if the outer 'if mob_template' was false
             logger.debug(f"LOOT: Mob template is None, no currency_drop definition.")


    if platinum_dropped > 0 or gold_dropped > 0 or silver_dropped > 0 or copper_dropped > 0:
        logger.debug(f"LOOT: Attempting to update character currency...")
        updated_char_for_currency, currency_message = crud.crud_character.update_character_currency(
            db, character_after_loot.id, platinum_dropped, gold_dropped, silver_dropped, copper_dropped
        )
        if updated_char_for_currency:
             character_after_loot = updated_char_for_currency
             logger.debug(f"LOOT: Currency updated. Message: {currency_message}")
        else:
            logger.warning(f"LOOT: crud.update_character_currency returned None for character.")

        
        drop_messages_parts = []
        # Use the actual dropped amounts for the message    
        if platinum_dropped > 0: drop_messages_parts.append(f"{platinum_dropped}p")
        if gold_dropped > 0: drop_messages_parts.append(f"{gold_dropped}g")
        if silver_dropped > 0: drop_messages_parts.append(f"{silver_dropped}s")
        if copper_dropped > 0: drop_messages_parts.append(f"{copper_dropped}c")
        
        if drop_messages_parts:
             log_messages_list.append(f"The {mob_template.name} drops: {', '.join(drop_messages_parts)}.")
             log_messages_list.append(currency_message) 
    elif mob_template and mob_template.currency_drop: # Only log this if there was a currency_drop table but rolls were 0
        logger.debug(f"LOOT: All currency drop rolls were zero.")


    # 3. Item Loot (Placeholder for future)
    # ...

    # 4. Despawn and Cleanup Combat State
    logger.debug(f"LOOT: Despawning mob {killed_mob_instance.id} and cleaning combat state.")
    crud.crud_mob.despawn_mob_from_room(db, killed_mob_instance.id) # This commits
    active_combats.get(character_after_loot.id, set()).discard(killed_mob_instance.id) # Use character_after_loot.id
    mob_targets.pop(killed_mob_instance.id, None)
    
    return character_after_loot # Return the potentially updated character object


async def resolve_skill_effect(
    db: Session,
    character: models.Character,
    skill_template: models.SkillTemplate,
    target_mob_instance: Optional[models.RoomMobInstance], # Target can be None for self-buffs etc.
    player_id: uuid.UUID, # For sending logs
    current_room_id_for_broadcast: uuid.UUID # For broadcasting echoes
) -> Tuple[List[str], bool, Optional[models.Character]]: # Returns (log_messages, was_successful_and_action_taken, updated_character_obj)
    """
    Resolves the effects of a used skill.
    Returns a list of log messages for the player, a boolean indicating if an action was taken,
    and the potentially updated character object (e.g., after XP gain from a kill).
    """
    skill_log: List[str] = []
    action_taken = False
    char_combat_stats = character.calculate_combat_stats() # Get fresh stats
    # This character object might be updated by _handle_mob_death_loot_and_cleanup, so we'll return it.
    character_after_skill = character 

    # 1. Check Mana Cost
    mana_cost = skill_template.effects_data.get("mana_cost", 0)
    if character.current_mana < mana_cost:
        skill_log.append(f"You don't have enough mana to use {skill_template.name} (needs {mana_cost}, have {character.current_mana}).")
        return skill_log, False, character_after_skill

    # 2. Pay Mana Cost (if any)
    if mana_cost > 0:
        # Ensure character object is the one from the current DB session if passed around
        # For this function, 'character' is the one passed in.
        character.current_mana -= mana_cost 
        db.add(character) # Mark for commit by the main process_combat_round
        skill_log.append(f"You spend {mana_cost} mana.")

    # 3. Apply Effects based on skill_id_tag
    action_taken = True # Assume action taken if mana paid, can be set to False if other checks fail

    if skill_template.skill_id_tag == "basic_punch":
        if not target_mob_instance or target_mob_instance.current_health <= 0:
            skill_log.append(f"Your target for {skill_template.name} is invalid or already defeated.")
            return skill_log, False, character_after_skill

        mob_ac = target_mob_instance.mob_template.base_defense if target_mob_instance.mob_template.base_defense is not None else 10
        unarmed_attack_bonus = char_combat_stats["attack_bonus"]
        unarmed_damage_dice = "1d2" 
        unarmed_damage_bonus = char_combat_stats["damage_bonus"]

        to_hit_roll = roll_dice("1d20")
        if (to_hit_roll + unarmed_attack_bonus) >= mob_ac:
            damage = max(1, roll_dice(unarmed_damage_dice) + unarmed_damage_bonus)
            skill_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>PUNCHES</span> <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for <span class='combat-hit'>{damage}</span> damage.")
            await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                          f"<span class='char-name'>{character.name}</span> PUNCHES <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for {damage} damage!")
            
            updated_mob = crud.crud_mob.update_mob_instance_health(db, target_mob_instance.id, -damage) # This commits
            if updated_mob and updated_mob.current_health <= 0:
                skill_log.append(f"<span class='combat-death'>The {target_mob_instance.mob_template.name} DIES! Good punch, champ.</span>")
                await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"The <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> DIES!")
                # Call helper for XP, loot, despawn, and combat state cleanup
                character_after_skill = await _handle_mob_death_loot_and_cleanup(
                    db, character, updated_mob, skill_log, player_id, current_room_id_for_broadcast
                )
            elif updated_mob:
                 skill_log.append(f"  {target_mob_instance.mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{target_mob_instance.mob_template.base_health}</span>.")
        else: # Punch misses
            skill_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> with a punch.")
            await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                          f"<span class='char-name'>{character.name}</span> MISSES the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> with a punch.")

    elif skill_template.skill_id_tag == "power_attack_melee":
        if not target_mob_instance or target_mob_instance.current_health <= 0:
            skill_log.append(f"Your target for {skill_template.name} is invalid or already defeated.")
            return skill_log, False, character_after_skill

        mob_ac = target_mob_instance.mob_template.base_defense if target_mob_instance.mob_template.base_defense is not None else 10
        skill_effects = skill_template.effects_data
        attack_roll_modifier = skill_effects.get("attack_roll_modifier", 0)
        damage_modifier_flat = skill_effects.get("damage_modifier_flat", 0)
        # uses_equipped_weapon = skill_effects.get("uses_equipped_weapon", True) # Assumed for Power Attack

        player_attack_bonus = char_combat_stats["attack_bonus"]
        player_damage_dice = char_combat_stats["damage_dice"]
        player_damage_bonus = char_combat_stats["damage_bonus"]
        final_attack_bonus = player_attack_bonus + attack_roll_modifier
        
        to_hit_roll = roll_dice("1d20")
        if (to_hit_roll + final_attack_bonus) >= mob_ac:
            base_weapon_damage = roll_dice(player_damage_dice)
            total_damage = max(1, base_weapon_damage + player_damage_bonus + damage_modifier_flat)
            
            skill_log.append(f"<span class='char-name'>{character.name}</span> unleashes a <span class='combat-success'>POWER ATTACK</span> on <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>, hitting for <span class='combat-hit'>{total_damage}</span> damage!")
            await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                          f"<span class='char-name'>{character.name}</span> POWER ATTACKS <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for {total_damage} damage!")
            
            updated_mob = crud.crud_mob.update_mob_instance_health(db, target_mob_instance.id, -total_damage) # This commits
            if updated_mob and updated_mob.current_health <= 0:
                skill_log.append(f"<span class='combat-death'>The {target_mob_instance.mob_template.name} is OBLITERATED by the Power Attack!</span>")
                await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"The <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> DIES from a mighty blow!")
                # Call helper for XP, loot, despawn, and combat state cleanup
                character_after_skill = await _handle_mob_death_loot_and_cleanup(
                    db, character, updated_mob, skill_log, player_id, current_room_id_for_broadcast
                )
            elif updated_mob:
                 skill_log.append(f"  {target_mob_instance.mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{target_mob_instance.mob_template.base_health}</span>.")
        else: # Power Attack misses
            skill_log.append(f"<span class='char-name'>{character.name}</span>'s <span class='combat-miss'>Power Attack</span> against <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> goes wide!")
            await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                          f"<span class='char-name'>{character.name}</span> misses a Power Attack on <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>.")
    else:
        skill_log.append(f"The skill '{skill_template.name}' is not fully implemented yet. Nothing happens except you waste a turn, dummy.")
        action_taken = False 

    # 4. TODO: Handle Cooldowns
    # if action_taken and skill_template.cooldown and skill_template.cooldown > 0:
    #    # ...
    #    skill_log.append(f"{skill_template.name} is now on cooldown.")

    return skill_log, action_taken, character_after_skill

def end_combat_for_character(character_id: uuid.UUID, reason: str = "unknown"):
    if character_id in active_combats:
        mobs_character_was_fighting = list(active_combats.pop(character_id, set()))
        for mob_id in mobs_character_was_fighting:
            if mob_id in mob_targets and mob_targets[mob_id] == character_id:
                mob_targets.pop(mob_id, None)
        # print(f"Combat ended for character {character_id}. Reason: {reason}. Active mobs for char cleared.") # Verbose
    else: 
        mobs_to_clear_target_for = [mid for mid, cid_target in mob_targets.items() if cid_target == character_id]
        for mid_clear in mobs_to_clear_target_for:
            mob_targets.pop(mid_clear, None)
    character_queued_actions.pop(character_id, None)


async def mob_initiates_combat(db: Session, mob_instance: models.RoomMobInstance, target_character: models.Character):
    if not mob_instance or mob_instance.current_health <= 0: return
    if not target_character or target_character.current_health <= 0: return
    if target_character.id in active_combats and mob_instance.id in active_combats[target_character.id]: return 
    logger.info(f"COMBAT: {mob_instance.mob_template.name} initiates combat with {target_character.name}!")
    active_combats.setdefault(target_character.id, set()).add(mob_instance.id)
    mob_targets[mob_instance.id] = target_character.id  
    mob_name_html = f"<span class='inv-item-name'>{mob_instance.mob_template.name}</span>"
    char_name_html = f"<span class='char-name'>{target_character.name}</span>"
    initiation_message_to_player_parts = []
    if is_character_resting(target_character.id): 
        set_character_resting_status(target_character.id, False)
        initiation_message_to_player_parts.append("<span class='combat-warning'>You are startled from your rest!</span>")
    initiation_message_to_player_parts.append(f"{mob_name_html} turns its baleful gaze upon you and <span class='combat-hit-player'>attacks!</span>")
    player_room_orm = crud.crud_room.get_room_by_id(db, room_id=target_character.current_room_id)
    player_room_schema = schemas.RoomInDB.from_orm(player_room_orm) if player_room_orm else None
    await send_combat_log(player_id=target_character.player_id, messages=initiation_message_to_player_parts, room_data=player_room_schema)
    broadcast_message = f"{mob_name_html} shrieks and <span class='combat-hit-player'>attacks</span> {char_name_html}!"
    if "<span class='combat-warning'>You are startled from your rest!</span>" in " ".join(initiation_message_to_player_parts):
         broadcast_message = f"{char_name_html} is startled from their rest as {mob_name_html} <span class='combat-hit-player'>attacks</span>!"
    await _broadcast_combat_event(db, mob_instance.room_id, target_character.player_id, broadcast_message)

def is_mob_in_any_player_combat(mob_id: uuid.UUID) -> bool:
    for _character_id, targeted_mob_ids in active_combats.items():
        if mob_id in targeted_mob_ids:
            return True
    return False

async def send_combat_log(
    player_id: uuid.UUID, 
    messages: List[str], 
    combat_ended: bool = False, 
    room_data: Optional[schemas.RoomInDB] = None,
    character_vitals: Optional[Dict[str, Any]] = None,
    transient: bool = False # <<< NEW
):
    if not messages and not combat_ended and not room_data:
        return
    payload = {
        "type": "combat_update", # or "transient_message" if transient else "combat_update"
        "log": messages,
        "combat_over": combat_ended,
        "room_data": room_data.model_dump() if room_data else None,
        "character_vitals": character_vitals,
        "is_transient_log": transient # <<< NEW
    }
    await ws_manager.send_personal_message(payload, player_id)

async def _broadcast_to_room_participants(
    db: Session, 
    room_id: uuid.UUID, 
    message: str, 
    exclude_player_id: Optional[uuid.UUID] = None
):
    """Broadcasts a message to all connected players in a room, optionally excluding the acting player."""
    excluded_character_id: Optional[uuid.UUID] = None
    if exclude_player_id:
        excluded_character_id = ws_manager.get_character_id(exclude_player_id)

    characters_to_notify = crud.crud_character.get_characters_in_room(
        db, 
        room_id=room_id, 
        exclude_character_id=excluded_character_id
    )
    
    player_ids_to_send_to = [
        char.player_id for char in characters_to_notify 
        if ws_manager.is_player_connected(char.player_id)
    ]
            
    if player_ids_to_send_to:
        await ws_manager.broadcast_to_players(
            {"type": "game_event", "message": message}, 
            player_ids_to_send_to
        )

async def _broadcast_combat_event(db: Session, room_id: uuid.UUID, acting_player_id: uuid.UUID, message: str):
    acting_char_id: Optional[uuid.UUID] = ws_manager.get_character_id(acting_player_id)
    player_ids_to_notify = [
        char.player_id for char in crud.crud_character.get_characters_in_room(db, room_id=room_id, exclude_character_id=acting_char_id)
        if ws_manager.is_player_connected(char.player_id) and char.player_id != acting_player_id
    ]
    if player_ids_to_notify:
        await ws_manager.broadcast_to_players({"type": "game_event", "message": message}, player_ids_to_notify)

async def initiate_combat_session(
    db: Session, player_id: uuid.UUID, character_id: uuid.UUID, character_name: str, target_mob_instance_id: uuid.UUID
):
    mob_instance_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_instance_id)
    if not mob_instance_check or mob_instance_check.current_health <= 0:
        await send_combat_log(player_id, ["Target is invalid or already dead."])
        return False
    character_check = crud.crud_character.get_character(db, character_id=character_id)
    if not character_check or character_check.current_health <= 0:
        await send_combat_log(player_id, ["You are too dead or incapacitated to start combat."])
        return False
    personal_log_messages = []
    if is_character_resting(character_check.id): 
        set_character_resting_status(character_check.id, False)
        personal_log_messages.append("You leap into action, abandoning your rest!")
    active_combats.setdefault(character_id, set()).add(target_mob_instance_id)
    mob_targets[target_mob_instance_id] = character_id 
    character_queued_actions[character_id] = f"attack {target_mob_instance_id}"
    engagement_message = f"<span class='char-name'>{character_name}</span> engages the <span class='inv-item-name'>{mob_instance_check.mob_template.name}</span>!"
    personal_log_messages.append(engagement_message)
    current_room_orm = crud.crud_room.get_room_by_id(db, character_check.current_room_id)
    current_room_schema = schemas.RoomInDB.from_orm(current_room_orm) if current_room_orm else None
    await send_combat_log(player_id, personal_log_messages, room_data=current_room_schema)
    return True

async def combat_ticker_loop():
    while True:
        await asyncio.sleep(COMBAT_ROUND_INTERVAL)
        # logger.debug("Combat ticker loop iteration starting...") # Can be very verbose
        with db_session_for_task_sync() as db:
            # Create a copy of player_ids to iterate over, as the original dict might change
            # if players disconnect during the loop.
            player_ids_to_process = list(ws_manager.active_player_connections.keys())
            
            for player_id in player_ids_to_process:
                character_id = ws_manager.get_character_id(player_id) # Get char_id for this player
                
                # Check if player is still connected and has a character_id
                if not character_id:
                    # logger.debug(f"Player {player_id} has no character_id or disconnected, skipping combat processing.")
                    continue

                if character_id in active_combats:
                    # logger.debug(f"Processing combat round for Character ID: {character_id} (Player ID: {player_id})")
                    try:
                        await process_combat_round(db, character_id, player_id)
                    except Exception as e_combat_round:
                        logger.error(f"Error during process_combat_round for char {character_id}: {e_combat_round}", exc_info=True)
                        # Decide if combat should be ended for this character due to error
                        end_combat_for_character(character_id, reason=f"error_in_round: {e_combat_round}")
                        try:
                            await send_combat_log(player_id, ["A server error occurred during combat. Combat has ended."], combat_ended=True)
                        except Exception as e_send_err:
                            logger.error(f"Failed to send combat error log to player {player_id}: {e_send_err}")
                # else:
                    # logger.debug(f"Character ID: {character_id} (Player ID: {player_id}) not in active_combats.")
        # logger.debug("Combat ticker loop iteration finished.")

_combat_ticker_task = None
def start_combat_ticker_task():
    global _combat_ticker_task
    if _combat_ticker_task is None:
        logger.info("Starting combat ticker task...")
        _combat_ticker_task = asyncio.create_task(combat_ticker_loop())
        logger.info("Combat ticker task created.")
    else:
        logger.info("Combat ticker task already running or requested.")
def stop_combat_ticker_task():
    global _combat_ticker_task
    if _combat_ticker_task and not _combat_ticker_task.done():
        logger.info("Stopping combat ticker task...")
        _combat_ticker_task.cancel()
        _combat_ticker_task = None
        logger.info("Combat ticker task cancelled.")


async def process_combat_round(db: Session, character_id: uuid.UUID, player_id: uuid.UUID):
    # --- Initial Character & Combat State Checks ---
    if character_id not in active_combats or not active_combats[character_id]:
        # Character is not in active combat or has no targets. Clean up if necessary.
        if character_id in active_combats: active_combats.pop(character_id, None)
        character_queued_actions.pop(character_id, None)
        # No log needed here, as there's no "round" to process for this character.
        return

    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character: 
        # Character data gone, critical error. Clean up combat states.
        active_combats.pop(character_id, None)
        mobs_to_clear_target = [mid for mid, cid in mob_targets.items() if cid == character_id]
        for mid in mobs_to_clear_target: mob_targets.pop(mid, None)
        character_queued_actions.pop(character_id, None)
        logger.critical(f"Character {character_id} not found during combat round processing.")
        return

    if character.current_health <= 0:
        # Character is dead. Send final message and clean up.
        round_log_dead_char = ["You are dead and cannot act."]
        active_combats.pop(character_id, None) # Remove from active combat
        mobs_to_clear_target = [mid for mid, cid in mob_targets.items() if cid == character_id]
        for mid in mobs_to_clear_target: mob_targets.pop(mid, None)
        character_queued_actions.pop(character_id, None)
        
        # Fetch final state for vitals and room data for the log
        final_char_state_for_vitals = crud.crud_character.get_character(db, character_id=character_id)
        vitals_for_payload = None
        current_room_schema_for_update = None
        if final_char_state_for_vitals: # Should exist
            current_room_for_update = crud.crud_room.get_room_by_id(db, room_id=final_char_state_for_vitals.current_room_id)
            current_room_schema_for_update = schemas.RoomInDB.from_orm(current_room_for_update) if current_room_for_update else None
            xp_for_next_lvl = crud.crud_character.get_xp_for_level(final_char_state_for_vitals.level + 1)
            vitals_for_payload = {
                "current_hp": final_char_state_for_vitals.current_health, "max_hp": final_char_state_for_vitals.max_health,
                "current_mp": final_char_state_for_vitals.current_mana, "max_mp": final_char_state_for_vitals.max_mana,
                "current_xp": final_char_state_for_vitals.experience_points,
                "next_level_xp": int(xp_for_next_lvl) if xp_for_next_lvl != float('inf') else -1,
                "level": final_char_state_for_vitals.level
            }
        await send_combat_log(player_id, round_log_dead_char, True, current_room_schema_for_update, character_vitals=vitals_for_payload)
        return
    # --- End Initial Checks ---

    # --- Round Setup ---
    char_combat_stats = character.calculate_combat_stats()
    # player_current_hp is character.current_health, updated directly on character model
    # player_max_hp is character.max_health
    player_ac = char_combat_stats["effective_ac"]
    
    round_log: List[str] = [] 
    combat_resolved_this_round = False # Flag if combat ends this round
    action_str = character_queued_actions.get(character_id)
    character_queued_actions[character_id] = None # Consume the action
    current_room_id_for_broadcast = character.current_room_id

    # --- Player's Action Processing ---
    if action_str and action_str.startswith("flee"):
        action_parts = action_str.split(" ", 1)
        # command_verb_from_queue = action_parts[0] # "flee"
        flee_direction_canonical = action_parts[1] if len(action_parts) > 1 and action_parts[1] else "random"

        if random.random() < 0.6: # 60% chance to flee successfully (adjust as needed)
            new_room_id, flee_departure_msg, flee_arrival_msg, _ = await _perform_server_side_move(
                db, character, flee_direction_canonical, player_id
            )

            if new_room_id:
                round_log.append(f"<span class='combat-success'>{flee_departure_msg}</span>")
                if flee_arrival_msg: round_log.append(flee_arrival_msg) # Append arrival to personal log
                
                # Character object's current_room_id is updated by _perform_server_side_move
                # The db.commit() and db.refresh(character) at the end of process_combat_round
                # will persist this and ensure the final payload uses the new room.
                combat_resolved_this_round = True # Combat ends for this player due to successful flee
                # The general combat cleanup logic for combat_resolved_this_round will handle active_combats.pop etc.
            else:
                # Flee movement failed (e.g., no exit, tried random but stuck)
                round_log.append(f"<span class='combat-miss'>You try to flee {flee_direction_canonical if flee_direction_canonical != 'random' else ''}, but there's nowhere to go!</span>")
                # Combat continues, action consumed.
        else: # Flee roll failed
            round_log.append("<span class='combat-miss'>Your attempt to flee fails! You stumble.</span>")
            await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                          f"<span class='char-name'>{character.name}</span> tries to flee, but stumbles!")
            # Combat continues, action consumed.
    elif action_str and action_str.startswith("attack"):
        try:
            target_mob_id_str = action_str.split(" ", 1)[1]
            target_mob_id = uuid.UUID(target_mob_id_str)
        except (IndexError, ValueError): target_mob_id = None

        if target_mob_id and target_mob_id in active_combats.get(character_id, set()):
            mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_id)
            if mob_instance and mob_instance.current_health > 0:
                mob_template = mob_instance.mob_template
                mob_ac = mob_template.base_defense if mob_template.base_defense is not None else 10
                
                player_attack_bonus = char_combat_stats["attack_bonus"]
                player_damage_dice = char_combat_stats["damage_dice"]
                player_damage_bonus = char_combat_stats["damage_bonus"]
                
                to_hit_roll = roll_dice("1d20")
                if (to_hit_roll + player_attack_bonus) >= mob_ac:
                    damage = max(1, roll_dice(player_damage_dice) + player_damage_bonus)
                    damage_class = "combat-hit" # Add crit logic later if desired
                    
                    round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>HITS</span> <span class='inv-item-name'>{mob_template.name}</span> for <span class='{damage_class}'>{damage}</span> damage.")
                    await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"<span class='char-name'>{character.name}</span> HITS <span class='inv-item-name'>{mob_template.name}</span> for {damage} damage!")

                    updated_mob = crud.crud_mob.update_mob_instance_health(db, mob_instance.id, -damage)
                    if updated_mob and updated_mob.current_health <= 0: # Mob Dies
                        round_log.append(f"<span class='combat-death'>The {mob_template.name} DIES! Fucking finally.</span>")
                        await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                      f"The <span class='inv-item-name'>{mob_template.name}</span> DIES!")
                        
                        # Call the centralized handler for XP, loot, despawn, and combat state cleanup
                        # This will also update the character object if they level up, etc.
                        character = await _handle_mob_death_loot_and_cleanup(
                            db, character, updated_mob, round_log, player_id, current_room_id_for_broadcast
                        )
                        # The _handle_mob_death_loot_and_cleanup function now handles:
                        # - XP award and adding messages to round_log
                        # - Currency drop and adding messages to round_log
                        # - Despawning the mob (crud.crud_mob.despawn_mob_from_room)
                        # - Removing mob from active_combats and mob_targets
                        
                    elif updated_mob:
                        round_log.append(f"  {mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{mob_template.base_health}</span>.")
                else: # Player Misses
                    round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{mob_template.name}</span>.")
                    await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"<span class='char-name'>{character.name}</span> MISSES the <span class='inv-item-name'>{mob_template.name}</span>.")
            else: # Target mob is invalid or dead
                if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id) # Clean from current combat
                round_log.append(f"Your target seems to have vanished or was already dealt with.")
        else: # Invalid target_mob_id or target not in this combat
             round_log.append("You swing wildly at nothing in particular. What a muppet.")
    
    elif action_str and action_str.startswith("use_skill"):
        parts = action_str.split(" ", 2) 
        skill_id_tag = parts[1] if len(parts) > 1 else None
        target_mob_id_str_from_queue = parts[2] if len(parts) > 2 and parts[2].lower() != "none" else None
        
        target_mob_instance_for_skill: Optional[models.RoomMobInstance] = None
        if target_mob_id_str_from_queue:
            try:
                target_mob_uuid = uuid.UUID(target_mob_id_str_from_queue)
                if target_mob_uuid in active_combats.get(character_id, set()): # Ensure target is part of current combat
                    target_mob_instance_for_skill = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_uuid)
                    if not target_mob_instance_for_skill or target_mob_instance_for_skill.current_health <=0:
                        round_log.append("Your skill target is no longer valid.")
                        target_mob_instance_for_skill = None # Invalidate if dead
                else:
                    round_log.append(f"You can't use that skill on something you're not fighting.")
            except ValueError:
                round_log.append(f"Invalid target ID for skill in queue.")
        
        skill_template = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_id_tag) if skill_id_tag else None

        if skill_template and (skill_template.target_type == "NONE" or skill_template.target_type == "SELF" or target_mob_instance_for_skill):
            # For targeted skills, ensure target_mob_instance_for_skill is valid
            # For non-targeted (self/none), target_mob_instance_for_skill will be None, which is fine for resolve_skill_effect
            if skill_template.target_type == "ENEMY_MOB" and not target_mob_instance_for_skill:
                 round_log.append(f"The skill '{skill_template.name}' requires a valid enemy target.")
            else:
                skill_messages, action_successful, character_after_skill_attempt = await resolve_skill_effect(
                    db, character, skill_template, target_mob_instance_for_skill, player_id, current_room_id_for_broadcast
                )
                round_log.extend(skill_messages)
                if not action_successful and not any("don't have enough mana" in m.lower() for m in skill_messages):
                     round_log.append(f"Your attempt to use {skill_template.name} fizzles.")
        elif skill_template and skill_template.target_type == "ENEMY_MOB" and not target_mob_instance_for_skill:
            round_log.append(f"You need a valid target to use '{skill_template.name}'.")
        else:
            round_log.append(f"You try to use a skill '{skill_id_tag}', but it's invalid or you can't find the target.")
            
    elif not action_str: # No action was queued (e.g. mob initiated, or player didn't input in time for a prior system)
        round_log.append("You pause, unsure of your next move.")
        # Or default to a very basic action, or just let mobs act. For now, just a pause.

    # Check if all player's targets are defeated after player's action (e.g., skill killed last mob)
    # This check needs to be robust: iterate all mob_ids in active_combats[character_id]
    # and see if they are all dead or removed.
    current_targets_for_player = list(active_combats.get(character_id, set()))
    all_targets_down = True
    if not current_targets_for_player: # No targets left in the set
        all_targets_down = True
    else:
        for mob_target_id in current_targets_for_player:
            mob_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_target_id)
            if mob_check and mob_check.current_health > 0:
                all_targets_down = False
                break
    
    if all_targets_down:
        if not combat_resolved_this_round: # Avoid double message if flee already resolved it
            round_log.append("All your targets are defeated or gone. Combat ends.")
        combat_resolved_this_round = True


    # --- Mobs' Actions (Retaliation) ---
    if not combat_resolved_this_round and character.current_health > 0:
        # Get mobs that are targeting this character AND are in this character's current combat session
        mobs_attacking_this_round = []
        for mob_id, target_char_id in mob_targets.items():
            if target_char_id == character_id: # This mob is targeting the player
                # Check if this mob is one the player is actively fighting
                if mob_id in active_combats.get(character_id, set()):
                    mob_instance_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id)
                    if mob_instance_check and mob_instance_check.current_health > 0:
                        mobs_attacking_this_round.append(mob_instance_check)
        
        for mob_instance in mobs_attacking_this_round:
            if character.current_health <= 0: break # Player died from a previous mob this round

            mob_template = mob_instance.mob_template
            mob_attack_bonus = mob_template.level or 1 
            mob_damage_dice = mob_template.base_attack or "1d4" # Ensure template has base_attack
            mob_to_hit = roll_dice("1d20")

            if (mob_to_hit + mob_attack_bonus) >= player_ac:
                damage_to_player = max(1, roll_dice(mob_damage_dice))
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-success'>HITS</span> <span class='char-name'>{character.name}</span> for <span class='combat-hit-player'>{damage_to_player}</span> damage. Ouch, buttercup.")
                await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> HITS <span class='char-name'>{character.name}</span> for {damage_to_player} damage!")
                
                # Update character health directly on the character object for this round's logic
                character.current_health -= damage_to_player 
                
                round_log.append(f"  Your HP: <span class='combat-hp'>{character.current_health}/{character.max_health}</span>.")
                
                if character.current_health <= 0:
                    character.current_health = 0 # Ensure health doesn't go negative on the object
                    
                    # Persist the death state (health 0) by directly setting and staging
                    # The crud.crud_character.update_character_health is relative, not absolute.
                    db.add(character) # Stage the health change to 0

                    round_log.append("<span class='combat-death'>YOU HAVE DIED! How utterly predictable.</span>")
                    await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"<span class='char-name'>{character.name}</span> <span class='combat-death'>HAS DIED!</span>")
                    
                    combat_resolved_this_round = True # Combat ends for this player

                    # --- Respawn Logic ---
                    max_health_at_death = character.max_health # Store before potential changes

                    respawn_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0) # Central starting point
                    if respawn_room_orm:
                        # Update character's room in DB.
                        updated_char_after_room_move = crud.crud_character.update_character_room(db, character_id=character.id, new_room_id=respawn_room_orm.id)
                        if updated_char_after_room_move:
                            character = updated_char_after_room_move # IMPORTANT: reassign character
                            round_log.append(f"A mystical force whisks your fading spirit away. You awaken, gasping, in <span class='room-name'>{respawn_room_orm.name}</span>.")
                        else:
                            round_log.append("Error: Failed to update character room during respawn. Your soul is lost.")
                            # active_combats, mob_targets, character_queued_actions are cleaned up by combat_resolved_this_round logic
                            break # Critical error, stop processing for this player this round
                    else:
                        round_log.append("Error: Respawn room (0,0,0) not found. Your soul wanders aimlessly, still dead where you fell.")
                        # Character remains in the death room. Health is already 0. No further healing.
                        # active_combats, etc., cleaned up by combat_resolved_this_round logic
                        break # Stop processing for this player this round

                    # Full heal on respawn - directly set current_health to max_health_at_death
                    character.current_health = max_health_at_death 
                    db.add(character) # Stage the health change
                    # The 'character' variable now refers to the ORM object, potentially in the new room, with full health staged.
                    # The db.commit() and db.refresh(character) at the end of process_combat_round will save and refresh.
                    round_log.append("You feel a surge of life, your wounds miraculously healed.")
                    
                    # Combat state cleanup (active_combats, mob_targets, character_queued_actions)
                    # will be handled by the general 'if combat_resolved_this_round:' block later.
                    
                    break # Stop further mob attacks this round since player died and respawned/healed
                else:
                    # If player didn't die from this mob's attack, persist their health change
                    # crud.crud_character.update_character_health expects a delta.
                    # Since character.current_health was already reduced, we stage the character object.
                    db.add(character) # Stage the health change from this mob's attack
            else: # Mob Misses
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-miss'>MISSES</span> <span class='char-name'>{character.name}</span>.")
                await _broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> MISSES <span class='char-name'>{character.name}</span>.")
    
    # --- End of Round Cleanup & Next Action Queuing ---
    if combat_resolved_this_round:
        active_combats.pop(character_id, None) # Remove character from active combat
        # Clear any mobs that were targeting this player
        mobs_to_clear_target_for_player = [mid for mid, cid in mob_targets.items() if cid == character_id]
        for mid in mobs_to_clear_target_for_player:
            mob_targets.pop(mid, None)
        character_queued_actions.pop(character_id, None) 
    elif character_id in active_combats and character.current_health > 0 : 
        # If player is still alive and combat is ongoing for them (not resolved by flee/all mobs dead)
        # And their action was an attack (or no action, meaning they should default to attack)
        # If they used a skill or failed to flee, they need to input a new command.
        if not action_str or action_str.startswith("attack"):
            remaining_targets_in_combat_list = list(active_combats.get(character_id, set()))
            if remaining_targets_in_combat_list:
                first_valid_target_id_for_next_round = None
                for mob_id_check_next in remaining_targets_in_combat_list:
                    mob_next_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id_check_next)
                    if mob_next_check and mob_next_check.current_health > 0:
                        first_valid_target_id_for_next_round = mob_id_check_next
                        break
                
                if first_valid_target_id_for_next_round:
                    character_queued_actions[character_id] = f"attack {first_valid_target_id_for_next_round}"
                else: # No valid (alive) targets left in their combat set
                    active_combats.pop(character_id, None)
                    # mobs targeting this player are cleaned up when combat_resolved_this_round is true
                    character_queued_actions.pop(character_id, None)
                    combat_resolved_this_round = True 
                    if not any("All your targets are defeated" in m for m in round_log):
                         round_log.append("No valid targets remain. Combat ends.")
            else: # Player's target set was empty somehow
                active_combats.pop(character_id, None)
                character_queued_actions.pop(character_id, None)
                combat_resolved_this_round = True 
                if not any("All your targets are defeated" in m for m in round_log):
                     round_log.append("No valid targets remain. Combat ends by default.")
        # If action was "use_skill" or "flee" (and flee failed), no automatic re-queue. Player needs to act.

    # --- Final DB Commit for character changes this round (mana, health from mob attacks if not dead) ---
    # Health changes from player attacks on mobs are handled in crud_mob.update_mob_instance_health
    # XP gains are committed in crud_character.add_experience
    # This commit primarily handles player's mana loss from skills, and health loss from mob attacks if they survived.
    db.add(character) 
    db.commit()
    db.refresh(character) # Crucial to get the absolute latest state for the outgoing payload

    # --- Send Final Log with Updated Vitals to Player ---
    # Character object should be up-to-date from db.refresh(character) above.
    # If character died and respawned, character.current_room_id is already updated.
    final_room_orm_for_log = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    final_room_schema_for_log = schemas.RoomInDB.from_orm(final_room_orm_for_log) if final_room_orm_for_log else None
    
    xp_for_next_level_final = crud.crud_character.get_xp_for_level(character.level + 1)
    vitals_payload_dict_key = "character_vitals" # or directly in final_vitals_payload
    final_vitals_payload = {
        "current_hp": character.current_health,
        "max_hp": character.max_health,
        "current_mp": character.current_mana,
        "max_mp": character.max_mana,
        "current_xp": character.experience_points,
        "next_level_xp": int(xp_for_next_level_final) if xp_for_next_level_final != float('inf') else -1,
        "level": character.level,
        "platinum": character.platinum_coins,     # <<< NEW
        "gold": character.gold_coins,     # <<< NEW
        "silver": character.silver_coins, # <<< NEW
        "copper": character.copper_coins  # <<< NEW
    }
    
    await send_combat_log(
        player_id, 
        round_log, 
        combat_resolved_this_round, 
        final_room_schema_for_log,
        character_vitals=final_vitals_payload
    )

async def _perform_server_side_move(
    db: Session,
    character: models.Character, # The ORM instance
    direction_canonical: str,
    player_id_for_broadcast: uuid.UUID # For broadcasting leave/arrive
) -> Tuple[Optional[uuid.UUID], str, str, Optional[models.Room]]: # (new_room_id, departure_msg, arrival_msg, new_room_orm)
    """
    Attempts to move a character server-side.
    Updates character's room in DB.
    Returns (new_room_id, departure_message, arrival_message, new_room_orm_object).
    Broadcasts departure and arrival.
    """
    old_room_id = character.current_room_id
    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=old_room_id)
    
    departure_message = f"You flee {direction_canonical}."
    arrival_message = "" # Will be constructed

    if not current_room_orm:
        return None, "You are in a void and cannot move.", "", None

    actual_direction_moved = direction_canonical
    if direction_canonical == "random":
        available_exits = [d for d, r_id in (current_room_orm.exits or {}).items() if r_id]
        if not available_exits:
            return None, "You look around frantically, but there's no obvious way to flee!", "", None
        actual_direction_moved = random.choice(available_exits)
        departure_message = f"You scramble away, fleeing {actual_direction_moved}!"

    target_room_uuid_str = (current_room_orm.exits or {}).get(actual_direction_moved)
    if not target_room_uuid_str:
        return None, f"You can't flee {actual_direction_moved} from here.", "", None

    try:
        target_room_uuid = uuid.UUID(hex=target_room_uuid_str)
        target_room_orm = crud.crud_room.get_room_by_id(db, room_id=target_room_uuid)
        if not target_room_orm:
            return None, f"The path {actual_direction_moved} seems to vanish into nothingness.", "", None

        # Broadcast departure from old room
        await _broadcast_to_room_participants(db, old_room_id, f"<span class='char-name'>{character.name}</span> flees {actual_direction_moved}.", exclude_player_id=player_id_for_broadcast)

        # Update character's location
        updated_char = crud.crud_character.update_character_room(db, character_id=character.id, new_room_id=target_room_orm.id)
        if not updated_char: return None, "A strange force prevents your escape.", "", None
        
        # Ensure the character object in the calling scope is updated
        character.current_room_id = target_room_orm.id 
        # db.add(character) # Staged for commit by the caller (process_combat_round)

        arrival_message = f"You burst into <span class='room-name'>{target_room_orm.name}</span>."
        
        # Broadcast arrival to new room
        opposite_direction = get_opposite_direction(actual_direction_moved)
        await _broadcast_to_room_participants(db, target_room_orm.id, f"<span class='char-name'>{character.name}</span> arrives from the {opposite_direction}.", exclude_player_id=player_id_for_broadcast)
        
        return target_room_orm.id, departure_message, arrival_message, target_room_orm
    except ValueError:
        return None, "The way forward is distorted and unnavigable.", "", None

OPPOSITE_DIRECTIONS_MAP = {
    "north": "south", "south": "north", "east": "west", "west": "east",
    "up": "down", "down": "up",
    "northeast": "southwest", "southwest": "northeast",
    "northwest": "southeast", "southeast": "northwest"
}
def get_opposite_direction(direction: str) -> str:
    return OPPOSITE_DIRECTIONS_MAP.get(direction.lower(), "somewhere")
--- END OF FILE backend/app/game_logic/combat_manager.py ---

--- START OF FILE backend/app/game_logic/world_ticker.py ---
# backend/app/game_logic/world_ticker.py
import asyncio
import time 
from typing import Callable, Iterator, List, Awaitable, Dict, Any, Optional # Added Optional
from sqlalchemy.orm import Session
from contextlib import contextmanager

from app.db.session import SessionLocal
# We might need crud/models here if the ticker itself directly does something,
# but generally, tasks will import what they need.

from app.game_logic.mob_respawner import manage_mob_populations_task 
from app.game_logic.mob_ai_ticker import process_roaming_mobs_task, process_aggressive_mobs_task
from app.game_logic.player_vital_regenerator import regenerate_player_vitals_task 

# --- Configuration ---
WORLD_TICK_INTERVAL_SECONDS = 10.0

# --- Task Registry ---
world_tick_tasks: Dict[str, Callable[[Session], Awaitable[None]]] = {}


@contextmanager
def db_session_for_world_tick() -> Iterator[Session]: 
    """Provides a DB session for the duration of a world tick's tasks."""
    db = SessionLocal()
    try:
        yield db 
    finally:
        db.close()

def register_world_tick_task(task_name: str, task_func: Callable[[Session], Awaitable[None]]):
    if task_name in world_tick_tasks:
        print(f"Warning: World tick task '{task_name}' is being redefined.")
    world_tick_tasks[task_name] = task_func

def _initialize_and_register_all_world_tasks():
    """
    This function is called once when this module is loaded.
    It registers all known world tick tasks.
    """
    print("World Ticker: Initializing and registering world tick tasks...")
    
    register_world_tick_task("mob_population_manager", manage_mob_populations_task)
    register_world_tick_task("roaming_mob_processor", process_roaming_mobs_task) # <<< NEW TASK
    register_world_tick_task("aggressive_mob_processor", process_aggressive_mobs_task) # <<< NEW TASK
    register_world_tick_task("player_vital_regenerator", regenerate_player_vitals_task)
    
    print(f"World Ticker: All tasks registered. Active tasks: {list(world_tick_tasks.keys())}")

_initialize_and_register_all_world_tasks() 


async def world_ticker_loop():
    print(f"World Ticker: Loop now running with interval: {WORLD_TICK_INTERVAL_SECONDS}s.")
    while True:
        start_time = time.time()
        
        if not world_tick_tasks:
            await asyncio.sleep(WORLD_TICK_INTERVAL_SECONDS)
            continue

        try:
            with db_session_for_world_tick() as db:
                # Create a list of tasks to run to avoid issues if tasks modify the registry (not expected)
                tasks_to_run = list(world_tick_tasks.items())
                for task_name, task_func in tasks_to_run:
                    try:
                        # print(f"World Ticker: Running task '{task_name}'...") # Verbose logging
                        await task_func(db)
                        # print(f"World Ticker: Task '{task_name}' completed.") # Verbose logging
                    except Exception as e:
                        print(f"ERROR in world_tick task '{task_name}': {e}") 
                db.commit() 
        except Exception as e:
            print(f"CRITICAL ERROR in world_ticker_loop's DB session: {e}") 

        end_time = time.time()
        processing_time = end_time - start_time
        
        sleep_duration = WORLD_TICK_INTERVAL_SECONDS - processing_time
        if sleep_duration < 0:
            print(f"Warning: World tick processing time ({processing_time:.2f}s) exceeded interval ({WORLD_TICK_INTERVAL_SECONDS}s).")
            sleep_duration = 0 
        
        await asyncio.sleep(sleep_duration)

_world_ticker_task_handle: Optional[asyncio.Task] = None

def start_world_ticker_task():
    global _world_ticker_task_handle
    if _world_ticker_task_handle is None or _world_ticker_task_handle.done():
        print("World Ticker: Attempting to start task...")
        _world_ticker_task_handle = asyncio.create_task(world_ticker_loop())
        print("World Ticker: Task created and running.")
    else:
        print("World Ticker: Task already running.")

def stop_world_ticker_task():
    global _world_ticker_task_handle
    if _world_ticker_task_handle and not _world_ticker_task_handle.done():
        print("World Ticker: Attempting to stop task...")
        _world_ticker_task_handle.cancel()
        _world_ticker_task_handle = None 
        print("World Ticker: Task cancellation requested.")
    else:
        print("World Ticker: Task not running or already stopped.")
--- END OF FILE backend/app/game_logic/world_ticker.py ---

--- START OF FILE backend/app/game_logic/mob_respawner.py ---
# backend/app/game_logic/mob_respawner.py
import asyncio
from datetime import datetime, timedelta, timezone
from sqlalchemy.orm import Session
import random # For chance_to_spawn_percent
from app.websocket_manager import connection_manager 

from app import crud, models # Ensure models.RoomMobInstance is available

# This task function will be registered by world_ticker.py
async def manage_mob_populations_task(db: Session):
    now = datetime.now(timezone.utc)
    definitions_to_check = crud.crud_mob_spawn_definition.get_definitions_ready_for_check(db, current_time=now)

    if not definitions_to_check:
        return

    for definition in definitions_to_check:
        living_children_count = db.query(models.RoomMobInstance).filter(
            models.RoomMobInstance.spawn_definition_id == definition.id,
            models.RoomMobInstance.current_health > 0
        ).count()

        needed_to_reach_min = definition.quantity_min - living_children_count
        
        if needed_to_reach_min > 0:
            can_spawn_up_to_max = definition.quantity_max - living_children_count
            num_to_attempt_spawn = min(needed_to_reach_min, can_spawn_up_to_max)

            if num_to_attempt_spawn > 0:
                mob_template_for_log = crud.crud_mob.get_mob_template(db, definition.mob_template_id)
                mob_name_for_log = mob_template_for_log.name if mob_template_for_log else "A mysterious creature"
                room_for_log = crud.crud_room.get_room_by_id(db, definition.room_id)
                room_name_for_log = room_for_log.name if room_for_log else "an unknown location"
                
                print(f"Mob Respawner: Definition '{definition.definition_name}' needs {needed_to_reach_min} (attempting {num_to_attempt_spawn}) of '{mob_name_for_log}' in '{room_name_for_log}'.")

                spawned_this_cycle_for_def = 0
                for _ in range(num_to_attempt_spawn):
                    if random.randint(1, 100) <= definition.chance_to_spawn_percent:
                        new_mob = crud.crud_mob.spawn_mob_in_room(
                            db,
                            room_id=definition.room_id,
                            mob_template_id=definition.mob_template_id,
                            originating_spawn_definition_id=definition.id
                        )
                        if new_mob:
                            spawned_this_cycle_for_def +=1
                            # --- BROADCAST SPAWN MESSAGE TO ROOM ---
                            # Ensure mob_template is loaded on new_mob for its name
                            # spawn_mob_in_room should return an instance with mob_template eager loaded if possible,
                            # or we fetch it again if necessary. Assuming new_mob.mob_template is accessible.
                            # If not, fetch the template name again:
                            spawned_mob_name = new_mob.mob_template.name if new_mob.mob_template else "A creature"
                            
                            spawn_message_payload = {
                                "type": "game_event", # Or a more specific "mob_spawn_event"
                                "message": f"<span class='inv-item-name'>{spawned_mob_name}</span> forms from the shadows!" 
                                           # Or "...materializes out of thin air!"
                                           # Or "...crawls out of a crack in the wall!"
                            }
                            
                            # Get player_ids of characters in the room where the mob spawned
                            player_ids_in_spawn_room = [
                                char.player_id for char in crud.crud_character.get_characters_in_room(
                                    db, room_id=definition.room_id 
                                    # No need to exclude anyone, everyone sees the spawn
                                ) if connection_manager.is_player_connected(char.player_id)
                            ]

                            if player_ids_in_spawn_room:
                                print(f"  Broadcasting spawn of '{spawned_mob_name}' to {len(player_ids_in_spawn_room)} players in room {definition.room_id}.")
                                await connection_manager.broadcast_to_players(spawn_message_payload, player_ids_in_spawn_room)
                            # --- END BROADCAST ---
                if spawned_this_cycle_for_def > 0:
                     print(f"  Successfully spawned {spawned_this_cycle_for_def} mobs for '{definition.definition_name}'.")

        next_check = now + timedelta(seconds=definition.respawn_delay_seconds)
        crud.crud_mob_spawn_definition.update_mob_spawn_definition_next_check_time(
            db, definition_id=definition.id, next_check_time=next_check
        )

--- END OF FILE backend/app/game_logic/mob_respawner.py ---

--- START OF FILE backend/app/game_logic/mob_ai_ticker.py ---
# backend/app/game_logic/mob_ai_ticker.py (NEW FILE)
import asyncio
import random
from typing import Optional
import uuid
from sqlalchemy.orm import Session, joinedload, selectinload
from sqlalchemy.dialects.postgresql import JSONB # For casting jsonb fields if needed, not used directly here

from app import models, crud
from app.game_logic import combat_manager # For initiating combat
from app.websocket_manager import connection_manager as ws_manager # For broadcasts
from app.db.session import SessionLocal # For standalone DB sessions if tasks run outside world_ticker context (not planned for now)

async def _broadcast_to_room_participants(
    db: Session, 
    room_id: uuid.UUID, 
    message_text: str, 
    message_type: str = "game_event",
    exclude_player_id: Optional[uuid.UUID] = None # If an action is caused by a player, exclude them from this echo
):
    """Helper to broadcast a message to all connected players in a room."""
    # Get player_ids of characters in the room
    player_ids_in_room = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            db, room_id=room_id 
            # No exclude_character_id here, as this is a general room event.
            # If an exclusion is needed based on player_id, it's handled by the caller.
        ) if ws_manager.is_player_connected(char.player_id) and (exclude_player_id is None or char.player_id != exclude_player_id)
    ]

    if player_ids_in_room:
        payload = {"type": message_type, "message": message_text}
        # print(f"Mob AI Ticker: Broadcasting to room {room_id} (players: {player_ids_in_room}): {message_text}")
        await ws_manager.broadcast_to_players(payload, player_ids_in_room)

async def process_roaming_mobs_task(db: Session):
    """
    Handles random movement for mobs with 'random_adjacent' roaming behavior.
    """
    # print("Mob AI Ticker: Processing roaming mobs...")
    
    # Query for mob instances that might roam
    # We need RoomMobInstance, its current Room, and its MobSpawnDefinition (and the spawn definition's Room)
    # Using selectinload for related collections if they were lists, joinedload for one-to-one/many-to-one.
    mobs_to_check_for_roaming = db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template), # For name
        joinedload(models.RoomMobInstance.room), # Mob's current room for exits and current coords
        joinedload(models.RoomMobInstance.originating_spawn_definition).joinedload(models.MobSpawnDefinition.room) # Spawn def and its room for origin coords
    ).filter(
        models.RoomMobInstance.spawn_definition_id != None, # Must come from a spawn definition
        models.RoomMobInstance.originating_spawn_definition.has(models.MobSpawnDefinition.is_active == True),
        models.RoomMobInstance.originating_spawn_definition.has(models.MobSpawnDefinition.roaming_behavior != None),
        # Using path expression for JSONB field 'type'
        models.RoomMobInstance.originating_spawn_definition.has(models.MobSpawnDefinition.roaming_behavior['type'].astext == 'random_adjacent')
    ).all()

    for mob in mobs_to_check_for_roaming:
        # Skip if mob is in combat.
        # A mob is considered in combat if it's a target in combat_manager.mob_targets.
        if mob.id in combat_manager.mob_targets:
            # print(f"Mob AI Ticker: Mob {mob.mob_template.name} ({mob.id}) is in combat, skipping roam.")
            continue

        if not mob.room or not mob.originating_spawn_definition or not mob.originating_spawn_definition.room:
            # print(f"Mob AI Ticker: Skipping mob {mob.id} due to missing room or spawn definition data.")
            continue

        roaming_config = mob.originating_spawn_definition.roaming_behavior
        if not isinstance(roaming_config, dict): continue # Should be a dict

        move_chance = roaming_config.get("move_chance_percent", 0)
        max_dist = roaming_config.get("max_distance_from_spawn", 999) # Default large distance

        if random.randint(1, 100) > move_chance:
            continue # Didn't pass move chance

        current_room_orm = mob.room
        valid_exits = [direction for direction, target_room_id_str in (current_room_orm.exits or {}).items() if target_room_id_str]
        
        if not valid_exits:
            continue # No way out

        chosen_direction = random.choice(valid_exits)
        next_room_id_str = (current_room_orm.exits or {}).get(chosen_direction)
        if not next_room_id_str: continue

        try:
            next_room_id = uuid.UUID(hex=next_room_id_str)
        except ValueError:
            continue # Invalid UUID for exit

        next_room_orm = crud.crud_room.get_room_by_id(db, room_id=next_room_id)
        if not next_room_orm:
            continue # Target room doesn't exist

        # Check max distance from spawn point for the *next* room
        spawn_room_coords = (mob.originating_spawn_definition.room.x, mob.originating_spawn_definition.room.y)
        next_room_coords = (next_room_orm.x, next_room_orm.y)
        
        distance_from_spawn = abs(next_room_coords[0] - spawn_room_coords[0]) + abs(next_room_coords[1] - spawn_room_coords[1])

        if distance_from_spawn > max_dist:
            # print(f"Mob AI Ticker: Mob {mob.mob_template.name} ({mob.id}) wants to move to {next_room_orm.name} but it's too far ({distance_from_spawn} > {max_dist}).")
            continue

        # --- Perform Move ---
        old_room_id = mob.room_id
        old_room_name = current_room_orm.name
        mob_name_html = f"<span class='inv-item-name'>{mob.mob_template.name}</span>" # Re-use style

        mob.room_id = next_room_id
        db.add(mob)
        # db.commit() # Commit per mob or at end of task? World ticker commits at end.

        print(f"Mob AI Ticker: Mob {mob.mob_template.name} ({mob.id}) roaming from {old_room_name} to {next_room_orm.name} via {chosen_direction}.")

        # Broadcast leave message
        await _broadcast_to_room_participants(db, old_room_id, f"{mob_name_html} shuffles off, heading {chosen_direction}.")
        
        # Broadcast arrive message
        await _broadcast_to_room_participants(db, next_room_id, f"{mob_name_html} arrives from the {combat_manager.get_opposite_direction(chosen_direction)}.") # Need get_opposite_direction
        # Let's add get_opposite_direction to combat_manager or a general util file.
        # For now, simplified arrival:
        # await _broadcast_to_room_participants(db, next_room_id, f"{mob_name_html} arrives.")


async def process_aggressive_mobs_task(db: Session):
    """
    Handles mobs initiating combat based on their aggression type.
    """
    # print("Mob AI Ticker: Processing aggressive mobs...")
    mobs_to_check_for_aggression = db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template),
        joinedload(models.RoomMobInstance.room)
    ).filter(
        models.RoomMobInstance.mob_template.has(models.MobTemplate.aggression_type == "AGGRESSIVE_ON_SIGHT"),
        models.RoomMobInstance.current_health > 0 # Only live mobs
    ).all()

    for mob in mobs_to_check_for_aggression:
        if not mob.room or not mob.mob_template: continue

        # Check if mob is already in combat
        if mob.id in combat_manager.mob_targets or combat_manager.is_mob_in_any_player_combat(mob.id):
            # print(f"Mob AI Ticker: Aggro Mob {mob.mob_template.name} ({mob.id}) already in combat.")
            continue
        
        # Find living characters in the same room
        characters_in_room = crud.crud_character.get_characters_in_room(db, room_id=mob.room_id)
        living_characters = [char for char in characters_in_room if char.current_health > 0 and ws_manager.is_player_connected(char.player_id)]

        if not living_characters:
            continue # No living, connected targets

        target_character = random.choice(living_characters) # Pick a random living character

        print(f"Mob AI Ticker: Aggro Mob {mob.mob_template.name} ({mob.id}) is attacking {target_character.name} ({target_character.id}) in room {mob.room.name}.")
        
        # Mob initiates combat
        await combat_manager.mob_initiates_combat(db, mob, target_character)
        
        # Broadcast handled by mob_initiates_combat
--- END OF FILE backend/app/game_logic/mob_ai_ticker.py ---

--- START OF FILE backend/app/game_logic/player_vital_regenerator.py ---
# backend/app/game_logic/player_vital_regenerator.py (NEW FILE)
import asyncio
import math
import uuid
from sqlalchemy.orm import Session

from app import crud, models, schemas
from app.websocket_manager import connection_manager as ws_manager
from app.game_logic import combat_manager # To check if player is in combat
from app.game_state import is_character_resting, set_character_resting_status

async def regenerate_player_vitals_task(db: Session):
    """
    Handles natural and resting HP/MP regeneration for all connected players.
    """
    connected_player_ids = ws_manager.get_all_active_player_ids()

    for player_id in connected_player_ids:
        character_id = ws_manager.get_character_id(player_id)
        if not character_id:
            continue

        character = crud.crud_character.get_character(db, character_id=character_id)
        if not character or character.current_health <= 0: # Dead or invalid
            continue

        # Skip regeneration if character is in combat
        if character.id in combat_manager.active_combats:
            continue

        hp_to_regen = 0
        mp_to_regen = 0
        
        # Store pre-regen values to check if an update is needed
        old_hp = character.current_health
        old_mp = character.current_mana

        if is_character_resting(character.id):
            # Resting regeneration: full HP/MP in ~3 minutes (180s). Tick interval 10s -> 18 ticks.
            hp_to_regen = math.ceil(character.max_health / 18)
            mp_to_regen = math.ceil(character.max_mana / 18)
        else:
            # Natural passive regeneration
            con_mod = character.get_attribute_modifier("constitution")
            wis_mod = character.get_attribute_modifier("wisdom")
            
            # Regenerate ~1% of max + stat modifier, min 1.
            hp_to_regen = max(1, math.floor(character.max_health * 0.01) + con_mod)
            mp_to_regen = max(1, math.floor(character.max_mana * 0.01) + wis_mod)

        # Apply HP regeneration
        if character.current_health < character.max_health:
            character.current_health = min(character.max_health, character.current_health + hp_to_regen)
        
        # Apply MP regeneration
        if character.current_mana < character.max_mana:
            character.current_mana = min(character.max_mana, character.current_mana + mp_to_regen)

        vitals_changed = (character.current_health != old_hp) or \
                         (character.current_mana != old_mp)

        if vitals_changed: # Or always send vitals even if only XP changed if we separate XP updates
            db.add(character) 
            
            xp_for_next_level = crud.crud_character.get_xp_for_level(character.level + 1)
            
            vitals_payload = {
                "type": "vitals_update",
                "current_hp": character.current_health,
                "max_hp": character.max_health,
                "current_mp": character.current_mana,
                "max_mp": character.max_mana,
                "current_xp": character.experience_points, # <<< ADDED
                "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1, # <<< ADDED (-1 for max level)
                "platinum": character.platinum_coins, # <<< NEW
                "gold": character.gold_coins,     # <<< NEW
                "silver": character.silver_coins, # <<< NEW
                "copper": character.copper_coins  # <<< NEW
            }
            await ws_manager.send_personal_message(vitals_payload, player_id)
            
            if is_character_resting(character.id) and \
               character.current_health == character.max_health and \
               character.current_mana == character.max_mana:
                set_character_resting_status(character.id, False)
                await ws_manager.send_personal_message({
                    "type": "game_event",
                    "message": "You feel fully rested and refreshed."
                }, player_id)
    # DB commit is handled by the world_ticker_loop.
--- END OF FILE backend/app/game_logic/player_vital_regenerator.py ---

--- START OF FILE backend/app/commands/command_args.py ---
# backend/app/commands/command_args.py
from typing import List, Optional
from sqlalchemy.orm import Session
from pydantic import BaseModel, Field

from app import models, schemas # Ensure these are accessible from app root

class CommandContext(BaseModel):
    db: Session
    active_character: models.Character
    current_room_orm: models.Room 
    current_room_schema: schemas.RoomInDB
    original_command: str 
    command_verb: str
    args: List[str] # The rest of the command words after the verb
    # For more complex parsing, args could be a pre-parsed Pydantic model itself

    class Config:
        arbitrary_types_allowed = True # For SQLAlchemy Session and ORM models
--- END OF FILE backend/app/commands/command_args.py ---

--- START OF FILE backend/app/commands/utils.py ---
# backend/app/commands/utils.py
import re
from typing import List, Optional, Tuple, Dict
import uuid
import random

from app import models, schemas
from app.models.item import EQUIPMENT_SLOTS

def get_visible_length(s: str) -> int: # ... content ...
    return len(re.sub(r'<[^>]+>', '', s))

def format_room_items_for_player_message(room_items: List[models.RoomItemInstance]) -> Tuple[str, Dict[int, uuid.UUID]]: # ... content ...
    lines = []
    item_map: Dict[int, uuid.UUID] = {}
    if room_items:
        lines.append("\nYou also see on the ground:")
        for idx, room_item_instance in enumerate(room_items):
            item_name = room_item_instance.item.name if room_item_instance.item else "Unknown Item"
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            item_name_html = f"<span class='inv-item-name'>{item_name}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {room_item_instance.quantity})</span>"
            prefix_html = f"  {item_number_html} "
            lines.append(f"{prefix_html}{item_name_html} {item_qty_html}")
            item_map[idx + 1] = room_item_instance.id
    return "\n".join(lines), item_map


def format_room_mobs_for_player_message(room_mobs: List[models.RoomMobInstance]) -> Tuple[str, Dict[int, uuid.UUID]]: # ... content ...
    lines = []
    mob_map: Dict[int, uuid.UUID] = {}
    if room_mobs:
        lines.append("\nAlso here:")
        for idx, mob_instance in enumerate(room_mobs):
            template = mob_instance.mob_template
            mob_name = template.name if template else "Unknown Creature"
            mob_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            mob_name_html = f"<span class='inv-item-name'>{mob_name}</span>"
            lines.append(f"  {mob_number_html} {mob_name_html}")
            mob_map[idx + 1] = mob_instance.id
    return "\n".join(lines), mob_map

def format_inventory_for_player_message(inventory_display_schema: schemas.CharacterInventoryDisplay) -> str:
    lines = []
    
    # --- Equipped Items ---
    equipped_item_parts = [] 
    max_visible_equipped_prefix_len = 0
    if inventory_display_schema.equipped_items:
        for slot_key, inv_item_schema in inventory_display_schema.equipped_items.items():
            processed_slot_key = str(slot_key).strip()
            display_slot_name_raw = EQUIPMENT_SLOTS.get(processed_slot_key, processed_slot_key.capitalize())
            slot_name_html = f"<span class='inv-slot-name'>{display_slot_name_raw}</span>"
            prefix_html = f"  [{slot_name_html}]"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_equipped_prefix_len = max(max_visible_equipped_prefix_len, visible_prefix_len)
            
            item_name_raw = inv_item_schema.item.name.strip() if inv_item_schema.item else "Unknown Item"
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {inv_item_schema.quantity})</span>" # Quantity of this equipped instance
            suffix_html = f"{item_name_html} {item_qty_html}"
            equipped_item_parts.append({
                'sort_key': display_slot_name_raw,
                'prefix_html': prefix_html,
                'visible_prefix_len': visible_prefix_len,
                'suffix_html': suffix_html
            })
            
    lines.append(f"<span class='inv-section-header'>--- Equipped ---</span>")
    if equipped_item_parts:
        equipped_item_parts.sort(key=lambda x: x['sort_key'])
        for parts in equipped_item_parts:
            # Calculate padding based on the visible length of the prefix (excluding HTML tags)
            padding_needed = max(0, (max_visible_equipped_prefix_len + 2) - parts['visible_prefix_len'])
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else:
        lines.append("  Nothing equipped. You're practically naked, you degenerate.")

    # --- Backpack Items ---
    backpack_item_parts = []
    max_visible_backpack_prefix_len = 0
    if inventory_display_schema.backpack_items:
        for idx, inv_item_schema in enumerate(inventory_display_schema.backpack_items):
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            prefix_html = f"  {item_number_html}"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_backpack_prefix_len = max(max_visible_backpack_prefix_len, visible_prefix_len)

            item_name_raw = inv_item_schema.item.name.strip() if inv_item_schema.item else "Unknown Item"
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {inv_item_schema.quantity})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"
            backpack_item_parts.append({
                'prefix_html': prefix_html,
                'visible_prefix_len': visible_prefix_len,
                'suffix_html': suffix_html
            })

    lines.append(f"\n<span class='inv-section-header'>--- Backpack ---</span>")
    if backpack_item_parts:
        for parts in backpack_item_parts:
            padding_needed = max(0, (max_visible_backpack_prefix_len + 1) - parts['visible_prefix_len'])
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else:
        lines.append("  Your backpack is as empty as your skull.")

    # --- Currency ---
    lines.append(f"\n<span class='inv-section-header'>--- Currency ---</span>")
    currency_parts = []
    if inventory_display_schema.platinum > 0:
        currency_parts.append(f"<span class='currency platinum'>{inventory_display_schema.platinum}p</span>")
    if inventory_display_schema.gold > 0:
        currency_parts.append(f"<span class='currency gold'>{inventory_display_schema.gold}g</span>")
    if inventory_display_schema.silver > 0:
        currency_parts.append(f"<span class='currency silver'>{inventory_display_schema.silver}s</span>")
    
    # Always show copper, even if 0, unless other currencies are present
    if currency_parts or inventory_display_schema.copper > 0 :
        currency_parts.append(f"<span class='currency copper'>{inventory_display_schema.copper}c</span>")

    if currency_parts:
        lines.append(f"  {' '.join(currency_parts)}")
    else:
        lines.append("  You are utterly destitute. Not a single coin to your pathetic name.")
            
    return "\n".join(lines)



def roll_dice(dice_str: str) -> int: # ... content ...
    if not dice_str: return 0
    dice_str = dice_str.replace(" ", "")
    parts = dice_str.lower().split('d')
    num_dice = 1
    if parts[0]:
        if parts[0] == "" and len(parts) > 1: num_dice = 1
        else:
            try: num_dice = int(parts[0])
            except ValueError:
                try: return int(parts[0])
                except ValueError: return 0
    if len(parts) < 2: return num_dice
    dice_spec = parts[1]
    modifier = 0
    if '+' in dice_spec:
        sides_mod = dice_spec.split('+')
        try:
            dice_sides = int(sides_mod[0]); modifier = int(sides_mod[1])
        except (ValueError, IndexError): return 0 
    elif '-' in dice_spec:
        sides_mod_neg = dice_spec.split('-')
        try:
            dice_sides = int(sides_mod_neg[0]); modifier = -int(sides_mod_neg[1])
        except (ValueError, IndexError): return 0
    else:
        try: dice_sides = int(dice_spec)
        except ValueError: return 0
    if dice_sides <= 0: return 0 
    total_roll = 0
    for _ in range(num_dice): total_roll += random.randint(1, dice_sides)
    return total_roll + modifier

def resolve_mob_target(
    target_ref: str, 
    mobs_in_room: List[models.RoomMobInstance] # Pass the list of RoomMobInstance ORM objects
) -> Tuple[Optional[models.RoomMobInstance], Optional[str]]:
    """
    Resolves a target reference (number, full name, or partial name) to a specific mob instance.
    Returns (mob_instance, error_message_or_ambiguity_prompt_or_None_if_success)
    """
    if not mobs_in_room: # No mobs to target
        return None, f"There is nothing called '{target_ref}' here to target."

    target_ref_lower = target_ref.lower()
    
    # 1. Try to parse as a number (from 1-based index)
    try:
        num_ref = int(target_ref)
        if 1 <= num_ref <= len(mobs_in_room):
            return mobs_in_room[num_ref - 1], None # Found by number
    except ValueError:
        pass # Not a number, proceed to name matching

    # 2. Try exact full name match (case-insensitive)
    exact_matches: List[models.RoomMobInstance] = []
    for mob_instance in mobs_in_room:
        if mob_instance.mob_template and mob_instance.mob_template.name.lower() == target_ref_lower:
            exact_matches.append(mob_instance)
    
    if len(exact_matches) == 1:
        return exact_matches[0], None # Unique exact match
    if len(exact_matches) > 1:
        # This case is unlikely if mob names are unique, but handle it.
        # For simplicity, if multiple exact matches, prompt for ambiguity.
        prompt_lines = [f"Multiple exact matches for '{target_ref}'. Which did you mean?"]
        exact_matches.sort(key=lambda m: m.mob_template.name if m.mob_template else "")
        for i, mob_match in enumerate(exact_matches):
            mob_name = mob_match.mob_template.name if mob_match.mob_template else "Unknown Mob"
            prompt_lines.append(f"  {i + 1}. {mob_name} (Exact)")
        return None, "\n".join(prompt_lines)

    # 3. Try flexible partial name match (case-insensitive)
    partial_matches: List[models.RoomMobInstance] = []
    # Use a set to ensure each mob instance is added to partial_matches only once
    # even if it matches multiple criteria (e.g., prefix and word start).
    matched_mob_ids_for_partial = set()

    for mob_instance in mobs_in_room:
        if not (mob_instance.mob_template and mob_instance.mob_template.name):
            continue

        mob_name_lower = mob_instance.mob_template.name.lower()
        mob_name_words = mob_name_lower.split()
        
        matched_this_instance = False

        # Criterion a: Full mob name starts with target_ref_lower (e.g., "gia" for "Giant Rat")
        if mob_name_lower.startswith(target_ref_lower):
            matched_this_instance = True
        
        # Criterion b: Any word in the mob name starts with target_ref_lower (e.g., "ra" for "Giant Rat")
        if not matched_this_instance:
            for word in mob_name_words:
                if word.startswith(target_ref_lower):
                    matched_this_instance = True
                    break
        
        # Criterion c: target_ref_lower is an exact match for any word in the mob name (e.g., "rat" for "Giant Rat")
        if not matched_this_instance:
            if target_ref_lower in mob_name_words:
                matched_this_instance = True
        
        if matched_this_instance:
            if mob_instance.id not in matched_mob_ids_for_partial:
                partial_matches.append(mob_instance)
                matched_mob_ids_for_partial.add(mob_instance.id)

    if len(partial_matches) == 1:
        return partial_matches[0], None # Unique partial match
    
    if len(partial_matches) > 1:
        # Ambiguous partial match
        prompt_lines = [f"Which '{target_ref}' did you mean?"]
        # Sort partial_matches by name for consistent numbering
        partial_matches.sort(key=lambda m: m.mob_template.name if m.mob_template else "")
        for i, mob_match in enumerate(partial_matches):
            mob_name = mob_match.mob_template.name if mob_match.mob_template else "Unknown Mob"
            prompt_lines.append(f"  {i + 1}. {mob_name}")
        return None, "\n".join(prompt_lines)

    # 4. No match found by any criteria
    return None, f"Cannot find anything called '{target_ref}' here to target."

def format_room_characters_for_player_message(
    room_characters: List[models.Character] # Expects a list of Character ORM objects
) -> str: # No map needed here, just the text
    """Formats characters in the room into a readable string."""
    if not room_characters:
        return "" # No extra "Also here for characters" if none are present

    lines = ["\nAlso present:"] # Or "You also see:"
    for char_orm in room_characters:
        # TODO: Add more detail later, e.g., " (PlayerName's CharacterName the Warrior)"
        # For now, just the character name and class.
        char_name_html = f"<span class='char-name'>{char_orm.name}</span>" # Re-use char-name style
        char_class_html = f"<span class='char-class'>({char_orm.class_name})</span>" # Re-use char-class style
        lines.append(f"  {char_name_html} {char_class_html}")
    return "\n".join(lines)
--- END OF FILE backend/app/commands/utils.py ---

--- START OF FILE backend/app/commands/movement_parser.py ---
# backend/app/commands/movement_parser.py
import uuid
from typing import Dict, List, Optional, Tuple # Ensure all are imported

from app import schemas, crud, models 
from .command_args import CommandContext
from .utils import ( # Assuming these are all in utils.py now
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message # Make sure this is imported
)
from app.websocket_manager import connection_manager # For broadcasting

# --- Helper Function (Ideally in utils.py) ---
def format_room_mobs_for_player_message(
    room_mobs: List[models.RoomMobInstance]
) -> Tuple[str, Dict[int, uuid.UUID]]:
    """Formats mobs in the room into a readable string, numbered."""
    lines = []
    mob_map: Dict[int, uuid.UUID] = {}

    if room_mobs:
        lines.append("\nAlso here:") # Or "Creatures present:"
        for idx, mob_instance in enumerate(room_mobs):
            template = mob_instance.mob_template
            mob_name = template.name if template else "Unknown Creature"
            
            mob_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>" # Re-use style for numbering
            mob_name_html = f"<span class='inv-item-name'>{mob_name}</span>" # Re-use style for name

            lines.append(f"  {mob_number_html} {mob_name_html}")
            mob_map[idx + 1] = mob_instance.id
    return "\n".join(lines), mob_map
# --- End Helper Function ---


async def handle_look(context: CommandContext) -> schemas.CommandResponse:
    message_to_player_parts: List[str] = []
    look_target_name = " ".join(context.args).strip() if context.args else None

    if look_target_name:
        # ... (existing logic for looking at specific items/mobs) ...
        # Ensure this section also lists other characters if looking at a target
        # For brevity, I'll skip repeating the full "look at target" block, but add char listing there too.

        # At the end of "look at target", after item/mob description, add other entities:
        # ... (after specific target description)
        # message_to_player_parts.append(f"\n\n{context.current_room_schema.name}\n{context.current_room_schema.description}")
        
        # List other items, mobs, AND characters
        other_items_on_ground = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
        if other_items_on_ground:
            ground_items_text, _ = format_room_items_for_player_message(other_items_on_ground)
            if ground_items_text: message_to_player_parts.append(ground_items_text)

        other_mobs_in_room = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
        if other_mobs_in_room:
            mobs_text, _ = format_room_mobs_for_player_message(other_mobs_in_room)
            if mobs_text: message_to_player_parts.append(mobs_text)
        
        # <<< NEW: List other characters (excluding self) when looking at a target
        other_characters_in_room = crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.current_room_orm.id, 
            exclude_character_id=context.active_character.id
        )
        if other_characters_in_room:
            chars_text = format_room_characters_for_player_message(other_characters_in_room)
            if chars_text: message_to_player_parts.append(chars_text)

        final_message = "\n".join(filter(None, message_to_player_parts)).strip()
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=final_message if final_message else None)


    # Default "look" (general room look)
    items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
    ground_items_text, _ = format_room_items_for_player_message(items_on_ground_orm)
    if ground_items_text:
        message_to_player_parts.append(ground_items_text)
        
    mobs_in_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
    mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room_orm)
    if mobs_text:
        message_to_player_parts.append(mobs_text)

    # <<< NEW: List other characters (excluding self) for general look
    characters_in_room_orm = crud.crud_character.get_characters_in_room(
        context.db, 
        room_id=context.current_room_orm.id, 
        exclude_character_id=context.active_character.id
    )
    if characters_in_room_orm:
        chars_text = format_room_characters_for_player_message(characters_in_room_orm)
        if chars_text: message_to_player_parts.append(chars_text)
        
    final_message = "\n".join(filter(None, message_to_player_parts)).strip()
    return schemas.CommandResponse(
        room_data=context.current_room_schema,
        message_to_player=final_message if final_message else None # Send only if there's something to say
    )

async def handle_move(context: CommandContext) -> schemas.CommandResponse:
    message_to_player: Optional[str] = None 
    moved = False
    target_room_orm_for_move: Optional[models.Room] = None
    
    direction_map = {"n": "north", "s": "south", "e": "east", "w": "west", "u": "up", "d": "down"}
    target_direction_str_raw = "" # The raw input for direction

    if context.command_verb == "go":
        if context.args: 
            target_direction_str_raw = context.args[0].lower()
        else:
            message_to_player = "Go where?"
            return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
    else: 
        target_direction_str_raw = context.command_verb.lower() # Command itself is the direction
        
    # Determine the full direction name (e.g., "n" -> "north")
    # target_direction will be the canonical direction name like "north", "south", etc.
    target_direction = direction_map.get(target_direction_str_raw, target_direction_str_raw)

    if target_direction not in direction_map.values(): # Validate against canonical names
        message_to_player = "That's not a valid direction to move."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # Store details from before the move
    old_room_id = context.active_character.current_room_id
    character_name_for_broadcast = context.active_character.name # For messages to others

    # Attempt to find the exit and the target room
    current_exits = context.current_room_orm.exits if context.current_room_orm.exits is not None else {}
    if target_direction in current_exits:
        next_room_uuid_str = current_exits.get(target_direction)
        if next_room_uuid_str:
            try:
                target_room_uuid = uuid.UUID(hex=next_room_uuid_str)
                potential_target_room_orm = crud.crud_room.get_room_by_id(context.db, room_id=target_room_uuid)
                if potential_target_room_orm:
                    target_room_orm_for_move = potential_target_room_orm
                    moved = True
                else: 
                    message_to_player = "The path ahead seems to vanish into thin air. Spooky."
            except ValueError: 
                message_to_player = "The exit in that direction appears to be corrupted. Call a dev, maybe."
        else: 
            # This case should ideally not happen if exits dict is well-formed,
            # but good to have a fallback.
            message_to_player = "The way in that direction is unclear or broken."
    else: 
        message_to_player = "You can't go that way."

    # If the move was successful
    if moved and target_room_orm_for_move:
        # 1. Update character's location in DB
        crud.crud_character.update_character_room(
            context.db, character_id=context.active_character.id, new_room_id=target_room_orm_for_move.id
        )
        # The context.active_character object itself is not updated by the above call immediately
        # unless we re-fetch it. For broadcasting, we use the new room ID.
        
        new_room_schema = schemas.RoomInDB.from_orm(target_room_orm_for_move) # For the mover's response

        # 2. Broadcast "leaves" message to players in the OLD room
        player_ids_in_old_room = [
            char.player_id for char in crud.crud_character.get_characters_in_room(
                context.db, room_id=old_room_id, exclude_character_id=context.active_character.id
            ) if connection_manager.is_player_connected(char.player_id)
        ]
        if player_ids_in_old_room:
            leave_message_payload = {
                "type": "game_event", 
                "message": f"<span class='char-name'>{character_name_for_broadcast}</span> leaves, heading {target_direction}."
            }
            await connection_manager.broadcast_to_players(leave_message_payload, player_ids_in_old_room)

        # 3. Broadcast "arrives" message to players in the NEW room
        player_ids_in_new_room_others = [ # Others already in the new room
            char.player_id for char in crud.crud_character.get_characters_in_room(
                context.db, room_id=target_room_orm_for_move.id, exclude_character_id=context.active_character.id
            ) if connection_manager.is_player_connected(char.player_id)
        ]
        if player_ids_in_new_room_others:
            # TODO: Determine direction of arrival (e.g., if moved north, arrived from south)
            # For now, a generic arrival message.
            arrive_message_payload = {
                "type": "game_event", 
                "message": f"<span class='char-name'>{character_name_for_broadcast}</span> arrives."
            }
            await connection_manager.broadcast_to_players(arrive_message_payload, player_ids_in_new_room_others)
        
        # 4. Prepare the message_to_player for the character who moved
        # This message will include the description of items, mobs, and other characters in the new room.
        # Room name and description itself will be handled by the client using room_data.
        arrival_message_parts: List[str] = []
        
        items_in_new_room_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=target_room_orm_for_move.id)
        ground_items_text, _ = format_room_items_for_player_message(items_in_new_room_orm)
        if ground_items_text:
            arrival_message_parts.append(ground_items_text)
            
        mobs_in_new_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=target_room_orm_for_move.id)
        mobs_text, _ = format_room_mobs_for_player_message(mobs_in_new_room_orm)
        if mobs_text:
            arrival_message_parts.append(mobs_text)

        # List other characters in the new room for the mover
        other_characters_in_new_room = crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=target_room_orm_for_move.id, 
            exclude_character_id=context.active_character.id # Exclude self
        )
        if other_characters_in_new_room:
            chars_text_for_mover = format_room_characters_for_player_message(other_characters_in_new_room)
            if chars_text_for_mover: 
                arrival_message_parts.append(chars_text_for_mover)
            
        final_arrival_message = "\n".join(filter(None, arrival_message_parts)).strip()
        
        return schemas.CommandResponse(
            room_data=new_room_schema, 
            message_to_player=final_arrival_message if final_arrival_message else None # Send only if there's something to describe
        )
            
    # If move failed, return the failure message and current room data
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/movement_parser.py ---

--- FILE NOT FOUND: backend/app/commands/inventory_parser.py# ---

--- FILE NOT FOUND: inventory, ---

--- FILE NOT FOUND: equip, ---

--- FILE NOT FOUND: etc. ---

--- START OF FILE backend/app/commands/social_parser.py ---
# backend/app/commands/social_parser.py
import random
from app import schemas, models, crud # app.
from .command_args import CommandContext # app.commands.command_args
from app.websocket_manager import connection_manager


async def handle_fart(context: CommandContext) -> schemas.CommandResponse:
    character_name = context.active_character.name

    # --- Diverse Onomatopoeia & Descriptions ---
    fart_sounds = [
        "*Pfffft!*", "*Braaap!*", "*Thrrrip!*", "*Squelch...*", "*Poot.*", "*Brrrt!*", 
        "*Toot!*", "*Phhhht.*", "*SBD (Silent But Deadly)*", "*Flrph*", "*Thwapp!*",
        "*Poo-tee-weet?*", "*A high-pitched whistle*", "*A low, bassy rumble*"
    ]
    
    actor_descriptions = [ # What the farter experiences/thinks
        "You feel a sudden pressure release.",
        "You subtly (or not so subtly) let one rip.",
        "A fragrant cloud emanates from your being.",
        "You add your unique aroma to the room's ambiance.",
        "Ah, sweet relief!",
        "You check discreetly to see if anyone noticed. They did.",
        "You try to blame the dog, but there is no dog.",
        "A moment of internal rebellion, now externalized.",
        "You punctuate the silence with a personal statement."
    ]

    observer_actions = [ # What others see/hear the farter DOING
        "bends over slightly", "winces momentarily", "shifts uncomfortably in their britches",
        "looks around innocently", "grins mischievously", "lets out a sigh of contentment",
        "fans the air nonchalantly", "suddenly seems very interested in a cobweb on the ceiling",
        "blushes faintly", "chuckles to themselves"
    ]

    observer_smells_or_sounds = [ # The sensory experience for others
        "A suspicious noise emanates from their direction.",
        "The distinct sound of escaping gas is heard.",
        "A foul wind blows from where they stand.",
        "The air suddenly becomes... heavier.",
        "A faint (or not so faint) odor permeates the area.",
        "It sounds like a small, trapped animal finally escaped.",
        "Someone should probably open a window."
    ]

    # --- Constructing the Messages ---
    chosen_sound = random.choice(fart_sounds)
    actor_desc_part = random.choice(actor_descriptions)
    observer_action_part = random.choice(observer_actions)
    observer_smell_sound_part = random.choice(observer_smells_or_sounds)

    # Message to the player who farted
    # Player sees the sound, their internal monologue/action, and perhaps a general observation.
    message_to_player = f"You {observer_action_part}. {chosen_sound} {actor_desc_part}"

    # Message to everyone else in the room
    # Others see the player's action, the sound, and the sensory result.
    message_to_others = (
        f"<span class='char-name'>{character_name}</span> {observer_action_part}. "
        f"{chosen_sound} {observer_smell_sound_part}"
    )

    # --- Broadcasting ---
    others_message_payload = {
        "type": "game_event", # Or a more specific "social_event" or "emote"
        "message": message_to_others
    }

    player_ids_in_room_to_notify = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Don't send broadcast to self
        ) if connection_manager.is_player_connected(char.player_id)
    ]

    if player_ids_in_room_to_notify:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room_to_notify)
    
    return schemas.CommandResponse(
        room_data=context.current_room_schema, 
        message_to_player=message_to_player
    )

async def handle_say(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Say what?")

    message_text = " ".join(context.args)
    character_name = context.active_character.name

    # Message to self (echo)
    self_message = f"You say, \"{message_text}\""
    
    # Message to others in the room
    others_message_payload = {
        "type": "game_event", # Or "chat_message"
        "message": f"<span class='char-name'>{character_name}</span> says, \"{message_text}\""
    }

    player_ids_in_room = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Exclude self from broadcast
        ) if connection_manager.is_player_connected(char.player_id)
    ]

    if player_ids_in_room:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room)

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=self_message)


async def handle_emote(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Emote what? (e.g., emote grins)")

    emote_text = " ".join(context.args)
    character_name = context.active_character.name

    # Message to self (echo) - may or may not include your own name based on MUD style
    self_message = f"<span class='char-name'>{character_name}</span> {emote_text}" # Or "You {emote_text}"
    
    # Message to others in the room
    others_message_payload = {
        "type": "game_event", # Or "emote_message"
        "message": f"<span class='char-name'>{character_name}</span> {emote_text}"
    }

    player_ids_in_room = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Exclude self from broadcast
        ) if connection_manager.is_player_connected(char.player_id)
    ]
    
    # Send to others first, then construct self_message which might be slightly different for some MUDs
    if player_ids_in_room:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room)
    
    # For emote, the player also sees the "CharacterName emotes..." message
    # So, we send the same payload to self, but via send_personal_message
    # Or, if the command response message_to_player handles the self-echo:
    # self_message_for_command_response = f"You {emote_text}." # if you want "You emote"
    self_message_for_command_response = self_message # Echo the same as others see

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=self_message_for_command_response)

async def handle_ooc(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="OOC what? (Out Of Character global chat)")

    message_text = " ".join(context.args)
    character_name = context.active_character.name
    player_username = context.active_character.owner.username if hasattr(context.active_character, 'owner') and context.active_character.owner else "UnknownPlayer" 
    # To get player_username, Character model needs `owner: Mapped["Player"] = relationship(back_populates="characters")` 
    # and it needs to be loaded. For now, let's stick to character name or a generic.
    # Let's use Character Name for simplicity in OOC for now.

    # Message for global broadcast
    # Using a distinct style for OOC messages is good.
    ooc_message_payload = {
        "type": "ooc_message", # A new type for the frontend to potentially style differently
        "message": f"[OOC] <span class='char-name'>{character_name}</span>: {message_text}"
    }

    # Get ALL active player_ids from ConnectionManager
    all_player_ids = connection_manager.get_all_active_player_ids() # Needs to be implemented in ConnectionManager
    
    # Broadcast to everyone, including self
    if all_player_ids:
        await connection_manager.broadcast_to_players(ooc_message_payload, all_player_ids)
    
    # No direct message_to_player in CommandResponse needed if the broadcast includes self.
    # Or, you can have a self-echo: "You OOC: message"
    # For now, assume the broadcast handles echoing to self too.
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=None) # Or "OOC message sent."
--- END OF FILE backend/app/commands/social_parser.py ---

--- START OF FILE backend/app/commands/meta_parser.py ---
# backend/app/commands/meta_parser.py
from typing import List
from app import schemas, models, crud # <<< ADDED models
from .command_args import CommandContext 

async def handle_help(context: CommandContext) -> schemas.CommandResponse:
    categories = {
        "General": [
            ("look [target]", "Shows description of location, item, or mob."),
            ("score", "Shows your character's stats and status."),
            ("skills", "Displays skills you have learned."),         
            ("traits", "Displays traits you have acquired."),       
            ("help (?)", "Shows this incredibly helpful message."),
            ("fart", "Express yourself. With great feeling."),
        ],
        "Movement": [
            ("north (n)", "Move North."),
            ("south (s)", "Move South."),
            ("east (e)", "Move East."),
            ("west (w)", "Move West."),
            ("up (u)", "Move Up."),
            ("down (d)", "Move Down."),
            ("go <direction>", "Move in a specified direction."),
        ],
        "Inventory & Items": [
            ("inventory (i)", "Shows your inventory."),
            ("equip (eq) <item_ref> [slot]", "Equips an item (e.g., 'eq Sword main_hand')."),
            ("unequip (uneq) <item/slot>", "Unequips an item (e.g., 'uneq head')."),
            ("drop <item_ref>", "Drops an item from backpack to ground."),
            ("get (take) <item_ref>", "Picks up an item from the ground."),
        ],
        "Combat (WebSocket)": [
            ("attack (atk, kill) <target>", "Attack a creature in the room."),
            ("flee", "Attempt to flee from combat."),
        ],
        "Debug (Use With Caution, You Filthy Cheater)": [
            ("giveme <item_name>", "DEBUG: Gives you an item."),
            ("spawnmob <mob_template_name>", "DEBUG: Spawns a mob."),
        ]
    }

    help_message_lines = ["<span class='inv-section-header'>--- Available Commands ---</span>"]
    
    # Find the length of the longest command string for padding
    max_cmd_len = 0
    for _, commands in categories.items():
        for cmd_text, _ in commands:
            if len(cmd_text) > max_cmd_len:
                max_cmd_len = len(cmd_text)
    
    # The fixed width for the command part of the line.
    # All command texts will be padded to this width.
    command_column_width = max_cmd_len 

    help_message_lines = ["<span class='inv-section-header'>--- Available Commands ---</span>"]
    command_col_width = 30 

    for category_name, commands in categories.items():
        help_message_lines.append(f"\n<span class='room-name-header'>-- {category_name} --</span>")
        for cmd, desc in commands:
            padded_command_text = cmd.ljust(command_col_width)
            line = f"  <span class='inv-item-name'>{cmd.ljust(command_col_width)}</span>  - {desc}" # Use ljust on cmd directly
            help_message_lines.append(line)

    message_to_player = "\n".join(help_message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_score(context: CommandContext) -> schemas.CommandResponse:
    char: models.Character = context.active_character
    
    effective_stats = char.calculate_combat_stats()
    
    # --- Calculate XP for next level ---
    xp_for_next_level_val = crud.crud_character.get_xp_for_level(char.level + 1)
    xp_to_next_display = ""
    if xp_for_next_level_val == float('inf'):
        xp_to_next_display = "(Max Level)"
    else:
        # xp_needed_for_this_level_up = int(xp_for_next_level_val) - int(crud.crud_character.get_xp_for_level(char.level))
        # xp_progress_this_level = char.experience_points - int(crud.crud_character.get_xp_for_level(char.level))
        # xp_to_next_display = f"{xp_progress_this_level} / {xp_needed_for_this_level_up} (Next: {int(xp_for_next_level_val)})"
        # Simpler: just show current XP / total XP for next level
        xp_to_next_display = f"{char.experience_points} / {int(xp_for_next_level_val)}"


    score_message_lines = [
        f"--- <span class='char-name'>{char.name}</span> --- the <span class='char-class'>{char.class_name}</span> ---",
        f"Level: {char.level}   XP: {xp_to_next_display}", # <<< UPDATED XP DISPLAY
        f"HP: <span class='combat-hp'>{char.current_health}/{char.max_health}</span>   MP: <span class='combat-hp'>{char.current_mana}/{char.max_mana}</span>",
        "--- Attributes ---",
        f"  Strength:     {char.strength:<4} ({char.get_attribute_modifier('strength'):+}) Intelligence: {char.intelligence:<4} ({char.get_attribute_modifier('intelligence'):+})",
        f"  Dexterity:    {char.dexterity:<4} ({char.get_attribute_modifier('dexterity'):+})    Wisdom:       {char.wisdom:<4} ({char.get_attribute_modifier('wisdom'):+})",
        f"  Constitution: {char.constitution:<4} ({char.get_attribute_modifier('constitution'):+}) Charisma:     {char.charisma:<4} ({char.get_attribute_modifier('charisma'):+})",
        f"  Luck:         {char.luck:<4} ({char.get_attribute_modifier('luck'):+})",
        "--- Effective Combat Stats ---",
        f"  Armor Class:  {effective_stats['effective_ac']:<4}         Attack Bonus: {effective_stats['attack_bonus']:<+4}",
        f"  Damage:       {effective_stats['damage_dice']} + {effective_stats['damage_bonus']}",
        f"  (Attack Attribute: {effective_stats['primary_attribute_for_attack'].capitalize()})",
    ]
    message_to_player = "\n".join(score_message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_skills(context: CommandContext) -> schemas.CommandResponse:
    char_skills: List[str] = context.active_character.learned_skills or []
    
    if not char_skills:
        message_to_player = "You have not learned any skills yet. Perhaps try hitting things with a stick?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    message_lines = ["<span class='inv-section-header'>--- Your Skills ---</span>"]
    for skill_tag in char_skills:
        skill_template = crud.crud_skill.get_skill_template_by_tag(context.db, skill_id_tag=skill_tag)
        if skill_template:
            line = f"  <span class='inv-item-name'>{skill_template.name}</span>"
            if skill_template.description:
                # Basic alignment for description (adjust width as needed)
                desc_indent = " " * (25 - len(skill_template.name))
                if len(skill_template.name) >= 23: desc_indent = "\n    " # Newline if name is too long
                line += f"{desc_indent}- {skill_template.description}"
            message_lines.append(line)
        else:
            message_lines.append(f"  Unknown skill ID: {skill_tag} (This is probably a bug, you poor sod.)")
            
    message_to_player = "\n".join(message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_traits(context: CommandContext) -> schemas.CommandResponse:
    char_traits: List[str] = context.active_character.learned_traits or []

    if not char_traits:
        message_to_player = "You possess no noteworthy traits. You are remarkably unremarkable."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    message_lines = ["<span class='inv-section-header'>--- Your Traits ---</span>"]
    for trait_tag in char_traits:
        trait_template = crud.crud_trait.get_trait_template_by_tag(context.db, trait_id_tag=trait_tag)
        if trait_template:
            line = f"  <span class='inv-item-name'>{trait_template.name}</span>"
            if trait_template.description:
                desc_indent = " " * (25 - len(trait_template.name))
                if len(trait_template.name) >= 23: desc_indent = "\n    "
                line += f"{desc_indent}- {trait_template.description}"
            message_lines.append(line)
        else:
            message_lines.append(f"  Unknown trait ID: {trait_tag} (The devs are slacking again.)")
            
    message_to_player = "\n".join(message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/meta_parser.py ---

--- START OF FILE backend/app/commands/debug_parser.py ---
# backend/app/commands/debug_parser.py
from app import schemas, crud, models # app.
from .command_args import CommandContext # app.commands.command_args
import shlex

async def handle_giveme(context: CommandContext) -> schemas.CommandResponse:
    message_to_player = "Debug: giveme what? (e.g., 'giveme Rusty Sword')"
    if context.args:
        item_name_to_give = " ".join(context.args).strip()
        item_template = crud.crud_item.get_item_by_name(context.db, name=item_name_to_give)
        if item_template:
            _, add_message = crud.crud_character_inventory.add_item_to_character_inventory(
                context.db, character_id=context.active_character.id, item_id=item_template.id, quantity=1
            )
            message_to_player = add_message
        else:
            message_to_player = f"Debug: Item template '{item_name_to_give}' not found."
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_spawnmob(context: CommandContext) -> schemas.CommandResponse:
    message_to_player = "Debug: spawnmob <mob_template_name>"
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # CORRECTED: Join all args to get the full mob template name
    mob_template_name = " ".join(context.args).strip()
    
    if not mob_template_name: # Handle if args were just spaces
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Debug: Please specify a mob template name.")


    target_room_id = context.current_room_orm.id # Default to current room

    mob_template = crud.crud_mob.get_mob_template_by_name(context.db, name=mob_template_name)
    if not mob_template:
        message_to_player = f"Debug: Mob template '{mob_template_name}' not found."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    spawned_mob = crud.crud_mob.spawn_mob_in_room(
        db=context.db,
        room_id=target_room_id,
        mob_template_id=mob_template.id
    )

    if spawned_mob:
        # Ensure mob_template is loaded on spawned_mob if not already by relationship default
        # For display, it's good to have it. spawned_mob.mob_template.name
        mob_display_name = spawned_mob.mob_template.name if spawned_mob.mob_template else mob_template_name
        message_to_player = f"Debug: Spawned '{mob_display_name}' (ID: {spawned_mob.id}) in current room."
    else:
        message_to_player = f"Debug: Failed to spawn '{mob_template_name}'."
        
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_set_hp(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Usage: set_hp <value>")
    try:
        value = int(context.args[0])
    except ValueError:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Invalid HP value. Must be an integer.")

    character = context.active_character
    # Use the CRUD function, but it expects a change, not a set.
    # So, calculate change needed or modify crud_character to have a set_current_health.
    # For now, let's just directly set and clamp.
    
    character.current_health = value
    if character.current_health < 0:
        character.current_health = 0
    if character.current_health > character.max_health:
        character.current_health = character.max_health
    
    context.db.add(character)
    context.db.commit()
    context.db.refresh(character)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=f"HP set to {character.current_health}/{character.max_health}.")

async def handle_mod_xp(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Usage: mod_xp <amount>")
    try:
        amount = int(context.args[0])
    except ValueError:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Invalid XP amount. Must be an integer.")

    updated_char, messages = crud.crud_character.add_experience(context.db, context.active_character.id, amount)
    
    if not updated_char:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Error modifying XP.")

    full_message = "\n".join(messages)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=full_message)


async def handle_set_level(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Usage: set_level <level>")
    try:
        target_level = int(context.args[0])
        if target_level < 1:
            return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Target level must be 1 or greater.")
    except ValueError:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Invalid level. Must be an integer.")

    character = context.active_character
    messages = [f"Attempting to set level to {target_level}... Current XP: {character.experience_points}, Level: {character.level}"]
    
    initial_char_level_for_loop = character.level

    # Iteratively level up or down
    # Using a safety counter to prevent infinite loops if logic is off
    safety_counter = 0
    max_iterations = abs(target_level - initial_char_level_for_loop) + 5 # Max iterations

    while character.level < target_level and safety_counter < max_iterations:
        xp_to_next_level = crud.crud_character.get_xp_for_level(character.level + 1)
        if xp_to_next_level == float('inf'):
            messages.append(f"Max defined level ({character.level}) reached. Cannot set level to {target_level} by leveling up further.")
            break
        
        # To level up, ensure XP is at least the threshold for the next level
        character.experience_points = int(xp_to_next_level) # Set XP to exactly what's needed
        # _apply_level_up will increment level and can handle XP reset for new level if needed
        level_up_msgs = crud.crud_character._apply_level_up(context.db, character)
        messages.extend(level_up_msgs)
        # _apply_level_up should handle setting XP to start of new level + overflow if any,
        # but for set_level, we just care about reaching the level.
        # Let's ensure XP is at the start of the new current level.
        character.experience_points = int(crud.crud_character.get_xp_for_level(character.level))

        context.db.add(character) # Stage changes
        safety_counter += 1


    while character.level > target_level and safety_counter < max_iterations:
        if character.level <= 1: # Should be caught by target_level check, but good failsafe
            messages.append("Cannot de-level below 1.")
            break
        
        # To de-level, XP will be set by _apply_level_down
        delevel_msgs = crud.crud_character._apply_level_down(context.db, character)
        messages.extend(delevel_msgs)
        context.db.add(character) # Stage changes
        safety_counter += 1
    
    if safety_counter >= max_iterations:
        messages.append("Warning: Max iterations reached in set_level. Level may not be correctly set.")

    context.db.commit()
    context.db.refresh(character)
    
    messages.append(f"Character is now Level {character.level} with {character.experience_points} XP.")
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="\n".join(messages))   

async def handle_set_money(context: CommandContext) -> schemas.CommandResponse:
    """
    Sets the character's currency.
    Usage: setmoney <platinum> <gold> <silver> <copper>
    Example: setmoney 0 10 50 120
    """
    if len(context.args) != 4:
        return schemas.CommandResponse(
            room_data=context.current_room_schema,
            message_to_player="Usage: setmoney <plat_amt> <gold_amt> <silver_amt> <copper_amt>"
        )

    try:
        plat = int(context.args[0])
        gold = int(context.args[1])
        silver = int(context.args[2])
        copper = int(context.args[3])
        
        if any(c < 0 for c in [plat, gold, silver, copper]):
            return schemas.CommandResponse(
                room_data=context.current_room_schema,
                message_to_player="Currency amounts cannot be negative for setmoney."
            )

    except ValueError:
        return schemas.CommandResponse(
            room_data=context.current_room_schema,
            message_to_player="Invalid amount. All currency amounts must be integers."
        )

    character = context.active_character
    character.platinum_coins = plat
    character.gold_coins = gold
    character.silver_coins = silver
    character.copper_coins = copper

    context.db.add(character)
    context.db.commit()
    context.db.refresh(character)
    
    message = f"Currency set to: {plat}p {gold}g {silver}s {copper}c."
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message)


async def handle_add_money(context: CommandContext) -> schemas.CommandResponse:
    """
    Adds or removes currency from the character.
    Usage: addmoney <type> <amount>  (e.g., addmoney gold 100, addmoney copper -50)
    Valid types: p, g, s, c (or platinum, gold, silver, copper)
    """
    if len(context.args) != 2:
        return schemas.CommandResponse(
            room_data=context.current_room_schema,
            message_to_player="Usage: addmoney <type> <amount> (e.g., addmoney gold 100)"
        )

    currency_type_arg = context.args[0].lower()
    try:
        amount = int(context.args[1])
    except ValueError:
        return schemas.CommandResponse(
            room_data=context.current_room_schema,
            message_to_player="Invalid amount. Must be an integer."
        )

    plat_change, gold_change, silver_change, copper_change = 0, 0, 0, 0

    if currency_type_arg in ["p", "plat", "platinum"]:
        plat_change = amount
    elif currency_type_arg in ["g", "gold"]:
        gold_change = amount
    elif currency_type_arg in ["s", "silv", "silver"]:
        silver_change = amount
    elif currency_type_arg in ["c", "cop", "copper"]:
        copper_change = amount
    else:
        return schemas.CommandResponse(
            room_data=context.current_room_schema,
            message_to_player="Invalid currency type. Use p, g, s, or c."
        )

    updated_char, message = crud.crud_character.update_character_currency(
        context.db,
        character_id=context.active_character.id,
        platinum_change=plat_change, # Pass platinum
        gold_change=gold_change,
        silver_change=silver_change,
        copper_change=copper_change
    )
    
    if not updated_char: # Should not happen if character exists
        message = "Error updating currency."

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message) 
--- END OF FILE backend/app/commands/debug_parser.py ---

--- START OF FILE backend/app/api/v1/endpoints/command.py ---
# backend/app/api/v1/endpoints/command.py
from fastapi import APIRouter, Depends, Body
from sqlalchemy.orm import Session
from typing import Dict, Callable, Awaitable # For typing the registry

from app import schemas, models, crud # app.
from app.db.session import get_db
from app.api.dependencies import get_current_active_character # app.api.dependencies
from app.commands.command_args import CommandContext # app.commands.command_args

# Import handler modules
from app.commands import movement_parser
from app.commands import inventory_parser
from app.commands import social_parser
from app.commands import debug_parser
from app.commands import meta_parser
# from app.commands import combat_parser 


router = APIRouter()

# Define the type for our handler functions
CommandHandler = Callable[[CommandContext], Awaitable[schemas.CommandResponse]] # If handlers are async
# Or if synchronous: CommandHandler = Callable[[CommandContext], schemas.CommandResponse]
# Let's assume handlers can be async for future flexibility, even if current ones are not.

COMMAND_REGISTRY: Dict[str, CommandHandler] = {
    # Movement and Perception
    "look": movement_parser.handle_look,
    "l": movement_parser.handle_look,
    "north": movement_parser.handle_move,
    "n": movement_parser.handle_move,
    "south": movement_parser.handle_move,
    "s": movement_parser.handle_move,
    "east": movement_parser.handle_move,
    "e": movement_parser.handle_move,
    "west": movement_parser.handle_move,
    "w": movement_parser.handle_move,
    "up": movement_parser.handle_move,
    "u": movement_parser.handle_move,
    "down": movement_parser.handle_move,
    "d": movement_parser.handle_move,
    "go": movement_parser.handle_move, # "go north" will be handled by move knowing original command

    # Inventory Management
    "inventory": inventory_parser.handle_inventory,
    "i": inventory_parser.handle_inventory,
    "equip": inventory_parser.handle_equip,
    "eq": inventory_parser.handle_equip,
    "unequip": inventory_parser.handle_unequip,
    "uneq": inventory_parser.handle_unequip,
    "drop": inventory_parser.handle_drop,
    "get": inventory_parser.handle_get,
    "take": inventory_parser.handle_get,

    # Combat >>> moved to websockets
    # "attack": combat_parser.handle_attack, 
    # "atk": combat_parser.handle_attack,    
    # "kill": combat_parser.handle_attack,    

    # Social
    "fart": social_parser.handle_fart,

    # Debug
    "giveme": debug_parser.handle_giveme,
    "spawnmob": debug_parser.handle_spawnmob,
    "set_hp": debug_parser.handle_set_hp,       # <<< NEW
    "mod_xp": debug_parser.handle_mod_xp,       # <<< NEW
    "set_level": debug_parser.handle_set_level, # <<< NEW
    "setmoney": debug_parser.handle_set_money,     # <<< NEW
    "addmoney": debug_parser.handle_add_money, 

    # Meta
    "score": meta_parser.handle_score, # <<< ADDED
    "sc": meta_parser.handle_score, # <<< ADDED
    "skills": meta_parser.handle_skills,     # <<< NEW
    "sk": meta_parser.handle_skills,     # <<< NEW
    "traits": meta_parser.handle_traits,     # <<< NEW
    "tr": meta_parser.handle_traits,     # <<< NEW
    "status": meta_parser.handle_score, # Alias for score
    "st": meta_parser.handle_score, # Alias for score
    "help": meta_parser.handle_help,
    "?": meta_parser.handle_help,

    # Social
    "say": social_parser.handle_say,
    "'": social_parser.handle_say, # Common alias for say
    "emote": social_parser.handle_emote,
    ":": social_parser.handle_emote, # Common alias for emote
    "ooc": social_parser.handle_ooc,
    "fart": social_parser.handle_fart,
}

@router.post("", response_model=schemas.CommandResponse)
async def process_command_for_character(
    payload: schemas.CommandRequest = Body(...),
    db: Session = Depends(get_db),
    active_character: models.Character = Depends(get_current_active_character)
):
    original_command_text = payload.command.strip()
    if not original_command_text:
        return schemas.CommandResponse(message_to_player="Please type a command.")

    command_parts = original_command_text.split()
    command_verb = command_parts[0].lower()
    args = command_parts[1:]

    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    if not current_room_orm:
        return schemas.CommandResponse(message_to_player="CRITICAL ERROR: Character in void.")
    current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)

    context = CommandContext(
        db=db, active_character=active_character, current_room_orm=current_room_orm,
        current_room_schema=current_room_schema, original_command=original_command_text,
        command_verb=command_verb, args=args
    )

    handler = COMMAND_REGISTRY.get(command_verb)
    if handler:
        return await handler(context)
    else:
        # If command is an attack verb, suggest using game interface (implying WS)
        if command_verb in ["attack", "atk", "kill", "kil", "ki", "k"]:
             return schemas.CommandResponse(
                room_data=current_room_schema,
                message_to_player=f"Combat actions like '{command_verb}' are handled in real-time. (Use game interface)"
            )
        return schemas.CommandResponse(
            room_data=current_room_schema,
            message_to_player=f"I don't understand the command: '{original_command_text}'. Type 'help' or '?'."
        )
--- END OF FILE backend/app/api/v1/endpoints/command.py ---

--- START OF FILE backend/app/models/__init__.py ---
# File: backend/app/models/__init__.py

from .room import Room
from .player import Player
from .character import Character
from .item import Item
from .character_inventory_item import CharacterInventoryItem
from .room_item_instance import RoomItemInstance
from .mob_template import MobTemplate
from .room_mob_instance import RoomMobInstance
from .character_class_template import CharacterClassTemplate
from .skill_template import SkillTemplate
from .trait_template import TraitTemplate 
from .mob_spawn_definition import MobSpawnDefinition
--- END OF FILE backend/app/models/__init__.py ---

--- START OF FILE backend/app/models/player.py ---
# backend/app/models/player.py
import uuid
from typing import Optional, List, TYPE_CHECKING # List for future relationship typing

from sqlalchemy import Column, String # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship # Import Mapped, mapped_column

from ..db.base_class import Base

if TYPE_CHECKING: 
    from .character import Character 

class Player(Base):
    __tablename__ = "players"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
    characters: Mapped[List["Character"]] = relationship(back_populates="owner")

    # --- Relationships (Example for future) ---
    # If a Player can have multiple Characters:
    # characters: Mapped[List["Character"]] = relationship(back_populates="owner")
    # Note: Use "Character" as a string if Character class is defined later or in another file to avoid circular imports.

    def __repr__(self) -> str:
        return f"<Player(id={self.id}, username='{self.username}')>"
--- END OF FILE backend/app/models/player.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    owner: Mapped["Player"] = relationship(back_populates="characters")

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)

    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/character_class_template.py ---
# backend/app/models/character_class_template.py
import uuid
from typing import Optional, Dict, Any, List

from sqlalchemy import String, Text, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base
# No direct relationships to Character needed here, Character will link to this.

class CharacterClassTemplate(Base):
    __tablename__ = "character_class_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # How this class modifies base character stats (e.g., {"strength": 2, "dexterity": 1, "constitution": -1})
    base_stat_modifiers: Mapped[Optional[Dict[str, int]]] = mapped_column(JSONB, nullable=True)
    
    starting_health_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    starting_mana_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # Placeholder for skill/trait progression - LLM will populate this JSON structure
    # Example: {"core_skills_by_level": {"1": ["punch_good"], "5": ["kick_better"]}, "specializations": ...}
    skill_tree_definition: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)

    # List of item template names or tags the class starts with (e.g., ["Rusty Sword", "Cloth Tunic"])
    starting_equipment_refs: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True)
    
    # Tags to help categorize or for LLM to understand playstyle (e.g., ["melee", "caster", "tank"])
    playstyle_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True)

    def __repr__(self) -> str:
        return f"<CharacterClassTemplate(id={self.id}, name='{self.name}')>"
--- END OF FILE backend/app/models/character_class_template.py ---

--- START OF FILE backend/app/models/skill_template.py ---
# backend/app/models/skill_template.py
import uuid
from typing import Optional, Dict, Any, List

from sqlalchemy import String, Text, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column

from ..db.base_class import Base

class SkillTemplate(Base):
    __tablename__ = "skill_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # Unique internal identifier/tag, e.g., "power_attack", "pick_lock_basic", "fireball_rank1"
    # This is what will be stored in Character.learned_skills and referenced in skill_tree_definition
    skill_id_tag: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    
    name: Mapped[str] = mapped_column(String(100), nullable=False, comment="Player-facing name, e.g., 'Power Attack'")
    description: Mapped[Text] = mapped_column(Text, nullable=True, comment="Player-facing description of what the skill does.")
    
    skill_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, 
                                            comment="e.g., 'COMBAT_ACTIVE', 'COMBAT_PASSIVE', 'UTILITY_OOC', 'SOCIAL'")
    
    target_type: Mapped[str] = mapped_column(String(50), default="NONE", nullable=False,
                                             comment="e.g., 'SELF', 'ENEMY_MOB', 'FRIENDLY_CHAR', 'DOOR', 'ITEM_IN_ROOM', 'NONE'")
    
    # How the skill's effects are defined. Structure depends heavily on skill_type.
    # Examples:
    # COMBAT_ACTIVE: {"mana_cost": 5, "damage": {"dice": "1d6", "bonus_stat": "strength", "type": "physical"}, "status_effect_chance": {"effect_id": "stunned", "duration_rounds": 1, "chance_percent": 25}}
    # UTILITY_OOC (Pick Lock): {"target_subtype": "lock", "difficulty_check_attr": "dexterity", "base_dc": 15, "consumes_item_tag": "lockpick_set", "success_message": "The lock clicks open!", "failure_message": "You fumble with the lock."}
    # COMBAT_PASSIVE: {"stat_bonuses": {"attack_bonus": 1}, "conditional_trigger": "on_crit_hit"}
    effects_data: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False, default=lambda: {})

    # Requirements to learn/use the skill. Can be checked during level up or skill use.
    # Example: {"min_level": 3, "required_stats": {"intelligence": 12}, "requires_learned_skill": "basic_spellcasting_id", "requires_class_tag": "Mage"}
    requirements_data: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)

    # For skills that might have ranks or tiers (future use)
    rank: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1)
    # Cooldown in combat rounds, or seconds for OOC skills
    cooldown: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) 

    def __repr__(self) -> str:
        return f"<SkillTemplate(id={self.id}, skill_id_tag='{self.skill_id_tag}', name='{self.name}')>"
--- END OF FILE backend/app/models/skill_template.py ---

--- START OF FILE backend/app/models/trait_template.py ---
# backend/app/models/trait_template.py
import uuid
from typing import Optional, Dict, Any, List # <<< MAKE SURE List IS IMPORTED FROM typing

from sqlalchemy import String, Text
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column

from ..db.base_class import Base

class TraitTemplate(Base):
    __tablename__ = "trait_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    trait_id_tag: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    
    name: Mapped[str] = mapped_column(String(100), nullable=False, comment="Player-facing name, e.g., 'Nimble Fingers'")
    description: Mapped[Text] = mapped_column(Text, nullable=True, comment="Player-facing description.")
    
    trait_type: Mapped[str] = mapped_column(String(50), default="PASSIVE", nullable=False, 
                                            comment="Usually 'PASSIVE', but could be 'SOCIAL', 'BACKGROUND', etc.")
    
    effects_data: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False, default=lambda: {})

    # If this trait is mutually exclusive with others
    mutually_exclusive_with: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # type: ignore # Added default

    def __repr__(self) -> str:
        return f"<TraitTemplate(id={self.id}, trait_id_tag='{self.trait_id_tag}', name='{self.name}')>"
--- END OF FILE backend/app/models/trait_template.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/models/character_inventory_item.py ---
# backend/app/models/character_inventory_item.py
import uuid
from typing import TYPE_CHECKING, Optional

from sqlalchemy import ForeignKey, Integer, Boolean, String
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .character import Character  # noqa: F401
    from .item import Item  # noqa: F401


class CharacterInventoryItem(Base):
    __tablename__ = "character_inventory_items"

    # Composite Primary Key: (character_id, item_id)
    # However, SQLAlchemy prefers a single surrogate primary key for association objects
    # if they have additional attributes beyond just the foreign keys.
    # Let's add an explicit id for this table for easier reference, though character_id + item_id could form a unique constraint.
    # Or, if an item can appear multiple times (e.g. two identical non-stackable swords),
    # then an auto-incrementing ID for this table row is essential.
    # Let's assume for now a character can only have ONE "entry" for a given item_id, and quantity handles multiples if stackable.
    # If not stackable, and they have two of the same sword, they'd be two separate Item instances in the Item table (e.g. with serial numbers or unique IDs anyway).
    # For our MUD, usually an Item is a "template". If a player has two "Long Sword" (same item_id), this table handles it.
    # Okay, if Item.stackable is false, each instance is a separate row here with quantity 1.
    # If Item.stackable is true, one row with quantity > 1.
    # Let's give this table its own UUID PK for simplicity in referencing a specific *instance* in inventory.

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, comment="Unique ID for this specific instance of an item in a character's inventory")
    
    character_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Indicates if this specific inventory item instance is currently equipped
    equipped: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False, index=True)
    
    # If equipped, this specifies which of the character's equipment slots it occupies.
    # This must be one of the keys from models.item.EQUIPMENT_SLOTS.
    # Necessary for items that can fit into more than one type of slot (e.g. generic 'ring' item into 'finger_1' or 'finger_2')
    # or to distinguish main_hand vs off_hand for identical weapons.
    equipped_slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="Actual character slot occupied if equipped, e.g. 'finger_1'")

    # Relationships
    character: Mapped["Character"] = relationship(back_populates="inventory_items")
    item: Mapped["Item"] = relationship() # No back_populates needed if Item doesn't need to know all its inventory entries directly

    def __repr__(self) -> str:
        return f"<CharInvItem(id={self.id}, char_id='{self.character_id}', item_id='{self.item_id}', qty={self.quantity}, equipped={self.equipped}, slot='{self.equipped_slot}')>"
--- END OF FILE backend/app/models/character_inventory_item.py ---

--- START OF FILE backend/app/models/room_item_instance.py ---
# backend/app/models/room_item_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room import Room  # noqa: F401
    from .item import Item  # noqa: F401
    from .character import Character # noqa: F401

class RoomItemInstance(Base):
    __tablename__ = "room_item_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Optional: if this instance on the ground has different properties than the item template
    properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    
    dropped_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    dropped_by_character_id: Mapped[Optional[uuid.UUID]] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), nullable=True, index=True)

    # Relationships
    room: Mapped["Room"] = relationship(back_populates="items_on_ground")
    item: Mapped["Item"] = relationship(lazy="joined") # Eager load item template details by default
    dropped_by: Mapped[Optional["Character"]] = relationship() # Character who dropped it

    def __repr__(self) -> str:
        return f"<RoomItemInstance(id={self.id}, room_id='{self.room_id}', item_id='{self.item_id}', qty={self.quantity})>"
--- END OF FILE backend/app/models/room_item_instance.py ---

--- START OF FILE backend/app/models/mob_template.py ---
# backend/app/models/mob_template.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import String, Text, Integer # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class MobTemplate(Base):
    __tablename__ = "mob_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    mob_type: Mapped[Optional[str]] = mapped_column(String(50), index=True, nullable=True, comment="e.g., beast, humanoid, undead")
    
    base_health: Mapped[int] = mapped_column(Integer, nullable=False, default=10)
    base_attack: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., 1d6") 
    base_defense: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=10, comment="e.g., Armor Class")
    
    xp_value: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    loot_table_ref: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, comment="Placeholder for loot table reference")
    currency_drop: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB, 
        nullable=True,
        comment="Defines currency drop. E.g., {'p_chance': 1, 'p_min':0, 'p_max':1, 'g_chance': 10, 'g_min': 0, 'g_max': 2, 's_min': 5, 's_max': 20, 'c_min':10, 'c_max':100}"
    )
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'faction': 'rats'}") # Removed aggression from here
    level: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    
    aggression_type: Mapped[Optional[str]] = mapped_column(String(50), default="NEUTRAL", nullable=True, index=True, comment="e.g., NEUTRAL, AGGRESSIVE_ON_SIGHT, AGGRESSIVE_IF_APPROACHED") # <<< NEW FIELD

    # room_instances: Mapped[List["RoomMobInstance"]] = relationship(back_populates="mob_template") # If needed

    def __repr__(self) -> str:
        return f"<MobTemplate(id={self.id}, name='{self.name}', aggression='{self.aggression_type}')>"
--- END OF FILE backend/app/models/mob_template.py ---

--- START OF FILE backend/app/models/room_mob_instance.py ---
# backend/app/models/room_mob_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func, String, Boolean 
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base
# from .. import models # Let's remove this direct import from here

if TYPE_CHECKING:
    from .room import Room # Import specific model for type hinting
    from .mob_template import MobTemplate
    from .mob_spawn_definition import MobSpawnDefinition

class RoomMobInstance(Base):
    __tablename__ = "room_mob_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    mob_template_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_templates.id"), index=True, nullable=False)
    
    spawn_definition_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True), 
        ForeignKey("mob_spawn_definitions.id"),
        nullable=True, 
        index=True,
        name="spawn_point_id" 
    ) 

    current_health: Mapped[int] = mapped_column(Integer, nullable=False)
    instance_properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    spawned_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_action_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    is_static_placement: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False,
                                                      comment="True if this mob was placed specifically and should not be respawned by general systems.")

    # Relationships
    # For the Mapped type hint, use the specific import from TYPE_CHECKING
    # For the relationship string, use the class name directly if it's defined in another module
    # or the fully qualified string if needed.
    room: Mapped["Room"] = relationship(back_populates="mobs_in_room")
    mob_template: Mapped["MobTemplate"] = relationship(lazy="joined") 
    
    originating_spawn_definition: Mapped[Optional["MobSpawnDefinition"]] = relationship(
        foreign_keys=[spawn_definition_id], 
        back_populates="spawned_mob_instances"
    )

    def __repr__(self) -> str:
        return f"<RoomMobInstance(id={self.id}, room_id='{self.room_id}', template_id='{self.mob_template_id}', spawn_def_id='{self.spawn_definition_id}', hp={self.current_health})>"
--- END OF FILE backend/app/models/room_mob_instance.py ---

--- START OF FILE backend/app/models/mob_spawn_definition.py ---
# backend/app/models/mob_spawn_definition.py
import uuid
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func, String, Boolean 
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room import Room 
    from .mob_template import MobTemplate
    from .room_mob_instance import RoomMobInstance

class MobSpawnDefinition(Base):
    __tablename__ = "mob_spawn_definitions" 

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    definition_name: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False,
                                                 comment="Unique descriptive name, e.g., 'CellarRatsNorthCorner'")
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False,
                                             comment="Primary room this definition is tied to / origin room for roamers.")
    mob_template_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_templates.id"), index=True, nullable=False)
    
    quantity_min: Mapped[int] = mapped_column(Integer, default=1, nullable=False,
                                             comment="Spawner tries to maintain at least this many alive from this definition.")
    quantity_max: Mapped[int] = mapped_column(Integer, default=1, nullable=False,
                                             comment="Spawner won't spawn more than this many from this definition if min is met.")
    
    respawn_delay_seconds: Mapped[int] = mapped_column(Integer, default=300, nullable=False, 
                                                      comment="Delay after population drops below min, or after individual kill.")
    
    chance_to_spawn_percent: Mapped[int] = mapped_column(Integer, default=100, nullable=False,
                                                        comment="0-100 percent chance to spawn when conditions are met.")
    
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False,
                                           comment="Whether this spawn definition is currently active.")

    next_respawn_check_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True, index=True,
                                                                   comment="Next time the ticker should evaluate this spawner.")

    roaming_behavior: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True,
                                                                    comment="e.g., {'type': 'random_adjacent', 'move_chance_percent': 25, 'max_distance_from_spawn': 5}")
    
    # Relationships
    room: Mapped[Optional["Room"]] = relationship() 
    mob_template: Mapped[Optional["MobTemplate"]] = relationship()

    spawned_mob_instances: Mapped[List["RoomMobInstance"]] = relationship( 
        back_populates="originating_spawn_definition" 
    )

    def __repr__(self) -> str:
        return f"<MobSpawnDefinition(id={self.id}, name='{self.definition_name}', mob='{self.mob_template_id}', room='{self.room_id}', qty='{self.quantity_min}-{self.quantity_max}')>"
--- END OF FILE backend/app/models/mob_spawn_definition.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py
import uuid
from typing import Optional, Dict, List, TYPE_CHECKING # Added List, TYPE_CHECKING

from sqlalchemy import Column, Integer, String, Text, JSON
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship # Added relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance 
    from .room_mob_instance import RoomMobInstance

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    exits: Mapped[Optional[Dict[str, str]]] = mapped_column(JSON, nullable=True, default=lambda: {})

    # --- Items on Ground Relationship --- (<<< ADDED)
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan", # If room is deleted, items on ground in it are also deleted.
        lazy="selectin" # Use selectin loading for items_on_ground when a Room is loaded
    )

    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan", # If room is deleted, mobs in it are also deleted.
        lazy="selectin" 
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', x={self.x}, y={self.y}, z={self.z})>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/schemas/__init__.py ---
# File: backend/app/schemas/__init__.py

# Make the Pydantic models from room.py available directly under the schemas package
from .room import RoomBase, RoomCreate, RoomUpdate, RoomInDB
from .player import PlayerBase, PlayerCreate, PlayerUpdate, Player, PlayerInDB
from .character import CharacterBase, CharacterCreate, CharacterUpdate, Character, CharacterInDB
from .command import CommandRequest, CommandResponse
from .item import (  # <<< ADDED
    ItemBase, ItemCreate, ItemUpdate, Item, ItemInDB,
    CharacterInventoryItemBase, CharacterInventoryItemCreate, CharacterInventoryItemUpdate,
    CharacterInventoryItem, CharacterInventoryDisplay, EquipRequest
)
from .room_item import ( # <<< ADDED
    RoomItemInstanceBase, RoomItemInstanceCreate, RoomItemInstanceUpdate,
    RoomItemInstance, RoomItemsView
)
from .mob import ( # <<< ADDED
    MobTemplateBase, MobTemplateCreate, MobTemplateUpdate, MobTemplate,
    RoomMobInstanceBase, RoomMobInstanceCreate, RoomMobInstanceUpdate,
    RoomMobInstance, RoomMobsView
)
from .character_class_template import ( # <<< ADD THIS BLOCK
    CharacterClassTemplateBase, CharacterClassTemplateCreate, CharacterClassTemplateUpdate,
    CharacterClassTemplate, CharacterClassTemplateInDB
)
from .map import MapLevelDataResponse, MapRoomData
from .skill import ( # <<< ADD THIS BLOCK
    SkillTemplateBase, SkillTemplateCreate, SkillTemplateUpdate, SkillTemplate
)
from .trait import ( # <<< ADD THIS BLOCK
    TraitTemplateBase, TraitTemplateCreate, TraitTemplateUpdate, TraitTemplate
)
from .mob_spawn_definition import (
    MobSpawnDefinitionBase, MobSpawnDefinitionCreate, MobSpawnDefinitionUpdate, MobSpawnDefinition
)
--- END OF FILE backend/app/schemas/__init__.py ---

--- START OF FILE backend/app/schemas/player.py ---
# backend/app/schemas/player.py
from typing import Optional
import uuid
from pydantic import BaseModel, Field, EmailStr # EmailStr if you add email later

class PlayerBase(BaseModel):
    username: Optional[str] = Field(None, min_length=3, max_length=100)
    # email: Optional[EmailStr] = None # Example for later

class PlayerCreate(PlayerBase):
    username: str = Field(..., min_length=3, max_length=100) # type: ignore[override] # Make username required
    password: str = Field(..., min_length=8) # Plain password for creation

class PlayerUpdate(PlayerBase): # Not used yet, but for completeness
    username: Optional[str] = None
    password: Optional[str] = None # For password change functionality

class PlayerInDBBase(PlayerBase):
    id: uuid.UUID
    # hashed_password should not be in schemas returned to client

    class Config:
        from_attributes = True

class Player(PlayerInDBBase): # Schema for returning player info (without password)
    pass

class PlayerInDB(PlayerInDBBase): # More complete internal representation if needed
    hashed_password: str
--- END OF FILE backend/app/schemas/player.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)

    # Currency: Optional at creation, with defaults
    platinum_coins: Optional[int] = Field(0, description="Platinum coins owned by the character")
    gold_coins: Optional[int] = Field(0, description="Gold coins owned by the character")
    silver_coins: Optional[int] = Field(0, description="Silver coins owned by the character")
    copper_coins: Optional[int] = Field(100, description="Copper coins owned by the character, default 100 for new chars")

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):  # Inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    platinum_coins: int # type: ignore
    gold_coins: int # type: ignore
    silver_coins: int # type: ignore
    copper_coins: int # type: ignore

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/schemas/character_class_template.py ---
# backend/app/schemas/character_class_template.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

class CharacterClassTemplateBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=100)
    description: Optional[str] = None
    base_stat_modifiers: Optional[Dict[str, int]] = Field(default_factory=dict)
    starting_health_bonus: int = 0
    starting_mana_bonus: int = 0
    skill_tree_definition: Optional[Dict[str, Any]] = Field(default_factory=dict)
    starting_equipment_refs: Optional[List[str]] = Field(default_factory=list)
    playstyle_tags: Optional[List[str]] = Field(default_factory=list)

class CharacterClassTemplateCreate(CharacterClassTemplateBase):
    pass

class CharacterClassTemplateUpdate(BaseModel): # For partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    base_stat_modifiers: Optional[Dict[str, int]] = None
    starting_health_bonus: Optional[int] = None
    starting_mana_bonus: Optional[int] = None
    skill_tree_definition: Optional[Dict[str, Any]] = None
    starting_equipment_refs: Optional[List[str]] = None
    playstyle_tags: Optional[List[str]] = None

class CharacterClassTemplateInDBBase(CharacterClassTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class CharacterClassTemplate(CharacterClassTemplateInDBBase): # For returning to client
    pass

class CharacterClassTemplateInDB(CharacterClassTemplateInDBBase): # For DB internal use
    pass
--- END OF FILE backend/app/schemas/character_class_template.py ---

--- START OF FILE backend/app/schemas/skill.py ---
# backend/app/schemas/skill.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List # Added List

class SkillTemplateBase(BaseModel):
    skill_id_tag: str = Field(..., min_length=3, max_length=100, pattern="^[a-z0-9_]+$",
                               description="Unique internal identifier, e.g., 'power_attack'. Lowercase, numbers, underscores.")
    name: str = Field(..., min_length=3, max_length=100, description="Player-facing name, e.g., 'Power Attack'")
    description: Optional[str] = None
    skill_type: str = Field(..., description="e.g., 'COMBAT_ACTIVE', 'PASSIVE', 'UTILITY_OOC'")
    target_type: str = Field(default="NONE", description="e.g., 'SELF', 'ENEMY_MOB', 'NONE'")
    effects_data: Dict[str, Any] = Field(default_factory=dict)
    requirements_data: Optional[Dict[str, Any]] = Field(default_factory=dict)
    rank: Optional[int] = Field(1, ge=1)
    cooldown: Optional[int] = Field(0, ge=0)

class SkillTemplateCreate(SkillTemplateBase):
    pass

class SkillTemplateUpdate(BaseModel): # For partial updates
    skill_id_tag: Optional[str] = Field(None, min_length=3, max_length=100, pattern="^[a-z0-9_]+$")
    name: Optional[str] = Field(None, min_length=3, max_length=100)
    description: Optional[str] = None
    skill_type: Optional[str] = None
    target_type: Optional[str] = None
    effects_data: Optional[Dict[str, Any]] = None
    requirements_data: Optional[Dict[str, Any]] = None
    rank: Optional[int] = Field(None, ge=1)
    cooldown: Optional[int] = Field(None, ge=0)

class SkillTemplateInDBBase(SkillTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class SkillTemplate(SkillTemplateInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/skill.py ---

--- START OF FILE backend/app/schemas/trait.py ---
# backend/app/schemas/trait.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List # Added List

class TraitTemplateBase(BaseModel):
    trait_id_tag: str = Field(..., min_length=3, max_length=100, pattern="^[a-z0-9_]+$",
                                description="Unique internal identifier, e.g., 'nimble_fingers'. Lowercase, numbers, underscores.")
    name: str = Field(..., min_length=3, max_length=100, description="Player-facing name, e.g., 'Nimble Fingers'")
    description: Optional[str] = None
    trait_type: str = Field(default="PASSIVE", description="e.g., 'PASSIVE', 'SOCIAL'")
    effects_data: Dict[str, Any] = Field(default_factory=dict)
    mutually_exclusive_with: Optional[List[str]] = Field(default_factory=list)

class TraitTemplateCreate(TraitTemplateBase):
    pass

class TraitTemplateUpdate(BaseModel): # For partial updates
    trait_id_tag: Optional[str] = Field(None, min_length=3, max_length=100, pattern="^[a-z0-9_]+$")
    name: Optional[str] = None
    description: Optional[str] = None
    trait_type: Optional[str] = None
    effects_data: Optional[Dict[str, Any]] = None
    mutually_exclusive_with: Optional[List[str]] = None

class TraitTemplateInDBBase(TraitTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class TraitTemplate(TraitTemplateInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/trait.py ---

--- START OF FILE backend/app/schemas/item.py ---
# backend/app/schemas/item.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- Item Schemas ---
class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    item_type: str = Field(..., description="e.g., weapon, armor, potion, junk")
    slot: Optional[str] = Field(None, description="Primary equippable slot type, e.g., head, main_hand, consumable")
    properties: Optional[Dict[str, Any]] = Field(None, description="e.g., {'damage': '1d6', 'armor_class': 5}")
    weight: float = Field(0.0, ge=0)
    value: int = Field(0, ge=0)
    stackable: bool = False
    max_stack_size: Optional[int] = Field(1, ge=1)

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    item_type: Optional[str] = None
    slot: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    weight: Optional[float] = None
    value: Optional[int] = None
    stackable: Optional[bool] = None
    max_stack_size: Optional[int] = None

class ItemInDBBase(ItemBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class Item(ItemInDBBase): # For returning item info
    pass

class ItemInDB(ItemInDBBase): # More complete internal representation if needed
    pass


# --- CharacterInventoryItem Schemas ---
# This represents an item *instance* in a character's inventory

class CharacterInventoryItemBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    equipped: bool = False
    equipped_slot: Optional[str] = None # Actual character slot occupied if equipped

class CharacterInventoryItemCreate(CharacterInventoryItemBase):
    # character_id will be supplied by the service/path
    pass

class CharacterInventoryItemUpdate(BaseModel):
    quantity: Optional[int] = Field(None, ge=1)
    equipped: Optional[bool] = None
    equipped_slot: Optional[str] = None

class CharacterInventoryItemInDBBase(CharacterInventoryItemBase):
    id: uuid.UUID # The unique ID of this inventory entry
    character_id: uuid.UUID
    item: Item # Include full item details when displaying inventory

    class Config:
        from_attributes = True

class CharacterInventoryItem(CharacterInventoryItemInDBBase): # For returning to client
    pass


# --- Composite Schema for Displaying Full Inventory ---
class CharacterInventoryDisplay(BaseModel):
    equipped_items: Dict[str, CharacterInventoryItem] = Field(default_factory=dict, description="Items currently equipped, keyed by their equipped_slot")
    backpack_items: List[CharacterInventoryItem] = Field(default_factory=list, description="Items in inventory but not equipped")
    platinum: int = 0
    gold: int = 0
    silver: int = 0
    copper: int = 0
    # Add more fields like total_weight, currency later

class EquipRequest(BaseModel):
    target_slot: Optional[str] = Field(None, description="Optional: The specific character slot to equip the item to, e.g., 'finger_1'")
--- END OF FILE backend/app/schemas/item.py ---

--- START OF FILE backend/app/schemas/room_item.py ---
# backend/app/schemas/room_item.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any

from .item import Item # Import the Item schema for nesting

class RoomItemInstanceBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    properties_override: Optional[Dict[str, Any]] = None

class RoomItemInstanceCreate(RoomItemInstanceBase):
    # room_id will be supplied by the service/path
    # dropped_by_character_id can be optional
    dropped_by_character_id: Optional[uuid.UUID] = None

class RoomItemInstanceUpdate(BaseModel): # For potential future use
    quantity: Optional[int] = Field(None, ge=1)
    properties_override: Optional[Dict[str, Any]] = None

class RoomItemInstanceInDBBase(RoomItemInstanceBase):
    id: uuid.UUID # The unique ID of this room item instance
    room_id: uuid.UUID
    dropped_at: datetime
    dropped_by_character_id: Optional[uuid.UUID] = None
    
    item: Item # Include full item details from the Item template

    class Config:
        from_attributes = True

class RoomItemInstance(RoomItemInstanceInDBBase): # For returning to client
    pass

# Schema for displaying items in a room (could be part of a larger RoomDetail schema)
class RoomItemsView(BaseModel):
    items_on_ground: List[RoomItemInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/room_item.py ---

--- START OF FILE backend/app/schemas/mob.py ---
# backend/app/schemas/mob.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- MobTemplate Schemas ---
class MobTemplateBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    mob_type: Optional[str] = None
    base_health: int = Field(10, gt=0)
    base_attack: Optional[str] = "1d4"
    base_defense: Optional[int] = 10
    xp_value: int = 0
    loot_table_ref: Optional[str] = None
    currency_drop: Optional[Dict[str, Any]] = None
    properties: Optional[Dict[str, Any]] = None
    level: Optional[int] = None
    aggression_type: Optional[str] = Field("NEUTRAL", description="e.g., NEUTRAL, AGGRESSIVE_ON_SIGHT") # <<< NEW FIELD

class MobTemplateCreate(MobTemplateBase):
    pass

class MobTemplateUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    mob_type: Optional[str] = None
    base_health: Optional[int] = Field(None, gt=0)
    base_attack: Optional[str] = None
    base_defense: Optional[int] = None
    xp_value: Optional[int] = None
    loot_table_ref: Optional[str] = None
    currency_drop: Optional[Dict[str, Any]] = None
    properties: Optional[Dict[str, Any]] = None
    level: Optional[int] = None
    aggression_type: Optional[str] = None # <<< NEW FIELD

class MobTemplateInDBBase(MobTemplateBase):
    id: uuid.UUID
    class Config:
        from_attributes = True

class MobTemplate(MobTemplateInDBBase): # For returning template info
    pass


# --- RoomMobInstance Schemas ---
class RoomMobInstanceBase(BaseModel):
    mob_template_id: uuid.UUID
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None

class RoomMobInstanceCreate(BaseModel): # For service layer use
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    # current_health typically set from template by service
    instance_properties_override: Optional[Dict[str, Any]] = None 
    spawn_definition_id: Optional[uuid.UUID] = None # <<< RENAMED FROM spawn_point_id
    
class RoomMobInstanceUpdate(BaseModel): # For combat updates
    current_health: Optional[int] = None
    instance_properties_override: Optional[Dict[str, Any]] = Field(None, description="Use with caution, replaces entire dict")

class RoomMobInstanceInDBBase(BaseModel): 
    id: uuid.UUID
    room_id: uuid.UUID
    mob_template_id: uuid.UUID 
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None
    spawn_definition_id: Optional[uuid.UUID] = None # <<< RENAMED FROM spawn_point_id
    spawned_at: datetime
    last_action_at: Optional[datetime] = None
    
    mob_template: MobTemplate 

    class Config:
        from_attributes = True

class RoomMobInstance(RoomMobInstanceInDBBase): 
    pass

class RoomMobsView(BaseModel):
    mobs_in_room: List[RoomMobInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/mob.py ---

--- START OF FILE backend/app/schemas/mob_spawn_definition.py ---
# backend/app/schemas/mob_spawn_definition.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any

from pydantic import BaseModel, Field

class MobSpawnDefinitionBase(BaseModel):
    definition_name: str = Field(..., min_length=3, max_length=255)
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    quantity_min: int = Field(default=1, ge=1)
    quantity_max: int = Field(default=1, ge=1) # Should validate quantity_max >= quantity_min later
    respawn_delay_seconds: int = Field(default=300, ge=5)
    chance_to_spawn_percent: int = Field(default=100, ge=0, le=100)
    is_active: bool = True
    roaming_behavior: Optional[Dict[str, Any]] = None
    # next_respawn_check_at is usually managed by the system, not set on create/update by user

class MobSpawnDefinitionCreate(MobSpawnDefinitionBase):
    pass

class MobSpawnDefinitionUpdate(BaseModel): # Allow partial updates
    definition_name: Optional[str] = Field(None, min_length=3, max_length=255)
    room_id: Optional[uuid.UUID] = None
    mob_template_id: Optional[uuid.UUID] = None
    quantity_min: Optional[int] = Field(None, ge=1)
    quantity_max: Optional[int] = Field(None, ge=1)
    respawn_delay_seconds: Optional[int] = Field(None, ge=5)
    chance_to_spawn_percent: Optional[int] = Field(None, ge=0, le=100)
    is_active: Optional[bool] = None
    roaming_behavior: Optional[Dict[str, Any]] = None
    next_respawn_check_at: Optional[datetime] = None # Allow admin to set/reset this

class MobSpawnDefinitionInDBBase(MobSpawnDefinitionBase):
    id: uuid.UUID
    next_respawn_check_at: Optional[datetime] = None

    class Config:
        from_attributes = True

class MobSpawnDefinition(MobSpawnDefinitionInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/mob_spawn_definition.py ---

--- START OF FILE backend/app/schemas/room.py ---
# backend/app/schemas/room.py
from pydantic import BaseModel, Field, field_validator # field_validator for Pydantic v2
import uuid # Import uuid
from typing import Dict, Optional, Any

class RoomBase(BaseModel):
    name: str
    description: Optional[str] = None
    x: int
    y: int
    z: int
    # Exits: keys are directions (str), values are target room UUIDs (str)
    exits: Optional[Dict[str, str]] = Field(default_factory=dict) 

class RoomCreate(RoomBase):
    # id can optionally be provided if you want to set it explicitly,
    # otherwise the DB model's default=uuid.uuid4 will handle it.
    id: Optional[uuid.UUID] = None 
    # name, description, x, y, z, exits are inherited
    pass

class RoomUpdate(BaseModel): # Not heavily used yet, but good to keep consistent
    name: Optional[str] = None
    description: Optional[str] = None
    x: Optional[int] = None
    y: Optional[int] = None
    z: Optional[int] = None
    exits: Optional[Dict[str, str]] = None

class RoomInDB(RoomBase): # This schema is used for reading rooms from DB
    id: uuid.UUID # ID from DB will definitely be a UUID

    class Config:
        from_attributes = True # For Pydantic v2 ORM mode

--- END OF FILE backend/app/schemas/room.py ---

--- START OF FILE backend/app/schemas/map.py ---
# backend/app/schemas/map.py (NEW FILE)
import uuid
from pydantic import BaseModel, Field
from typing import List, Dict, Optional

from .room import RoomInDB # We'll use the existing RoomInDB for individual room details

class MapRoomData(BaseModel):
    id: uuid.UUID
    x: int
    y: int
    name: Optional[str] = None # Optional: for tooltips or labels
    exits: Optional[Dict[str, str]] = Field(default_factory=dict)
    is_current_room: bool = False
    is_visited: bool = True # For now, all fetched rooms are considered visited

class MapLevelDataResponse(BaseModel):
    z_level: int
    current_room_id: Optional[uuid.UUID] = None
    rooms: List[MapRoomData] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/map.py ---

--- START OF FILE backend/app/schemas/command.py ---
# backend/app/schemas/command.py
from pydantic import BaseModel
from typing import Optional
from .room import RoomInDB

class CommandRequest(BaseModel):
    command: str

class CommandResponse(BaseModel):
    room_data: Optional[RoomInDB] = None
    message_to_player: Optional[str] = None
    combat_over: bool = False # True if combat resolved (death, flee)
    # Add other potential fields for game state updates if needed for HTTP path
--- END OF FILE backend/app/schemas/command.py ---

--- FILE NOT FOUND: backend/app/schemas/token.py ---

--- START OF FILE backend/app/crud/__init__.py ---
# File: backend/app/crud/__init__.py

from . import crud_room # This makes the crud_room.py module accessible as crud.crud_room
from . import crud_player
from . import crud_character
from . import crud_item  # <<< ADDED
from . import crud_character_inventory  # <<< ADDED
from . import crud_room_item  # <<< ADDED
from . import crud_mob
from . import crud_character_class
from . import crud_skill
from . import crud_trait
from . import crud_mob_spawn_definition
--- END OF FILE backend/app/crud/__init__.py ---

--- START OF FILE backend/app/crud/crud_player.py ---
# backend/app/crud/crud_player.py
from sqlalchemy.orm import Session
import uuid # Ensure uuid is imported
from typing import Optional

from .. import models, schemas # models.Player, schemas.PlayerCreate etc.
from ..core.security import get_password_hash # Our password hashing utility

def get_player(db: Session, player_id: uuid.UUID) -> Optional[models.Player]:
    return db.query(models.Player).filter(models.Player.id == player_id).first()

def get_player_by_username(db: Session, username: str) -> Optional[models.Player]:
    return db.query(models.Player).filter(models.Player.username == username).first()

def create_player(db: Session, *, player_in: schemas.PlayerCreate) -> models.Player:
    hashed_password = get_password_hash(player_in.password)
    # Create a dictionary for the DB model, excluding the plain password
    db_player_data = player_in.model_dump(exclude={'password'})
    db_player = models.Player(**db_player_data, hashed_password=hashed_password)
    
    db.add(db_player)
    db.commit()
    db.refresh(db_player)
    return db_player
--- END OF FILE backend/app/crud/crud_player.py ---

--- START OF FILE backend/app/crud/crud_character.py ---
# backend/app/crud/crud_character.py
from sqlalchemy.orm import Session, attributes
import uuid
from typing import Any, Dict, Optional, List, Tuple, Union 

from .. import models, schemas, crud # <<< ADDED crud FOR crud_character_class

DEFAULT_STATS = {
    "strength": 10, "dexterity": 10, "constitution": 10,
    "intelligence": 10, "wisdom": 10, "charisma": 10, "luck": 5,
    "current_health": 20, "max_health": 20,
    "current_mana": 10, "max_mana": 10,
    "level": 1, "experience_points": 0,
    "base_ac": 10, "base_attack_bonus": 0,
    "base_damage_dice": "1d4", "base_damage_bonus": 0,
    "learned_skills": [], "learned_traits": []
}

XP_THRESHOLDS = {
    1: 0,       # Start at level 1 with 0 XP
    2: 100,
    3: 300,     # Need 200 more XP from level 2 (100+200)
    4: 600,     # Need 300 more XP from level 3 (300+300)
    5: 1000,    # Need 400 more XP
    # ... add more levels as needed
}

COPPER_PER_SILVER = 100
SILVER_PER_GOLD = 100
GOLD_PER_PLATINUM = 100

CLASS_LEVEL_BONUSES = {
    "Warrior": {"hp_per_level": 5, "mp_per_level": 1, "base_attack_bonus_per_level": 0.5}, # BAB increases every 2 levels
    "Swindler": {"hp_per_level": 3, "mp_per_level": 2, "base_attack_bonus_per_level": 0.5},
    "Adventurer": {"hp_per_level": 4, "mp_per_level": 1, "base_attack_bonus_per_level": 0.5}, # Default
    # Add other seeded classes
}

def update_character_currency(
    db: Session, 
    character_id: uuid.UUID, 
    platinum_change: int = 0,
    gold_change: int = 0, 
    silver_change: int = 0, 
    copper_change: int = 0
) -> Tuple[Optional[models.Character], str]: # Returns char and a message
    """
    Updates a character's currency. Handles negative changes by attempting to make change.
    Returns the updated character and a status message.
    """
    character = get_character(db, character_id=character_id)
    if not character:
        return None, "Character not found."

    # Convert all existing currency and changes to the smallest unit (copper)
    current_total_copper = (character.platinum_coins * GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                           (character.gold_coins * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                           (character.silver_coins * COPPER_PER_SILVER) + \
                            character.copper_coins
    
    change_total_copper = (platinum_change * GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                          (gold_change * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                          (silver_change * COPPER_PER_SILVER) + \
                           copper_change

    if current_total_copper + change_total_copper < 0:
        return character, "Not enough funds for this transaction."

    new_total_copper = current_total_copper + change_total_copper

    # Convert back to platinum, gold, silver, copper
    new_platinum = new_total_copper // (GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER)
    remainder_after_platinum = new_total_copper % (GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER)
    
    new_gold = remainder_after_platinum // (SILVER_PER_GOLD * COPPER_PER_SILVER) 
    remainder_after_gold = remainder_after_platinum % (SILVER_PER_GOLD * COPPER_PER_SILVER)    
    
    new_silver = remainder_after_gold // COPPER_PER_SILVER
    new_copper = remainder_after_gold % COPPER_PER_SILVER

    character.platinum_coins = new_platinum # Store platinum
    character.gold_coins = new_gold
    character.silver_coins = new_silver
    character.copper_coins = new_copper

    db.add(character)
    db.commit()
    db.refresh(character)
    
    # Construct a message about the change
    change_parts = []
    if platinum_change != 0: change_parts.append(f"{abs(platinum_change)}p") # Add platinum to change parts
    if gold_change != 0: change_parts.append(f"{abs(gold_change)}g")
    if silver_change != 0: change_parts.append(f"{abs(silver_change)}s")
    if copper_change != 0: change_parts.append(f"{abs(copper_change)}c")
    
    action = "gained" if change_total_copper > 0 else "lost" if change_total_copper < 0 else "changed by"
    
    # Construct current balance string
    balance_parts = []
    if new_platinum > 0: balance_parts.append(f"{new_platinum}p")
    if new_gold > 0: balance_parts.append(f"{new_gold}g")
    if new_silver > 0: balance_parts.append(f"{new_silver}s")
    # Always show copper if it's the only currency or if other denominations are zero
    if new_copper > 0 or not balance_parts: balance_parts.append(f"{new_copper}c")
    current_balance_str = " ".join(balance_parts) if balance_parts else "0c"


    if not change_parts and change_total_copper == 0:
        message = "Currency unchanged."
    elif not change_parts and change_total_copper != 0: 
         message = f"Currency updated. New total: {current_balance_str}"
    else:
        message = f"You {action} {' '.join(change_parts)}. Current balance: {current_balance_str}"

    return character, message

def get_xp_for_level(level: int) -> Union[int, float]: # <<< CHANGED RETURN TYPE
    """Returns the total XP required to attain the specified level."""
    return XP_THRESHOLDS.get(level, float('inf')) # <<< USE float('inf')


def get_character(db: Session, character_id: uuid.UUID) -> Optional[models.Character]:
    return db.query(models.Character).filter(models.Character.id == character_id).first()

def get_character_by_name(db: Session, name: str) -> Optional[models.Character]:
    return db.query(models.Character).filter(models.Character.name == name).first()

def get_characters_by_player(db: Session, player_id: uuid.UUID, skip: int = 0, limit: int = 100) -> List[models.Character]:
    return db.query(models.Character).filter(models.Character.player_id == player_id).offset(skip).limit(limit).all()

def _grant_abilities_for_level(db: Session, character: models.Character, level_to_grant_for: int) -> List[str]:
    """Grants skills/traits for a specific level. Called by create_character for L1, and _apply_level_up for L2+."""
    granted_messages = []
    level_str = str(level_to_grant_for)
    # --- Debug prints to add if still having issues ---
    # print(f"DEBUG GrantAbilities: Char '{character.name}', Attempting for Level: {level_str}")

    class_template: Optional[models.CharacterClassTemplate] = None
    if character.character_class_template_id:
        if character.class_template_ref and character.class_template_ref.id == character.character_class_template_id:
            class_template = character.class_template_ref
        else:
            class_template = crud.crud_character_class.get_character_class_template(db, class_template_id=character.character_class_template_id)
    
    # --- Debug prints ---
    # if class_template:
    #     print(f"DEBUG GrantAbilities: Found class template '{class_template.name}' with skill tree: {class_template.skill_tree_definition is not None}")
    #     if class_template.skill_tree_definition: print(f"DEBUG GrantAbilities: Skill tree: {class_template.skill_tree_definition}")
    # else:
    #     print(f"DEBUG GrantAbilities: No class template found for character {character.name} (template_id: {character.character_class_template_id})")
    #     return granted_messages


    if class_template and class_template.skill_tree_definition:
        skill_tree: Dict[str, Any] = class_template.skill_tree_definition

        # Grant Core Skills
        core_skills_for_level: List[str] = skill_tree.get("core_skills_by_level", {}).get(level_str, [])
        # print(f"DEBUG GrantAbilities: Skills for level '{level_str}': {core_skills_for_level}")
        if core_skills_for_level:
            if character.learned_skills is None: character.learned_skills = []
            learned_new = False
            for skill_tag in core_skills_for_level:
                skill_def = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_tag)
                # print(f"DEBUG GrantAbilities: Trying skill '{skill_tag}', found def: {skill_def is not None}")
                if skill_def and skill_tag not in character.learned_skills:
                    character.learned_skills.append(skill_tag)
                    granted_messages.append(f"You have learned skill: {skill_def.name}!")
                    learned_new = True
            if learned_new: attributes.flag_modified(character, "learned_skills")

        # Grant Core Traits
        core_traits_for_level: List[str] = skill_tree.get("core_traits_by_level", {}).get(level_str, [])
        # print(f"DEBUG GrantAbilities: Traits for level '{level_str}': {core_traits_for_level}")
        if core_traits_for_level:
            if character.learned_traits is None: character.learned_traits = []
            learned_new = False
            for trait_tag in core_traits_for_level:
                trait_def = crud.crud_trait.get_trait_template_by_tag(db, trait_id_tag=trait_tag)
                # print(f"DEBUG GrantAbilities: Trying trait '{trait_tag}', found def: {trait_def is not None}")
                if trait_def and trait_tag not in character.learned_traits:
                    character.learned_traits.append(trait_tag)
                    granted_messages.append(f"You have gained trait: {trait_def.name}!")
                    learned_new = True
            if learned_new: attributes.flag_modified(character, "learned_traits")
    # else:
        # print(f"DEBUG GrantAbilities: No class template or skill tree for character {character.name} at level '{level_str}'")
        
    return granted_messages

def create_character(
    db: Session, *,
    character_in: schemas.CharacterCreate,
    player_id: uuid.UUID,
    initial_room_id: uuid.UUID
) -> models.Character:
    db_character_data = character_in.model_dump(exclude_unset=True)
    final_char_args = DEFAULT_STATS.copy()
    class_template_id_to_set: Optional[uuid.UUID] = None
    class_name_to_set = db_character_data.get("class_name", "Adventurer") # Changed default to Adventurer to match class bonuses
    class_template: Optional[models.CharacterClassTemplate] = None

    if class_name_to_set and class_name_to_set != "Adventurer": # Match the default
        class_template = crud.crud_character_class.get_character_class_template_by_name(db, name=class_name_to_set)
        if class_template:
            class_template_id_to_set = class_template.id
            class_name_to_set = class_template.name
            if class_template.base_stat_modifiers:
                for stat, modifier in class_template.base_stat_modifiers.items():
                    if stat in final_char_args: final_char_args[stat] += modifier
            final_char_args["max_health"] += class_template.starting_health_bonus
            final_char_args["current_health"] = final_char_args["max_health"]
            final_char_args["max_mana"] += class_template.starting_mana_bonus
            final_char_args["current_mana"] = final_char_args["max_mana"]
        else:
            print(f"Warning: Character class template '{class_name_to_set}' not found. Defaulting to Adventurer stats.")
            class_name_to_set = "Adventurer"
            
    db_character = models.Character(
        name=db_character_data["name"],
        class_name=class_name_to_set,
        player_id=player_id,
        current_room_id=initial_room_id,
        character_class_template_id=class_template_id_to_set,
        **final_char_args
    )
    db.add(db_character)
    db.commit()
    db.refresh(db_character)

    # --- Crucial: Grant Level 1 Abilities AFTER character is in DB and refreshed ---
    # Ensure class_template is available for _grant_abilities_for_level
    # The refresh above might not populate db_character.class_template_ref if not configured for eager loading.
    # So, we re-use the 'class_template' variable we fetched earlier if it's valid.
    # If 'class_template' is None (e.g. for "Adventurer" if no template defined or for a class not found),
    # then _grant_abilities_for_level will try to fetch it again using db_character.character_class_template_id
    if class_template: # If we had fetched a valid class template earlier
        db_character.class_template_ref = class_template # Explicitly assign to the instance for _grant_abilities_for_level

    initial_ability_messages = _grant_abilities_for_level(db, db_character, 1) # Grant for Level 1
    
    # If abilities were granted, the lists in db_character are modified.
    # We need to add to session again and commit.
    if initial_ability_messages: # Check if any messages were generated (implies changes)
        print(f"Character '{db_character.name}' initial abilities granted: {', '.join(initial_ability_messages)}")
        db.add(db_character) 
        db.commit()
        db.refresh(db_character) # Refresh again to get the latest state with learned skills/traits

    # Grant starting equipment
    if class_template and class_template.starting_equipment_refs:
        for item_ref_name in class_template.starting_equipment_refs:
            item_template_to_add = crud.crud_item.get_item_by_name(db, name=item_ref_name)
            if item_template_to_add:
                crud.crud_character_inventory.add_item_to_character_inventory(
                    db, character_id=db_character.id, item_id=item_template_to_add.id, quantity=1
                )
        db.commit()
        db.refresh(db_character)
        
    return db_character

def update_character_room(db: Session, character_id: uuid.UUID, new_room_id: uuid.UUID) -> Optional[models.Character]:
    db_character = get_character(db, character_id=character_id)
    if db_character:
        db_character.current_room_id = new_room_id # Direct assignment is fine
        db.add(db_character) # Add to session to mark as dirty
        db.commit()
        db.refresh(db_character)
        return db_character
    return None

def update_character_health(db: Session, character_id: uuid.UUID, amount_change: int) -> Optional[models.Character]:
    """Updates character's current health by amount_change. Clamps between 0 and max_health."""
    character = get_character(db, character_id=character_id)
    if not character:
        return None
    
    character.current_health += amount_change
    if character.current_health < 0:
        character.current_health = 0
    if character.current_health > character.max_health:
        character.current_health = character.max_health
        
    db.add(character)
    db.commit()
    db.refresh(character)
    return character

# Conceptual: def level_up_character(db: Session, character: models.Character): ...
def _apply_level_up(db: Session, character: models.Character) -> List[str]:
    level_up_messages = []
    
    current_max_defined_level = max(XP_THRESHOLDS.keys()) if XP_THRESHOLDS else 0 # Ensure XP_THRESHOLDS is not empty
    if character.level >= current_max_defined_level and get_xp_for_level(character.level + 1) == float('inf'):
         level_up_messages.append(f"You are already at the maximum defined level ({character.level}). Cannot level up further.")
         return level_up_messages

    character.level += 1
    new_level_str = str(character.level)
    level_up_messages.append(f"Ding! You have reached Level {character.level}!")

    class_bonuses = CLASS_LEVEL_BONUSES.get(character.class_name, CLASS_LEVEL_BONUSES["Adventurer"])
    con_mod = character.get_attribute_modifier("constitution")
    hp_gain = max(1, con_mod + class_bonuses.get("hp_per_level", 3)) 
    character.max_health += hp_gain
    level_up_messages.append(f"Your maximum health increases by {hp_gain}!")

    int_mod = character.get_attribute_modifier("intelligence")
    mp_gain = max(0, int_mod + class_bonuses.get("mp_per_level", 1)) 
    character.max_mana += mp_gain
    if mp_gain > 0:
        level_up_messages.append(f"Your maximum mana increases by {mp_gain}!")

    character.current_health = character.max_health
    character.current_mana = character.max_mana
    level_up_messages.append("You feel invigorated!")
    
    # Grant abilities for the NEW level achieved
    ability_messages = _grant_abilities_for_level(db, character, character.level) # Pass the new level
    level_up_messages.extend(ability_messages)
    
    db.add(character)
    return level_up_messages


def _apply_level_down(db: Session, character: models.Character) -> List[str]:
    if character.level <= 1:
        return ["You cannot de-level below level 1, you pathetic worm."]
    
    level_down_messages = []
    
    # Store previous level's XP requirement BEFORE changing level
    xp_for_new_lower_level = get_xp_for_level(character.level - 1)
    if xp_for_new_lower_level == float('inf'): # Should not happen if level > 1
        xp_for_new_lower_level = XP_THRESHOLDS.get(character.level -1, 0) # Failsafe


    class_bonuses = CLASS_LEVEL_BONUSES.get(character.class_name, CLASS_LEVEL_BONUSES["Adventurer"])
    con_mod = character.get_attribute_modifier("constitution") 
    hp_loss_estimate = max(1, con_mod + class_bonuses.get("hp_per_level", 3))
    character.max_health = max(1, character.max_health - hp_loss_estimate) 
    level_down_messages.append(f"Your maximum health decreases by {hp_loss_estimate}.")

    int_mod = character.get_attribute_modifier("intelligence")
    mp_loss_estimate = max(0, int_mod + class_bonuses.get("mp_per_level", 1))
    character.max_mana = max(0, character.max_mana - mp_loss_estimate)
    if mp_loss_estimate > 0:
        level_down_messages.append(f"Your maximum mana decreases by {mp_loss_estimate}.")

    character.current_health = min(character.current_health, character.max_health)
    character.current_mana = min(character.current_mana, character.max_mana)

    character.level -= 1
    level_down_messages.append(f"You feel weaker... You have de-leveled to Level {character.level}.")
    
    character.experience_points = int(xp_for_new_lower_level) # XP at start of new (lower) level

    db.add(character)
    return level_down_messages


def add_experience(db: Session, character_id: uuid.UUID, amount: int) -> Tuple[Optional[models.Character], List[str]]:

    
    character = get_character(db, character_id=character_id)
    if not character:
        return None, ["Character not found."]

    messages = []
    if amount == 0:
        return character, ["No experience gained or lost. How pointless."]

    initial_level = character.level
    character.experience_points += amount
    if amount !=0 : # only print if xp actually changed
      messages.append(f"{'Gained' if amount > 0 else 'Lost'} {abs(amount)} experience points. Current XP: {character.experience_points}")


    # Handle Leveling Up
    xp_for_next_level = get_xp_for_level(character.level + 1)
    while character.experience_points >= xp_for_next_level and xp_for_next_level != float('inf'):
        overflow_xp = character.experience_points - int(xp_for_next_level) # xp_for_next_level is total for that level
        
        # Temporarily set XP to what's needed for the level up, so _apply_level_up has correct context if it needs it.
        # character.experience_points = int(xp_for_next_level) # Not strictly necessary with current _apply_level_up
        
        level_up_messages = _apply_level_up(db, character) # character.level is incremented inside
        messages.extend(level_up_messages)
        
        # After level up, new character.level is set.
        # XP should be the XP requirement for this new level + any overflow from the previous.
        xp_at_start_of_new_level = get_xp_for_level(character.level)
        character.experience_points = int(xp_at_start_of_new_level) + overflow_xp
        
        xp_for_next_level = get_xp_for_level(character.level + 1) # Update for potential multi-level up

    # Handle De-Leveling
    xp_required_for_current_level = get_xp_for_level(character.level)
    while character.level > 1 and character.experience_points < xp_required_for_current_level :
        # Note: _apply_level_down sets XP to the start of the new lower level.
        delevel_messages = _apply_level_down(db, character) # character.level is decremented
        messages.extend(delevel_messages)
        xp_required_for_current_level = get_xp_for_level(character.level) # Update for new (lower) current level

    # Clamp XP if it went negative after de-leveling to level 1
    if character.level == 1 and character.experience_points < 0:
        character.experience_points = 0
        # messages.append("Your experience cannot fall below zero at level 1.") # Already part of _apply_level_down potentially

    db.add(character)
    db.commit()
    db.refresh(character)
    if character.level != initial_level and not any("Ding!" in m or "de-leveled" in m for m in messages): # Ensure level change message is there
        messages.append(f"Your level is now {character.level}.")
    return character, messages

def get_characters_in_room(db: Session, *, room_id: uuid.UUID, exclude_character_id: Optional[uuid.UUID] = None) -> List[models.Character]:
    """
    Retrieves all characters currently in the specified room,
    optionally excluding one character (e.g., the one looking).
    """
    query = db.query(models.Character).filter(models.Character.current_room_id == room_id)
    if exclude_character_id:
        query = query.filter(models.Character.id != exclude_character_id)
    return query.all()
--- END OF FILE backend/app/crud/crud_character.py ---

--- START OF FILE backend/app/crud/crud_character_class.py ---
# backend/app/crud/crud_character_class.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas

def get_character_class_template(db: Session, class_template_id: uuid.UUID) -> Optional[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).filter(models.CharacterClassTemplate.id == class_template_id).first()

def get_character_class_template_by_name(db: Session, name: str) -> Optional[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).filter(models.CharacterClassTemplate.name == name).first()

def get_character_class_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.CharacterClassTemplate]:
    return db.query(models.CharacterClassTemplate).offset(skip).limit(limit).all()

def create_character_class_template(db: Session, *, template_in: schemas.CharacterClassTemplateCreate) -> models.CharacterClassTemplate:
    db_template = models.CharacterClassTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def update_character_class_template(
    db: Session, *, 
    db_template: models.CharacterClassTemplate, 
    template_in: schemas.CharacterClassTemplateUpdate
) -> models.CharacterClassTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_template, field, value)
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def delete_character_class_template(db: Session, class_template_id: uuid.UUID) -> Optional[models.CharacterClassTemplate]:
    db_template = get_character_class_template(db, class_template_id)
    if db_template:
        db.delete(db_template)
        db.commit()
    return db_template

# --- Seeding Initial Class Templates (Example) ---
INITIAL_CLASS_TEMPLATES = [
    {
        "name": "Warrior",
        "description": "A stalwart fighter...",
        "base_stat_modifiers": {"strength": 2, "constitution": 1, "intelligence": -1},
        "starting_health_bonus": 5, "starting_mana_bonus": -5,
        "skill_tree_definition": {
            "core_skills_by_level": {
                "1": ["basic_punch"], # Assuming "basic_punch" is a seeded skill_id_tag
                "2": ["power_attack_melee"] # Assuming this is seeded
            },
            "core_traits_by_level": {
                "1": ["tough_hide"] # Assuming "tough_hide" is a seeded trait_id_tag
            }
        },
        "starting_equipment_refs": ["Rusty Sword", "Wooden Shield", "Cloth Tunic"],
        "playstyle_tags": ["melee", "tank", "physical_dps"]
    },
    {
        "name": "Swindler",
        "description": "A cunning rogue...",
        "base_stat_modifiers": {"dexterity": 2, "luck": 1, "strength": -1},
        "skill_tree_definition": {
            "core_skills_by_level": {
                "1": ["basic_punch"], # Swindlers can punch too!
                "3": ["pick_lock_basic"] # Assuming this is seeded
            },
            "core_traits_by_level": {
                 "2": ["quick_learner"] # Assuming this is seeded
            }
        },
        "starting_equipment_refs": ["Dagger", "Cloth Tunic"],
        "playstyle_tags": ["melee", "stealth", "utility", "debuff"]
    },
    # Add Adventurer if you want it to have a basic progression too
    {
        "name": "Adventurer",
        "description": "A jack-of-all-trades, master of none. Ready for anything, prepared for nothing.",
        "base_stat_modifiers": {}, # No stat mods, uses defaults
        "skill_tree_definition": {
            "core_skills_by_level": {
                "1": ["basic_punch"]
            }
            # No special traits by default for Adventurer unless you add them
        },
        "starting_equipment_refs": ["Dagger", "Cloth Tunic"], # Generic start
        "playstyle_tags": ["versatile", "generalist"]
    }
]

def seed_initial_character_class_templates(db: Session):
    print("Attempting to seed initial character class templates...")
    seeded_count = 0
    for template_data in INITIAL_CLASS_TEMPLATES:
        existing = get_character_class_template_by_name(db, name=template_data["name"])
        if not existing:
            print(f"  Creating class template: {template_data['name']}")
            create_character_class_template(db, template_in=schemas.CharacterClassTemplateCreate(**template_data))
            seeded_count += 1
        else:
            print(f"  Class template '{template_data['name']}' already exists.")
    if seeded_count > 0:
        print(f"Seeded {seeded_count} new class templates.")
    else:
        print("No new class templates seeded. They probably already existed, you overachiever.")
    print("Character class template seeding complete.")
--- END OF FILE backend/app/crud/crud_character_class.py ---

--- START OF FILE backend/app/crud/crud_skill.py ---
# backend/app/crud/crud_skill.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas # models.SkillTemplate, schemas.SkillTemplateCreate etc.

def get_skill_template(db: Session, skill_template_id: uuid.UUID) -> Optional[models.SkillTemplate]:
    return db.query(models.SkillTemplate).filter(models.SkillTemplate.id == skill_template_id).first()

def get_skill_template_by_tag(db: Session, skill_id_tag: str) -> Optional[models.SkillTemplate]:
    return db.query(models.SkillTemplate).filter(models.SkillTemplate.skill_id_tag == skill_id_tag).first()

def get_skill_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.SkillTemplate]:
    return db.query(models.SkillTemplate).offset(skip).limit(limit).all()

def create_skill_template(db: Session, *, template_in: schemas.SkillTemplateCreate) -> models.SkillTemplate:
    # Ensure skill_id_tag is unique if we're not relying solely on DB constraints during high volume creates
    existing = get_skill_template_by_tag(db, skill_id_tag=template_in.skill_id_tag)
    if existing:
        # Or raise an HTTPException if this were an API endpoint
        print(f"Warning: Skill template with tag '{template_in.skill_id_tag}' already exists. Skipping creation.")
        return existing # Or handle error appropriately
    
    db_template = models.SkillTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def update_skill_template(
    db: Session, *, 
    db_template: models.SkillTemplate, 
    template_in: schemas.SkillTemplateUpdate
) -> models.SkillTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    
    # If skill_id_tag is being changed, ensure new one isn't taken by another skill
    if "skill_id_tag" in update_data and update_data["skill_id_tag"] != db_template.skill_id_tag:
        existing = get_skill_template_by_tag(db, skill_id_tag=update_data["skill_id_tag"])
        if existing and existing.id != db_template.id:
            print(f"Warning: Cannot update skill_id_tag to '{update_data['skill_id_tag']}', it's already in use. Update failed for tag.")
            # Or raise error. For now, just don't update the tag.
            del update_data["skill_id_tag"] 

    for field, value in update_data.items():
        setattr(db_template, field, value)
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def delete_skill_template(db: Session, skill_template_id: uuid.UUID) -> Optional[models.SkillTemplate]:
    db_template = get_skill_template(db, skill_template_id)
    if db_template:
        db.delete(db_template)
        db.commit()
    return db_template

# --- Placeholder for Seeding Initial Skills ---
INITIAL_SKILL_TEMPLATES = [
    {
        "skill_id_tag": "basic_punch", "name": "Basic Punch", "description": "A simple, untrained punch.",
        "skill_type": "COMBAT_ACTIVE", "target_type": "ENEMY_MOB",
        "effects_data": {"damage": {"dice": "1d2", "bonus_stat": "strength", "type": "bludgeoning"}, "mana_cost": 0},
        "requirements_data": {"min_level": 1}, "cooldown": 0
    },
    {
        "skill_id_tag": "power_attack_melee", "name": "Power Attack", "description": "A forceful melee attack that is harder to land but deals more damage.",
        "skill_type": "COMBAT_ACTIVE", "target_type": "ENEMY_MOB",
        "effects_data": {
            "mana_cost": 5, 
            "attack_roll_modifier": -2, # Harder to hit
            "damage_modifier_flat": 3,  # Adds flat damage
            "uses_equipped_weapon": True # Implies it will use weapon's damage dice + this mod
        },
        "requirements_data": {"min_level": 2, "required_stats": {"strength": 12}}, "cooldown": 2 # 2 combat rounds
    },
    {
        "skill_id_tag": "pick_lock_basic", "name": "Pick Lock (Basic)", "description": "Attempt to pick a simple lock.",
        "skill_type": "UTILITY_OOC", "target_type": "DOOR", # Or "CONTAINER"
        "effects_data": {
            "difficulty_check_attr": "dexterity", "base_dc": 12,
            "success_message": "The lock clicks open.", "failure_message": "You fail to pick the lock."
        },
        "requirements_data": {"min_level": 1}, "cooldown": 10 # 10 seconds OOC
    }
]

def seed_initial_skill_templates(db: Session):
    print("Attempting to seed initial skill templates...")
    seeded_count = 0
    for template_data in INITIAL_SKILL_TEMPLATES:
        if not get_skill_template_by_tag(db, skill_id_tag=template_data["skill_id_tag"]):
            create_skill_template(db, template_in=schemas.SkillTemplateCreate(**template_data))
            print(f"  Created skill template: {template_data['name']} ({template_data['skill_id_tag']})")
            seeded_count += 1
        else:
            print(f"  Skill template '{template_data['name']}' ({template_data['skill_id_tag']}) already exists.")
    if seeded_count > 0: print(f"Seeded {seeded_count} new skill templates.")
    print("Skill template seeding complete.")
--- END OF FILE backend/app/crud/crud_skill.py ---

--- START OF FILE backend/app/crud/crud_trait.py ---
# backend/app/crud/crud_trait.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas # models.TraitTemplate, schemas.TraitTemplateCreate etc.

def get_trait_template(db: Session, trait_template_id: uuid.UUID) -> Optional[models.TraitTemplate]:
    return db.query(models.TraitTemplate).filter(models.TraitTemplate.id == trait_template_id).first()

def get_trait_template_by_tag(db: Session, trait_id_tag: str) -> Optional[models.TraitTemplate]:
    return db.query(models.TraitTemplate).filter(models.TraitTemplate.trait_id_tag == trait_id_tag).first()

def get_trait_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.TraitTemplate]:
    return db.query(models.TraitTemplate).offset(skip).limit(limit).all()

def create_trait_template(db: Session, *, template_in: schemas.TraitTemplateCreate) -> models.TraitTemplate:
    existing = get_trait_template_by_tag(db, trait_id_tag=template_in.trait_id_tag)
    if existing:
        print(f"Warning: Trait template with tag '{template_in.trait_id_tag}' already exists. Skipping creation.")
        return existing
        
    db_template = models.TraitTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def update_trait_template(
    db: Session, *, 
    db_template: models.TraitTemplate, 
    template_in: schemas.TraitTemplateUpdate
) -> models.TraitTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    
    if "trait_id_tag" in update_data and update_data["trait_id_tag"] != db_template.trait_id_tag:
        existing = get_trait_template_by_tag(db, trait_id_tag=update_data["trait_id_tag"])
        if existing and existing.id != db_template.id:
            print(f"Warning: Cannot update trait_id_tag to '{update_data['trait_id_tag']}', it's already in use. Update failed for tag.")
            del update_data["trait_id_tag"]

    for field, value in update_data.items():
        setattr(db_template, field, value)
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def delete_trait_template(db: Session, trait_template_id: uuid.UUID) -> Optional[models.TraitTemplate]:
    db_template = get_trait_template(db, trait_template_id)
    if db_template:
        db.delete(db_template)
        db.commit()
    return db_template

# --- Placeholder for Seeding Initial Traits ---
INITIAL_TRAIT_TEMPLATES = [
    {
        "trait_id_tag": "tough_hide", "name": "Tough Hide", "description": "Your skin is naturally resilient.",
        "trait_type": "PASSIVE", 
        "effects_data": {"ac_bonus_natural": 1} # Example: a natural AC bonus
    },
    {
        "trait_id_tag": "quick_learner", "name": "Quick Learner", "description": "You gain experience slightly faster.",
        "trait_type": "PASSIVE",
        "effects_data": {"xp_gain_modifier_percent": 5} # Gain 5% more XP
    }
]

def seed_initial_trait_templates(db: Session):
    print("Attempting to seed initial trait templates...")
    seeded_count = 0
    for template_data in INITIAL_TRAIT_TEMPLATES:
        if not get_trait_template_by_tag(db, trait_id_tag=template_data["trait_id_tag"]):
            create_trait_template(db, template_in=schemas.TraitTemplateCreate(**template_data))
            print(f"  Created trait template: {template_data['name']} ({template_data['trait_id_tag']})")
            seeded_count += 1
        else:
            print(f"  Trait template '{template_data['name']}' ({template_data['trait_id_tag']}) already exists.")
    if seeded_count > 0: print(f"Seeded {seeded_count} new trait templates.")
    print("Trait template seeding complete.")
--- END OF FILE backend/app/crud/crud_trait.py ---

--- START OF FILE backend/app/crud/crud_item.py ---
# backend/app/crud/crud_item.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas

# --- Item CRUD ---
def get_item(db: Session, item_id: uuid.UUID) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.id == item_id).first()

def get_item_by_name(db: Session, name: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.name == name).first()

def get_items(db: Session, skip: int = 0, limit: int = 100) -> List[models.Item]:
    return db.query(models.Item).offset(skip).limit(limit).all()

def create_item(db: Session, *, item_in: schemas.ItemCreate) -> models.Item:
    db_item_data = item_in.model_dump()
    db_item = models.Item(**db_item_data)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def update_item(
    db: Session, *, db_item: models.Item, item_in: schemas.ItemUpdate
) -> models.Item:
    update_data = item_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_item, field, value)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def delete_item(db: Session, *, item_id: uuid.UUID) -> Optional[models.Item]:
    db_item = db.query(models.Item).filter(models.Item.id == item_id).first()
    if db_item:
        db.delete(db_item)
        db.commit()
    return db_item

# --- Seeding Initial Items ---
INITIAL_ITEMS_TO_SEED = [
    {
        "name": "Rusty Sword", "description": "A short sword, pitted with rust. Better than nothing.",
        "item_type": "weapon", "slot": "main_hand",
        "properties": {
            "damage": "1d6", "damage_type": "slashing", "weapon_type": "sword"
            # "attack_bonus": 0, "damage_bonus": 0 // Explicitly 0 if not magical
            }, "weight": 3.0, "value": 5,
        "stackable": False, "max_stack_size": 1
    },
    {
        "name": "Cloth Tunic", "description": "Simple, patched-up clothing.",
        "item_type": "armor", "slot": "torso",
        "properties": {
            "armor_class_bonus": 1 
            # No max_dex_bonus_to_ac for simple cloth
            }, "weight": 1.0, "value": 2,
        "stackable": False, "max_stack_size": 1
    },
    # ... (Minor Healing Potion remains the same) ...
    {
        "name": "Wooden Shield", "description": "A basic round wooden shield.",
        "item_type": "armor", "slot": "off_hand", # "armor" type, "off_hand" slot implies shield behavior
        "properties": {
            "armor_class_bonus": 2, "item_subtype": "shield" 
            # Shields don't typically cap Dex in 5e, but some heavier ones might.
            }, "weight": 5.0, "value": 8,
        "stackable": False, "max_stack_size": 1
    },
    {
        "name": "Dagger", "description": "A small, easily concealable dagger.",
        "item_type": "weapon", "slot": "main_hand", 
        "properties": {
            "damage": "1d4", "damage_type": "piercing", "weapon_type": "dagger",
            "finesse": True # <<< IMPORTANT FOR DEX USAGE
            }, "weight": 1.0, "value": 2,
        "stackable": False, "max_stack_size": 1
    },
    # Example of heavier armor that might cap Dex:
    # {
    #     "name": "Chain Mail", "description": "A suit of interlocking metal rings.",
    #     "item_type": "armor", "slot": "torso",
    #     "properties": {
    #         "armor_class_bonus": 6, # e.g. total AC provided by chain mail is 16 if base is 10 and no dex
    #         "max_dex_bonus_to_ac": 0, # Heavy armor often gives no dex bonus to AC
    #         "strength_requirement": 13 # Future use
    #         }, "weight": 55.0, "value": 75,
    #     "stackable": False, "max_stack_size": 1
    # },
]


def seed_initial_items(db: Session):
    print("Attempting to seed initial items...")
    seeded_count = 0
    for item_data in INITIAL_ITEMS_TO_SEED:
        existing_item = get_item_by_name(db, name=item_data["name"])
        if not existing_item:
            print(f"  Creating item: {item_data['name']}")
            create_item(db, item_in=schemas.ItemCreate(**item_data))
            seeded_count += 1
        else:
            print(f"  Item '{item_data['name']}' already exists.")
    if seeded_count > 0:
        print(f"Seeded {seeded_count} new items.")
    print("Item seeding complete.")
--- END OF FILE backend/app/crud/crud_item.py ---

--- START OF FILE backend/app/crud/crud_character_inventory.py ---
# backend/app/crud/crud_character_inventory.py
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import List, Optional, Tuple

from .. import models, schemas
from ..models.item import EQUIPMENT_SLOTS # For validation

# Helper to get a specific inventory entry
def get_inventory_item_entry(db: Session, inventory_item_id: uuid.UUID) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item) # Eager load item details
    ).filter(models.CharacterInventoryItem.id == inventory_item_id).first()

# Helper to get inventory entry by character_id and item_id (useful for stackable items)
def get_inventory_item_by_character_and_item_ids(
    db: Session, character_id: uuid.UUID, item_id: uuid.UUID
) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item)
    ).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.CharacterInventoryItem.item_id == item_id
    ).first()


def get_character_inventory(db: Session, character_id: uuid.UUID) -> List[models.CharacterInventoryItem]:
    """Returns all inventory item entries for a character, with item details eager loaded."""
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item) # Eager load the related Item object
    ).filter(models.CharacterInventoryItem.character_id == character_id).all()


def add_item_to_character_inventory(
    db: Session, *, character_id: uuid.UUID, item_id: uuid.UUID, quantity: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Adds an item to a character's inventory.
    If item is stackable and already exists, increases quantity.
    If item is not stackable, creates a new entry for each quantity (e.g. two rusty swords).
    Returns the created/updated inventory item entry and a message.
    """
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    
    character = db.query(models.Character).filter(models.Character.id == character_id).first()
    if not character:
        return None, "Character not found."

    if quantity <= 0:
        return None, "Quantity must be positive."

    # Handle stackable items
    if item_template.stackable:
        existing_entry = get_inventory_item_by_character_and_item_ids(db, character_id, item_id)
        if existing_entry:
            max_stack = item_template.max_stack_size or float('inf') # Should have a default
            if existing_entry.quantity + quantity <= max_stack:
                existing_entry.quantity += quantity
                db.add(existing_entry)
                db.commit()
                db.refresh(existing_entry)
                return existing_entry, f"Added {quantity} to stack of {item_template.name}."
            else:
                # Handle overflow if necessary (e.g. create new stack or error)
                return None, f"Cannot add {quantity}; exceeds max stack size of {max_stack} for {item_template.name}."
        else: # New stackable item entry
            if quantity <= (item_template.max_stack_size or float('inf')):
                new_entry = models.CharacterInventoryItem(
                    character_id=character_id,
                    item_id=item_id,
                    quantity=quantity
                )
                db.add(new_entry)
                db.commit()
                db.refresh(new_entry)
                return new_entry, f"Added {quantity} x {item_template.name} to inventory."
            else:
                return None, f"Cannot add {quantity}; exceeds max stack size for new stack of {item_template.name}."
    else: # Handle non-stackable items (create one entry per item)
        # For non-stackable, 'quantity' means add 'quantity' distinct instances.
        # We'll return the last one created for simplicity, or a list if needed.
        created_entry = None
        for _ in range(quantity):
            new_entry = models.CharacterInventoryItem(
                character_id=character_id,
                item_id=item_id,
                quantity=1 # Non-stackable always has quantity 1 per entry
            )
            db.add(new_entry)
            created_entry = new_entry # Keep track of the last one
        db.commit()
        if created_entry: # Refresh the last created entry
             db.refresh(created_entry) # Need to refresh after commit to get generated ID
        return created_entry, f"Added {quantity} x {item_template.name} (non-stackable) to inventory."


def remove_item_from_character_inventory(
    db: Session, *, inventory_item_id: uuid.UUID, quantity_to_remove: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Removes a specific quantity of an item from an inventory entry.
    If quantity becomes zero or less, the entry is deleted.
    Returns the (potentially modified) entry or None if deleted, and a message.
    """
    entry = get_inventory_item_entry(db, inventory_item_id)
    if not entry:
        return None, "Inventory item entry not found."
    
    if entry.equipped:
        return None, f"Cannot remove '{entry.item.name}'; it is currently equipped. Unequip it first."

    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = entry.item.name # Get name before potential deletion

    if entry.quantity > quantity_to_remove:
        entry.quantity -= quantity_to_remove
        db.add(entry)
        db.commit()
        db.refresh(entry)
        return entry, f"Removed {quantity_to_remove} x {original_item_name}. {entry.quantity} remaining."
    else:
        removed_qty = entry.quantity
        db.delete(entry)
        db.commit()
        return None, f"Removed all {removed_qty} x {original_item_name} from inventory."


def equip_item_from_inventory(
    db: Session, *, character_id: uuid.UUID, inventory_item_id: uuid.UUID, target_slot: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Equips an item from the character's inventory to a specified slot.
    - inventory_item_id: The ID of the CharacterInventoryItem entry.
    - target_slot: The character's equipment slot (e.g., 'main_hand', 'finger_1').
                   Required if item can go in multiple slots or if slot needs disambiguation.
    """
    char_inv_entry = get_inventory_item_entry(db, inventory_item_id)

    if not char_inv_entry:
        return None, "Item not found in your inventory."
    if char_inv_entry.character_id != character_id:
        return None, "This item does not belong to you." # Should not happen with active char
    if char_inv_entry.equipped:
        return char_inv_entry, f"{char_inv_entry.item.name} is already equipped in {char_inv_entry.equipped_slot}."

    item_template = char_inv_entry.item # Already eager loaded
    if not item_template.slot or item_template.slot == "consumable": # 'slot' on item_template is its intended use type
        return None, f"{item_template.name} is not equippable in that manner."

    # Determine the actual character slot to use
    final_target_slot = target_slot
    if not final_target_slot:
        # If item's slot is directly one of EQUIPMENT_SLOTS keys, use it
        if item_template.slot in EQUIPMENT_SLOTS:
            final_target_slot = item_template.slot
        else:
            # This logic needs refinement for items fitting multiple abstract slots.
            # E.g. item.slot = "ring", target_slot could be "finger_1" or "finger_2"
            # For now, if target_slot is not given, and item.slot isn't direct, it's an error.
            return None, f"Please specify which slot to equip {item_template.name} (e.g., 'finger_1', 'finger_2' if it's a ring)."

    if final_target_slot not in EQUIPMENT_SLOTS:
        return None, f"Invalid equipment slot: '{final_target_slot}'. Valid slots are: {', '.join(EQUIPMENT_SLOTS.keys())}."

    # Check if the slot is already occupied by another item
    # (A character can't wear two helmets, etc. Rings are an exception if slots are distinct like finger_1, finger_2)
    # This includes checking for two-handed weapons taking up main_hand and off_hand (future)
    currently_equipped_in_slot = db.query(models.CharacterInventoryItem).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.CharacterInventoryItem.equipped == True,
        models.CharacterInventoryItem.equipped_slot == final_target_slot
    ).first()

    if currently_equipped_in_slot:
        return None, f"Slot '{EQUIPMENT_SLOTS[final_target_slot]}' is already occupied by {currently_equipped_in_slot.item.name}. Unequip it first."

    # All checks passed, equip the item
    char_inv_entry.equipped = True
    char_inv_entry.equipped_slot = final_target_slot
    db.add(char_inv_entry)
    db.commit()
    db.refresh(char_inv_entry)
    return char_inv_entry, f"{item_template.name} equipped to {EQUIPMENT_SLOTS[final_target_slot]}."


def unequip_item_to_inventory(
    db: Session, *, character_id: uuid.UUID, inventory_item_id: uuid.UUID
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """Unequips an item, moving it back to the general 'backpack' part of inventory."""
    char_inv_entry = get_inventory_item_entry(db, inventory_item_id)

    if not char_inv_entry:
        return None, "Item not found in your inventory records."
    if char_inv_entry.character_id != character_id:
        return None, "This item does not belong to you."
    if not char_inv_entry.equipped or not char_inv_entry.equipped_slot:
        return char_inv_entry, f"{char_inv_entry.item.name} is not currently equipped."

    item_name = char_inv_entry.item.name
    slot_name = EQUIPMENT_SLOTS.get(char_inv_entry.equipped_slot, char_inv_entry.equipped_slot)

    char_inv_entry.equipped = False
    char_inv_entry.equipped_slot = None
    db.add(char_inv_entry)
    db.commit()
    db.refresh(char_inv_entry)
    return char_inv_entry, f"{item_name} unequipped from {slot_name}."
--- END OF FILE backend/app/crud/crud_character_inventory.py ---

--- START OF FILE backend/app/crud/crud_room_item.py ---
# backend/app/crud/crud_room_item.py
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import Dict, List, Optional, Tuple

from .. import models, schemas

def get_room_item_instance(db: Session, room_item_instance_id: uuid.UUID) -> Optional[models.RoomItemInstance]:
    return db.query(models.RoomItemInstance).options(
        joinedload(models.RoomItemInstance.item) # Eager load item details
    ).filter(models.RoomItemInstance.id == room_item_instance_id).first()

def get_items_in_room(db: Session, room_id: uuid.UUID) -> List[models.RoomItemInstance]:
    """Returns all item instances on the ground in a room, with item details eager loaded."""
    return db.query(models.RoomItemInstance).options(
        joinedload(models.RoomItemInstance.item)
    ).filter(models.RoomItemInstance.room_id == room_id).all()

def add_item_to_room(
    db: Session, *, 
    room_id: uuid.UUID, 
    item_id: uuid.UUID, 
    quantity: int = 1,
    dropped_by_character_id: Optional[uuid.UUID] = None,
    properties_override: Optional[Dict] = None
) -> Tuple[Optional[models.RoomItemInstance], str]:
    """
    Adds an item instance to a room's floor.
    If item is stackable and an identical instance (same item_id, same properties_override) exists, increases quantity.
    Otherwise, creates a new RoomItemInstance entry.
    """
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    
    room = db.query(models.Room).filter(models.Room.id == room_id).first()
    if not room:
        return None, "Room not found."

    if quantity <= 0:
        return None, "Quantity must be positive."

    # For stackable items, check if an identical stack already exists on the floor
    # Identical means same item_id AND same properties_override (usually None)
    created_entry = None
    if item_template.stackable:
        existing_stack = db.query(models.RoomItemInstance).filter(
            models.RoomItemInstance.room_id == room_id,
            models.RoomItemInstance.item_id == item_id,
            models.RoomItemInstance.properties_override == properties_override # Crucial for stacking
        ).first()

        if existing_stack:
            max_stack = item_template.max_stack_size or float('inf')
            if existing_stack.quantity + quantity <= max_stack:
                existing_stack.quantity += quantity
                db.add(existing_stack)
                db.commit()
                db.refresh(existing_stack)
                return existing_stack, f"Added {quantity} to stack of {item_template.name} on the ground."
            else:
                # Create a new stack for the overflow if needed, or error.
                # For simplicity now, let's just create a new stack for the full requested quantity
                # if the existing stack would overflow. This might lead to multiple stacks of same item.
                # A more advanced logic would fill up the existing stack then create a new one for remainder.
                pass # Fall through to create a new instance for the current quantity


    # Create a new instance (either non-stackable, or new stack for stackable)
    # For non-stackable, quantity means number of distinct instances.
    # For stackable, if we reached here, it's a new stack of 'quantity'.
    
    num_instances_to_create = quantity if not item_template.stackable else 1
    actual_quantity_per_instance = 1 if not item_template.stackable else quantity
    
    if item_template.stackable and actual_quantity_per_instance > (item_template.max_stack_size or float('inf')):
        return None, f"Cannot drop stack of {actual_quantity_per_instance}; exceeds max stack size for {item_template.name}."

    for _ in range(num_instances_to_create):
        new_instance = models.RoomItemInstance(
            room_id=room_id,
            item_id=item_id,
            quantity=actual_quantity_per_instance,
            dropped_by_character_id=dropped_by_character_id,
            properties_override=properties_override
        )
        db.add(new_instance)
        created_entry = new_instance # Keep track of the last one

    db.commit()
    if created_entry:
        db.refresh(created_entry) # Ensure IDs are loaded
    
    if item_template.stackable:
         return created_entry, f"Dropped a stack of {quantity} x {item_template.name}."
    else:
         return created_entry, f"Dropped {quantity} x {item_template.name}."


def remove_item_from_room(
    db: Session, *, 
    room_item_instance_id: uuid.UUID, 
    quantity_to_remove: int = 1
) -> Tuple[Optional[models.RoomItemInstance], str]: # Returns (remaining_instance_or_None, message)
    """
    Removes a specific quantity of an item from a RoomItemInstance.
    If quantity becomes zero or less, the instance is deleted.
    """
    instance = get_room_item_instance(db, room_item_instance_id) # This already eager loads .item
    if not instance:
        return None, "Item instance not found on the ground."

    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = instance.item.name

    if instance.quantity > quantity_to_remove:
        instance.quantity -= quantity_to_remove
        db.add(instance)
        db.commit()
        db.refresh(instance)
        return instance, f"Picked up {quantity_to_remove} x {original_item_name}. {instance.quantity} remaining on ground."
    else:
        # Removing all or more than available from this specific instance
        removed_qty = instance.quantity
        db.delete(instance)
        db.commit()
        return None, f"Picked up all {removed_qty} x {original_item_name} from the ground (this stack/instance)."
--- END OF FILE backend/app/crud/crud_room_item.py ---

--- START OF FILE backend/app/crud/crud_mob.py ---
# backend/app/crud/crud_mob.py
from datetime import datetime, timezone
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import Dict, List, Optional, Tuple

from .. import models, schemas, crud

# --- MobTemplate CRUD ---
def get_mob_template(db: Session, mob_template_id: uuid.UUID) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.id == mob_template_id).first()

def get_mob_template_by_name(db: Session, name: str) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.name == name).first()

def get_mob_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.MobTemplate]:
    return db.query(models.MobTemplate).offset(skip).limit(limit).all()

def create_mob_template(db: Session, *, template_in: schemas.MobTemplateCreate) -> models.MobTemplate:
    db_template = models.MobTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

# --- RoomMobInstance CRUD ---
def get_room_mob_instance(db: Session, room_mob_instance_id: uuid.UUID) -> Optional[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template) # Eager load template
    ).filter(models.RoomMobInstance.id == room_mob_instance_id).first()

def get_mobs_in_room(db: Session, room_id: uuid.UUID) -> List[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template)
    ).filter(models.RoomMobInstance.room_id == room_id).all()

def spawn_mob_in_room(
    db: Session, *, 
    room_id: uuid.UUID, 
    mob_template_id: uuid.UUID,
    instance_properties_override: Optional[Dict] = None,
    originating_spawn_definition_id: Optional[uuid.UUID] = None # <<< RENAMED PARAMETER
) -> Optional[models.RoomMobInstance]:
    template = get_mob_template(db, mob_template_id)
    if not template: return None
    room = db.query(models.Room).filter(models.Room.id == room_id).first()
    if not room: return None

    mob_instance = models.RoomMobInstance(
        room_id=room_id,
        mob_template_id=mob_template_id,
        current_health=template.base_health,
        instance_properties_override=instance_properties_override,
        spawn_definition_id=originating_spawn_definition_id # <<< SETTING THE CORRECT FIELD
    )
    db.add(mob_instance)
    db.commit()
    db.refresh(mob_instance)
    return mob_instance

def despawn_mob_from_room(db: Session, room_mob_instance_id: uuid.UUID) -> bool:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance:
        spawn_def_id_to_update = instance.spawn_definition_id # Use the renamed field

        db.delete(instance)
        db.commit() 

        if spawn_def_id_to_update:
            # When a mob from a definition is despawned, its definition should be checked soon.
            # Set its next_respawn_check_at to now to make it eligible for the next tick.
            crud.crud_mob_spawn_definition.update_mob_spawn_definition_next_check_time(
                db, 
                definition_id=spawn_def_id_to_update, 
                next_check_time=datetime.now(timezone.utc)
            )
            print(f"Triggered immediate re-check for spawn definition {spawn_def_id_to_update} due to mob despawn.")
        return True
    return False

def update_mob_instance_health(
    db: Session, room_mob_instance_id: uuid.UUID, change_in_health: int
) -> Optional[models.RoomMobInstance]:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance:
        instance.current_health += change_in_health
        # Basic health clamping, can be more sophisticated (e.g. death on <=0)
        if instance.current_health < 0:
            instance.current_health = 0 
        # Max health check if applicable (e.g. instance.mob_template.base_health)
        # if instance.current_health > instance.mob_template.base_health:
        #     instance.current_health = instance.mob_template.base_health
            
        db.add(instance)
        db.commit()
        db.refresh(instance)
        return instance
    return None

# --- Seeding Initial Mob Templates ---
INITIAL_MOB_TEMPLATES = [
    {
        "name": "Giant Rat", "description": "A filthy rat...",
        "mob_type": "beast", "base_health": 8, "base_attack": "1d4", "base_defense": 11,
        "xp_value": 5, 
        "currency_drop": {"c_min": 1, "c_max": 5}, # Drops 1-5 copper
        "aggression_type": "AGGRESSIVE_IF_APPROACHED", "level": 1
    },
    {
        "name": "Goblin Scout", "description": "A small, green-skinned humanoid...",
        "mob_type": "humanoid", "base_health": 12, "base_attack": "1d6", "base_defense": 13,
        "xp_value": 10, 
        "currency_drop": { # Goblins are a bit richer
            "c_min": 10, "c_max": 50, 
            "s_chance": 25, "s_min": 1, "s_max": 3 # 25% chance for 1-3 silver
        },
        "properties": {"faction": "goblins"}, 
        "aggression_type": "AGGRESSIVE_ON_SIGHT", "level": 1
    },
]

def seed_initial_mob_templates(db: Session):
    print("Attempting to seed initial mob templates...")
    seeded_count = 0
    for template_data in INITIAL_MOB_TEMPLATES:
        existing = get_mob_template_by_name(db, name=template_data["name"])
        template_schema = schemas.MobTemplateCreate(**template_data) # Convert to schema for validation
        if not existing:
            print(f"  Creating mob template: {template_schema.name}")
            create_mob_template(db, template_in=template_schema)
            seeded_count += 1
        else:
            # Optionally update existing templates if their aggression_type or other fields changed
            # For now, just log existence
            print(f"  Mob template '{template_schema.name}' already exists. Current aggression: {existing.aggression_type}, Seeded: {template_schema.aggression_type}")
            if existing.aggression_type != template_schema.aggression_type:
                 print(f"    Updating aggression type for {existing.name} to {template_schema.aggression_type}")
                 existing.aggression_type = template_schema.aggression_type
                 db.add(existing)
                 db.commit() # Commit update

    if seeded_count > 0:
        print(f"Seeded {seeded_count} new mob templates.")
    print("Mob template seeding complete.")
--- END OF FILE backend/app/crud/crud_mob.py ---

--- START OF FILE backend/app/crud/crud_mob_spawn_definition.py ---
# backend/app/crud/crud_mob_spawn_definition.py
from sqlalchemy.orm import Session
import uuid
from datetime import datetime, timedelta, timezone # Added timezone
from typing import List, Optional

from .. import models, schemas # Uses new MobSpawnDefinition schemas
from ..crud import crud_room, crud_mob # For seeder

# --- MobSpawnDefinition CRUD ---

def get_mob_spawn_definition(db: Session, definition_id: uuid.UUID) -> Optional[models.MobSpawnDefinition]:
    return db.query(models.MobSpawnDefinition).filter(models.MobSpawnDefinition.id == definition_id).first()

def get_mob_spawn_definition_by_name(db: Session, definition_name: str) -> Optional[models.MobSpawnDefinition]:
    return db.query(models.MobSpawnDefinition).filter(models.MobSpawnDefinition.definition_name == definition_name).first()

def get_definitions_ready_for_check(db: Session, current_time: datetime, limit: int = 1000) -> List[models.MobSpawnDefinition]:
    """
    Gets active spawn definitions whose next_respawn_check_at is due.
    Or where next_respawn_check_at is NULL (meaning they haven't been processed yet or need immediate check).
    """
    return db.query(models.MobSpawnDefinition).filter(
        models.MobSpawnDefinition.is_active == True,
        (models.MobSpawnDefinition.next_respawn_check_at == None) | (models.MobSpawnDefinition.next_respawn_check_at <= current_time)
    ).limit(limit).all()

def create_mob_spawn_definition(db: Session, *, definition_in: schemas.MobSpawnDefinitionCreate) -> models.MobSpawnDefinition:
    # Basic validation
    if definition_in.quantity_min > definition_in.quantity_max:
        raise ValueError("quantity_min cannot be greater than quantity_max")

    existing = get_mob_spawn_definition_by_name(db, definition_name=definition_in.definition_name)
    if existing:
        # Handle error or return existing one; for now, let's assume names should be unique
        raise ValueError(f"MobSpawnDefinition with name '{definition_in.definition_name}' already exists.")

    db_definition_data = definition_in.model_dump()
    # Set initial next_respawn_check_at to now to make it eligible for first check
    db_definition_data["next_respawn_check_at"] = datetime.now(timezone.utc)
    
    db_definition = models.MobSpawnDefinition(**db_definition_data)
    db.add(db_definition)
    db.commit()
    db.refresh(db_definition)
    return db_definition

def update_mob_spawn_definition_next_check_time(
    db: Session, *, 
    definition_id: uuid.UUID, 
    next_check_time: datetime
) -> Optional[models.MobSpawnDefinition]:
    db_definition = get_mob_spawn_definition(db, definition_id)
    if db_definition:
        db_definition.next_respawn_check_at = next_check_time
        db.add(db_definition)
        db.commit() # Commit immediately as this is a frequent state update
        db.refresh(db_definition)
        return db_definition
    return None

def update_mob_spawn_definition(
    db: Session, *,
    db_definition: models.MobSpawnDefinition,
    definition_in: schemas.MobSpawnDefinitionUpdate
) -> models.MobSpawnDefinition:
    update_data = definition_in.model_dump(exclude_unset=True)
    if "quantity_min" in update_data and "quantity_max" in update_data:
        if update_data["quantity_min"] > update_data["quantity_max"]:
            raise ValueError("quantity_min cannot be greater than quantity_max")
    elif "quantity_min" in update_data:
        if update_data["quantity_min"] > db_definition.quantity_max:
            raise ValueError("quantity_min cannot be greater than current quantity_max")
    elif "quantity_max" in update_data:
        if db_definition.quantity_min > update_data["quantity_max"]:
            raise ValueError("current quantity_min cannot be greater than new quantity_max")

    for field, value in update_data.items():
        setattr(db_definition, field, value)
    db.add(db_definition)
    db.commit()
    db.refresh(db_definition)
    return db_definition


# --- Seeding ---
def seed_initial_mob_spawn_definitions(db: Session):
    print("Attempting to seed initial mob spawn definitions...")
    cpu_room = crud_room.get_room_by_coords(db, x=0, y=0, z=0)
    rat_template = crud_mob.get_mob_template_by_name(db, name="Giant Rat")
    goblin_template = crud_mob.get_mob_template_by_name(db, name="Goblin Scout")
    personnel_room = crud_room.get_room_by_coords(db, x=2, y=0, z=0) 
    
    definitions_to_seed = []
    if cpu_room and rat_template:
        definitions_to_seed.append(schemas.MobSpawnDefinitionCreate(
            definition_name="CPURatsMain", room_id=cpu_room.id, mob_template_id=rat_template.id,
            quantity_min=1, quantity_max=2, respawn_delay_seconds=60,
            roaming_behavior={"type": "random_adjacent", "move_chance_percent": 40, "max_distance_from_spawn": 2} # <<< ADD ROAMING
        ))
    if personnel_room and goblin_template:
        definitions_to_seed.append(schemas.MobSpawnDefinitionCreate(
            definition_name="PersonnelIntakeGoblinSentry", room_id=personnel_room.id, mob_template_id=goblin_template.id,
            quantity_min=1, quantity_max=1, respawn_delay_seconds=180 
            # Goblin is AGGRESSIVE_ON_SIGHT from its template, no specific roaming here.
        ))

    seeded_count = 0
    for def_in in definitions_to_seed:
        existing_def = get_mob_spawn_definition_by_name(db, definition_name=def_in.definition_name)
        if not existing_def:
            create_mob_spawn_definition(db, definition_in=def_in)
            print(f"  Created mob spawn definition: {def_in.definition_name}")
            seeded_count += 1
        else:
            # Optionally update existing definitions
            print(f"  Mob spawn definition '{def_in.definition_name}' already exists. Current roaming: {existing_def.roaming_behavior}, Seeded: {def_in.roaming_behavior}")
            if existing_def.roaming_behavior != def_in.roaming_behavior: # Simple dict comparison
                print(f"    Updating roaming behavior for {existing_def.definition_name}")
                existing_def.roaming_behavior = def_in.roaming_behavior
                db.add(existing_def)
                db.commit() # Commit update
    
    if seeded_count > 0: print(f"Seeded {seeded_count} new mob spawn definitions.")
    print("Mob spawn definition seeding complete.")
--- END OF FILE backend/app/crud/crud_mob_spawn_definition.py ---

--- START OF FILE backend/app/crud/crud_room.py ---
# backend/app/crud/crud_room.py
from sqlalchemy.orm import Session
import uuid # Import uuid
from typing import Optional, Dict, List
from .. import models, schemas

def get_rooms_by_z_level(db: Session, *, z_level: int) -> List[models.Room]:
    """
    Retrieve all rooms from the database by their Z-coordinate.
    """
    return db.query(models.Room).filter(models.Room.z == z_level).all()

def get_room_by_id(db: Session, room_id: uuid.UUID) -> Optional[models.Room]: # room_id is now uuid.UUID
    """
    Retrieve a room from the database by its ID (which is a UUID).
    """
    return db.query(models.Room).filter(models.Room.id == room_id).first()

def get_room_by_coords(db: Session, *, x: int, y: int, z: int) -> Optional[models.Room]:
    return db.query(models.Room).filter(
        models.Room.x == x,
        models.Room.y == y,
        models.Room.z == z
    ).first()

def create_room(db: Session, *, room_in: schemas.RoomCreate) -> models.Room:
    """
    Create a new room in the database.
    Takes a Pydantic schema RoomCreate as input.
    If room_in.id is None (typical), a new UUID will be generated by the model's default.
    If room_in.id is provided, that UUID will be used.
    Returns the created SQLAlchemy ORM model instance.
    """
    db_room_data = room_in.model_dump(exclude_unset=True) # Exclude unset to allow DB defaults like UUID
    
    # If an ID (UUID) is provided in room_in, use it. Otherwise, DB default uuid.uuid4() kicks in.
    # The model_dump already includes 'id' if it was set in room_in.
    
    db_room = models.Room(**db_room_data)
    db.add(db_room)
    db.commit()
    db.refresh(db_room)
    return db_room

# We'll need a robust way to update room exits as well, or a general update_room
def update_room(db: Session, *, db_room: models.Room, room_in: schemas.RoomUpdate) -> models.Room:
    """
    General purpose room update.
    """
    update_data = room_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_room, field, value)
    db.add(db_room)
    db.commit()
    db.refresh(db_room)
    return db_room

# --- World Seeding Logic ---
# This will be called from main.py's startup event
# We'll define 3 rooms: Genesis (0,0,0), Chilly North (0,1,0), Overlook East (1,1,0)

# Store known UUIDs for linking (these will be generated once)
# In a real app, these might be constants or looked up if seeding is idempotent.
# For simplicity, we'll generate them if rooms don't exist.
# This global dict is a temporary hack for seeding to pass UUIDs between room creations.
_SEED_ROOM_UUIDS: Dict[str, uuid.UUID] = {}

def seed_initial_world(db: Session):
    print("Attempting to seed a new, slightly more expansive initial world...")
    _SEED_ROOM_UUIDS.clear() # Ensure it's empty before seeding

    room_definitions = [
        {
            "coords": {"x": 0, "y": 0, "z": 0}, "name_tag": "central_hub",
            "data": schemas.RoomCreate(name="Central Processing Unit (CPU)", x=0, y=0, z=0,
                                       description="The air hums with the barely audible whir of unseen processes. Various identical corridors branch off. All business, no pleasure.")
        },
        {
            "coords": {"x": 0, "y": 1, "z": 0}, "name_tag": "north_corridor_1",
            "data": schemas.RoomCreate(name="North Data Conduit Alpha", x=0, y=1, z=0,
                                       description="A sterile corridor stretches northwards. The faint scent of ozone and regret hangs in the air.")
        },
        {
            "coords": {"x": 0, "y": 2, "z": 0}, "name_tag": "archive_access_north",
            "data": schemas.RoomCreate(name="Archival Sub-sector N-47b", x=0, y=2, z=0,
                                       description="Rows of identical, featureless data monoliths stand silent sentinel. One of them is probably important.")
        },
        {
            "coords": {"x": 1, "y": 0, "z": 0}, "name_tag": "east_corridor_1",
            "data": schemas.RoomCreate(name="East Packet-Switching Nexus", x=1, y=0, z=0,
                                       description="This passage heads east, past blinking lights that signify... something. Or perhaps nothing at all.")
        },
        {
            "coords": {"x": 2, "y": 0, "z": 0}, "name_tag": "personnel_intake_east",
            "data": schemas.RoomCreate(name="Personnel Intake & Re-Education", x=2, y=0, z=0,
                                       description="A single, uncomfortable chair sits under a harsh light. A faded motivational poster reads: 'Compliance is Key.'")
        },
        {
            "coords": {"x": 0, "y": -1, "z": 0}, "name_tag": "south_corridor_1",
            "data": schemas.RoomCreate(name="South Maintenance Tunnel 7", x=0, y=-1, z=0,
                                       description="Dimly lit and smelling faintly of burnt coffee and existential dread. The floor is slightly sticky.")
        },
        {
            "coords": {"x": 0, "y": -2, "z": 0}, "name_tag": "waste_reclamation_south",
            "data": schemas.RoomCreate(name="Waste Reclamation & Data Incineration", x=0, y=-2, z=0,
                                       description="A large, ominous chute dominates one wall. You try not to think about what 'Waste Reclamation' entails here.")
        },
        {
            "coords": {"x": -1, "y": 0, "z": 0}, "name_tag": "west_corridor_1",
            "data": schemas.RoomCreate(name="West Logic Gate Array", x=-1, y=0, z=0,
                                       description="To the west, a series of humming conduits. One emits a slightly higher-pitched hum than the others, a tiny rebellion in a sea of conformity.")
        },
        {
            "coords": {"x": -2, "y": 0, "z": 0}, "name_tag": "auxiliary_storage_west",
            "data": schemas.RoomCreate(name="Auxiliary Data Storage Unit W-Alpha", x=-2, y=0, z=0,
                                       description="More data storage. It's data all the way down. You suspect some of it might be recipes for lukewarm soup.")
        },
        # A room not directly connected to the hub, to make the map more interesting
        {
            "coords": {"x": 1, "y": 1, "z": 0}, "name_tag": "break_room_anomaly",
            "data": schemas.RoomCreate(name="Restricted Sub-routine Lounge (Anomaly)", x=1, y=1, z=0,
                                       description="An oddly out-of-place room. A dusty vending machine hums defiantly in the corner, offering only 'Nutrient Paste (Beige)'.")
        }
    ]

    created_rooms_this_run = False
    for room_def in room_definitions:
        coords = room_def["coords"]
        name_tag = room_def["name_tag"]
        
        existing_room = get_room_by_coords(db, **coords)
        if not existing_room:
            print(f"Creating room '{room_def['data'].name}' at {coords} with tag '{name_tag}'...")
            created_room_orm = create_room(db, room_in=room_def["data"])
            _SEED_ROOM_UUIDS[name_tag] = created_room_orm.id
            print(f"  Created '{created_room_orm.name}' with UUID: {_SEED_ROOM_UUIDS[name_tag]}")
            created_rooms_this_run = True
        else:
            print(f"Room '{existing_room.name}' at {coords} (tag: '{name_tag}') already exists with UUID: {existing_room.id}.")
            _SEED_ROOM_UUIDS[name_tag] = existing_room.id

    # Link rooms using their known/generated UUIDs
    print("Linking room exits for the new world configuration...")

    # Define exits as a list of tuples: (source_tag, direction, target_tag)
    exit_links = [
        ("central_hub", "north", "north_corridor_1"), ("north_corridor_1", "south", "central_hub"),
        ("north_corridor_1", "north", "archive_access_north"), ("archive_access_north", "south", "north_corridor_1"),
        
        ("central_hub", "east", "east_corridor_1"), ("east_corridor_1", "west", "central_hub"),
        ("east_corridor_1", "east", "personnel_intake_east"), ("personnel_intake_east", "west", "east_corridor_1"),
        
        ("central_hub", "south", "south_corridor_1"), ("south_corridor_1", "north", "central_hub"),
        ("south_corridor_1", "south", "waste_reclamation_south"), ("waste_reclamation_south", "north", "south_corridor_1"),

        ("central_hub", "west", "west_corridor_1"), ("west_corridor_1", "east", "central_hub"),
        ("west_corridor_1", "west", "auxiliary_storage_west"), ("auxiliary_storage_west", "east", "west_corridor_1"),

        # Connecting the "anomaly" room
        ("north_corridor_1", "east", "break_room_anomaly"), ("break_room_anomaly", "west", "north_corridor_1"),
        ("east_corridor_1", "north", "break_room_anomaly"), ("break_room_anomaly", "south", "east_corridor_1"),
    ]

    for source_tag, direction, target_tag in exit_links:
        if source_tag in _SEED_ROOM_UUIDS and target_tag in _SEED_ROOM_UUIDS:
            source_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS[source_tag])
            if source_room_orm:
                # Ensure exits dictionary exists and work with a mutable copy
                current_exits = source_room_orm.exits.copy() if source_room_orm.exits is not None else {} # type: ignore
                
                new_exit_uuid_str = str(_SEED_ROOM_UUIDS[target_tag])

                # Only update if the exit is different or doesn't exist
                if current_exits.get(direction) != new_exit_uuid_str:
                    source_name_for_log = source_room_orm.name if source_room_orm.name else f"Room with ID {_SEED_ROOM_UUIDS[source_tag]}"
                    target_name_for_log = "Unknown Target Room" # Placeholder
                    # Attempt to get target room name for better logging
                    target_room_for_log = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS[target_tag])
                    if target_room_for_log and target_room_for_log.name:
                        target_name_for_log = target_room_for_log.name
                    else:
                        target_name_for_log = f"Room with ID {_SEED_ROOM_UUIDS[target_tag]}"

                    print(f"  Setting exit for '{source_name_for_log}': {direction} -> '{target_name_for_log}' (UUID: {new_exit_uuid_str})")
                    
                    current_exits[direction] = new_exit_uuid_str
                    source_room_orm.exits = current_exits # Re-assign the modified dictionary
                    db.add(source_room_orm) # Add to session to mark as dirty for commit
        else:
            print(f"  Warning: Could not link exit {source_tag} -> {target_tag}. One or both tags not found in _SEED_ROOM_UUIDS.")
            print(f"    Available tags: {list(_SEED_ROOM_UUIDS.keys())}")

    db.commit() # Commit all exit updates at once
    print("New world seeding and exit linking complete.")



--- END OF FILE backend/app/crud/crud_room.py ---

--- START OF FILE backend/app/api/dependencies.py ---
# backend/app/api/dependencies.py
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
import uuid

from app.core.config import settings
from app import models, schemas, crud
from app.db.session import get_db
from app.game_state import active_game_sessions # <<< ADDED THIS IMPORT

reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/users/login"
)

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY

async def get_current_player(
    db: Session = Depends(get_db), token: str = Depends(reusable_oauth2)
) -> models.Player:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username_or_player_id: Optional[str] = payload.get("sub")
        if username_or_player_id is None:
            raise credentials_exception
        
        try:
            player_uuid = uuid.UUID(username_or_player_id)
        except ValueError:
            raise credentials_exception
            
    except JWTError as e:
        raise credentials_exception
    
    player = crud.crud_player.get_player(db, player_id=player_uuid)
    if player is None:
        raise credentials_exception
    return player

async def get_current_active_character( 
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
) -> models.Character:
    character_id = active_game_sessions.get(current_player.id)
    
    if not character_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, 
            detail="No active character selected for this session. Please select a character.",
        )
    
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        active_game_sessions.pop(current_player.id, None)
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Active character with ID {character_id} not found. Session reset.",
        )

    if character.player_id != current_player.id:
        active_game_sessions.pop(current_player.id, None) 
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="CRITICAL: Active character's player ID does not match authenticated player. Session reset.",
        )
    return character
--- END OF FILE backend/app/api/dependencies.py ---

--- START OF FILE backend/app/api/v1/api_router.py ---
from fastapi import APIRouter
from .endpoints import room, command, user, character, inventory, map, character_class # This imports the router from endpoints/room.py

# This router will be included with a prefix like /api by main.py
# So paths here are relative to that.
api_router = APIRouter() 

# All routes defined in 'room.router' will be prefixed with '/room'
# So, a GET "/{x}/{y}/{z}" in room.router becomes GET "/room/{x}/{y}/{z}" here.
api_router.include_router(room.router, prefix="/room", tags=["Rooms"])
api_router.include_router(command.router, prefix="/command", tags=["Commands"])
api_router.include_router(user.router, prefix="/users", tags=["Users"])
api_router.include_router(character.router, prefix="/character", tags=["Characters"])
api_router.include_router(inventory.router, prefix="/inventory", tags=["Inventory"])
api_router.include_router(map.router, prefix="/map", tags=["Map"])
api_router.include_router(character_class.router, prefix="/classes", tags=["Character Classes"]) 
--- END OF FILE backend/app/api/v1/api_router.py ---

--- FILE NOT FOUND: backend/app/api/v1/endpoints/users.py ---

--- START OF FILE backend/app/api/v1/endpoints/character.py ---
# backend/app/api/v1/endpoints/character.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from sqlalchemy.orm import Session
import uuid
from typing import Any, List

from .... import schemas, crud, models
from ....db.session import get_db
# from ....crud.crud_room import get_room_by_coords # No longer needed for this file directly if only used in create
from ....api.dependencies import get_current_player
from ....game_state import active_game_sessions # <<< ADDED THIS IMPORT

router = APIRouter()


@router.post("/create", response_model=schemas.Character, status_code=status.HTTP_201_CREATED)
def create_new_character_for_current_player(
    *,
    db: Session = Depends(get_db),
    character_payload: schemas.CharacterCreate = Body(...), # Contains name, optional class_name
    current_player: models.Player = Depends(get_current_player)
) -> Any:
    # ... (existing_character check remains the same) ...
    existing_character = crud.crud_character.get_character_by_name(db, name=character_payload.name)
    if existing_character:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"A character with the name '{character_payload.name}' already exists."
        )
    
    start_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0)
    if not start_room_orm:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Starting room not found. Cannot create character. Server misconfiguration."
        )
    
    # The character_payload (schemas.CharacterCreate) now passes name and class_name (optional)
    # to crud.crud_character.create_character.
    # The CRUD function handles looking up the class template and applying defaults/modifiers.
    character = crud.crud_character.create_character(
        db,
        character_in=character_payload, # Contains name and potentially class_name
        player_id=current_player.id,
        initial_room_id=start_room_orm.id
    )
    
    print(f"Character '{character.name}' (Class: {character.class_name}) created for player '{current_player.username}', starting in room '{start_room_orm.name}'.")
    return character # FastAPI will convert to schemas.Character


@router.get("/mine", response_model=List[schemas.Character])
def read_characters_for_current_player(
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
):
    """
    Retrieve all characters for the currently authenticated player.
    """
    characters = crud.crud_character.get_characters_by_player(db, player_id=current_player.id)
    return characters


@router.post("/{character_id}/select", response_model=schemas.RoomInDB) # <<< NEW ENDPOINT
def select_character_for_session(
    *,
    db: Session = Depends(get_db),
    character_id: uuid.UUID,
    current_player: models.Player = Depends(get_current_player)
) -> Any:
    """
    Selects a character to be the active character for the player's session.
    Returns the character's current room data.
    """
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Character with ID {character_id} not found."
        )
    
    if character.player_id != current_player.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Operation not permitted: This character does not belong to you."
        )

    # Set this character as active for the player's session
    active_game_sessions[current_player.id] = character.id
    
    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    if not current_room_orm:
        active_game_sessions.pop(current_player.id, None) # Clean up inconsistent state
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Character '{character.name}' (ID: {character.id}) is in an invalid room (ID: {character.current_room_id}). Data integrity error. Session not started."
        )
    
    print(f"Player '{current_player.username}' (ID: {current_player.id}) selected character '{character.name}' (ID: {character.id}).")
    print(f"Active sessions: {active_game_sessions}") # For debugging
    return current_room_orm # FastAPI will convert ORM to schemas.RoomInDB
--- END OF FILE backend/app/api/v1/endpoints/character.py ---

--- START OF FILE backend/app/api/v1/endpoints/character_class.py ---
# backend/app/api/v1/endpoints/character_class.py (NEW FILE)
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from typing import List

from app import schemas, crud, models # app.
from app.db.session import get_db
# No specific auth needed for listing public class templates usually

router = APIRouter()

@router.get("", response_model=List[schemas.CharacterClassTemplate])
def read_available_character_classes(
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 100 # Allow for future pagination if many classes
):
    """
    Retrieve a list of all available character class templates.
    """
    class_templates = crud.crud_character_class.get_character_class_templates(db, skip=skip, limit=limit)
    return class_templates
--- END OF FILE backend/app/api/v1/endpoints/character_class.py ---

--- START OF FILE backend/app/api/v1/endpoints/map.py ---
# backend/app/api/v1/endpoints/map.py (NEW FILE)
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import Any # List for type hint

from app import schemas, models, crud
from app.db.session import get_db
from app.api.dependencies import get_current_active_character

router = APIRouter()

@router.get("/level_data", response_model=schemas.MapLevelDataResponse)
def get_map_data_for_current_level(
    *,
    db: Session = Depends(get_db),
    active_character: models.Character = Depends(get_current_active_character)
) -> Any:
    """
    Provides map data for the Z-level the active character is currently on.
    """
    if active_character.current_room_id is None:
        # This should ideally not happen if a character is active
        raise HTTPException(status_code=404, detail="Active character is not in a valid room.")

    # Fetch the current room to get the Z-level
    # current_room_orm = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    # We can get Z directly from the character's current_room object if it's loaded with coords,
    # or from the current_room_orm if we fetch it.
    # For simplicity, let's assume active_character.current_room (if relationship is loaded) has x,y,z
    # Or, safer, fetch the current room again to ensure we have its Z.
    # Let's rely on the character's current room being valid and its details accessible
    # For this, we need to ensure current_room is loaded on active_character, or we fetch it.
    # The get_current_active_character dependency already fetches the character.
    # We need to ensure its `current_room_id` can be used to get the room's Z.

    current_room = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    if not current_room:
         raise HTTPException(status_code=500, detail="Current room for active character not found.")
    
    character_z_level = current_room.z

    rooms_on_level_orm = crud.crud_room.get_rooms_by_z_level(db, z_level=character_z_level)

    map_rooms_data: list[schemas.MapRoomData] = []
    for room_orm in rooms_on_level_orm:
        map_rooms_data.append(
            schemas.MapRoomData(
                id=room_orm.id,
                x=room_orm.x,
                y=room_orm.y,
                name=room_orm.name,
                exits=room_orm.exits or {}, # Ensure exits is a dict, not None
                is_current_room=(room_orm.id == active_character.current_room_id),
                is_visited=True # Placeholder: For now, all rooms on the Z-level are "visited"
            )
        )
    
    return schemas.MapLevelDataResponse(
        z_level=character_z_level,
        current_room_id=active_character.current_room_id,
        rooms=map_rooms_data
    )
--- END OF FILE backend/app/api/v1/endpoints/map.py ---

--- START OF FILE backend/app/api/v1/endpoints/inventory.py ---
# backend/app/api/v1/endpoints/inventory.py
from fastapi import APIRouter, Depends, HTTPException, Body, status
from sqlalchemy.orm import Session
import uuid
from typing import List

from .... import schemas, models, crud
from ....db.session import get_db
from ....api.dependencies import get_current_active_character
from ....models.item import EQUIPMENT_SLOTS # For constructing display

router = APIRouter()

def format_inventory_for_display(
    inventory_items: List[models.CharacterInventoryItem]
) -> schemas.CharacterInventoryDisplay:
    """Helper function to format raw inventory items into the display schema."""
    equipped_dict: dict[str, schemas.CharacterInventoryItem] = {}
    backpack_list: list[schemas.CharacterInventoryItem] = []

    for inv_item_orm in inventory_items:
        # Convert ORM to Pydantic schema. The item sub-object should also be converted.
        # schemas.CharacterInventoryItem.from_orm(inv_item_orm) should handle this due to nested Config.
        item_schema = schemas.CharacterInventoryItem.from_orm(inv_item_orm)
        if inv_item_orm.equipped and inv_item_orm.equipped_slot:
            equipped_dict[inv_item_orm.equipped_slot] = item_schema
        else:
            backpack_list.append(item_schema)
            
    return schemas.CharacterInventoryDisplay(equipped_items=equipped_dict, backpack_items=backpack_list)


@router.get("/mine", response_model=schemas.CharacterInventoryDisplay)
def get_my_inventory(
    db: Session = Depends(get_db),
    current_character: models.Character = Depends(get_current_active_character),
):
    """
    Retrieve the inventory for the currently active character.
    """
    inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        db, character_id=current_character.id
    )
    return format_inventory_for_display(inventory_items_orm)


@router.post("/equip/{inventory_item_id}", response_model=schemas.CommandResponse) # Using CommandResponse for feedback
def equip_inventory_item_api(
    inventory_item_id: uuid.UUID,
    payload: schemas.EquipRequest = Body(None), # Payload can be optional if target_slot isn't always needed
    db: Session = Depends(get_db),
    current_character: models.Character = Depends(get_current_active_character),
):
    """
    Equip an item from the character's inventory.
    inventory_item_id is the UUID of the CharacterInventoryItem entry.
    """
    target_slot_from_payload = payload.target_slot if payload else None
    
    updated_inv_item, message = crud.crud_character_inventory.equip_item_from_inventory(
        db=db,
        character_id=current_character.id,
        inventory_item_id=inventory_item_id,
        target_slot=target_slot_from_payload
    )

    if not updated_inv_item and not message.lower().endswith("already equipped.") and not message.lower().startswith("item not found"): # Distinguish not found vs other errors
        # A more robust error check is needed here. If equip_item_from_inventory returns None but a real error message,
        # it's an issue. If it returns None and "item not found", it's a 404.
        # For now, assume if updated_inv_item is None and it's not "already equipped", it's a failure.
        # This logic needs refinement based on how crud function signals true errors vs valid "cannot equip" scenarios.
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)


    # If successful or "already equipped", we could return the new inventory state or just the message.
    # For now, let's just return the message. The client can re-fetch inventory if needed.
    # To provide full context, we'd fetch the current room as well.
    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=current_character.current_room_id)
    if not current_room_orm: # Should not happen if character is valid
        current_room_schema = None
    else:
        current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)
        
    return schemas.CommandResponse(
        message_to_player=message,
        room_data=current_room_schema # Provide current room context
    )


@router.post("/unequip/{inventory_item_id}", response_model=schemas.CommandResponse) # Using CommandResponse for feedback
def unequip_inventory_item_api(
    inventory_item_id: uuid.UUID,
    db: Session = Depends(get_db),
    current_character: models.Character = Depends(get_current_active_character),
):
    """
    Unequip an item, moving it back to the backpack.
    inventory_item_id is the UUID of the CharacterInventoryItem entry.
    """
    updated_inv_item, message = crud.crud_character_inventory.unequip_item_to_inventory(
        db=db,
        character_id=current_character.id,
        inventory_item_id=inventory_item_id
    )

    if not updated_inv_item and not message.lower().endswith("not currently equipped.") and not message.lower().startswith("item not found"):
        # Similar to equip, needs better error handling from CRUD
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)

    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=current_character.current_room_id)
    if not current_room_orm:
        current_room_schema = None
    else:
        current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)

    return schemas.CommandResponse(
        message_to_player=message,
        room_data=current_room_schema
    )
--- END OF FILE backend/app/api/v1/endpoints/inventory.py ---

--- FILE NOT FOUND: /src/index.html ---

--- FILE NOT FOUND: /src/main.js ---

--- FILE NOT FOUND: /src/ui.js ---

--- FILE NOT FOUND: /src/api.js ---

--- FILE NOT FOUND: /src/websocket.js ---

--- FILE NOT FOUND: /src/map.js ---

--- FILE NOT FOUND: /src/state.js ---

--- FILE NOT FOUND: /src/config.js ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
