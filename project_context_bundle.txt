--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Wed Jun  4 01:20:55 PM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/exits_z0.json
backend/app/seeds/rooms_z0.json
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
bundle_context.sh
frontend/src/api.js
frontend/src/config.js
frontend/src/index.html
frontend/src/main.js
frontend/src/map.js
frontend/src/script.js
frontend/src/state.js
frontend/src/ui.js
frontend/src/websocket.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed." >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh"  # Include the script itself for context on the bundling process

    # Backend - Core application & setup
    "$BACKEND_APP_DIR/main.py"
    "$BACKEND_APP_DIR/core/config.py"
    "$BACKEND_APP_DIR/websocket_router.py"

    # Seed examples
    "$BACKEND_APP_DIR/seeds/exits_z0.json"
    "$BACKEND_APP_DIR/seeds/rooms_z0.json"

    # Backend - Key game logic (example)
    "$BACKEND_APP_DIR/game_logic/combat/combat_round_processor.py"
    "$BACKEND_APP_DIR/game_logic/combat/skill_resolver.py" # Example of another key file

    # Backend - Key models (example)
    "$BACKEND_APP_DIR/models/character.py"
    "$BACKEND_APP_DIR/models/room.py"

    # Backend - Key CRUD (example)
    "$BACKEND_APP_DIR/crud/crud_room.py"

    # Frontend - Main entry point (example, if it exists)
    "$FRONTEND_SRC_DIR/main.js"
    "$FRONTEND_SRC_DIR/websocket.js"
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE backend/app/main.py ---
# backend/app/main.py
import asyncio
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
import sys # For detailed print statements
from app.core.config import settings
import logging # Import logging

# --- Setup Logging First ---
# This needs to happen before other modules that might use logging are imported,
# or at least before they try to log.
try:
    from app.core.logging_config import setup_logging
    setup_logging()
    print("--- MAIN.PY: setup_logging() CALLED (no exception caught) ---", flush=True)
except ImportError as e_log_setup:
    print(f"--- CRITICAL: main.py - FAILED to import or run setup_logging: {e_log_setup} ---", flush=True)
    sys.exit(1) # Exit if logging can't be set up, as it's crucial for debugging

logger = logging.getLogger(__name__) # Get a logger for this module

# --- Add these lines for immediate feedback on logger level ---
print(f"--- MAIN.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_main = logger.getEffectiveLevel()
print(f"--- MAIN.PY: Effective log level for 'app.main' logger = {effective_level_main} ({logging.getLevelName(effective_level_main)}) ---", flush=True)
logger.debug(f"--- MAIN.PY DEBUG LOG TEST: Top of file, Python version: {sys.version} ---") # Changed from logger.debug to ensure it prints if DEBUG is working
logger.info(f"--- MAIN.PY INFO LOG TEST: Top of file, Python version: {sys.version} ---")
# --- End of added lines ---

from app.api.v1.api_router import api_router as v1_api_router
logger.debug("--- main.py - Imported v1_api_router ---")
from app.websocket_router import router as ws_router
logger.debug("--- main.py - Imported ws_router ---")
from app.db.session import engine, get_db
logger.debug("--- main.py - Imported engine, get_db from app.db.session ---")
from app.db import base_class
logger.debug("--- main.py - Imported base_class from app.db ---")
from app.core.config import settings
logger.debug(f"--- main.py - Imported settings. Project Name: {settings.PROJECT_NAME} ---")
from app.crud.crud_room import seed_initial_world
logger.debug("--- main.py - Imported seed_initial_world ---")
from app.crud.crud_item import seed_initial_items 
logger.debug("--- main.py - Imported seed_initial_items ---")
from app.crud.crud_mob import seed_initial_mob_templates
logger.debug("--- main.py - Imported seed_initial_mob_templates ---")
from app.game_logic.combat import start_combat_ticker_task, stop_combat_ticker_task
logger.debug("--- main.py - Imported combat_manager tasks ---")
from app.crud.crud_character_class import seed_initial_character_class_templates 
logger.debug("--- main.py - Imported seed_initial_character_class_templates ---")
from app.crud.crud_skill import seed_initial_skill_templates 
logger.debug("--- main.py - Imported seed_initial_skill_templates ---")
from app.crud.crud_trait import seed_initial_trait_templates 
logger.debug("--- main.py - Imported seed_initial_trait_templates ---")
from app.game_logic.world_ticker import start_world_ticker_task, stop_world_ticker_task
logger.debug("--- main.py - Imported world_ticker tasks ---")
from app.crud.crud_mob_spawn_definition import seed_initial_mob_spawn_definitions 
logger.debug("--- main.py - Imported seed_initial_mob_spawn_definitions ---")

logger.debug("--- main.py - About to call Base.metadata.create_all(bind=engine) ---")
try:
    base_class.Base.metadata.create_all(bind=engine)
    logger.info("--- main.py - Base.metadata.create_all(bind=engine) COMPLETED ---")
except Exception as e:
    logger.error(f"--- main.py - ERROR during Base.metadata.create_all: {e} ---", exc_info=True)
    # Depending on the severity, you might want to sys.exit() here

logger.debug("--- main.py - Creating FastAPI app instance ---")
app = FastAPI(title=settings.PROJECT_NAME)
logger.info("--- main.py - FastAPI app instance CREATED ---")

@app.on_event("startup")
def on_startup_sync(): # Renamed to avoid clash if we make it async later
    logger.info("--- main.py - START of on_startup_sync event ---")
    db: Session = next(get_db())
    logger.debug("--- main.py - on_startup_sync: Acquired DB session ---")
    try:
        logger.info("--- main.py - on_startup_sync: Running startup event: Seeding initial world... ---")
        seed_initial_world(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_world COMPLETED ---")
        seed_initial_mob_templates(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_templates COMPLETED ---")
        seed_initial_items(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_items COMPLETED ---")
        seed_initial_character_class_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_character_class_templates COMPLETED ---")
        seed_initial_skill_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_skill_templates COMPLETED ---")
        seed_initial_trait_templates(db) # Make sure this is imported if you uncomment it
        logger.debug("--- main.py - on_startup_sync: seed_initial_trait_templates COMPLETED ---")
        seed_initial_mob_spawn_definitions(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_spawn_definitions COMPLETED ---")
        
        logger.info("--- main.py - on_startup_sync: Starting combat ticker... ---")
        start_combat_ticker_task()
        logger.debug("--- main.py - on_startup_sync: Combat ticker STARTED ---")      

        logger.info("--- main.py - on_startup_sync: Starting world ticker... ---") 
        start_world_ticker_task()    
        logger.debug("--- main.py - on_startup_sync: World ticker STARTED ---")     
        logger.info("--- main.py - on_startup_sync: Startup event processing FINISHED ---")
    except Exception as e_startup:
        logger.error(f"--- main.py - ERROR during on_startup_sync: {e_startup} ---", exc_info=True)
    finally:
        logger.debug("--- main.py - on_startup_sync: Closing DB session ---")
        db.close()
        logger.debug("--- main.py - on_startup_sync: DB session CLOSED ---")
    logger.info("--- main.py - END of on_startup_sync event ---")

logger.debug("--- main.py - About to include v1_api_router ---")
app.include_router(v1_api_router, prefix=settings.API_V1_STR)
logger.debug("--- main.py - v1_api_router INCLUDED ---")

logger.debug("--- main.py - About to include ws_router ---")
app.include_router(ws_router)
logger.debug("--- main.py - ws_router INCLUDED ---")

@app.get("/")
async def root():
    logger.debug("--- main.py - GET / request received ---")
    return {"message": f"Welcome to {settings.PROJECT_NAME}. Now with a World Ticker humming in the background!"}

logger.info("--- main.py - FastAPI app instance configured. End of file. ---")
--- END OF FILE backend/app/main.py ---

--- START OF FILE backend/app/core/config.py ---
# backend/app/core/config.py
import os
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict

# Check if we're likely running in an Alembic 'env.py' context BEFORE settings are needed for DB connection
# This is a heuristic. Alembic sets 'alembic.version' in its context.
# A simpler heuristic: if a specific env var for alembic is set.
IS_ALEMBIC_ENV_PY_CONTEXT = os.getenv("ALEMBIC_ENV_PY_RUNNING") == "true"

class Settings(BaseSettings):
    PROJECT_NAME: str = "MUD Project - Backend"
    API_V1_STR: str = "/api/v1"
    
    DATABASE_URL: Optional[str] = "postgresql://dummy_user:dummy_password@dummy_host:5432/dummy_db" if IS_ALEMBIC_ENV_PY_CONTEXT else os.getenv("DATABASE_URL", "postgresql://user:password@db/llmud_db") # Added os.getenv for normal case
    SECRET_KEY: str = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7" # CHANGE THIS IN PRODUCTION!
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7 # Token expires in 7 days

    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO").upper() # Default to INFO
    SHOW_COMBAT_ROLLS_TO_PLAYER: bool = os.getenv("SHOW_COMBAT_ROLLS_TO_PLAYER", "True").lower() == "true"


    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8', extra='ignore')

settings = Settings() 

# After instantiation, if it was a dummy, ensure it's overridden if not in Alembic context
# and the real env var is available.
if IS_ALEMBIC_ENV_PY_CONTEXT and settings.DATABASE_URL is not None and "dummy_user" in settings.DATABASE_URL:
    # logger.info("Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.") # Can't use logger before setup
    print("INFO: Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.")
elif not IS_ALEMBIC_ENV_PY_CONTEXT and os.getenv("DATABASE_URL"):
    settings.DATABASE_URL = os.getenv("DATABASE_URL") # Ensure it's set from env if not in alembic context
elif not IS_ALEMBIC_ENV_PY_CONTEXT and not os.getenv("DATABASE_URL"):
    # This will have already failed in Settings() if '...' was used and no env var
    # logger.warning("DATABASE_URL not found in environment for normal app run!") # Can't use logger before setup
    print("WARNING: DATABASE_URL not found in environment for normal app run!")
--- END OF FILE backend/app/core/config.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple, Union
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session # attributes removed as it's used in parsers now
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

from app.core.config import settings
from app.db.session import SessionLocal
from app import crud, models, schemas # Full app imports
from app.websocket_manager import connection_manager
from app.game_logic import combat # For access to combat.active_combats, combat.send_combat_log etc.

from app.commands.utils import ( # General utils
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message
    # resolve_mob_target is used within ws_combat_actions_parser
    # resolve_room_item_target is used within ws_interaction_parser
)
from app.game_state import is_character_resting, set_character_resting_status
# ExitDetail is used within ws_movement_parser.attempt_player_move

# Import the new WS command parsers
from app.ws_command_parsers import (
    handle_ws_movement, handle_ws_flee,
    handle_ws_attack, handle_ws_use_combat_skill,
    handle_ws_get_take, handle_ws_unlock, handle_ws_search_examine,
    handle_ws_contextual_interactable, handle_ws_use_ooc_skill,
    handle_ws_look, handle_ws_rest
)

logger = logging.getLogger(__name__)
# --- Logger setup print lines (can be removed once stable) ---
print(f"--- WEBSOCKET_ROUTER.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_ws = logger.getEffectiveLevel()
print(f"--- WEBSOCKET_ROUTER.PY: Effective log level for '{logger.name}' logger = {effective_level_ws} ({logging.getLevelName(effective_level_ws)}) ---", flush=True)
logger.info("--- WEBSOCKET_ROUTER.PY INFO LOG TEST: Module loaded (Post-Refactor) ---")
# --- End of logger setup print lines ---

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str) # Ensure player_id_str is a valid UUID string
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError): # Catch JWT errors and ValueError from UUID conversion
        return None

# _handle_websocket_move_if_not_in_combat has been moved to ws_movement_parser.attempt_player_move

@router.websocket("/ws") 
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character_orm: Optional[models.Character] = None # Renamed from 'character' to avoid confusion with character_id param

    with get_db_sync() as db_conn_init: 
        player = await get_player_from_token(token, db_conn_init)
        if not player:
            logger.warning(f"WS Connect: Invalid token for char_id: {character_id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return
        
        fetched_char = crud.crud_character.get_character(db_conn_init, character_id=character_id)
        if not fetched_char or fetched_char.player_id != player.id:
            logger.warning(f"WS Connect: Invalid char_id: {character_id} for player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character_orm = fetched_char # Assign to the correctly scoped variable
    
    await connection_manager.connect(websocket, player.id, character_orm.id)
    logger.info(f"Player {player.id} (Character {character_orm.name} - {character_orm.id}) connected via WebSocket.")
    
    # --- Welcome Package ---
    initial_messages = [f"Welcome {character_orm.name}! You are connected via WebSocket."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db_welcome: 
        initial_room_orm = crud.crud_room.get_room_by_id(db_welcome, room_id=character_orm.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.")
            items_on_ground = crud.crud_room_item.get_items_in_room(db_welcome, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: initial_messages.append(items_text)
            
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db_welcome, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: initial_messages.append(mobs_text)
            
            other_chars_in_room = crud.crud_character.get_characters_in_room(db_welcome, room_id=initial_room_orm.id, exclude_character_id=character_orm.id)
            chars_text_initial = format_room_characters_for_player_message(other_chars_in_room)
            if chars_text_initial: initial_messages.append(chars_text_initial)
    
    xp_for_next_level = crud.crud_character.get_xp_for_level(character_orm.level + 1)
    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump(exclude_none=True) if initial_room_schema else None,
        "character_vitals": {
            "current_hp": character_orm.current_health, "max_hp": character_orm.max_health,
            "current_mp": character_orm.current_mana, "max_mp": character_orm.max_mana,
            "current_xp": character_orm.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character_orm.level,
            "platinum": character_orm.platinum_coins, "gold": character_orm.gold_coins,
            "silver": character_orm.silver_coins, "copper": character_orm.copper_coins
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)
    # --- End Welcome Package ---

    try:
        while True:
            received_data = await websocket.receive_json()
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            # It's crucial to get fresh state at the beginning of each command processing loop
            with get_db_sync() as db_loop: 
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character_orm.id) # Use original character_orm.id
                if not current_char_state: 
                    logger.error(f"WS Loop: Character state lost for char_id: {character_orm.id}.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost in loop")
                    break 
                
                current_room_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                if not current_room_orm:
                    logger.error(f"WS Loop: Character {current_char_state.name} in invalid room {current_char_state.current_room_id}.")
                    await combat.send_combat_log(player.id, ["Error: Your current location is unstable. Please relog or contact support."], combat_ended=True)
                    continue 

                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_orm)
                
                verb_for_rest_check = command_text.split(" ", 1)[0].lower() if command_text else ""
                
                non_breaking_verbs = [ # Commands that don't break resting
                    "rest", "look", "l", "score", "sc", "status", "st", 
                    "help", "?", "skills", "sk", "traits", "tr", 
                    "inventory", "i", "ooc", "say", "'", "emote", ":" 
                ]
                
                if verb_for_rest_check and verb_for_rest_check not in non_breaking_verbs and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat.send_combat_log(player.id, ["You stop resting."], room_data=current_room_schema_for_command)

                if message_type == "command" and command_text:
                    verb = verb_for_rest_check 
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""
                    args_list = args_str.split() # For handlers that need a list

                    logger.debug(f"WS Router: Processing verb='{verb}', args='{args_str}' for char {current_char_state.name}")

                    # --- Command Dispatching ---
                    if verb == "rest":
                        await handle_ws_rest(db_loop, player, current_char_state, current_room_orm)
                    elif verb in ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]:
                        await handle_ws_movement(db_loop, player, current_char_state, current_room_schema_for_command, verb, args_str)
                    elif verb == "flee":
                        await handle_ws_flee(db_loop, player, current_char_state, current_room_schema_for_command, args_str)
                    elif verb in ["attack", "atk", "kill", "k"]:
                        await handle_ws_attack(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "use":
                        if not args_str: 
                            await combat.send_combat_log(player.id, ["Use what skill?"], room_data=current_room_schema_for_command); continue
                        
                        temp_args_list_for_skill_parse = args_str.split()
                        learned_skill_tags = current_char_state.learned_skills or []
                        if not learned_skill_tags: 
                            await combat.send_combat_log(player.id, ["You have no skills."], room_data=current_room_schema_for_command); continue

                        # Simplified skill name parsing (copied from previous) - THIS SHOULD BE A UTILITY
                        parsed_skill_template: Optional[models.SkillTemplate] = None
                        parsed_remaining_args: str = ""
                        possible_matches_temp: List[Tuple[models.SkillTemplate, str]] = []
                        for i in range(len(temp_args_list_for_skill_parse), 0, -1):
                            current_skill_input = " ".join(temp_args_list_for_skill_parse[:i]).lower()
                            potential_target_str = " ".join(temp_args_list_for_skill_parse[i:]).strip()
                            for skill_tag_loop in learned_skill_tags:
                                st_db = crud.crud_skill.get_skill_template_by_tag(db_loop, skill_id_tag=skill_tag_loop)
                                if not st_db: continue
                                if st_db.skill_id_tag.lower().startswith(current_skill_input) or st_db.name.lower().startswith(current_skill_input):
                                    if not any(em.id == st_db.id for em, _ in possible_matches_temp):
                                        possible_matches_temp.append((st_db, potential_target_str))
                            if possible_matches_temp and len(current_skill_input.split()) > 0: break
                        
                        if not possible_matches_temp: await combat.send_combat_log(player.id, [f"No skill matching '{temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else args_str}'."], room_data=current_room_schema_for_command); continue
                        elif len(possible_matches_temp) == 1: parsed_skill_template, parsed_remaining_args = possible_matches_temp[0]
                        else:
                            exact_match_s = None; s_input_first = temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else ""
                            for sm_t, sm_a in possible_matches_temp:
                                if sm_t.name.lower() == s_input_first or sm_t.skill_id_tag.lower() == s_input_first:
                                    exact_match_s = sm_t; parsed_remaining_args = sm_a; break
                            if exact_match_s: parsed_skill_template = exact_match_s
                            else: await combat.send_combat_log(player.id, [f"Multiple skills match. Specify: {', '.join(list(set([st.name for st, _ in possible_matches_temp])))}"], room_data=current_room_schema_for_command); continue
                        
                        if not parsed_skill_template: await combat.send_combat_log(player.id, ["Error selecting skill for 'use' command."], room_data=current_room_schema_for_command); continue

                        # Dispatch based on skill type
                        if parsed_skill_template.skill_type == "COMBAT_ACTIVE":
                            await handle_ws_use_combat_skill(db_loop, player, current_char_state, current_room_schema_for_command, args_str) # Pass original args_str for its own parsing
                        elif parsed_skill_template.skill_type == "UTILITY_OOC":
                            # parsed_remaining_args is the target for the OOC skill (e.g., direction string)
                            await handle_ws_use_ooc_skill(db_loop, player, current_char_state, current_room_orm, parsed_skill_template, parsed_remaining_args)
                        else:
                            await combat.send_combat_log(player.id, [f"Skill '{parsed_skill_template.name}' type ({parsed_skill_template.skill_type}) cannot be 'used' this way."], room_data=current_room_schema_for_command)
                    
                    elif verb in ["get", "take"]:
                        await handle_ws_get_take(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "unlock":
                        await handle_ws_unlock(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "search" or verb == "examine":
                        await handle_ws_search_examine(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "look" or verb == "l":
                        await handle_ws_look(db_loop, player, current_char_state, current_room_orm, args_str)
                    else: # Fallback: Try contextual interactable actions
                        is_interactable_action_handled = False
                        if current_room_orm.interactables: # Check if list is not None and not empty
                            target_interactable_name_or_id = args_str.lower()
                            for interactable_dict_ws in current_room_orm.interactables:
                                try:
                                    interactable_obj_ws = schemas.InteractableDetail(**interactable_dict_ws) # Validate from DB data
                                    is_visible = not interactable_obj_ws.is_hidden or current_char_state.id in interactable_obj_ws.revealed_to_char_ids
                                    
                                    if is_visible and verb == interactable_obj_ws.action_verb.lower():
                                        matches_this_interactable = False
                                        if not target_interactable_name_or_id: # e.g. "pull"
                                            # Count how many pullable things are visible
                                            count_with_verb = 0
                                            for other_i_d in current_room_orm.interactables:
                                                other_i = schemas.InteractableDetail(**other_i_d)
                                                other_vis = not other_i.is_hidden or current_char_state.id in other_i.revealed_to_char_ids
                                                if other_vis and other_i.action_verb.lower() == verb:
                                                    count_with_verb +=1
                                            if count_with_verb == 1: matches_this_interactable = True
                                        elif interactable_obj_ws.id_tag.lower() == target_interactable_name_or_id or \
                                             target_interactable_name_or_id in interactable_obj_ws.name.lower():
                                            matches_this_interactable = True
                                        
                                        if matches_this_interactable:
                                            await handle_ws_contextual_interactable(db_loop, player, current_char_state, current_room_orm, verb, args_list, interactable_obj_ws)
                                            is_interactable_action_handled = True; break 
                                except Exception as e_parse_interactable_ws_ctx: 
                                    logger.error(f"WS: Error parsing interactable for contextual check: {e_parse_interactable_ws_ctx}. Data: {interactable_dict_ws}")
                        
                        if not is_interactable_action_handled:
                            # If not any of the above, it's an unknown command for WebSocket
                            await combat.send_combat_log(player.id, [f"Unrecognized command via WebSocket: '{command_text}'. Try 'help' (HTTP)."], room_data=current_room_schema_for_command)
                
                elif message_type != "command": 
                    await combat.send_combat_log(player.id, [f"Unrecognized message type: {message_type}."], room_data=current_room_schema_for_command)
                elif not command_text : # Empty command string for type "command"
                     await combat.send_combat_log(player.id, ["Empty command received."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'} (Character {character_orm.id if character_orm else 'N/A'})")
        if character_orm and character_orm.id: 
            combat.end_combat_for_character(character_orm.id, reason="websocket_disconnect_main_handler")
            if is_character_resting(character_orm.id):
                set_character_resting_status(character_orm.id, False)
    except Exception as e:
        err_player_id_str = str(player.id) if player else "Unknown Player"
        err_char_id_str = str(character_orm.id) if character_orm else "Unknown Character"
        logger.error(f"Critical Error in WebSocket handler for Player {err_player_id_str} (Character {err_char_id_str}): {e}", exc_info=True)
        try:
            # Attempt to send a generic error to the client before closing
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred. Please try reconnecting."})
        except Exception as send_err: 
            logger.error(f"Failed to send critical error to WebSocket for Player {err_player_id_str}: {send_err}")
    finally:
        if player and player.id: 
            connection_manager.disconnect(player.id) 
            if character_orm and character_orm.id and is_character_resting(character_orm.id): 
                set_character_resting_status(character_orm.id, False)
        char_id_log_final = str(character_orm.id) if character_orm else "N/A"
        player_id_log_final = str(player.id) if player else "N/A"
        logger.info(f"WebSocket connection for Player {player_id_log_final} (Character {char_id_log_final}) fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/seeds/exits_z0.json ---
[
  {
    "source_tag": "central_hub_0_0_0", "direction": "north", "target_tag": "north_corridor_0_1_0",
    "details": {}
  },
  {
    "source_tag": "north_corridor_0_1_0", "direction": "south", "target_tag": "central_hub_0_0_0",
    "details": {}
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "east", "target_tag": "east_storage_1_0_0",
    "details": {
      "is_locked": true,
      "lock_id_tag": "cpu_east_door_lock",
      "description_when_locked": "A heavy blast door to the east is sealed tight. The nearby lever might control it."
    }
  },
  {
    "source_tag": "east_storage_1_0_0", "direction": "west", "target_tag": "central_hub_0_0_0",
    "details": {
      "is_locked": true,
      "lock_id_tag": "cpu_east_door_lock",
      "description_when_locked": "The blast door to the west is sealed. It seems to be controlled from the other side."
    }
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "south", "target_tag": "south_corridor_0_-1_0",
    "details": {}
  },
  {
    "source_tag": "south_corridor_0_-1_0", "direction": "north", "target_tag": "central_hub_0_0_0",
    "details": {}
  },
  {
    "source_tag": "south_corridor_0_-1_0", "direction": "south", "target_tag": "deep_archive_0_-2_0",
    "details": {
      "is_locked": true,
      "lock_id_tag": "deep_archive_key_lock",
      "key_item_tag_opens": "archive_key_alpha",
      "description_when_locked": "A formidable iron door blocks passage south. It has a complex keyhole.",
      "skill_to_pick": {"skill_id_tag": "pick_lock_basic", "dc": 18}
    }
  },
  {
    "source_tag": "deep_archive_0_-2_0", "direction": "north", "target_tag": "south_corridor_0_-1_0",
    "details": {
      "is_locked": true,
      "lock_id_tag": "deep_archive_key_lock",
      "key_item_tag_opens": "archive_key_alpha",
      "description_when_locked": "The iron door to the north is locked from this side too.",
      "skill_to_pick": {"skill_id_tag": "pick_lock_basic", "dc": 18}
    }
  },
  {
    "source_tag": "central_hub_0_0_0", "direction": "west", "target_tag": "west_corridor_-1_0_0",
    "details": {}
  },
  {
    "source_tag": "west_corridor_-1_0_0", "direction": "east", "target_tag": "central_hub_0_0_0",
    "details": {}
  },
  {
    "source_tag": "north_corridor_0_1_0", "direction": "north", "target_tag": "nexus_junction_0_2_0",
    "details": {}
  },
  {
    "source_tag": "nexus_junction_0_2_0", "direction": "south", "target_tag": "north_corridor_0_1_0",
    "details": {}
  },
  {
    "source_tag": "nexus_junction_0_2_0", "direction": "east", "target_tag": "sanctuary_alcove_1_2_0",
    "details": {}
  },
  {
    "source_tag": "sanctuary_alcove_1_2_0", "direction": "west", "target_tag": "nexus_junction_0_2_0",
    "details": {}
  },
  {
    "source_tag": "sanctuary_alcove_1_2_0", "direction": "east", "target_tag": "shop_node_2_2_0",
    "details": {}
  },
  {
    "source_tag": "shop_node_2_2_0", "direction": "west", "target_tag": "sanctuary_alcove_1_2_0",
    "details": {}
  },
  {
    "source_tag": "shop_node_2_2_0", "direction": "east", "target_tag": "trainer_sim_3_2_0",
    "details": {}
  },
  {
    "source_tag": "trainer_sim_3_2_0", "direction": "west", "target_tag": "shop_node_2_2_0",
    "details": {}
  }
]
--- END OF FILE backend/app/seeds/exits_z0.json ---

--- START OF FILE backend/app/seeds/rooms_z0.json ---
[
  {
    "unique_tag": "central_hub_0_0_0",
    "data": {
      "name": "Central Processing Unit (CPU)",
      "description": "The air hums. Corridors branch off. A sturdy-looking door to the east is currently closed. A faint inscription reads 'Sector 0,0,0'.",
      "x": 0, "y": 0, "z": 0,
      "room_type": "standard",
      "interactables": [
        {
          "id_tag": "cpu_east_lever",
          "name": "a sturdy metal lever",
          "description": "A heavy metal lever is set into the wall, currently in the 'up' position.",
          "is_hidden": false,
          "reveal_dc_perception": null,
          "action_verb": "pull",
          "on_interact_effect": {
            "type": "toggle_exit_lock",
            "target_exit_direction": "east",
            "message_success_self": "You pull the lever down with a CLUNK. You hear a mechanism engage nearby.",
            "message_success_others": "{character_name} pulls the lever. A distant clunk is heard."
          }
        }
      ],
      "exits": {}
    }
  },
  {
    "unique_tag": "north_corridor_0_1_0",
    "data": {
      "name": "North Data Conduit Alpha",
      "description": "A sterile corridor stretches northwards. Panel N-1. The walls are smooth and featureless for the most part.",
      "x": 0, "y": 1, "z": 0,
      "room_type": "standard",
      "interactables": [
        {
          "id_tag": "loose_panel_north_wall",
          "name": "a slightly loose wall panel",
          "description": "Upon closer inspection, one of the wall panels seems slightly askew. You could probably pry it open.",
          "is_hidden": true,
          "reveal_dc_perception": 15, 
          "revealed_to_char_ids": [],
          "action_verb": "pry", 
          "on_interact_effect": {
            "type": "custom_event", 
            "message_success_self": "You pry the loose panel open. Tucked inside, you find a datachip labeled 'Emergency Exit Override Codes - Obsolete'. It crumbles to dust as you touch it.",
            "message_success_others": "{character_name} pries open a loose wall panel, finding something that quickly turns to dust."
          }
        }
      ],
      "exits": {}
    }
  },
  {
    "unique_tag": "east_storage_1_0_0",
    "data": {
      "name": "Secure Storage Vault Epsilon",
      "description": "Dust motes dance in the dim light. Shelves line the walls, mostly empty. Panel E-1.",
      "x": 1, "y": 0, "z": 0,
      "room_type": "standard",
      "interactables": [],
      "exits": {}
    }
  },
  {
    "unique_tag": "south_corridor_0_-1_0",
    "data": {
      "name": "South Maintenance Tunnel 7",
      "description": "Dimly lit and smelling faintly of burnt coffee. A heavy iron door blocks the way south. Panel S-1.",
      "x": 0, "y": -1, "z": 0,
      "room_type": "standard",
      "interactables": [],
      "exits": {}
    }
  },
  {
    "unique_tag": "deep_archive_0_-2_0",
    "data": {
      "name": "Deep Archive Sector 42",
      "description": "Ancient, whirring machinery fills this chamber. It feels important. Panel S-2.",
      "x": 0, "y": -2, "z": 0,
      "room_type": "puzzle",
      "interactables": [],
      "exits": {}
    }
  },
  {
    "unique_tag": "west_corridor_-1_0_0",
    "data": {
      "name": "West Logic Gate Array",
      "description": "To the west, a series of humming conduits. Panel W-1.",
      "x": -1, "y": 0, "z": 0,
      "room_type": "standard",
      "interactables": [],
      "exits": {}
    }
  },
  {
    "unique_tag": "nexus_junction_0_2_0",
    "data": {
      "name": "Nexus Junction N-2",
      "description": "A wider intersection of data conduits.",
      "x": 0, "y": 2, "z": 0,
      "room_type": "standard",
      "interactables": [],
      "exits": {}
    }
  },
  {
    "unique_tag": "sanctuary_alcove_1_2_0",
    "data": {
      "name": "Quiet Reflection Alcove",
      "description": "A surprisingly calm alcove. Soft light emanates from the walls. You feel a sense of peace here.",
      "x": 1, "y": 2, "z": 0,
      "room_type": "sanctuary",
      "interactables": [],
      "exits": {}
    }
  },
  {
    "unique_tag": "shop_node_2_2_0",
    "data": {
      "name": "Automated Goods Dispenser Node",
      "description": "A humming terminal offers various wares for digital currency. A holographic shopkeeper glitches occasionally.",
      "x": 2, "y": 2, "z": 0,
      "room_type": "shop",
      "interactables": [],
      "exits": {}
    }
  },
  {
    "unique_tag": "trainer_sim_3_2_0",
    "data": {
      "name": "Combat Simulation Pod",
      "description": "A sleek pod invites users to hone their skills. A sign reads: 'Skill Enhancement Services'.",
      "x": 3, "y": 2, "z": 0,
      "room_type": "trainer",
      "interactables": [],
      "exits": {}
    }
  }
]
--- END OF FILE backend/app/seeds/rooms_z0.json ---

--- START OF FILE backend/app/game_logic/combat/combat_round_processor.py ---
# backend/app/game_logic/combat/combat_round_processor.py
import uuid
import random
import logging
from typing import List, Optional, Tuple, Union, Dict, Any

from sqlalchemy.orm import Session, attributes

from app import crud, models, schemas
from app.commands.utils import roll_dice


# combat sub-package imports
from .combat_state_manager import (
    active_combats, mob_targets, character_queued_actions,
    end_combat_for_character
)
from .skill_resolver import resolve_skill_effect
from .combat_utils import (
    send_combat_log, broadcast_combat_event,
    perform_server_side_move, direction_map
)

logger = logging.getLogger(__name__)

async def process_combat_round(db: Session, character_id: uuid.UUID, player_id: uuid.UUID):
    # --- 1. Initial Character & Combat State Checks ---
    if character_id not in active_combats or not active_combats[character_id]:
        if character_id in active_combats:
            end_combat_for_character(character_id, reason="no_targets_in_active_combats_dict_proc_round")
        return

    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character: 
        logger.critical(f"PROC_ROUND: Character {character_id} not found. Cleaning combat states.")
        end_combat_for_character(character_id, reason="character_not_found_in_db_proc_round")
        return

    # Now 'character' is guaranteed to be a models.Character object.
    if character.current_health <= 0:
        # ... (dead character handling as before, 'character' is not None here) ...
        round_log_dead_char = ["You are dead and cannot act."]
        end_combat_for_character(character_id, reason="character_is_dead_proc_round")
        current_room_for_update = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
        current_room_schema_for_update = schemas.RoomInDB.from_orm(current_room_for_update) if current_room_for_update else None
        xp_for_next_lvl = crud.crud_character.get_xp_for_level(character.level + 1)
        vitals_for_payload = {
            "current_hp": character.current_health, "max_hp": character.max_health,
            "current_mp": character.current_mana, "max_mp": character.max_mana,
            "current_xp": character.experience_points,
            "next_level_xp": int(xp_for_next_lvl) if xp_for_next_lvl != float('inf') else -1,
            "level": character.level,
            "platinum": character.platinum_coins, "gold": character.gold_coins,
            "silver": character.silver_coins, "copper": character.copper_coins
        }
        await send_combat_log(player_id, round_log_dead_char, True, current_room_schema_for_update, character_vitals=vitals_for_payload)
        return

    # --- 2. Round Setup ---
    char_combat_stats = character.calculate_combat_stats()
    player_ac = char_combat_stats["effective_ac"]
    round_log: List[str] = [] 
    combat_resolved_this_round = False
    action_str = character_queued_actions.get(character_id)
    character_queued_actions[character_id] = None
    
    room_of_action_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    if not room_of_action_orm:
        logger.error(f"PROC_ROUND: Character {character.name} ({character.id}) in invalid room_id {character.current_room_id}. Ending combat.")
        end_combat_for_character(character_id, reason="character_in_invalid_room_proc_round")
        await send_combat_log(player_id, ["Error: Your location is unstable. Combat disengaged."], combat_ended=True)
        # Commit character state change if any (e.g. mana from previous turn) before returning
        db.add(character)
        db.commit()
        return
    current_room_id_for_action_broadcasts = room_of_action_orm.id

    # --- 3. Player's Action Processing ---
    if action_str:
        if action_str.startswith("flee"):
            # ... (flee logic as before, perform_server_side_move itself should handle None rooms) ...
            action_parts = action_str.split(" ", 1)
            flee_direction_canonical = action_parts[1] if len(action_parts) > 1 and action_parts[1] else "random"
            if random.random() < 0.6: 
                new_room_id, flee_departure_msg, flee_arrival_msg, _ = await perform_server_side_move(
                    db, character, flee_direction_canonical, player_id
                )
                if new_room_id:
                    round_log.append(f"<span class='combat-success'>{flee_departure_msg}</span>")
                    if flee_arrival_msg: round_log.append(flee_arrival_msg)
                    combat_resolved_this_round = True 
                else: 
                    round_log.append(f"<span class='combat-miss'>You try to flee {flee_direction_canonical if flee_direction_canonical != 'random' else ''}, but there's nowhere to go! ({flee_departure_msg})</span>") # Include flee_departure_msg if it's an error
            else: 
                round_log.append("<span class='combat-miss'>Your attempt to flee fails! You stumble.</span>")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='char-name'>{character.name}</span> tries to flee, but stumbles!")
        
        elif action_str.startswith("attack"):
            target_mob_id: Optional[uuid.UUID] = None
            try:
                target_mob_id_str = action_str.split(" ", 1)[1]
                target_mob_id = uuid.UUID(target_mob_id_str)
            except (IndexError, ValueError):
                round_log.append("Invalid attack target format in queue.")
            
            if target_mob_id and target_mob_id in active_combats.get(character_id, set()):
                mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_id)
                if mob_instance and mob_instance.mob_template: # CRUCIAL: Check mob_template exists
                    if mob_instance.current_health > 0: # Check health AFTER confirming mob_instance and template
                        mob_template = mob_instance.mob_template # Now safe to access
                        mob_ac = mob_template.base_defense if mob_template.base_defense is not None else 10
                        player_attack_bonus = char_combat_stats["attack_bonus"]
                        player_damage_dice = char_combat_stats["damage_dice"]
                        player_damage_bonus = char_combat_stats["damage_bonus"]
                        to_hit_roll = roll_dice("1d20")

                        updated_mob = None  # Ensure updated_mob is always defined

                        if (to_hit_roll + player_attack_bonus) >= mob_ac:
                            damage = max(1, roll_dice(player_damage_dice) + player_damage_bonus)
                            round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>HITS</span> <span class='inv-item-name'>{mob_template.name}</span> for <span class='combat-hit'>{damage}</span> damage.")
                            await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"<span class='char-name'>{character.name}</span> HITS <span class='inv-item-name'>{mob_template.name}</span> for {damage} damage!")
                            updated_mob = crud.crud_mob.update_mob_instance_health(db, mob_instance.id, -damage)
                        if updated_mob and updated_mob.current_health <= 0:
                            round_log.append(f"<span class='combat-death'>The {mob_template.name} DIES! Fucking finally.</span>")
                            await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"The <span class='inv-item-name'>{mob_template.name}</span> DIES!")
                            
                            # XP Award
                            if mob_template.xp_value > 0:
                                char_obj_after_xp, xp_msgs = crud.crud_character.add_experience(db, character.id, mob_template.xp_value)
                                if char_obj_after_xp : character = char_obj_after_xp 
                                round_log.extend(xp_msgs)

                            # >>> ADD CURRENCY DROP LOGIC HERE (copied from skill_resolver) <<<
                            platinum_dropped, gold_dropped, silver_dropped, copper_dropped = 0, 0, 0, 0
                            if mob_template.currency_drop: # mob_template is already confirmed to exist
                                cd = mob_template.currency_drop
                                copper_dropped = random.randint(cd.get("c_min", 0), cd.get("c_max", 0))
                                if random.randint(1, 100) <= cd.get("s_chance", 0):
                                    silver_dropped = random.randint(cd.get("s_min", 0), cd.get("s_max", 0))
                                if random.randint(1, 100) <= cd.get("g_chance", 0):
                                    gold_dropped = random.randint(cd.get("g_min", 0), cd.get("g_max", 0))
                                if random.randint(1, 100) <= cd.get("p_chance", 0):
                                    platinum_dropped = random.randint(cd.get("p_min", 0), cd.get("p_max", 0))
                            
                            if platinum_dropped > 0 or gold_dropped > 0 or silver_dropped > 0 or copper_dropped > 0:
                                char_obj_after_currency, currency_message = crud.crud_character.update_character_currency(
                                    db, character.id, platinum_dropped, gold_dropped, silver_dropped, copper_dropped
                                )
                                if char_obj_after_currency:
                                     character = char_obj_after_currency # Update local character
                                
                                drop_msg_parts_attack = []
                                if platinum_dropped > 0: drop_msg_parts_attack.append(f"{platinum_dropped}p")
                                if gold_dropped > 0: drop_msg_parts_attack.append(f"{gold_dropped}g")
                                if silver_dropped > 0: drop_msg_parts_attack.append(f"{silver_dropped}s")
                                if copper_dropped > 0: drop_msg_parts_attack.append(f"{copper_dropped}c")
                                
                                if drop_msg_parts_attack:
                                     round_log.append(f"The {mob_template.name} drops: {', '.join(drop_msg_parts_attack)}.")
                                     round_log.append(currency_message) # "You gained X. Current balance: Y"
                            # >>> END CURRENCY DROP LOGIC <<<
                            
                            # TODO: Item drops for basic attacks

                            crud.crud_mob.despawn_mob_from_room(db, updated_mob.id)
                            active_combats.get(character_id, set()).discard(updated_mob.id)
                            if updated_mob.id in mob_targets: mob_targets.pop(updated_mob.id, None)
                            elif updated_mob:
                                round_log.append(f"  {mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{mob_template.base_health}</span>.")
                        else: 
                            round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{mob_template.name}</span>.")
                            await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"<span class='char-name'>{character.name}</span> MISSES the <span class='inv-item-name'>{mob_template.name}</span>.")
                    else: # Mob is dead or has 0 HP
                        round_log.append(f"Your target, {mob_instance.mob_template.name if mob_instance.mob_template else 'the creature'}, is already defeated.")
                        if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
                elif mob_instance: # Mob instance exists but mob_template is None (data issue)
                    logger.error(f"PROC_ROUND: Mob instance {mob_instance.id} missing mob_template. Cannot process attack.")
                    round_log.append(f"Your target is an unrecognizable entity. Attack fails.")
                    if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
                else: # Mob instance not found in DB
                    round_log.append(f"Your target (ID: {target_mob_id}) seems to have vanished utterly.")
                    if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
            elif target_mob_id: # Target mob ID was valid UUID but not in this character's combat
                round_log.append("You try to attack, but your target isn't part of this fight.")
            else: # target_mob_id was None (parsing error from queue)
                 round_log.append("You flail at the air, unsure who to attack. What a loser.")
        
        elif action_str.startswith("use_skill"):
            parts = action_str.split(" ", 2) 
            skill_id_tag_from_queue = parts[1] if len(parts) > 1 else None
            target_identifier_from_queue = parts[2] if len(parts) > 2 else "NONE"
            
            target_entity_for_skill_resolution: Optional[Union[models.RoomMobInstance, str]] = None
            skill_template_to_use = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_id_tag_from_queue) if skill_id_tag_from_queue else None
            valid_target_context_for_skill = False

            if skill_template_to_use:
                if skill_template_to_use.target_type == "ENEMY_MOB":
                    if target_identifier_from_queue.lower() not in ["none", "self"]:
                        try:
                            target_mob_uuid = uuid.UUID(target_identifier_from_queue)
                            if target_mob_uuid in active_combats.get(character_id, set()):
                                mob_for_skill = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_uuid)
                                # CRITICAL: Check mob_for_skill AND mob_for_skill.mob_template
                                if mob_for_skill and mob_for_skill.mob_template and mob_for_skill.current_health > 0:
                                    target_entity_for_skill_resolution = mob_for_skill
                                    valid_target_context_for_skill = True
                                else: round_log.append(f"Skill target '{mob_for_skill.mob_template.name if mob_for_skill and mob_for_skill.mob_template else 'creature'}' is invalid or dead.")
                            else: round_log.append(f"You can't use '{skill_template_to_use.name}' on something you're not actively fighting ({target_identifier_from_queue}).")
                        except ValueError: round_log.append(f"Invalid target ID '{target_identifier_from_queue}' for skill.")
                    else: round_log.append(f"'{skill_template_to_use.name}' requires an enemy target.")
                
                elif skill_template_to_use.target_type == "DOOR":
                    if target_identifier_from_queue.lower() not in ["none", "self"]:
                        target_entity_for_skill_resolution = target_identifier_from_queue 
                        valid_target_context_for_skill = True
                    else: round_log.append(f"You need to specify a direction for '{skill_template_to_use.name}'.")

                elif skill_template_to_use.target_type in ["SELF", "NONE"]:
                    target_entity_for_skill_resolution = None 
                    valid_target_context_for_skill = True
                
                if valid_target_context_for_skill:
                    skill_messages, action_was_taken_by_skill, char_after_skill = await resolve_skill_effect(
                        db, character, skill_template_to_use, target_entity_for_skill_resolution, 
                        player_id, current_room_id_for_action_broadcasts
                    )
                    round_log.extend(skill_messages)
                    if char_after_skill: character = char_after_skill 
                    
                    if not action_was_taken_by_skill and not any("enough mana" in m.lower() for m in skill_messages) and \
                       not any("already unlocked" in m.lower() for m in skill_messages):
                        round_log.append(f"Your attempt to use {skill_template_to_use.name} fizzles.")
                elif not round_log: 
                    round_log.append(f"Could not determine a valid target or context for '{skill_template_to_use.name}'.")
            else:
                round_log.append(f"You try to use a skill '{skill_id_tag_from_queue}', but it's invalid or unknown.")
    else: 
        round_log.append("You pause, bewildered by the chaos.")

    # --- 4. Check if Player's Targets Are Defeated (Post-Player Action) ---
    current_targets_for_player = list(active_combats.get(character_id, set()))
    all_targets_down_after_player_action = True
    if not current_targets_for_player:
        all_targets_down_after_player_action = True
    else:
        for mob_target_id in current_targets_for_player:
            mob_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_target_id)
            if mob_check and mob_check.current_health > 0: # Ensure mob exists AND is alive
                all_targets_down_after_player_action = False; break
    
    if all_targets_down_after_player_action and not combat_resolved_this_round:
        round_log.append("All your targets are defeated or gone. Combat ends.")
        combat_resolved_this_round = True

    # --- 5. Mobs' Actions (Retaliation) ---
    if not combat_resolved_this_round and character.current_health > 0:
        mobs_attacking_character_this_round: List[models.RoomMobInstance] = []
        for mob_id, targeted_char_id in list(mob_targets.items()): # Iterate copy
            if targeted_char_id == character_id:
                mob_instance_to_act = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id)
                if mob_instance_to_act and mob_instance_to_act.mob_template and \
                   mob_instance_to_act.current_health > 0 and \
                   mob_instance_to_act.room_id == character.current_room_id:
                    mobs_attacking_character_this_round.append(mob_instance_to_act)
        
        for mob_instance in mobs_attacking_character_this_round:
            if character.current_health <= 0: break 
            mob_template = mob_instance.mob_template # Safe due to check above
            # ... (mob attack logic as before, character health is updated directly) ...
            mob_attack_bonus = mob_template.level or 1 
            mob_damage_dice = mob_template.base_attack or "1d4"
            mob_to_hit_roll = roll_dice("1d20")

            if (mob_to_hit_roll + mob_attack_bonus) >= player_ac:
                damage_to_player = max(1, roll_dice(mob_damage_dice))
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-success'>HITS</span> <span class='char-name'>{character.name}</span> for <span class='combat-hit-player'>{damage_to_player}</span> damage.")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> HITS <span class='char-name'>{character.name}</span> for {damage_to_player} damage!")
                character.current_health -= damage_to_player 
                round_log.append(f"  Your HP: <span class='combat-hp'>{character.current_health}/{character.max_health}</span>.")
                if character.current_health <= 0:
                    character.current_health = 0 
                    round_log.append("<span class='combat-death'>YOU HAVE DIED! How utterly predictable.</span>")
                    await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                  f"<span class='char-name'>{character.name}</span> <span class='combat-death'>HAS DIED!</span>")
                    combat_resolved_this_round = True 
                    max_health_at_death = character.max_health
                    respawn_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0)
                    if respawn_room_orm:
                        char_after_respawn = crud.crud_character.update_character_room(db, character_id=character.id, new_room_id=respawn_room_orm.id)
                        if char_after_respawn: 
                            character = char_after_respawn # Update local character
                            round_log.append(f"A mystical force whisks your fading spirit away. You awaken, gasping, in <span class='room-name'>{respawn_room_orm.name}</span>.")
                        else: round_log.append("Error: Failed to update character room during respawn."); break 
                    else: round_log.append("Error: Respawn room (0,0,0) not found."); break 
                    character.current_health = max_health_at_death 
                    round_log.append("You feel a surge of life, your wounds miraculously healed.")
                    break 
            else: 
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-miss'>MISSES</span> <span class='char-name'>{character.name}</span>.")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> MISSES <span class='char-name'>{character.name}</span>.")
    
    # --- 6. End of Round Cleanup & Next Action Queuing ---
    if combat_resolved_this_round:
        end_combat_for_character(character_id, reason="combat_resolved_this_round_proc_round")
    elif character.current_health > 0 and character_id in active_combats:
        if not action_str or action_str.startswith("attack") or (action_str.startswith("flee") and not combat_resolved_this_round):
            remaining_targets_for_next_round = list(active_combats.get(character_id, set()))
            first_valid_target_id_for_next_round = None
            if remaining_targets_for_next_round:
                for mob_id_check in remaining_targets_for_next_round:
                    mob_next_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id_check)
                    if mob_next_check and mob_next_check.current_health > 0:
                        first_valid_target_id_for_next_round = mob_id_check; break 
            if first_valid_target_id_for_next_round:
                character_queued_actions[character_id] = f"attack {first_valid_target_id_for_next_round}"
            else: 
                if not combat_resolved_this_round : 
                    round_log.append("No valid targets remain for next round. Combat ends.")
                end_combat_for_character(character_id, reason="no_valid_targets_remain_proc_round")
                combat_resolved_this_round = True 
    
    # --- 7. Final DB Commit & Send Log ---
    db.add(character) # Ensure character changes are staged
    # Room changes (e.g. from lockpicking) are staged by resolve_skill_effect
    db.commit()
    db.refresh(character) 
    
    # Send log with potentially updated room (if fled/died)
    final_room_for_payload_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    final_room_schema_for_payload = schemas.RoomInDB.from_orm(final_room_for_payload_orm) if final_room_for_payload_orm else None
    
    xp_for_next_level_final = crud.crud_character.get_xp_for_level(character.level + 1)
    final_vitals_payload = {
        "current_hp": character.current_health, "max_hp": character.max_health,
        "current_mp": character.current_mana, "max_mp": character.max_mana,
        "current_xp": character.experience_points,
        "next_level_xp": int(xp_for_next_level_final) if xp_for_next_level_final != float('inf') else -1,
        "level": character.level,
        "platinum": character.platinum_coins, "gold": character.gold_coins,
        "silver": character.silver_coins, "copper": character.copper_coins
    }
    
    await send_combat_log(
        player_id, round_log, combat_resolved_this_round, 
        final_room_schema_for_payload, character_vitals=final_vitals_payload
    )
--- END OF FILE backend/app/game_logic/combat/combat_round_processor.py ---

--- START OF FILE backend/app/game_logic/combat/skill_resolver.py ---
# backend/app/game_logic/combat/skill_resolver.py
import uuid
import random
import logging # Make sure logging is imported
from typing import List, Optional, Tuple, Union, Dict, Any # Ensure all are here

from sqlalchemy.orm import Session, attributes

from app import crud, models, schemas # For type hints and DB access
from app.commands.utils import roll_dice # If still used by skills directly
from .combat_utils import broadcast_combat_event, broadcast_to_room_participants # Use from local combat package
from app.schemas.common_structures import ExitDetail # For door lock skills

logger = logging.getLogger(__name__)


async def _handle_mob_death_loot_and_cleanup( # This is tightly coupled with skill effects that kill
    db: Session,
    character: models.Character, 
    killed_mob_instance: models.RoomMobInstance,
    log_messages_list: List[str], 
    player_id: uuid.UUID, 
    current_room_id_for_broadcast: uuid.UUID
) -> models.Character:
    # This function's logic from the old combat_manager.py (unchanged for now)
    mob_template = killed_mob_instance.mob_template 
    character_after_loot = character

    logger.debug(f"LOOT (SkillResolver): Handling death of {mob_template.name if mob_template else 'Unknown Mob'}")

    if mob_template and mob_template.xp_value > 0:
        logger.debug(f"LOOT (SkillResolver): Awarding {mob_template.xp_value} XP.")
        updated_char_for_xp, xp_messages = crud.crud_character.add_experience(
            db, character_after_loot.id, mob_template.xp_value
        )
        if updated_char_for_xp:
            character_after_loot = updated_char_for_xp 
        log_messages_list.extend(xp_messages)
    elif not mob_template:
        logger.warning(f"LOOT (SkillResolver): No mob_template for killed_mob_instance {killed_mob_instance.id}")

    platinum_dropped, gold_dropped, silver_dropped, copper_dropped = 0, 0, 0, 0
    if mob_template and mob_template.currency_drop:
        cd = mob_template.currency_drop
        copper_dropped = random.randint(cd.get("c_min", 0), cd.get("c_max", 0))
        if random.randint(1, 100) <= cd.get("s_chance", 0):
            silver_dropped = random.randint(cd.get("s_min", 0), cd.get("s_max", 0))
        if random.randint(1, 100) <= cd.get("g_chance", 0):
            gold_dropped = random.randint(cd.get("g_min", 0), cd.get("g_max", 0))
        if random.randint(1, 100) <= cd.get("p_chance", 0):
            platinum_dropped = random.randint(cd.get("p_min", 0), cd.get("p_max", 0))
    
    if platinum_dropped > 0 or gold_dropped > 0 or silver_dropped > 0 or copper_dropped > 0:
        updated_char_for_currency, currency_message = crud.crud_character.update_character_currency(
            db, character_after_loot.id, platinum_dropped, gold_dropped, silver_dropped, copper_dropped
        )
        if updated_char_for_currency:
             character_after_loot = updated_char_for_currency
        
        drop_messages_parts = []
        if platinum_dropped > 0: drop_messages_parts.append(f"{platinum_dropped}p")
        if gold_dropped > 0: drop_messages_parts.append(f"{gold_dropped}g")
        if silver_dropped > 0: drop_messages_parts.append(f"{silver_dropped}s")
        if copper_dropped > 0: drop_messages_parts.append(f"{copper_dropped}c")
        
        if drop_messages_parts:
             log_messages_list.append(f"The {mob_template.name} drops: {', '.join(drop_messages_parts)}.")
             log_messages_list.append(currency_message) 

    logger.debug(f"LOOT (SkillResolver): Despawning mob {killed_mob_instance.id}.")
    crud.crud_mob.despawn_mob_from_room(db, killed_mob_instance.id)
    
    # IMPORTANT: Removing the mob from global combat state (active_combats, mob_targets)
    # should now be handled by the combat_state_manager or the round processor after this.
    # This function should focus on loot/XP and despawn.
    # For now, let's assume the caller (process_combat_round) will clean active_combats and mob_targets
    # after seeing a mob is dead.
    
    return character_after_loot

async def resolve_skill_effect(
    db: Session,
    character: models.Character,
    skill_template: models.SkillTemplate,
    target_entity: Optional[Union[models.RoomMobInstance, models.Character, str]], 
    player_id: uuid.UUID, 
    current_room_id_for_broadcast: uuid.UUID
) -> Tuple[List[str], bool, Optional[models.Character]]:
    # This is the full function from the previous response.
    # Ensure all imports are correct at the top of this file.
    # All references to _broadcast_combat_event and _broadcast_to_room_participants
    # should now use the renamed versions from .combat_utils
    skill_log: List[str] = []
    action_taken = False 
    character_after_skill = character 
    char_combat_stats = character.calculate_combat_stats()

    mana_cost = skill_template.effects_data.get("mana_cost", 0)
    if character.current_mana < mana_cost and skill_template.skill_type != "PASSIVE": # Passive skills shouldn't have mana cost checked here
        skill_log.append(f"You don't have enough mana to use {skill_template.name} (needs {mana_cost}, have {character.current_mana}).")
        return skill_log, False, character_after_skill

    # Defer mana payment until after target validation for the specific skill type.

    if skill_template.skill_type == "COMBAT_ACTIVE" and skill_template.target_type == "ENEMY_MOB":
        target_mob_instance = target_entity if isinstance(target_entity, models.RoomMobInstance) else None
        
        if not target_mob_instance or target_mob_instance.current_health <= 0:
            skill_log.append(f"Your target for {skill_template.name} is invalid or already defeated.")
            return skill_log, False, character_after_skill

        if mana_cost > 0:
            character.current_mana -= mana_cost 
            db.add(character)
            skill_log.append(f"You spend {mana_cost} mana.")
        action_taken = True

        if skill_template.skill_id_tag == "basic_punch":
            mob_ac = target_mob_instance.mob_template.base_defense if target_mob_instance.mob_template.base_defense is not None else 10
            unarmed_attack_bonus = char_combat_stats["attack_bonus"]
            unarmed_damage_dice = "1d2" 
            unarmed_damage_bonus = char_combat_stats["damage_bonus"]
            to_hit_roll = roll_dice("1d20")
            if (to_hit_roll + unarmed_attack_bonus) >= mob_ac:
                damage = max(1, roll_dice(unarmed_damage_dice) + unarmed_damage_bonus)
                skill_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>PUNCHES</span> <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for <span class='combat-hit'>{damage}</span> damage.")
                await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='char-name'>{character.name}</span> PUNCHES <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for {damage} damage!")
                updated_mob = crud.crud_mob.update_mob_instance_health(db, target_mob_instance.id, -damage)
                if updated_mob and updated_mob.current_health <= 0:
                    skill_log.append(f"<span class='combat-death'>The {target_mob_instance.mob_template.name} DIES! Good punch, champ.</span>")
                    await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"The <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> DIES!")
                    character_after_skill = await _handle_mob_death_loot_and_cleanup(
                        db, character, updated_mob, skill_log, player_id, current_room_id_for_broadcast
                    )
                elif updated_mob:
                     skill_log.append(f"  {target_mob_instance.mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{target_mob_instance.mob_template.base_health}</span>.")
            else: 
                skill_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> with a punch.")
                await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='char-name'>{character.name}</span> MISSES the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> with a punch.")

        elif skill_template.skill_id_tag == "power_attack_melee":
            mob_ac = target_mob_instance.mob_template.base_defense if target_mob_instance.mob_template.base_defense is not None else 10
            skill_effects = skill_template.effects_data
            attack_roll_modifier = skill_effects.get("attack_roll_modifier", 0)
            damage_modifier_flat = skill_effects.get("damage_modifier_flat", 0)
            player_attack_bonus = char_combat_stats["attack_bonus"]
            player_damage_dice = char_combat_stats["damage_dice"]
            player_damage_bonus = char_combat_stats["damage_bonus"]
            final_attack_bonus = player_attack_bonus + attack_roll_modifier
            to_hit_roll = roll_dice("1d20")
            if (to_hit_roll + final_attack_bonus) >= mob_ac:
                base_weapon_damage = roll_dice(player_damage_dice)
                total_damage = max(1, base_weapon_damage + player_damage_bonus + damage_modifier_flat)
                skill_log.append(f"<span class='char-name'>{character.name}</span> unleashes a <span class='combat-success'>POWER ATTACK</span> on <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>, hitting for <span class='combat-hit'>{total_damage}</span> damage!")
                await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='char-name'>{character.name}</span> POWER ATTACKS <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> for {total_damage} damage!")
                updated_mob = crud.crud_mob.update_mob_instance_health(db, target_mob_instance.id, -total_damage)
                if updated_mob and updated_mob.current_health <= 0:
                    skill_log.append(f"<span class='combat-death'>The {target_mob_instance.mob_template.name} is OBLITERATED by the Power Attack!</span>")
                    await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                                  f"The <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> DIES from a mighty blow!")
                    character_after_skill = await _handle_mob_death_loot_and_cleanup(
                        db, character, updated_mob, skill_log, player_id, current_room_id_for_broadcast
                    )
                elif updated_mob:
                     skill_log.append(f"  {target_mob_instance.mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{target_mob_instance.mob_template.base_health}</span>.")
            else: 
                skill_log.append(f"<span class='char-name'>{character.name}</span>'s <span class='combat-miss'>Power Attack</span> against <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span> goes wide!")
                await broadcast_combat_event(db, current_room_id_for_broadcast, player_id,
                                              f"<span class='char-name'>{character.name}</span> misses a Power Attack on <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>.")
        else:
            skill_log.append(f"The combat skill '{skill_template.name}' is not fully implemented for mob targets yet.")
            action_taken = True # Mana was spent

    elif skill_template.skill_type == "UTILITY_OOC" and skill_template.target_type == "DOOR":
        if not isinstance(target_entity, str):
            skill_log.append("You must specify a direction for this skill (e.g., 'use pick_lock north').")
            return skill_log, False, character_after_skill
        
        target_direction = target_entity.lower() 
        current_room_orm = crud.crud_room.get_room_by_id(db, room_id=current_room_id_for_broadcast)
        if not current_room_orm:
            skill_log.append("Error: Cannot determine your current location to use this skill.")
            return skill_log, False, character_after_skill

        current_exits_dict = current_room_orm.exits or {}
        exit_data_dict = current_exits_dict.get(target_direction)

        if not exit_data_dict or not isinstance(exit_data_dict, dict):
            skill_log.append(f"There's no exit in that direction ({target_direction}) or it's malformed.")
            return skill_log, False, character_after_skill

        try:
            exit_detail = ExitDetail(**exit_data_dict)
        except Exception as e_parse:
            skill_log.append(f"The lock mechanism on the {target_direction} exit seems broken ({e_parse}).")
            logger.error(f"Pydantic parse error for ExitDetail in skill: {e_parse}, data: {exit_data_dict}")
            return skill_log, False, character_after_skill

        if not exit_detail.is_locked:
            skill_log.append(f"The way {target_direction} is already unlocked.")
            return skill_log, False, character_after_skill
        
        if not exit_detail.skill_to_pick or exit_detail.skill_to_pick.skill_id_tag != skill_template.skill_id_tag:
            skill_log.append(f"You can't use '{skill_template.name}' on the lock for the {target_direction} exit.")
            return skill_log, False, character_after_skill

        if mana_cost > 0:
            character.current_mana -= mana_cost
            db.add(character)
            skill_log.append(f"You spend {mana_cost} mana.")
        action_taken = True

        check_attribute = skill_template.effects_data.get("check_attribute", "dexterity")
        attribute_score = getattr(character, check_attribute, 10)
        modifier = (attribute_score - 10) // 2
        roll = random.randint(1, 20) + modifier 
        required_dc = exit_detail.skill_to_pick.dc

        if roll >= required_dc:
            exit_detail.is_locked = False
            updated_exits_for_orm = dict(current_room_orm.exits or {})
            updated_exits_for_orm[target_direction] = exit_detail.model_dump(mode='json')
            current_room_orm.exits = updated_exits_for_orm
            
            attributes.flag_modified(current_room_orm, "exits")
            db.add(current_room_orm) # Stage room change

            skill_log.append(f"<span class='success-message'>Success!</span> With a satisfying *click*, you pick the lock to the {target_direction} (Roll: {roll} vs DC: {required_dc}).")
            await broadcast_to_room_participants(
                db, current_room_id_for_broadcast,
                f"<span class='char-name'>{character.name}</span> skillfully picks the lock to the {target_direction}ern passage.",
                exclude_player_id=player_id
            )
        else:
            skill_log.append(f"<span class='failure-message'>Failure!</span> You failed to pick the lock to the {target_direction} (Roll: {roll} vs DC: {required_dc}). Your lockpicks make a frustrated scraping sound.")
    
    elif skill_template.skill_type == "UTILITY_OOC" and skill_template.target_type == "SELF":
        if mana_cost > 0:
            character.current_mana -= mana_cost
            db.add(character)
            skill_log.append(f"You spend {mana_cost} mana.")
        action_taken = True
        skill_log.append(f"You use {skill_template.name} on yourself. (Effect not yet implemented, you magnificent specimen!)")

    else:
        skill_log.append(f"The skill '{skill_template.name}' (Type: {skill_template.skill_type}, Target: {skill_template.target_type}) is not fully implemented or used incorrectly. Typical.")
        action_taken = False

    # Cooldowns are not implemented yet
    return skill_log, action_taken, character_after_skill
--- END OF FILE backend/app/game_logic/combat/skill_resolver.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    owner: Mapped["Player"] = relationship(back_populates="characters")

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)

    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py

import uuid
from typing import Optional, Dict, List, TYPE_CHECKING, Any 
from enum import Enum as PyEnum # To avoid conflict with potential future 'Enum' table

from sqlalchemy import Column, Integer, String, Text, Enum as SQLEnum # Enum for DB
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance 
    from .room_mob_instance import RoomMobInstance

# NEW RoomType Enum
class RoomTypeEnum(PyEnum):
    STANDARD = "standard"
    SANCTUARY = "sanctuary" # No combat, perhaps faster regen
    SHOP = "shop"
    TRAINER = "trainer"
    DUNGEON_ENTRANCE = "dungeon_entrance"
    PUZZLE = "puzzle"
    # Add more as needed

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    
    room_type: Mapped[RoomTypeEnum] = mapped_column( # <<< NEW FIELD
        SQLEnum(RoomTypeEnum, name="roomtypeenum", create_type=True), # create_type=True for SQLAlchemy to manage Enum in DB
        default=RoomTypeEnum.STANDARD, 
        nullable=False,
        index=True
    )

    exits: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB, 
        nullable=True, 
        default=lambda: {}
    )
    interactables: Mapped[Optional[List[Dict[str, Any]]]] = mapped_column(
        JSONB, 
        nullable=True, 
        default=lambda: []
    )
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin"
    )
    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin" 
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', type='{self.room_type.value}', x={self.x}, y={self.y}, z={self.z})>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/crud/crud_room.py ---
# backend/app/crud/crud_room.py
import json
import os 
import uuid
from typing import Optional, Dict, List, Any 
from sqlalchemy.orm import Session, attributes 

from .. import models, schemas, crud # crud for item seeding
from ..schemas.common_structures import ExitDetail, ExitSkillToPickDetail # Ensure sub-models are available if needed directly

# Path to the seeds directory
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

_SEED_ROOM_UUIDS_CACHE: Dict[str, uuid.UUID] = {} # Cache for UUIDs based on unique_tag

def _load_seed_data(filename: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"ERROR: Seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        print(f"ERROR: Could not decode JSON from {filepath}: {e}")
        return []

def get_room_by_id(db: Session, room_id: uuid.UUID) -> Optional[models.Room]:
    return db.query(models.Room).filter(models.Room.id == room_id).first()

def get_rooms_by_z_level(db: Session, *, z_level: int) -> List[models.Room]:
    return db.query(models.Room).filter(models.Room.z == z_level).all()

def get_room_by_coords(db: Session, *, x: int, y: int, z: int) -> Optional[models.Room]:
    return db.query(models.Room).filter(
        models.Room.x == x,
        models.Room.y == y,
        models.Room.z == z
    ).first()

def create_room(db: Session, *, room_in: schemas.RoomCreate) -> models.Room:
    db_room_data = room_in.model_dump(exclude_unset=True)
    if 'exits' not in db_room_data: db_room_data['exits'] = {}
    if 'interactables' not in db_room_data: db_room_data['interactables'] = []
    
    # Ensure room_type is correctly passed as Enum member if it's a string from JSON
    if 'room_type' in db_room_data and isinstance(db_room_data['room_type'], str):
        try:
            db_room_data['room_type'] = models.RoomTypeEnum(db_room_data['room_type'])
        except ValueError:
            print(f"Warning: Invalid room_type '{db_room_data['room_type']}' in create_room. Defaulting to STANDARD.")
            db_room_data['room_type'] = models.RoomTypeEnum.STANDARD
            
    db_room = models.Room(**db_room_data)
    db.add(db_room)
    return db_room

def update_room(db: Session, *, db_room: models.Room, room_in: schemas.RoomUpdate) -> models.Room:
    update_data = room_in.model_dump(exclude_unset=True)
    changed = False
    for field, value in update_data.items():
        # Handle room_type enum conversion for updates
        if field == 'room_type' and isinstance(value, str):
            try:
                value = models.RoomTypeEnum(value)
            except ValueError:
                print(f"Warning: Invalid room_type '{value}' in update_room. Skipping update for this field.")
                continue # Skip updating room_type if invalid

        if getattr(db_room, field) != value:
            setattr(db_room, field, value)
            if field in ["exits", "interactables"]: 
                attributes.flag_modified(db_room, field)
            changed = True
    if changed:
        db.add(db_room)
    return db_room

def seed_initial_world(db: Session):
    print("Attempting to seed initial world from JSON files...")
    _SEED_ROOM_UUIDS_CACHE.clear()

    room_definitions_from_file = _load_seed_data("rooms_z0.json")
    if not room_definitions_from_file:
        print("No room definitions found or error loading. Aborting room seeding.")
        return

    print(f"Loaded {len(room_definitions_from_file)} room definitions from file.")
    for room_entry in room_definitions_from_file:
        unique_tag = room_entry.get("unique_tag")
        room_data_dict = room_entry.get("data")

        if not unique_tag or not room_data_dict:
            print(f"Skipping malformed room entry (no tag/data): {room_entry}")
            continue
        
        try:
            room_create_schema = schemas.RoomCreate(**room_data_dict)
        except Exception as e_pydantic_room:
            print(f"ERROR: Pydantic validation failed for room '{unique_tag}' data: {room_data_dict}. Error: {e_pydantic_room}")
            continue
            
        existing_room = get_room_by_coords(db, x=room_create_schema.x, y=room_create_schema.y, z=room_create_schema.z)
        
        if not existing_room:
            print(f"Creating room '{room_create_schema.name}' (tag: {unique_tag})...")
            created_room_orm = create_room(db, room_in=room_create_schema)
            db.commit() 
            db.refresh(created_room_orm)
            _SEED_ROOM_UUIDS_CACHE[unique_tag] = created_room_orm.id
        else:
            print(f"Room '{existing_room.name}' (tag: {unique_tag}) already exists. Updating...")
            update_payload_data = room_create_schema.model_dump(exclude_defaults=False, exclude_unset=False) # Get all fields for update
            
            # Ensure interactables and exits are present in the update_payload_data if they are in room_create_schema
            # This is to make sure they get updated correctly even if they are empty lists/dicts.
            if 'interactables' not in update_payload_data and hasattr(room_create_schema, 'interactables'):
                update_payload_data['interactables'] = room_create_schema.interactables
            if 'exits' not in update_payload_data and hasattr(room_create_schema, 'exits'):
                update_payload_data['exits'] = room_create_schema.exits

            room_update_schema = schemas.RoomUpdate(**update_payload_data)
            update_room(db, db_room=existing_room, room_in=room_update_schema)
            db.commit() 
            db.refresh(existing_room)
            _SEED_ROOM_UUIDS_CACHE[unique_tag] = existing_room.id
    
    exits_data_from_file = _load_seed_data("exits_z0.json")
    if not exits_data_from_file:
        print("No exits data found or error loading. Skipping exit linking.")
    else:
        print(f"Loaded {len(exits_data_from_file)} exit definitions from file.")
        for exit_def in exits_data_from_file:
            source_tag = exit_def.get("source_tag")
            direction_str = exit_def.get("direction")
            target_tag = exit_def.get("target_tag")
            exit_details_override_dict = exit_def.get("details", {})

            if not source_tag or not direction_str or not target_tag:
                print(f"Skipping malformed exit entry (missing tag/direction/target): {exit_def}")
                continue

            if source_tag in _SEED_ROOM_UUIDS_CACHE and target_tag in _SEED_ROOM_UUIDS_CACHE:
                source_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS_CACHE[source_tag])
                if source_room_orm:
                    if source_room_orm.exits is None: 
                        source_room_orm.exits = {}
                    
                    target_uuid = _SEED_ROOM_UUIDS_CACHE[target_tag]
                    
                    # EXPLICITLY build the data for ExitDetail, respecting Pydantic defaults
                    data_for_exit_detail_model = {
                        "target_room_id": target_uuid,
                        "is_locked": exit_details_override_dict.get("is_locked", schemas.ExitDetail.model_fields["is_locked"].default),
                        "lock_id_tag": exit_details_override_dict.get("lock_id_tag", schemas.ExitDetail.model_fields["lock_id_tag"].default),
                        "key_item_tag_opens": exit_details_override_dict.get("key_item_tag_opens", schemas.ExitDetail.model_fields["key_item_tag_opens"].default),
                        # For skill_to_pick, if it's in overrides, Pydantic will parse the dict. If not, it defaults to None.
                        "skill_to_pick": exit_details_override_dict.get("skill_to_pick", schemas.ExitDetail.model_fields["skill_to_pick"].default),
                        "description_when_locked": exit_details_override_dict.get("description_when_locked", schemas.ExitDetail.model_fields["description_when_locked"].default),
                        "force_open_dc": exit_details_override_dict.get("force_open_dc", schemas.ExitDetail.model_fields["force_open_dc"].default)
                    }
                    # If skill_to_pick is a dict, ensure it's correctly formed for ExitSkillToPickDetail
                    if isinstance(data_for_exit_detail_model["skill_to_pick"], dict):
                        try:
                            # Validate/parse the skill_to_pick sub-dict
                            data_for_exit_detail_model["skill_to_pick"] = ExitSkillToPickDetail(**data_for_exit_detail_model["skill_to_pick"])
                        except Exception as e_skill_pick:
                             print(f"  ERROR: Pydantic validation for skill_to_pick in exit {source_tag}->{direction_str} failed: {e_skill_pick}. Data: {data_for_exit_detail_model['skill_to_pick']}")
                             data_for_exit_detail_model["skill_to_pick"] = None # Set to None if parsing fails

                    try:
                        exit_detail_pydantic = schemas.ExitDetail(**data_for_exit_detail_model)
                        
                        current_exits = dict(source_room_orm.exits) 
                        current_exits[direction_str] = exit_detail_pydantic.model_dump(mode='json')
                        source_room_orm.exits = current_exits 
                        
                        attributes.flag_modified(source_room_orm, "exits") 
                        db.add(source_room_orm)
                    except Exception as e_pydantic_exit:
                        print(f"  ERROR: Pydantic validation for exit {source_tag}->{direction_str} failed: {e_pydantic_exit}. Input data to Pydantic: {data_for_exit_detail_model}")
                else:
                    print(f"  Warning: Source room ORM object for tag '{source_tag}' not found in DB.")
            else:
                print(f"  Warning: Could not link exit {source_tag} -> {target_tag}. One or both tags not found in UUID cache: {list(_SEED_ROOM_UUIDS_CACHE.keys())}")
        
        db.commit() 

    print("World seeding from JSON files complete.")

    key_item_source_tag = "east_storage_1_0_0"
    if key_item_source_tag in _SEED_ROOM_UUIDS_CACHE:
        key_item_name = "Archive Key Alpha"
        # This assumes crud.crud_item is available and its create_item, get_item_by_name are defined
        # and crud.crud_room_item.add_item_to_room is defined.
        existing_key_template = crud.crud_item.get_item_by_name(db, name=key_item_name)
        if not existing_key_template:
            key_data = {
                "name": key_item_name, 
                "description": "A small, intricately carved metal key. Sector 42.",
                "item_type": "key", "slot": None,
                "properties": {"item_tag": "archive_key_alpha"}, 
                "weight": 0.1, "value": 0, "stackable": False
            }
            key_template = crud.crud_item.create_item(db, item_in=schemas.ItemCreate(**key_data))
            db.commit() 
            print(f"Seeded key item: {key_template.name}")
            
            room_to_place_key_id = _SEED_ROOM_UUIDS_CACHE[key_item_source_tag]
            crud.crud_room_item.add_item_to_room(db, room_id=room_to_place_key_id, item_id=key_template.id, quantity=1)
            print(f"Placed '{key_template.name}' in room '{key_item_source_tag}'.")
            db.commit()
        else:
            print(f"Key item '{key_item_name}' already exists.")
    else:
        print(f"Warning: Room with tag '{key_item_source_tag}' for key placement not found in cache.")
--- END OF FILE backend/app/crud/crud_room.py ---

--- START OF FILE frontend/src/main.js ---
// frontend/src/main.js
import { UI } from './ui.js';
import { API } from './api.js';
import { WebSocketService } from './websocket.js';
import { MapDisplay } from './map.js';
import { gameState, saveSession, loadSession, clearSession, updateGameState } from './state.js';

// This function handles messages received over WebSocket
// It's defined here because it orchestrates calls to UI, MapDisplay, and updates gameState.
export function handleWebSocketMessage(serverData) {
    let charVitals = null; // To hold character vitals if present in the message

    // Consolidate extraction of character_vitals
    if (serverData.type === "welcome_package" && serverData.character_vitals) {
        charVitals = serverData.character_vitals;
    } else if (serverData.type === "combat_update" && serverData.character_vitals) {
        charVitals = serverData.character_vitals;
    } else if (serverData.type === "vitals_update") { // vitals_update sends them at root level of serverData
        charVitals = serverData; // The whole serverData object is the vitals payload here
    }

    // If we have character vitals from any source, update relevant UI components
    if (charVitals) {
        if (typeof UI.updatePlayerVitals === 'function') {
            UI.updatePlayerVitals(
                charVitals.current_hp, charVitals.max_hp,
                charVitals.current_mp, charVitals.max_mp,
                charVitals.current_xp, charVitals.next_level_xp
            );
        }
        if (typeof UI.updateCharacterInfoBar === 'function') {
            // Use gameState for name/class as they are more stable during session
            // Level comes from charVitals as it can change
            UI.updateCharacterInfoBar(
                gameState.selectedCharacterName,
                gameState.selectedCharacterClass,
                charVitals.level // Assumes 'level' is present in charVitals
            );
        }
        if (typeof UI.updateCurrencyDisplay === 'function' && charVitals &&
            (typeof charVitals.platinum !== 'undefined' ||
                typeof charVitals.gold !== 'undefined' ||
                typeof charVitals.silver !== 'undefined' ||
                typeof charVitals.copper !== 'undefined')
        ) {
            UI.updateCurrencyDisplay(
                charVitals.platinum,
                charVitals.gold,
                charVitals.silver,
                charVitals.copper
            );
        }
    }

    // Handle specific message types for logs, room data, and other events
    switch (serverData.type) {
        case "welcome_package":
            if (serverData.log && serverData.log.length > 0) {
                UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            }
            if (serverData.room_data) {
                UI.updateGameDisplay(serverData.room_data);
                UI.updateExitsDisplay(serverData.room_data);
                updateGameState({ displayedRoomId: serverData.room_data.id });
                MapDisplay.fetchAndDrawMap(); // Initial map draw
            }
            // Vitals already handled by the common charVitals block above
            break;

        case "combat_update":
            if (serverData.room_data) {
                const movedRoom = gameState.displayedRoomId !== serverData.room_data.id;
                UI.updateGameDisplay(serverData.room_data);
                UI.updateExitsDisplay(serverData.room_data);
                updateGameState({ displayedRoomId: serverData.room_data.id });
                if (movedRoom) MapDisplay.redrawMapForCurrentRoom(serverData.room_data.id);
            }
            if (serverData.log && serverData.log.length > 0) {
                UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            }
            updateGameState({ isInCombat: !serverData.combat_over });
            // Vitals already handled by the common charVitals block above
            break;

        case "vitals_update":
            // Vitals (HP, MP, XP, Currency, Level) already handled by the common charVitals block above.
            // No further specific action needed here unless there are logs associated with only vitals_update.
            break;

        case "ooc_message":
            UI.appendToOutput(serverData.message, { styleClass: "ooc-chat-message" });
            break;

        case "game_event":
            if (serverData.message) UI.appendToOutput(serverData.message, { styleClass: "game-message" });
            break;

        default:
            // Fallback for messages that have a 'message' field but unknown type
            if (serverData.message) {
                UI.appendToOutput(`GS (${serverData.type}): ${serverData.message}`, { styleClass: "game-message" });
            } else { // Fallback for completely unrecognized structures
                UI.appendToOutput(`GS (unparsed type: ${serverData.type}): ${JSON.stringify(serverData)}`, { styleClass: "game-message" });
            }
            break;
    }
}

// --- Game Flow and State Management Functions ---

async function startLoginProcess() {
    clearSession(); // Resets gameState and clears localStorage
    updateGameState({ loginState: 'PROMPT_USER' });
    WebSocketService.close();
    MapDisplay.clearMap();
    UI.showAppropriateView(); // Hides game UI elements
    UI.clearOutput();
    UI.appendToOutput("Welcome to The Unholy MUD of Tron & Allen1.");
    UI.appendToOutput("Version: Refactored & Ready to Rumble!"); // New version string
    UI.appendToOutput("-------------------------------------------------");
    UI.appendToOutput("Username (or type 'new' to register): ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Enter username or 'new'");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function promptForPassword() {
    updateGameState({ loginState: 'PROMPT_PASSWORD' });
    UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true });
    UI.setInputCommandPlaceholder("Enter password");
    UI.setInputCommandType('password');
    UI.focusCommandInput();
}

async function promptForRegistrationUsername() {
    updateGameState({ loginState: 'REGISTER_PROMPT_USER' });
    UI.appendToOutput("Registering new user.");
    UI.appendToOutput("Desired username: ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Enter desired username");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function promptForRegistrationPassword() {
    updateGameState({ loginState: 'REGISTER_PROMPT_PASSWORD' });
    UI.appendToOutput("Desired password (min 8 chars): ", { isPrompt: true, noNewLineBefore: true });
    UI.setInputCommandPlaceholder("Enter desired password");
    UI.setInputCommandType('password');
    UI.focusCommandInput();
}

async function displayCharacterSelection() {
    updateGameState({ loginState: 'CHAR_SELECT_PROMPT' });
    UI.showAppropriateView();
    if (!gameState.currentAuthToken) {
        UI.appendToOutput("! Authentication token missing. Please log in.", { styleClass: 'error-message-inline' });
        handleLogout(); // Should take back to login start
        return;
    }
    UI.appendToOutput("\nFetching character list...");
    try {
        const characters = await API.fetchCharacters();
        updateGameState({ availableCharacters: characters });
        UI.appendToOutput("\n--- Character Selection ---");
        if (characters.length === 0) {
            UI.appendToOutput("No characters found for your account.");
        } else {
            UI.appendToOutput("Your characters:");
            characters.forEach((char, index) => {
                UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${char.name}</span> (<span class="char-class">${char.class_name}</span> - Lvl ${char.level})</span>`);
            });
        }
        UI.appendToOutput("Enter character # to play, or type 'new' to create one: ", { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter # or 'new'");
    } catch (error) {
        UI.appendToOutput(`! Error fetching characters: ${error.message}`, { styleClass: 'error-message-inline' });
        if (error.response && error.response.status === 401) { // Unauthorized
            UI.appendToOutput("! Your session may have expired. Please log in again.", { styleClass: 'error-message-inline' });
            handleLogout();
        } else {
            startLoginProcess(); // Fallback for other errors
        }
    }
    UI.focusCommandInput();
}

async function promptForNewCharacterName() {
    updateGameState({ loginState: 'CHAR_CREATE_PROMPT_NAME', tempCharName: '' });
    UI.appendToOutput("\n--- New Character Creation ---");
    UI.appendToOutput("Enter character name: ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Character Name (3-50 chars)");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function displayClassSelection() {
    updateGameState({ loginState: 'CHAR_CREATE_PROMPT_CLASS' });
    UI.appendToOutput(`\nFetching available classes for ${gameState.tempCharName}...`);
    try {
        const classes = await API.fetchAvailableClasses();
        updateGameState({ availableClasses: classes });
        if (classes.length === 0) {
            UI.appendToOutput("! No character classes available. Defaulting to 'Adventurer'.", { styleClass: 'error-message-inline' });
            updateGameState({ tempCharClassName: 'Adventurer' });
            await createCharacterWithSelectedClass();
            return;
        }
        UI.appendToOutput("Available Classes:");
        classes.forEach((charClass, index) => {
            UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${charClass.name}</span> - <span class="char-class-desc">${charClass.description || 'A mysterious path.'}</span></span>`);
        });
        UI.appendToOutput(`Select class for '${gameState.tempCharName}' by number: `, { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter class #");
    } catch (error) {
        UI.appendToOutput(`! Error fetching classes: ${error.message}. Defaulting to 'Adventurer'.`, { styleClass: 'error-message-inline' });
        updateGameState({ tempCharClassName: 'Adventurer' });
        await createCharacterWithSelectedClass();
    }
    UI.focusCommandInput();
}

async function createCharacterWithSelectedClass() {
    const charName = gameState.tempCharName;
    const charClassName = gameState.tempCharClassName || "Adventurer";
    UI.appendToOutput(`\nCreating ${charName} the ${charClassName}...`);
    try {
        await API.createCharacter(charName, charClassName);
        UI.appendToOutput("Character created successfully!");
        await displayCharacterSelection(); // Refresh character list
    } catch (error) {
        UI.appendToOutput(`! Error creating character: ${error.data?.detail || error.message}`, { styleClass: 'error-message-inline' });
        await displayCharacterSelection(); // Go back to char select on error
    }
}

async function selectCharacterAndStartGame(character) {
    UI.appendToOutput(`\nSelecting character: ${character.name}...`);
    try {
        const initialRoomData = await API.selectCharacterOnBackend(character.id);
        saveSession(
            gameState.currentAuthToken,
            character.id,
            character.name,
            character.class_name || 'Adventurer' // Save class name from the selected character object
        );
        // Pass the full character object from selection which includes level for initial info bar
        await enterGameModeWithCharacter(character, initialRoomData);
    } catch (error) {
        UI.appendToOutput(`! Error selecting character: ${error.message}`, { styleClass: 'error-message-inline' });
        await displayCharacterSelection();
    }
}

async function enterGameModeWithCharacter(character, initialRoomDataFromHttpSelect) {
    updateGameState({
        selectedCharacterId: character.id,
        selectedCharacterName: character.name,
        selectedCharacterClass: character.class_name || 'Adventurer',
        loginState: 'IN_GAME'
    });

    // Update Character Info Bar with potentially more complete data from 'character' object
    UI.updateCharacterInfoBar(character.name, character.class_name, character.level); // character.level from fetchCharacters
    UI.updateCurrencyDisplay(character.platinum_coins || 0, character.gold_coins || 0, character.silver_coins || 0, character.copper_coins || 0); // From fetchCharacters

    UI.showAppropriateView();
    UI.clearOutput();
    UI.appendToOutput(`Playing as: <span class="char-name">${character.name}</span>, the <span class="char-class">${character.class_name || 'Adventurer'}</span> (Lvl ${character.level || 1})`);
    UI.setInputCommandPlaceholder("Type command...");
    UI.setInputCommandType('text');

    if (initialRoomDataFromHttpSelect) {
        UI.updateGameDisplay(initialRoomDataFromHttpSelect);
        UI.updateExitsDisplay(initialRoomDataFromHttpSelect);
        updateGameState({ displayedRoomId: initialRoomDataFromHttpSelect.id });
        MapDisplay.fetchAndDrawMap();
    }
    WebSocketService.connect(); // This will trigger "welcome_package" which also updates vitals/UI
    UI.focusCommandInput();
}

function handleLogout() {
    WebSocketService.close();
    MapDisplay.clearMap();
    clearSession(); // Resets gameState and clears localStorage
    console.log("Logged out.");
    startLoginProcess();
}

async function handleHttpCommandResponse(responseData, originalCommand) {
    if (responseData.message_to_player) {
        UI.appendToOutput(responseData.message_to_player, { styleClass: 'game-message' });
    }
    if (responseData.room_data) {
        const cmdClean = originalCommand.toLowerCase().trim();
        const isLook = cmdClean.startsWith("look") || cmdClean === "l"; // 'look' via HTTP should still update
        const movedRoom = gameState.displayedRoomId !== responseData.room_data.id;

        if (isLook || movedRoom) {
            UI.updateGameDisplay(responseData.room_data);
        }
        UI.updateExitsDisplay(responseData.room_data);
        updateGameState({ displayedRoomId: responseData.room_data.id });
        if (movedRoom) MapDisplay.redrawMapForCurrentRoom(responseData.room_data.id);
    }
    // No combat_over or vitals expected from HTTP commands anymore
}

async function handleInputSubmission() {
    const commandInputEl = UI.getCommandInput();
    if (!commandInputEl) return;
    const inputText = commandInputEl.value.trim();
    let echoText = inputText;
    let echoOptions = { isPrompt: false };

    if (gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
        echoText = '*'.repeat(inputText.length || 8);
        echoOptions.noNewLineBefore = true;
    } else if (gameState.loginState === 'IN_GAME' && inputText) {
        echoText = `> ${inputText}`;
    } else if (inputText) {
        echoOptions.noNewLineBefore = true;
    }

    if (inputText || gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
        UI.appendToOutput(echoText, echoOptions);
    }
    commandInputEl.value = '';

    try {
        switch (gameState.loginState) {
            case 'PROMPT_USER':
                if (inputText.toLowerCase() === 'new') await promptForRegistrationUsername();
                else if (inputText) { updateGameState({ tempUsername: inputText }); await promptForPassword(); }
                else UI.appendToOutput("Username (or 'new'): ", { isPrompt: true, noNewLineBefore: true });
                break;
            case 'PROMPT_PASSWORD':
                UI.appendToOutput("\nAttempting login...");
                const loginData = await API.loginUser(gameState.tempUsername, inputText);
                saveSession(loginData.access_token, null, null, null); // Token only for now
                UI.appendToOutput("Login successful!");
                UI.setInputCommandType('text');
                await displayCharacterSelection();
                break;
            case 'REGISTER_PROMPT_USER':
                if (inputText) { updateGameState({ tempUsername: inputText }); await promptForRegistrationPassword(); }
                else UI.appendToOutput("Desired username: ", { isPrompt: true, noNewLineBefore: true });
                break;
            case 'REGISTER_PROMPT_PASSWORD':
                updateGameState({ tempPassword: inputText });
                UI.appendToOutput("\nAttempting registration...");
                await API.registerUser(gameState.tempUsername, gameState.tempPassword);
                UI.appendToOutput("Registration successful!");
                UI.appendToOutput(`Now, please log in as '${gameState.tempUsername}'.`);
                updateGameState({ loginState: 'PROMPT_PASSWORD' });
                UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true });
                UI.setInputCommandPlaceholder("Enter password");
                UI.setInputCommandType('password');
                break;
            case 'CHAR_SELECT_PROMPT':
                if (inputText.toLowerCase() === 'new') await promptForNewCharacterName();
                else {
                    const charIndex = parseInt(inputText, 10) - 1;
                    if (gameState.availableCharacters && charIndex >= 0 && charIndex < gameState.availableCharacters.length) {
                        await selectCharacterAndStartGame(gameState.availableCharacters[charIndex]);
                    } else {
                        UI.appendToOutput("! Invalid selection.", { styleClass: 'error-message-inline' });
                        UI.appendToOutput("Enter character #, or 'new': ", { isPrompt: true, noNewLineBefore: true });
                    }
                }
                break;
            case 'CHAR_CREATE_PROMPT_NAME':
                if (!inputText || inputText.length < 3 || inputText.length > 50) {
                    UI.appendToOutput("! Invalid name (3-50 chars). Name: ", { isPrompt: true, styleClass: 'error-message-inline', noNewLineBefore: true });
                    break;
                }
                updateGameState({ tempCharName: inputText });
                await displayClassSelection();
                break;
            case 'CHAR_CREATE_PROMPT_CLASS':
                const classIndex = parseInt(inputText, 10) - 1;
                if (gameState.availableClasses && classIndex >= 0 && classIndex < gameState.availableClasses.length) {
                    const selectedClass = gameState.availableClasses[classIndex];
                    updateGameState({ tempCharClassName: selectedClass.name });
                    await createCharacterWithSelectedClass();
                } else {
                    UI.appendToOutput("! Invalid class selection. Please enter a valid number.", { styleClass: 'error-message-inline' });
                    UI.appendToOutput(`Select class for ${gameState.tempCharName} by number: `, { isPrompt: true, noNewLineBefore: true });
                }
                break;
            case 'IN_GAME':
                if (!inputText) break;
                const lowerInputText = inputText.toLowerCase();
                const commandVerb = lowerInputText.split(" ")[0];

                if (commandVerb === "logout") { handleLogout(); break; }

                const webSocketHandledVerbs = [
                    "attack", "atk", "kill", "k",
                    "flee",
                    "look", "l",
                    "rest",
                    "use", "skill", "cast",
                    "get", "take", 
                    "unlock",       
                    "search", "examine",                     
                    "pull", "push", "turn", "pry", "activate",
                    "n", "s", "e", "w", "north", "south", "east", "west", "up", "down", "u", "d", "go"
                ];
                if (webSocketHandledVerbs.includes(commandVerb)) {
                    WebSocketService.sendMessage({ type: "command", command_text: inputText });
                } else {
                    // These commands might still go via HTTP if you have specific endpoints/handlers
                    // For example, complex UI-driven things or pure info displays.
                    // If 'help', 'score', 'inventory' etc. are implemented as HTTP endpoints:
                    const httpOkayVerbs = [
                        "spawnmob", "mod_xp", "set_hp",
                        "help", 
                        "ooc", "say", 
                        "score", 
                        "inventory", "i", 
                        "skills", "traits", "status", "st", "sc", "sk", "tr", 
                        "?", 
                        "equip", "unequip", "wear", "remove", "eq"];
                    if (httpOkayVerbs.includes(commandVerb)) {
                        const httpResponse = await API.sendHttpCommand(inputText);
                        handleHttpCommandResponse(httpResponse, inputText);
                    } else {
                        // If it's not in WS list and not in HTTP list, it's truly unknown by client
                        UI.appendToOutput(`> ${inputText}`); // Echo the command
                        UI.appendToOutput(`Hmm, '${commandVerb}'? Not sure if that goes to WS or HTTP, or if it's valid. Assuming WS for now.`);
                        WebSocketService.sendMessage({ type: "command", command_text: inputText });
                        // Or, be stricter:
                        // UI.appendToOutput(`! Unknown command routing for '${commandVerb}'.`);
                    }
                }
                break;
            default:
                UI.appendToOutput("! System error: Unknown login state.", { styleClass: 'error-message-inline' });
                startLoginProcess();
        }
    } catch (error) {
        console.error("Error during input submission:", error);
        UI.appendToOutput(`\n! Error: ${error.data?.detail || error.message || 'An unknown error occurred.'}`, { styleClass: 'error-message-inline' });
        // Fallback based on state to avoid getting stuck
        if (gameState.loginState === 'PROMPT_PASSWORD') await promptForPassword();
        else if (gameState.loginState.includes('CHAR_')) await displayCharacterSelection();
        else if (gameState.loginState.includes('REGISTER_')) await promptForRegistrationUsername();
        // else startLoginProcess(); // Last resort
    }
    UI.focusCommandInput();
}

async function attemptSessionResume() {
    if (loadSession() && gameState.currentAuthToken && gameState.selectedCharacterId) {
        UI.clearOutput(); // Clear before attempting resume
        UI.appendToOutput("Attempting to resume session...");
        try {
            const initialRoomData = await API.selectCharacterOnBackend(gameState.selectedCharacterId);
            UI.appendToOutput(`Resumed session as ${gameState.selectedCharacterName}.`);
            const resumedCharacter = { // Construct enough data for enterGameMode
                id: gameState.selectedCharacterId,
                name: gameState.selectedCharacterName,
                class_name: gameState.selectedCharacterClass,
                // Level and currency should come from welcome_package from WS after connect
                // OR fetch full character details here if needed before WS connect for some reason.
                // For now, let's assume welcome_package will provide full initial stats.
                level: 1, // Placeholder, will be updated by welcome_package
                platinum_coins: 0, gold_coins: 0, silver_coins: 0, copper_coins: 0 // Placeholders
            };
            await enterGameModeWithCharacter(resumedCharacter, initialRoomData);
            return true;
        } catch (error) {
            UI.appendToOutput(`! Session resume failed: ${error.data?.detail || error.message}. Please log in.`, { styleClass: 'error-message-inline' });
            clearSession(); // Important: clear invalid/stale session data
        }
    }
    return false;
}

// --- Initial Setup (DOMContentLoaded) ---
document.addEventListener('DOMContentLoaded', async () => {
    if (!UI.initializeElements()) return; // Critical UI elements check
    MapDisplay.initialize();

    const commandInputEl = UI.getCommandInput();
    if (commandInputEl) {
        commandInputEl.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleInputSubmission();
            }
        });
    } else {
        console.error("Command input not found during DOMContentLoaded setup. Input will not work.");
    }

    if (!(await attemptSessionResume())) {
        startLoginProcess();
    }
});
--- END OF FILE frontend/src/main.js ---

--- START OF FILE frontend/src/websocket.js ---
// frontend/src/websocket.js
import { WS_PROTOCOL, WS_HOST } from './config.js';
import { gameState, updateGameState } from './state.js';
import { UI } from './ui.js';
// Import GameLogic or main app event handlers if WS messages need to trigger complex game logic
import { handleWebSocketMessage } from './main.js'; // Assuming handleWebSocketMessage will be in main.js

export const WebSocketService = {
    connect: function () {
        if (!gameState.currentAuthToken || !gameState.selectedCharacterId) {
            UI.appendToOutput("! Cannot connect WebSocket: Missing token or character ID.", { styleClass: "error-message-inline" });
            return;
        }
        if (gameState.gameSocket && gameState.gameSocket.readyState === WebSocket.OPEN) {
            console.log("WebSocket already open.");
            return;
        }

        const wsUrl = `${WS_PROTOCOL}//${WS_HOST}/ws?token=${gameState.currentAuthToken}&character_id=${gameState.selectedCharacterId}`;
        UI.appendToOutput("Connecting to game server...");
        console.log("Attempting WS connection to:", wsUrl);
        
        const socket = new WebSocket(wsUrl); // Use local var first

        socket.onopen = function (event) {
            console.log("WebSocket connection established.");
            updateGameState({ gameSocket: socket }); // Store the successfully opened socket
            // Optionally send a "client_ready" or similar message if backend expects one
        };

        socket.onmessage = function (event) {
            try {
                const serverData = JSON.parse(event.data);
                console.log("WS RCV:", serverData);
                handleWebSocketMessage(serverData); // Delegate to main handler
            } catch (e) {
                console.error("Error parsing WebSocket message or processing:", e);
                UI.appendToOutput(`GS (unparsed): ${event.data}`, { styleClass: "game-message" });
            }
        };

        socket.onerror = function (event) {
            console.error("WebSocket error observed:", event);
            UI.appendToOutput("! WebSocket connection error.", { styleClass: "error-message-inline" });
            updateGameState({ gameSocket: null, isInCombat: false });
        };

        socket.onclose = function (event) {
            console.log("WebSocket connection closed:", event.code, event.reason);
            UI.appendToOutput(`! Game server connection closed. (Code: ${event.code} ${event.reason || ''})`.trim(), { styleClass: "game-message" });
            updateGameState({ gameSocket: null, isInCombat: false });
        };
    },

    sendMessage: function (payloadObject) {
        if (gameState.gameSocket && gameState.gameSocket.readyState === WebSocket.OPEN) {
            gameState.gameSocket.send(JSON.stringify(payloadObject));
        } else {
            UI.appendToOutput("! Cannot send command: Not connected to game server.", { styleClass: "error-message-inline" });
        }
    },

    close: function () {
        if (gameState.gameSocket) {
            if (gameState.gameSocket.readyState === WebSocket.OPEN || gameState.gameSocket.readyState === WebSocket.CONNECTING) {
                gameState.gameSocket.close();
            }
        }
        updateGameState({ gameSocket: null }); // Ensure it's nulled out in global state
    }
};
--- END OF FILE frontend/src/websocket.js ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
