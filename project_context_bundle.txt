--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Fri May 30 02:04:49 PM UTC 2025

--- START OF FILE backend/app/main.py ---
# backend/app/main.py
import asyncio
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session

from app.api.v1.api_router import api_router as v1_api_router
from app.websocket_router import router as ws_router # <<< NEW
from app.db.session import engine, get_db
from app.db import base_class
from app.core.config import settings
from app.crud.crud_room import seed_initial_world
from app.crud.crud_item import seed_initial_items 
from app.crud.crud_mob import seed_initial_mob_templates, seed_initial_mob_spawns
from app.game_logic.combat_manager import start_combat_ticker_task # <<< NEW

base_class.Base.metadata.create_all(bind=engine)
app = FastAPI(title=settings.PROJECT_NAME)

@app.on_event("startup")
def on_startup_sync(): # Renamed to avoid clash if we make it async later
    db: Session = next(get_db())
    try:
        print("Running startup event: Seeding initial world...")
        seed_initial_world(db)
        # ... other seeders ...
        seed_initial_mob_templates(db)
        seed_initial_mob_spawns(db)
        
        print("Starting combat ticker...")
        start_combat_ticker_task() # Call the function to create the task
        print("Startup event finished.")        
    finally:
        db.close()

app.include_router(v1_api_router, prefix=settings.API_V1_STR)
app.include_router(ws_router) # <<< ADDED WEBSOCKET ROUTER (usually no prefix or /ws)

@app.get("/")
async def root():
    return {"message": f"Welcome to {settings.PROJECT_NAME}. Now with WebSockets for combat!"}

print("FastAPI app instance created.")
--- END OF FILE backend/app/main.py ---

--- START OF FILE backend/app/core/config.py ---
# backend/app/core/config.py
import os
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict

# Check if we're likely running in an Alembic 'env.py' context BEFORE settings are needed for DB connection
# This is a heuristic. Alembic sets 'alembic.version' in its context.
# A simpler heuristic: if a specific env var for alembic is set.
IS_ALEMBIC_ENV_PY_CONTEXT = os.getenv("ALEMBIC_ENV_PY_RUNNING") == "true"

class Settings(BaseSettings):
    PROJECT_NAME: str = "MUD Project - Backend"
    API_V1_STR: str = "/api/v1"
    
    DATABASE_URL: Optional[str] = "postgresql://dummy_user:dummy_password@dummy_host:5432/dummy_db" if IS_ALEMBIC_ENV_PY_CONTEXT else None
    SECRET_KEY: str = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7" # CHANGE THIS IN PRODUCTION!
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7 # Token expires in 7 days

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8', extra='ignore')

settings = Settings() 

# After instantiation, if it was a dummy, ensure it's overridden if not in Alembic context
# and the real env var is available. This is getting complex.
if IS_ALEMBIC_ENV_PY_CONTEXT and settings.DATABASE_URL is not None and settings.DATABASE_URL.startswith("postgresql://dummy_user"):
    print("INFO: Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.")
elif settings.DATABASE_URL is not None and not settings.DATABASE_URL.startswith("postgresql://dummy_user") and os.getenv("DATABASE_URL"):
     # This would be the normal app run, where env var should override any default
     pass
elif not IS_ALEMBIC_ENV_PY_CONTEXT and not os.getenv("DATABASE_URL"):
    # This will have already failed in Settings() if '...' was used and no env var
    print("WARNING: DATABASE_URL not found in environment for normal app run!")
--- END OF FILE backend/app/core/config.py ---

--- START OF FILE backend/app/core/security.py ---
# backend/app/core/security.py
from datetime import datetime, timedelta, timezone # Use timezone-aware datetimes
from typing import Optional, Any, Union
from jose import JWTError, jwt # Import from jose
from passlib.context import CryptContext

from ..core.config import settings # Import our settings instance

# Initialize CryptContext. We'll use bcrypt.
# "auto" will use the first scheme (bcrypt) for hashing new passwords
# and will also be able to verify passwords hashed with any scheme listed.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(subject: Union[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode = {"exp": expire, "sub": str(subject)} # "sub" is the standard claim for subject (e.g., player_id)
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
--- END OF FILE backend/app/core/security.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator # Added Generator for type hint
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session
from jose import JWTError, jwt
from contextlib import contextmanager # For synchronous context manager

from app.db.session import SessionLocal # For WS DB sessions
from app import crud, models, schemas # General app imports
from app.core.config import settings # Corrected settings import
from app.websocket_manager import connection_manager # Global connection manager instance
from app.game_logic import combat_manager # For initiating combat, sending structured messages
from app.commands.utils import format_room_items_for_player_message, format_room_mobs_for_player_message, resolve_mob_target # Corrected import for formatters

router = APIRouter()

# --- Synchronous DB Session Context Manager for WebSocket Handlers ---
@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    """Helper to authenticate a player from a JWT token."""
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str)
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError):
        return None

@router.websocket("/ws") # Main WebSocket endpoint
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character: Optional[models.Character] = None

    # --- Authentication and Character Validation (uses one DB session) ---
    with get_db_sync() as db: # Use synchronous context manager
        player = await get_player_from_token(token, db)
        if not player:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return

        character = crud.crud_character.get_character(db, character_id=character_id)
        if not character or character.player_id != player.id:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
    # --- End Authentication and Character Validation ---

    # If successful, connect to the manager
    await connection_manager.connect(websocket, player.id, character.id)
    
    # --- Send Initial Game State ---
    initial_messages = [f"Welcome {character.name}! You are connected."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db: # New session for this block of operations
        initial_room_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.") # Insert before items/mobs

            items_on_ground = crud.crud_room_item.get_items_in_room(db, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: 
                initial_messages.append(items_text)
            
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: 
                initial_messages.append(mobs_text)
    
    await combat_manager.send_combat_log( # Using this generic sender for structured messages
        player_id=player.id, 
        messages=initial_messages,
        combat_ended=False, # Not in combat on initial connect
        room_data=initial_room_schema # Send current room data
    )
    # --- End Initial Game State ---

    try:
        while True:
            # Expect JSON messages from client: {"type": "command", "command_text": "..."}
            received_data = await websocket.receive_json()
            
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            with get_db_sync() as db_loop: # New DB session for each incoming message
                # Refresh character ORM object for current state in this session
                # This is important if character state (like room_id) can change via HTTP commands too
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character.id)
                if not current_char_state: # Should not happen if connected
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost")
                    break 
                
                current_room_for_command = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_for_command) if current_room_for_command else None

                print(f"WS command from Player {player.id} (Char {character.id}): '{command_text}' in room {current_char_state.current_room_id}")

                if message_type == "command" and command_text:
                    verb = command_text.split(" ", 1)[0].lower()
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""

                    if verb in ["attack", "atk", "kill", "k"]:
                        if not args_str: # No target specified for attack
                            await combat_manager.send_combat_log(
                                player.id, 
                                ["Attack what? (e.g., 'attack Giant Rat' or 'attack 1')"], 
                                room_data=current_room_schema_for_command
                            )
                            continue # Skip to the next WebSocket message

                        # Fetch mobs in the character's current room for target resolution
                        mobs_in_char_room = crud.crud_mob.get_mobs_in_room(db_loop, room_id=current_char_state.current_room_id)
                        
                        if not mobs_in_char_room:
                            await combat_manager.send_combat_log(
                                player.id, 
                                ["There is nothing here to attack."], 
                                room_data=current_room_schema_for_command
                            )
                            continue

                        # Use the utility function to resolve the target reference
                        target_mob_instance, error_or_prompt = resolve_mob_target(args_str, mobs_in_char_room)
                        
                        if error_or_prompt:
                            # This covers "not found" or ambiguity prompts
                            await combat_manager.send_combat_log(
                                player.id, 
                                [error_or_prompt], 
                                room_data=current_room_schema_for_command
                            )
                        elif target_mob_instance:
                            # Successfully resolved target, now initiate or queue combat
                            # Check if character is already in any combat session
                            is_already_in_any_combat = character.id in combat_manager.active_combats
                            
                            # Check if specifically targeting an already engaged mob (by this character)
                            is_already_targeting_this_specific_mob = False
                            if is_already_in_any_combat:
                                if target_mob_instance.id in combat_manager.active_combats.get(character.id, set()):
                                    is_already_targeting_this_specific_mob = True
                            
                            if not is_already_in_any_combat:
                                # Not in combat, so initiate with this target
                                await combat_manager.initiate_combat_session(
                                    db_loop, player.id, character.id, character.name, target_mob_instance.id
                                )
                            elif not is_already_targeting_this_specific_mob:
                                # In combat, but switching to a new valid target (or adding a new one)
                                # Ensure initiate_combat_session or a similar function correctly adds
                                # this new target to the existing combat session if that's the desired logic,
                                # or if it always starts a "new" combat context against this mob.
                                # For now, let's assume initiate_combat_session can handle adding a new target.
                                # Or, more simply, just update the queued action to this new target.
                                combat_manager.active_combats.setdefault(character.id, set()).add(target_mob_instance.id)
                                combat_manager.mob_targets[target_mob_instance.id] = character.id # Ensure mob targets player
                                combat_manager.character_queued_actions[character.id] = f"attack {target_mob_instance.id}"
                                await combat_manager.send_combat_log(
                                    player.id, 
                                    [f"You switch your attack to the <span class='inv-item-name'>{target_mob_instance.mob_template.name}</span>!"], 
                                    room_data=current_room_schema_for_command
                                )
                            else: 
                                # Already in combat and already targeting this mob (or re-affirming).
                                # Queue the attack action for the ticker.
                                combat_manager.character_queued_actions[character.id] = f"attack {target_mob_instance.id}"
                                # Optional: Send a minor confirmation, or let the ticker show the next round's action.
                                # await combat_manager.send_combat_log(player.id, [f"Continuing attack on {target_mob_instance.mob_template.name}."], room_data=current_room_schema_for_command)
                                # No 'else' needed for target_mob_instance here, as resolve_mob_target's error_or_prompt covers it.

                    elif verb == "flee":
                        if character.id in combat_manager.active_combats:
                            combat_manager.character_queued_actions[character.id] = "flee"
                            await combat_manager.send_combat_log(player.id, ["You prepare to flee..."], room_data=current_room_schema_for_command)
                        else:
                            await combat_manager.send_combat_log(player.id, ["You are not in combat."], room_data=current_room_schema_for_command)
                    
                    elif verb in ["look", "l"]: # Handle 'look' via WebSocket
                         look_messages = []
                         # Room name/desc will be in room_data part of send_combat_log
                         items_on_ground = crud.crud_room_item.get_items_in_room(db_loop, current_char_state.current_room_id)
                         items_text, _ = format_room_items_for_player_message(items_on_ground)
                         if items_text: look_messages.append(items_text)
                         
                         mobs_in_current_room = crud.crud_mob.get_mobs_in_room(db_loop, current_char_state.current_room_id)
                         mobs_text, _ = format_room_mobs_for_player_message(mobs_in_current_room)
                         if mobs_text: look_messages.append(mobs_text)
                         
                         await combat_manager.send_combat_log(player.id, look_messages, room_data=current_room_schema_for_command)
                    
                    # TODO: Add more WebSocket command handlers (move, inventory, etc.) or a dispatcher
                    # For commands not handled here, the client would still use HTTP
                    else:
                        await combat_manager.send_combat_log(player.id, [f"Command '{verb}' not yet supported over WebSocket. Try HTTP or combat actions."], room_data=current_room_schema_for_command)
                else: # Unrecognized message type or empty command
                    await combat_manager.send_combat_log(player.id, [f"Unrecognized message type: {message_type} or empty command."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        print(f"WebSocket disconnected for Player {player.id} (Character {character.id})")
        # Clean up combat state for this character
        if character.id in combat_manager.active_combats:
            combat_manager.active_combats.pop(character.id, None)
            mobs_to_clear = [mid for mid, cid_target in combat_manager.mob_targets.items() if cid_target == character.id]
            for mid in mobs_to_clear: combat_manager.mob_targets.pop(mid, None)
        combat_manager.character_queued_actions.pop(character.id, None)
    except Exception as e:
        print(f"Error in WebSocket for Player {player.id} (Character {character.id}): {e}")
        # Attempt to send an error to client if possible, then close
        try:
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred."})
        except Exception:
            pass # Ignore if send fails (connection likely already broken)
    finally:
        # This ensures disconnect is called even if an error occurs within the try block
        # before WebSocketDisconnect is raised.
        connection_manager.disconnect(player.id) 
        print(f"Cleaned up WebSocket resources for Player {player.id} (Character {character.id})")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/websocket_manager.py ---
# backend/app/websocket_manager.py
import uuid
from typing import Dict, List, Optional
from fastapi import WebSocket
from fastapi.encoders import jsonable_encoder

class ConnectionManager:
    def __init__(self):
        # player_id -> WebSocket mapping
        self.active_player_connections: Dict[uuid.UUID, WebSocket] = {}
        # player_id -> active_character_id mapping (CRUCIAL for WS knowing context)
        self.player_active_characters: Dict[uuid.UUID, uuid.UUID] = {}

    async def connect(self, websocket: WebSocket, player_id: uuid.UUID, character_id: uuid.UUID):
        await websocket.accept()
        self.active_player_connections[player_id] = websocket
        self.player_active_characters[player_id] = character_id # Associate character with this WS connection
        print(f"Player {player_id} (Character {character_id}) connected via WebSocket.")

    def disconnect(self, player_id: uuid.UUID):
        if player_id in self.active_player_connections:
            del self.active_player_connections[player_id]
        if player_id in self.player_active_characters:
            del self.player_active_characters[player_id]
        print(f"Player {player_id} disconnected from WebSocket.")

    def get_character_id(self, player_id: uuid.UUID) -> Optional[uuid.UUID]:
        return self.player_active_characters.get(player_id)

    async def send_personal_message(self, message_payload: dict, player_id: uuid.UUID): # Expects a dict
        if player_id in self.active_player_connections:
            websocket = self.active_player_connections[player_id]
            try:
                encoded_payload = jsonable_encoder(message_payload) # <<< USE JSONABLE ENCODER
                await websocket.send_json(encoded_payload)
            except Exception as e:
                # Log the original payload to see what might have caused an issue
                # Be careful logging sensitive data in production
                print(f"Error sending WS message to {player_id}: {e} (Original payload structure might be an issue for encoding: {type(message_payload)})")
                # For more detailed debug, print keys and types of values in message_payload
                # for k, v in message_payload.items():
                #     print(f"DEBUG PAYLOAD: key='{k}', type='{type(v)}'")
                #     if k == 'room_data' and v is not None:
                #         for rk, rv in v.items() if isinstance(v, dict) else vars(v).items() if hasattr(v, '__dict__') else []:
                #              print(f"  RoomData Sub: key='{rk}', type='{type(rv)}'")


    async def broadcast_to_room(self, message: dict, room_id: uuid.UUID, db_session_getter, current_player_id_to_skip: Optional[uuid.UUID] = None):
        # This is more advanced: requires knowing which players/characters are in which room
        # For now, this is a placeholder for future room-based broadcasts
        # It would iterate through self.active_player_connections, get their char_id,
        # then query DB (via db_session_getter) for char's room_id.
        print(f"Placeholder: Broadcast to room {room_id}: {message}")
        # For a simple broadcast to all connected (not room specific):
        # for player_id, websocket in self.active_player_connections.items():
        #     if player_id != current_player_id_to_skip:
        #         try:
        #             await websocket.send_json(message)
        #         except Exception:
        #             pass # Handle send errors or disconnects

    def is_player_connected(self, player_id: uuid.UUID) -> bool:
        return player_id in self.active_player_connections

# Global instance
connection_manager = ConnectionManager()
--- END OF FILE backend/app/websocket_manager.py ---

--- START OF FILE backend/app/game_logic/combat_manager.py ---
# backend/app/game_logic/combat_manager.py
import asyncio
import uuid
import random
from typing import Dict, List, Set, Optional, Any

from sqlalchemy.orm import Session # For type hinting

from app.db.session import SessionLocal # For creating new DB sessions in tasks
from app import crud, models, schemas
from app.websocket_manager import connection_manager as ws_manager
from app.commands.utils import roll_dice, format_room_mobs_for_player_message, format_room_items_for_player_message 

# --- Database Session for Async Tasks ---
from contextlib import contextmanager
@contextmanager
def db_session_for_task_sync(): # Synchronous context manager for DB sessions
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- Combat State (Module-level, simple for single instance) ---
# character_id -> Set of target mob_instance_IDs
active_combats: Dict[uuid.UUID, Set[uuid.UUID]] = {}
# mob_instance_id -> character_id it's targeting
mob_targets: Dict[uuid.UUID, uuid.UUID] = {}
# character_id -> queued action string (e.g., "attack mob_instance_id", "flee")
# This implies one action per character per round.
character_queued_actions: Dict[uuid.UUID, Optional[str]] = {}

COMBAT_ROUND_INTERVAL = 3.0  # seconds

async def send_combat_log(player_id: uuid.UUID, messages: List[str], combat_ended: bool = False, room_data: Optional[schemas.RoomInDB] = None):
    """Helper to send structured combat updates via WebSocket."""
    if not messages and not combat_ended and not room_data: # Don't send empty updates unless it's an important state change
        return

    payload = {
        "type": "combat_update",
        "log": messages,
        "combat_over": combat_ended,
        "room_data": room_data.model_dump() if room_data else None # Send current room state if needed
    }
    await ws_manager.send_personal_message(payload, player_id)


async def initiate_combat_session(
    db: Session, 
    player_id: uuid.UUID, # Player account ID
    character_id: uuid.UUID, 
    character_name: str,
    target_mob_instance_id: uuid.UUID
):
    mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_instance_id)
    if not mob_instance or mob_instance.current_health <= 0:
        await send_combat_log(player_id, ["Target is invalid or already dead."])
        return False # Combat not initiated

    active_combats.setdefault(character_id, set()).add(target_mob_instance_id)
    mob_targets[target_mob_instance_id] = character_id # Mob targets character who initiated
    character_queued_actions[character_id] = f"attack {target_mob_instance_id}" # Default action

    await send_combat_log(player_id, [f"<span class='char-name'>{character_name}</span> engages the <span class='inv-item-name'>{mob_instance.mob_template.name}</span>!"])
    return True


async def process_combat_round(db: Session, character_id: uuid.UUID, player_id: uuid.UUID):
    """Processes one round of combat for a given character."""
    if character_id not in active_combats or not active_combats[character_id]:
        return # Character is not in combat or has no targets

    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character: # Should not happen if in active_combats
        active_combats.pop(character_id, None)
        return

    # TODO: Implement Player Health & Stats on character model
    # For now, placeholders:
    player_current_hp = getattr(character, 'current_health', 100) # Assume 100 HP
    player_max_hp = getattr(character, 'max_health', 100)
    player_ac = getattr(character, 'ac', 12)
    player_attack_bonus = getattr(character, 'attack_bonus', 2)
    player_damage_dice = getattr(character, 'damage_dice', "1d6")
    player_damage_bonus = getattr(character, 'damage_bonus', 1)
    # End Placeholders

    round_log: List[str] = []
    combat_resolved_this_round = False
    
    action_str = character_queued_actions.get(character_id)
    character_queued_actions[character_id] = None # Consume action, default to attack next round if combat continues

    # --- Player's Action ---
    if action_str == "flee":
        if random.random() < 0.5: # 50% flee chance
            round_log.append("<span class='combat-success'>You successfully flee from combat!</span>")
            combat_resolved_this_round = True
        else:
            round_log.append("<span class='combat-miss'>Your attempt to flee fails!</span>")
    elif action_str and action_str.startswith("attack"):
        try:
            target_mob_id_str = action_str.split(" ", 1)[1]
            target_mob_id = uuid.UUID(target_mob_id_str)
        except (IndexError, ValueError):
            round_log.append("Invalid attack target in action queue.")
            target_mob_id = None # Ensure it's None

        if target_mob_id and target_mob_id in active_combats.get(character_id, set()):
            mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_id)
            if mob_instance and mob_instance.current_health > 0:
                mob_template = mob_instance.mob_template
                mob_ac = mob_template.base_defense if mob_template.base_defense is not None else 10
                
                to_hit_roll = roll_dice("1d20")
                if (to_hit_roll + player_attack_bonus) >= mob_ac:
                    damage = max(1, roll_dice(player_damage_dice) + player_damage_bonus)
                    damage_class = "combat-crit" if damage > (roll_dice(player_damage_dice.split('d')[0]+"d1")*int(player_damage_dice.split('d')[1].split('+')[0])/2 + player_damage_bonus) else "combat-hit" # Simple crit idea
                    round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>HITS</span> <span class='inv-item-name'>{mob_template.name}</span> for <span class='{damage_class}'>{damage}</span> damage.")
                    
                    updated_mob = crud.crud_mob.update_mob_instance_health(db, mob_instance.id, -damage)
                    if updated_mob and updated_mob.current_health <= 0:
                        round_log.append(f"<span class='combat-death'>The {mob_template.name} DIES!</span>")
                        crud.crud_mob.despawn_mob_from_room(db, updated_mob.id)
                        active_combats.get(character_id, set()).discard(updated_mob.id)
                        mob_targets.pop(updated_mob.id, None)
                        # TODO: XP, Loot
                    elif updated_mob:
                        round_log.append(f"  {mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{mob_template.base_health}</span>.")
                else:
                    round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{mob_template.name}</span>.")
            else: # Target mob died or became invalid before player's attack resolved
                active_combats.get(character_id, set()).discard(target_mob_id)
        else: # No valid target specified or target not in current combat
             round_log.append("You pause, unsure who to attack.")
    
    if not active_combats.get(character_id): # All targets for this character died
        combat_resolved_this_round = True

    # --- Mobs' Actions (Retaliation) ---
    if not combat_resolved_this_round and player_current_hp > 0: # Player is alive and combat not over
        mobs_to_attack_player = list(active_combats.get(character_id, set())) # Copy set for iteration
        for mob_instance_id in mobs_to_attack_player:
            mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_instance_id)
            if not mob_instance or mob_instance.current_health <= 0: # Already dead
                active_combats.get(character_id, set()).discard(mob_instance_id) # Clean up
                mob_targets.pop(mob_instance_id, None)
                continue

            mob_template = mob_instance.mob_template
            mob_attack_bonus = mob_template.level or 1
            mob_damage_dice = mob_template.base_attack or "1d4"

            mob_to_hit = roll_dice("1d20")
            if (mob_to_hit + mob_attack_bonus) >= player_ac:
                damage_to_player = max(1, roll_dice(mob_damage_dice))
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-success'>HITS</span> <span class='char-name'>{character.name}</span> for <span class='combat-hit-player'>{damage_to_player}</span> damage.")
                player_current_hp -= damage_to_player # Apply to temporary var
                # TODO: CRUD update player health: crud.crud_character.update_health(db, character_id, -damage_to_player)
                round_log.append(f"  Your HP: <span class='combat-hp'>{player_current_hp}/{player_max_hp}</span>.")
                if player_current_hp <= 0:
                    round_log.append("<span class='combat-death'>YOU HAVE DIED!</span>")
                    combat_resolved_this_round = True
                    # TODO: Handle player death (respawn, etc.)
                    break # Stop other mobs attacking if player died
            else:
                round_log.append(f"<span class='inv-item_name'>{mob_template.name}</span> <span class='combat-miss'>MISSES</span> <span class='char-name'>{character.name}</span>.")

    # --- End of Round ---
    if combat_resolved_this_round:
        active_combats.pop(character_id, None)
        mobs_to_clear_target = [mid for mid, cid in mob_targets.items() if cid == character_id]
        for mid in mobs_to_clear_target: mob_targets.pop(mid, None)
        character_queued_actions.pop(character_id, None) # Clear any lingering action
    elif character_id in active_combats: # Combat continues, set default action to attack a remaining target
        remaining_targets = list(active_combats[character_id])
        if remaining_targets:
            character_queued_actions[character_id] = f"attack {remaining_targets[0]}"
        else: # Should have been caught by combat_resolved_this_round
            active_combats.pop(character_id, None)
            character_queued_actions.pop(character_id, None)
            combat_resolved_this_round = True # Ensure it's marked over

    # Send update to player
    current_room_for_update = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    current_room_schema_for_update = schemas.RoomInDB.from_orm(current_room_for_update) if current_room_for_update else None
    
    # If combat ended, list remaining mobs in room for context
    if combat_resolved_this_round and current_room_for_update:
        remaining_mobs_in_room_orm = crud.crud_mob.get_mobs_in_room(db, room_id=current_room_for_update.id)
        mobs_text, _ = format_room_mobs_for_player_message(remaining_mobs_in_room_orm)
        if mobs_text:
            round_log.append(mobs_text)

    await send_combat_log(player_id, round_log, combat_resolved_this_round, current_room_schema_for_update)


async def combat_ticker_loop():
    """Main game loop for processing combat rounds."""
    while True:
        await asyncio.sleep(COMBAT_ROUND_INTERVAL)
        
        # Create a list of characters currently in combat to iterate over
        # This avoids issues if active_combats dict changes during iteration
        # And allows fetching player_id associated with character_id for WebSocket comms
        
        # Get player_id for each character_id in combat
        # This requires ws_manager to have player_id -> character_id mapping, or vice-versa
        # For now, we iterate player_ids from ws_manager and get their active char_id
        
        # Create a new DB session for this entire tick
        with db_session_for_task_sync() as db:
            # print(f"DEBUG ticker: active_combats={active_combats}, mob_targets={mob_targets}, actions={character_queued_actions}")
            # Need to iterate over players who are actually connected and have characters in combat.
            player_ids_to_process = list(ws_manager.active_player_connections.keys())

            for player_id in player_ids_to_process:
                character_id = ws_manager.get_character_id(player_id) # Get active char for this player
                if character_id and character_id in active_combats:
                    # print(f"DEBUG: Processing combat for char {character_id} (Player {player_id})")
                    await process_combat_round(db, character_id, player_id)

# This function should be called once on application startup
_combat_ticker_task = None

def start_combat_ticker_task():
    global _combat_ticker_task
    if _combat_ticker_task is None:
        print("Starting combat ticker task...")
        _combat_ticker_task = asyncio.create_task(combat_ticker_loop())
        print("Combat ticker task created.")
    else:
        print("Combat ticker task already running or requested.")

def stop_combat_ticker_task(): # For graceful shutdown if needed
    global _combat_ticker_task
    if _combat_ticker_task and not _combat_ticker_task.done():
        print("Stopping combat ticker task...")
        _combat_ticker_task.cancel()
        _combat_ticker_task = None
        print("Combat ticker task cancelled.")
--- END OF FILE backend/app/game_logic/combat_manager.py ---

--- START OF FILE backend/app/commands/command_args.py ---
# backend/app/commands/command_args.py
from typing import List, Optional
from sqlalchemy.orm import Session
from pydantic import BaseModel, Field

from app import models, schemas # Ensure these are accessible from app root

class CommandContext(BaseModel):
    db: Session
    active_character: models.Character
    current_room_orm: models.Room 
    current_room_schema: schemas.RoomInDB
    original_command: str 
    command_verb: str
    args: List[str] # The rest of the command words after the verb
    # For more complex parsing, args could be a pre-parsed Pydantic model itself

    class Config:
        arbitrary_types_allowed = True # For SQLAlchemy Session and ORM models
--- END OF FILE backend/app/commands/command_args.py ---

--- START OF FILE backend/app/commands/utils.py ---
# backend/app/commands/utils.py
import re
from typing import List, Optional, Tuple, Dict
import uuid
import random

from app import models, schemas
from app.models.item import EQUIPMENT_SLOTS

def get_visible_length(s: str) -> int: # ... content ...
    return len(re.sub(r'<[^>]+>', '', s))

def format_room_items_for_player_message(room_items: List[models.RoomItemInstance]) -> Tuple[str, Dict[int, uuid.UUID]]: # ... content ...
    lines = []
    item_map: Dict[int, uuid.UUID] = {}
    if room_items:
        lines.append("\nYou also see on the ground:")
        for idx, room_item_instance in enumerate(room_items):
            item_name = room_item_instance.item.name if room_item_instance.item else "Unknown Item"
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            item_name_html = f"<span class='inv-item-name'>{item_name}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {room_item_instance.quantity})</span>"
            prefix_html = f"  {item_number_html} "
            lines.append(f"{prefix_html}{item_name_html} {item_qty_html}")
            item_map[idx + 1] = room_item_instance.id
    return "\n".join(lines), item_map


def format_room_mobs_for_player_message(room_mobs: List[models.RoomMobInstance]) -> Tuple[str, Dict[int, uuid.UUID]]: # ... content ...
    lines = []
    mob_map: Dict[int, uuid.UUID] = {}
    if room_mobs:
        lines.append("\nAlso here:")
        for idx, mob_instance in enumerate(room_mobs):
            template = mob_instance.mob_template
            mob_name = template.name if template else "Unknown Creature"
            mob_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            mob_name_html = f"<span class='inv-item-name'>{mob_name}</span>"
            lines.append(f"  {mob_number_html} {mob_name_html}")
            mob_map[idx + 1] = mob_instance.id
    return "\n".join(lines), mob_map

def format_inventory_for_player_message(inventory_display_schema: schemas.CharacterInventoryDisplay) -> str: # ... content from previous version ...
    lines = []
    equipped_item_parts = [] 
    max_visible_equipped_prefix_len = 0
    if inventory_display_schema.equipped_items:
        for slot_key, inv_item_schema in inventory_display_schema.equipped_items.items():
            processed_slot_key = str(slot_key).strip()
            display_slot_name_raw = EQUIPMENT_SLOTS.get(processed_slot_key, processed_slot_key.capitalize())
            slot_name_html = f"<span class='inv-slot-name'>{display_slot_name_raw}</span>"
            prefix_html = f"  [{slot_name_html}]"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_equipped_prefix_len = max(max_visible_equipped_prefix_len, visible_prefix_len)
            item_name_raw = inv_item_schema.item.name.strip() if inv_item_schema.item else "Unknown Item"
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {inv_item_schema.quantity})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"
            equipped_item_parts.append({'sort_key': display_slot_name_raw,'prefix_html': prefix_html,'visible_prefix_len': visible_prefix_len,'suffix_html': suffix_html})
    lines.append(f"<span class='inv-section-header'>--- Equipped ---</span>")
    if equipped_item_parts:
        equipped_item_parts.sort(key=lambda x: x['sort_key'])
        for parts in equipped_item_parts:
            padding_needed = (max_visible_equipped_prefix_len + 2) - parts['visible_prefix_len']
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else: lines.append("  Nothing equipped.")
    backpack_item_parts = []
    max_visible_backpack_prefix_len = 0
    if inventory_display_schema.backpack_items:
        for idx, inv_item_schema in enumerate(inventory_display_schema.backpack_items):
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            prefix_html = f"  {item_number_html}"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_backpack_prefix_len = max(max_visible_backpack_prefix_len, visible_prefix_len)
            item_name_raw = inv_item_schema.item.name.strip() if inv_item_schema.item else "Unknown Item"
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {inv_item_schema.quantity})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"
            backpack_item_parts.append({'prefix_html': prefix_html,'visible_prefix_len': visible_prefix_len,'suffix_html': suffix_html})
    lines.append(f"\n<span class='inv-section-header'>--- Backpack ---</span>")
    if backpack_item_parts:
        for parts in backpack_item_parts:
            padding_needed = (max_visible_backpack_prefix_len + 1) - parts['visible_prefix_len']
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else: lines.append("  Your backpack is empty.")
    return "\n".join(lines)

def roll_dice(dice_str: str) -> int: # ... content ...
    if not dice_str: return 0
    dice_str = dice_str.replace(" ", "")
    parts = dice_str.lower().split('d')
    num_dice = 1
    if parts[0]:
        if parts[0] == "" and len(parts) > 1: num_dice = 1
        else:
            try: num_dice = int(parts[0])
            except ValueError:
                try: return int(parts[0])
                except ValueError: return 0
    if len(parts) < 2: return num_dice
    dice_spec = parts[1]
    modifier = 0
    if '+' in dice_spec:
        sides_mod = dice_spec.split('+')
        try:
            dice_sides = int(sides_mod[0]); modifier = int(sides_mod[1])
        except (ValueError, IndexError): return 0 
    elif '-' in dice_spec:
        sides_mod_neg = dice_spec.split('-')
        try:
            dice_sides = int(sides_mod_neg[0]); modifier = -int(sides_mod_neg[1])
        except (ValueError, IndexError): return 0
    else:
        try: dice_sides = int(dice_spec)
        except ValueError: return 0
    if dice_sides <= 0: return 0 
    total_roll = 0
    for _ in range(num_dice): total_roll += random.randint(1, dice_sides)
    return total_roll + modifier

def resolve_mob_target(
    target_ref: str, 
    mobs_in_room: List[models.RoomMobInstance] # Pass the list of RoomMobInstance ORM objects
) -> Tuple[Optional[models.RoomMobInstance], Optional[str]]:
    """
    Resolves a target reference (number, full name, or partial name) to a specific mob instance.
    Returns (mob_instance, error_message_or_ambiguity_prompt_or_None_if_success)
    """
    if not mobs_in_room: # No mobs to target
        return None, f"There is nothing called '{target_ref}' here to target."

    target_ref_lower = target_ref.lower()
    
    # 1. Try to parse as a number (from 1-based index)
    try:
        num_ref = int(target_ref)
        if 1 <= num_ref <= len(mobs_in_room):
            return mobs_in_room[num_ref - 1], None # Found by number
    except ValueError:
        pass # Not a number, proceed to name matching

    # 2. Try exact full name match (case-insensitive)
    exact_matches: List[models.RoomMobInstance] = []
    for mob_instance in mobs_in_room:
        if mob_instance.mob_template and mob_instance.mob_template.name.lower() == target_ref_lower:
            exact_matches.append(mob_instance)
    
    if len(exact_matches) == 1:
        return exact_matches[0], None # Unique exact match
    if len(exact_matches) > 1:
        # Prefer exact match over partial if multiple exacts (unlikely for unique mob instances)
        return exact_matches[0], "(Multiple exact name matches found, targeting first.)" 

    # 3. Try partial name match (prefix, case-insensitive)
    partial_matches: List[models.RoomMobInstance] = []
    for mob_instance in mobs_in_room:
        if mob_instance.mob_template and mob_instance.mob_template.name.lower().startswith(target_ref_lower):
            partial_matches.append(mob_instance)

    if len(partial_matches) == 1:
        return partial_matches[0], None # Unique partial match
    
    if len(partial_matches) > 1:
        # Ambiguous partial match
        prompt_lines = [f"Which '{target_ref}' did you mean?"]
        # Sort partial_matches by name for consistent numbering, if desired
        partial_matches.sort(key=lambda m: m.mob_template.name if m.mob_template else "")
        for i, mob_match in enumerate(partial_matches):
            mob_name = mob_match.mob_template.name if mob_match.mob_template else "Unknown Mob"
            prompt_lines.append(f"  {i + 1}. {mob_name}")
        return None, "\n".join(prompt_lines)

    # 4. No match found
    return None, f"Cannot find anything called '{target_ref}' here to target."
--- END OF FILE backend/app/commands/utils.py ---

--- START OF FILE backend/app/commands/movement_parser.py ---
# backend/app/commands/movement_parser.py
import uuid
from typing import Dict, List, Optional, Tuple # Ensure all are imported

from app import schemas, crud, models # app.
from .command_args import CommandContext # app.commands.command_args

# If format_room_items_for_player_message is in utils.py:
from .utils import format_room_items_for_player_message
# If format_room_mobs_for_player_message will also be in utils.py eventually, import it too.
# For now, defining format_room_mobs_for_player_message directly here for this example,
# but it's better placed in utils.py.

# --- Helper Function (Ideally in utils.py) ---
def format_room_mobs_for_player_message(
    room_mobs: List[models.RoomMobInstance]
) -> Tuple[str, Dict[int, uuid.UUID]]:
    """Formats mobs in the room into a readable string, numbered."""
    lines = []
    mob_map: Dict[int, uuid.UUID] = {}

    if room_mobs:
        lines.append("\nAlso here:") # Or "Creatures present:"
        for idx, mob_instance in enumerate(room_mobs):
            template = mob_instance.mob_template
            mob_name = template.name if template else "Unknown Creature"
            
            mob_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>" # Re-use style for numbering
            mob_name_html = f"<span class='inv-item-name'>{mob_name}</span>" # Re-use style for name

            lines.append(f"  {mob_number_html} {mob_name_html}")
            mob_map[idx + 1] = mob_instance.id
    return "\n".join(lines), mob_map
# --- End Helper Function ---


async def handle_look(context: CommandContext) -> schemas.CommandResponse:
    message_to_player_parts: List[str] = [] # Collect parts of the message

    look_target_name = " ".join(context.args).strip() if context.args else None

    if look_target_name:
        item_to_look_at: Optional[models.Item] = None
        mob_to_look_at: Optional[models.MobTemplate] = None

        # 1. Check inventory items
        inventory = crud.crud_character_inventory.get_character_inventory(context.db, character_id=context.active_character.id)
        for inv_entry in inventory:
            if inv_entry.item.name.lower() == look_target_name.lower():
                item_to_look_at = inv_entry.item
                break
        
        # 2. Check items on ground if not found in inventory
        if not item_to_look_at:
            items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
            for room_item_inst in items_on_ground_orm:
                if room_item_inst.item and room_item_inst.item.name.lower() == look_target_name.lower():
                    item_to_look_at = room_item_inst.item
                    break
        
        # 3. Check mobs in room by name if not an item
        if not item_to_look_at:
            mobs_in_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
            for mob_inst in mobs_in_room_orm:
                if mob_inst.mob_template and mob_inst.mob_template.name.lower() == look_target_name.lower():
                    mob_to_look_at = mob_inst.mob_template
                    # Future: could also show mob_inst.current_health here for "look mob"
                    break
        
        # Construct message based on what was found
        if item_to_look_at:
            item_look_msg = f"{item_to_look_at.name}:\n{item_to_look_at.description or 'No special description.'}"
            if item_to_look_at.properties: item_look_msg += f"\nProperties: {item_to_look_at.properties}"
            item_look_msg += f"\nType: {item_to_look_at.item_type}, Slot: {item_to_look_at.slot or 'N/A'}, Weight: {item_to_look_at.weight}"
            message_to_player_parts.append(item_look_msg)
        elif mob_to_look_at:
            mob_look_msg = f"{mob_to_look_at.name}:\n{mob_to_look_at.description or 'A creature of an unknown type.'}"
            # Add more mob details if desired: (Level X Beast), Health: (approximate)
            mob_look_msg += f"\nType: {mob_to_look_at.mob_type or 'N/A'}, Level: {mob_to_look_at.level or 'N/A'}"
            # Could look up the specific instance to show current health:
            # for mob_inst in mobs_in_room_orm: # Assuming mobs_in_room_orm is already fetched if mob_to_look_at is true
            #    if mob_inst.mob_template_id == mob_to_look_at.id:
            #        mob_look_msg += f"\nHealth: {mob_inst.current_health}/{mob_to_look_at.base_health}" # Example health display
            #        break
            message_to_player_parts.append(mob_look_msg)
        else:
            message_to_player_parts.append(f"You don't see '{look_target_name}' to examine closely.")

        # Always add current room context when looking at a specific target
        message_to_player_parts.append(f"\n\n{context.current_room_schema.name}\n{context.current_room_schema.description}")
        
        # Also list other items and mobs in the room for full context
        all_other_items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
        if all_other_items_on_ground_orm:
            ground_items_text, _ = format_room_items_for_player_message(all_other_items_on_ground_orm)
            if ground_items_text: message_to_player_parts.append(ground_items_text)

        all_mobs_in_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
        if all_mobs_in_room_orm:
            mobs_text, _ = format_room_mobs_for_player_message(all_mobs_in_room_orm)
            if mobs_text: message_to_player_parts.append(mobs_text)
            
        final_message = "\n".join(filter(None, message_to_player_parts)).strip()
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=final_message if final_message else None)

    # Default "look" (general room look: room desc comes from room_data, message is for items/mobs)
    # message_to_player will contain only items and mobs. Room name/desc handled by frontend using room_data.
    
    items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
    ground_items_text, _ = format_room_items_for_player_message(items_on_ground_orm)
    if ground_items_text:
        message_to_player_parts.append(ground_items_text)
        
    mobs_in_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
    mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room_orm)
    if mobs_text:
        message_to_player_parts.append(mobs_text)
        
    final_message = "\n".join(filter(None, message_to_player_parts)).strip()
    return schemas.CommandResponse(
        room_data=context.current_room_schema,
        message_to_player=final_message if final_message else None
    )

async def handle_move(context: CommandContext) -> schemas.CommandResponse:
    message_to_player: Optional[str] = None 
    moved = False
    target_room_orm_for_move: Optional[models.Room] = None
    
    direction_map = {"n": "north", "s": "south", "e": "east", "w": "west", "u": "up", "d": "down"}
    target_direction_str = ""

    if context.command_verb == "go":
        if context.args: 
            target_direction_str = context.args[0].lower()
        else:
            message_to_player = "Go where?"
            return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
    else: 
        target_direction_str = context.command_verb 
        
    target_direction = direction_map.get(target_direction_str, target_direction_str)

    if target_direction not in direction_map.values():
        message_to_player = "That's not a valid direction to move."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    current_exits = context.current_room_orm.exits if context.current_room_orm.exits is not None else {}
    if target_direction in current_exits:
        next_room_uuid_str = current_exits.get(target_direction)
        if next_room_uuid_str:
            try:
                target_room_uuid = uuid.UUID(hex=next_room_uuid_str)
                potential_target_room_orm = crud.crud_room.get_room_by_id(context.db, room_id=target_room_uuid)
                if potential_target_room_orm:
                    target_room_orm_for_move = potential_target_room_orm
                    moved = True
                else: 
                    message_to_player = "The path ahead seems to vanish into thin air."
            except ValueError: 
                message_to_player = "The exit in that direction appears to be corrupted."
        else: 
            message_to_player = "The way in that direction is unclear."
    else: 
        message_to_player = "You can't go that way."

    if moved and target_room_orm_for_move:
        crud.crud_character.update_character_room(
            context.db, character_id=context.active_character.id, new_room_id=target_room_orm_for_move.id
        )
        new_room_schema = schemas.RoomInDB.from_orm(target_room_orm_for_move)
        
        # On successful move, build message with items and mobs in the new room
        arrival_message_parts: List[str] = []
        
        items_in_new_room_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=target_room_orm_for_move.id)
        ground_items_text, _ = format_room_items_for_player_message(items_in_new_room_orm)
        if ground_items_text: # Only append if not empty
            arrival_message_parts.append(ground_items_text)
            
        mobs_in_new_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=target_room_orm_for_move.id)
        mobs_text, _ = format_room_mobs_for_player_message(mobs_in_new_room_orm)
        if mobs_text: # Only append if not empty
            arrival_message_parts.append(mobs_text)
            
        final_arrival_message = "\n".join(filter(None, arrival_message_parts)).strip()
        
        return schemas.CommandResponse(
            room_data=new_room_schema, 
            message_to_player=final_arrival_message if final_arrival_message else None
        )
            
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/movement_parser.py ---

--- START OF FILE backend/app/commands/inventory_parser.py ---
# backend/app/commands/inventory_parser.py
from typing import Optional, List, Dict
import uuid # Ensure uuid is imported

from app import schemas, crud, models # app.
from .command_args import CommandContext # app.commands.command_args
from .utils import format_inventory_for_player_message # app.commands.utils
# format_inventory_schema needs to be imported carefully if it's from an API endpoint file,
# or its logic moved to utils. For now, assuming it's correctly aliased or moved.
from app.api.v1.endpoints.inventory import format_inventory_for_display as format_inventory_schema
from app.models.item import EQUIPMENT_SLOTS # For equip/unequip logic

async def handle_inventory(context: CommandContext) -> schemas.CommandResponse:
    raw_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    )
    inventory_as_schema = format_inventory_schema(raw_inventory_items_orm)
    message_to_player = format_inventory_for_player_message(inventory_as_schema)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_equip(context: CommandContext) -> schemas.CommandResponse:
    message_to_player: Optional[str] = None
    preliminary_message: Optional[str] = None
    
    if not context.args:
        message_to_player = "Equip/Eq what? (e.g., 'equip Rusty Sword' or 'eq 1 main_hand')"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # Reconstruct item_ref_to_equip and target_slot_arg from context.args
    # args = ["Rusty", "Sword", "main_hand"] or ["1", "main_hand"] or ["Rusty", "Sword"] or ["1"]
    item_ref_str = ""
    target_slot_arg: Optional[str] = None

    if context.args:
        potential_slot_word = context.args[-1].lower()
        is_last_word_a_slot = False
        for slot_key_iter, slot_display_iter in EQUIPMENT_SLOTS.items():
            if potential_slot_word == slot_key_iter.lower() or potential_slot_word == slot_display_iter.lower():
                target_slot_arg = slot_key_iter
                item_ref_str = " ".join(context.args[:-1]).strip()
                is_last_word_a_slot = True
                break
        if not is_last_word_a_slot:
            item_ref_str = " ".join(context.args).strip()
    
    if not item_ref_str:
        message_to_player = "Equip/Eq what item?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # ... (rest of the equip logic from old command.py, using context.db, context.active_character, etc.)
    inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    )
    temp_backpack_map: Dict[int, models.CharacterInventoryItem] = {}
    current_backpack_idx = 1
    unequipped_items_by_name: Dict[str, List[models.CharacterInventoryItem]] = {}

    for inv_item_orm in inventory_items_orm:
        if not inv_item_orm.equipped:
            temp_backpack_map[current_backpack_idx] = inv_item_orm
            current_backpack_idx += 1
            item_name_lower = inv_item_orm.item.name.lower()
            if item_name_lower not in unequipped_items_by_name:
                unequipped_items_by_name[item_name_lower] = []
            unequipped_items_by_name[item_name_lower].append(inv_item_orm)

    found_inv_item_entry: Optional[models.CharacterInventoryItem] = None
    
    try:
        ref_num = int(item_ref_str)
        if ref_num in temp_backpack_map:
            found_inv_item_entry = temp_backpack_map[ref_num]
    except ValueError:
        matching_items = unequipped_items_by_name.get(item_ref_str.lower())
        if matching_items:
            found_inv_item_entry = matching_items[0]
            if len(matching_items) > 1:
                preliminary_message = f"(You have multiple unequipped '{matching_items[0].item.name}'. Equipping the first one found.)\n"
    
    if found_inv_item_entry:
        _, equip_message_crud = crud.crud_character_inventory.equip_item_from_inventory(
            context.db, character_id=context.active_character.id,
            inventory_item_id=found_inv_item_entry.id, target_slot=target_slot_arg
        )
        message_to_player = (preliminary_message or "") + equip_message_crud
    else:
        message_to_player = f"You don't have an unequipped item matching '{item_ref_str}'."
        
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_unequip(context: CommandContext) -> schemas.CommandResponse:
    # ... (Similar migration of unequip logic using context.args for target_to_unequip_str)
    message_to_player: Optional[str] = None
    preliminary_message: Optional[str] = None
    target_to_unequip_str = " ".join(context.args).strip()

    if not target_to_unequip_str:
        message_to_player = "Unequip/Uneq what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    )
    found_inv_item_entry: Optional[models.CharacterInventoryItem] = None
    
    for slot_key_iter, slot_display_iter in EQUIPMENT_SLOTS.items():
        if target_to_unequip_str.lower() == slot_key_iter.lower() or target_to_unequip_str.lower() == slot_display_iter.lower():
            for inv_item in inventory_items_orm:
                if inv_item.equipped and inv_item.equipped_slot == slot_key_iter:
                    found_inv_item_entry = inv_item
                    break
            if found_inv_item_entry: break
    
    if not found_inv_item_entry:
        equipped_items_by_name: Dict[str, List[models.CharacterInventoryItem]] = {}
        for inv_item in inventory_items_orm:
            if inv_item.equipped:
                item_name_lower = inv_item.item.name.lower()
                if item_name_lower not in equipped_items_by_name: equipped_items_by_name[item_name_lower] = []
                equipped_items_by_name[item_name_lower].append(inv_item)
        matching_equipped_items = equipped_items_by_name.get(target_to_unequip_str.lower())
        if matching_equipped_items:
            found_inv_item_entry = matching_equipped_items[0] 
            if len(matching_equipped_items) > 1:
                 preliminary_message = f"(Multiple items named '{matching_equipped_items[0].item.name}' somehow equipped. Unequipping one.)\n"

    if found_inv_item_entry:
        _, unequip_message_crud = crud.crud_character_inventory.unequip_item_to_inventory(
            context.db, character_id=context.active_character.id, inventory_item_id=found_inv_item_entry.id
        )
        message_to_player = (preliminary_message or "") + unequip_message_crud
    else:
        message_to_player = f"You don't have an item equipped matching '{target_to_unequip_str}'."
    
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_drop(context: CommandContext) -> schemas.CommandResponse:
    # ... (Migrate drop logic using context.args for item_ref_to_drop)
    message_to_player: Optional[str] = None
    preliminary_message: Optional[str] = None
    item_ref_to_drop = " ".join(context.args).strip()

    if not item_ref_to_drop:
        message_to_player = "Drop what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    char_inventory_orm = crud.crud_character_inventory.get_character_inventory(context.db, character_id=context.active_character.id)
    temp_backpack_map: Dict[int, models.CharacterInventoryItem] = {}
    current_backpack_idx = 1
    backpack_items_by_name_lower: Dict[str, List[models.CharacterInventoryItem]] = {}
    for inv_item_orm in char_inventory_orm:
        if not inv_item_orm.equipped:
            temp_backpack_map[current_backpack_idx] = inv_item_orm
            current_backpack_idx += 1
            item_name_lower = inv_item_orm.item.name.lower()
            if item_name_lower not in backpack_items_by_name_lower: backpack_items_by_name_lower[item_name_lower] = []
            backpack_items_by_name_lower[item_name_lower].append(inv_item_orm)

    item_to_drop_instance: Optional[models.CharacterInventoryItem] = None
    try:
        ref_num = int(item_ref_to_drop)
        if ref_num in temp_backpack_map: item_to_drop_instance = temp_backpack_map[ref_num]
    except ValueError:
        matching_items = backpack_items_by_name_lower.get(item_ref_to_drop.lower())
        if matching_items:
            item_to_drop_instance = matching_items[0]
            if len(matching_items) > 1: preliminary_message = f"(Dropping one of multiple '{matching_items[0].item.name}'.)\n"
    
    if not item_to_drop_instance:
        message_to_player = f"You don't have '{item_ref_to_drop}' in your backpack."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    _, removal_msg = crud.crud_character_inventory.remove_item_from_character_inventory(
        context.db, inventory_item_id=item_to_drop_instance.id, quantity_to_remove=item_to_drop_instance.quantity
    )
    if "Error" in removal_msg or "Cannot" in removal_msg : message_to_player = removal_msg
    else:
        _, drop_msg_room = crud.crud_room_item.add_item_to_room(
            context.db, room_id=context.current_room_orm.id, item_id=item_to_drop_instance.item_id,
            quantity=item_to_drop_instance.quantity, dropped_by_character_id=context.active_character.id
        )
        message_to_player = (preliminary_message or "") + f"You drop {item_to_drop_instance.item.name}. ({drop_msg_room})"
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_get(context: CommandContext) -> schemas.CommandResponse:
    # ... (Migrate get logic using context.args for item_ref_to_get)
    message_to_player: Optional[str] = None
    preliminary_message: Optional[str] = None
    item_ref_to_get = " ".join(context.args).strip()

    if not item_ref_to_get:
        message_to_player = "Get what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
    temp_ground_map: Dict[int, models.RoomItemInstance] = {}
    current_ground_idx = 1
    ground_items_by_name_lower: Dict[str, List[models.RoomItemInstance]] = {}
    for room_item_inst_orm in items_on_ground_orm:
        temp_ground_map[current_ground_idx] = room_item_inst_orm
        current_ground_idx += 1
        if room_item_inst_orm.item:
            item_name_lower = room_item_inst_orm.item.name.lower()
            if item_name_lower not in ground_items_by_name_lower: ground_items_by_name_lower[item_name_lower] = []
            ground_items_by_name_lower[item_name_lower].append(room_item_inst_orm)

    item_to_get_instance: Optional[models.RoomItemInstance] = None
    try:
        ref_num = int(item_ref_to_get)
        if ref_num in temp_ground_map: item_to_get_instance = temp_ground_map[ref_num]
    except ValueError:
        matching_items = ground_items_by_name_lower.get(item_ref_to_get.lower())
        if matching_items:
            item_to_get_instance = matching_items[0]
            if len(matching_items) > 1: preliminary_message = f"(Getting one of multiple '{matching_items[0].item.name}'.)\n"
    
    if not item_to_get_instance:
        message_to_player = f"No '{item_ref_to_get}' on the ground here."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    _, removal_msg = crud.crud_room_item.remove_item_from_room(
        context.db, room_item_instance_id=item_to_get_instance.id, quantity_to_remove=item_to_get_instance.quantity
    )
    if "Error" in removal_msg or "not found" in removal_msg: message_to_player = removal_msg
    else:
        _, add_msg_inv = crud.crud_character_inventory.add_item_to_character_inventory(
            context.db, character_id=context.active_character.id, item_id=item_to_get_instance.item_id,
            quantity=item_to_get_instance.quantity
        )
        if "Error" in add_msg_inv or "Cannot" in add_msg_inv:
            message_to_player = (preliminary_message or "") + f"You pick up {item_to_get_instance.item.name}, but {add_msg_inv.lower()}"
            # TODO: Re-drop item if add to inventory fails
        else:
            message_to_player = (preliminary_message or "") + f"You pick up {item_to_get_instance.item.name}. ({add_msg_inv})"
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/inventory_parser.py ---

--- START OF FILE backend/app/commands/meta_parser.py ---
# backend/app/commands/meta_parser.py
from app import schemas # app.
from .command_args import CommandContext # app.commands.command_args

async def handle_help(context: CommandContext) -> schemas.CommandResponse:
    help_message_lines = [
        "Available commands:",            
        "  Movement: north (n), south (s), east (e), west (w), up (u), down (d), go <dir>.",
        "  look [target]                - Shows description of location, items on ground,",
        "                                 or an item in your inventory.",
        "  attack (atk, kill) <target>  - Attack a creature in the room.",
        "  inventory (i)                - Shows your inventory (backpack items are numbered).",
        "  equip (eq) <item/num> [slot] - Equips an item (e.g. 'eq Dagger 1 main_hand').", 
        "  unequip (uneq) <item/slot>   - Unequips an item (e.g. 'uneq head').",
        "  drop <item/num>              - Drops an item from your backpack to the ground.", 
        "  get (take) <item/num>        - Picks up an item from the ground.",
        "  fart                         - Express yourself.",
        "  help (?)                     - Shows this help message.",
        "  giveme <item_name>           - DEBUG: Gives you an item.",
    ]
    message_to_player = "\n".join(help_message_lines)
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/meta_parser.py ---

--- START OF FILE backend/app/commands/debug_parser.py ---
# backend/app/commands/debug_parser.py
from app import schemas, crud # app.
from .command_args import CommandContext # app.commands.command_args

async def handle_giveme(context: CommandContext) -> schemas.CommandResponse:
    message_to_player = "Debug: giveme what? (e.g., 'giveme Rusty Sword')"
    if context.args:
        item_name_to_give = " ".join(context.args).strip()
        item_template = crud.crud_item.get_item_by_name(context.db, name=item_name_to_give)
        if item_template:
            _, add_message = crud.crud_character_inventory.add_item_to_character_inventory(
                context.db, character_id=context.active_character.id, item_id=item_template.id, quantity=1
            )
            message_to_player = add_message
        else:
            message_to_player = f"Debug: Item template '{item_name_to_give}' not found."
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

async def handle_spawnmob(context: CommandContext) -> schemas.CommandResponse:
    message_to_player = "Debug: spawnmob <mob_template_name>"
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # CORRECTED: Join all args to get the full mob template name
    mob_template_name = " ".join(context.args).strip()
    
    if not mob_template_name: # Handle if args were just spaces
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Debug: Please specify a mob template name.")


    target_room_id = context.current_room_orm.id # Default to current room

    mob_template = crud.crud_mob.get_mob_template_by_name(context.db, name=mob_template_name)
    if not mob_template:
        message_to_player = f"Debug: Mob template '{mob_template_name}' not found."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    spawned_mob = crud.crud_mob.spawn_mob_in_room(
        db=context.db,
        room_id=target_room_id,
        mob_template_id=mob_template.id
    )

    if spawned_mob:
        # Ensure mob_template is loaded on spawned_mob if not already by relationship default
        # For display, it's good to have it. spawned_mob.mob_template.name
        mob_display_name = spawned_mob.mob_template.name if spawned_mob.mob_template else mob_template_name
        message_to_player = f"Debug: Spawned '{mob_display_name}' (ID: {spawned_mob.id}) in current room."
    else:
        message_to_player = f"Debug: Failed to spawn '{mob_template_name}'."
        
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/debug_parser.py ---

--- START OF FILE backend/app/api/v1/endpoints/command.py ---
# backend/app/api/v1/endpoints/command.py
from fastapi import APIRouter, Depends, Body
from sqlalchemy.orm import Session
from typing import Dict, Callable, Awaitable # For typing the registry

from app import schemas, models, crud # app.
from app.db.session import get_db
from app.api.dependencies import get_current_active_character # app.api.dependencies
from app.commands.command_args import CommandContext # app.commands.command_args

# Import handler modules
from app.commands import movement_parser
from app.commands import inventory_parser
from app.commands import social_parser
from app.commands import debug_parser
from app.commands import meta_parser
# from app.commands import combat_parser 

router = APIRouter()

# Define the type for our handler functions
CommandHandler = Callable[[CommandContext], Awaitable[schemas.CommandResponse]] # If handlers are async
# Or if synchronous: CommandHandler = Callable[[CommandContext], schemas.CommandResponse]
# Let's assume handlers can be async for future flexibility, even if current ones are not.

COMMAND_REGISTRY: Dict[str, CommandHandler] = {
    # Movement and Perception
    "look": movement_parser.handle_look,
    "l": movement_parser.handle_look,
    "north": movement_parser.handle_move,
    "n": movement_parser.handle_move,
    "south": movement_parser.handle_move,
    "s": movement_parser.handle_move,
    "east": movement_parser.handle_move,
    "e": movement_parser.handle_move,
    "west": movement_parser.handle_move,
    "w": movement_parser.handle_move,
    "up": movement_parser.handle_move,
    "u": movement_parser.handle_move,
    "down": movement_parser.handle_move,
    "d": movement_parser.handle_move,
    "go": movement_parser.handle_move, # "go north" will be handled by move knowing original command

    # Inventory Management
    "inventory": inventory_parser.handle_inventory,
    "i": inventory_parser.handle_inventory,
    "equip": inventory_parser.handle_equip,
    "eq": inventory_parser.handle_equip,
    "unequip": inventory_parser.handle_unequip,
    "uneq": inventory_parser.handle_unequip,
    "drop": inventory_parser.handle_drop,
    "get": inventory_parser.handle_get,
    "take": inventory_parser.handle_get,

    # Combat >>> moved to websockets
    # "attack": combat_parser.handle_attack, 
    # "atk": combat_parser.handle_attack,    
    # "kill": combat_parser.handle_attack,    

    # Social
    "fart": social_parser.handle_fart,

    # Debug
    "giveme": debug_parser.handle_giveme,
    "spawnmob": debug_parser.handle_spawnmob,

    # Meta
    "help": meta_parser.handle_help,
    "?": meta_parser.handle_help,
}

@router.post("", response_model=schemas.CommandResponse)
async def process_command_for_character(
    payload: schemas.CommandRequest = Body(...),
    db: Session = Depends(get_db),
    active_character: models.Character = Depends(get_current_active_character)
):
    original_command_text = payload.command.strip()
    if not original_command_text:
        return schemas.CommandResponse(message_to_player="Please type a command.")

    command_parts = original_command_text.split()
    command_verb = command_parts[0].lower()
    args = command_parts[1:]

    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    if not current_room_orm:
        return schemas.CommandResponse(message_to_player="CRITICAL ERROR: Character in void.")
    current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)

    context = CommandContext(
        db=db, active_character=active_character, current_room_orm=current_room_orm,
        current_room_schema=current_room_schema, original_command=original_command_text,
        command_verb=command_verb, args=args
    )

    handler = COMMAND_REGISTRY.get(command_verb)
    if handler:
        return await handler(context)
    else:
        # If command is an attack verb, suggest using game interface (implying WS)
        if command_verb in ["attack", "atk", "kill", "kil", "ki", "k"]:
             return schemas.CommandResponse(
                room_data=current_room_schema,
                message_to_player=f"Combat actions like '{command_verb}' are handled in real-time. (Use game interface)"
            )
        return schemas.CommandResponse(
            room_data=current_room_schema,
            message_to_player=f"I don't understand the command: '{original_command_text}'. Type 'help' or '?'."
        )
--- END OF FILE backend/app/api/v1/endpoints/command.py ---

--- START OF FILE backend/app/models/player.py ---
# backend/app/models/player.py
import uuid
from typing import Optional, List # List for future relationship typing

from sqlalchemy import Column, String # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship # Import Mapped, mapped_column

from ..db.base_class import Base

class Player(Base):
    __tablename__ = "players"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)

    # --- Relationships (Example for future) ---
    # If a Player can have multiple Characters:
    # characters: Mapped[List["Character"]] = relationship(back_populates="owner")
    # Note: Use "Character" as a string if Character class is defined later or in another file to avoid circular imports.

    def __repr__(self) -> str:
        return f"<Player(id={self.id}, username='{self.username}')>"
--- END OF FILE backend/app/models/player.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Optional, List, TYPE_CHECKING # Added List, TYPE_CHECKING

from sqlalchemy import Column, String, ForeignKey
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player # For type hint if using string before
    from .room import Room   # For type hint if using string before
    from .character_inventory_item import CharacterInventoryItem # <<< ADDED

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer")

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)

    # --- Inventory Relationship --- (<<< ADDED)
    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character", 
        cascade="all, delete-orphan" # If character is deleted, their inventory items are also deleted.
    )
    
    # --- Relationships (Example with Mapped type hints) ---
    # owner: Mapped["Player"] = relationship(back_populates="characters") 
    # current_room: Mapped["Room"] = relationship()

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', player_id='{self.player_id}')>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/schemas/player.py ---
# backend/app/schemas/player.py
from typing import Optional
import uuid
from pydantic import BaseModel, Field, EmailStr # EmailStr if you add email later

class PlayerBase(BaseModel):
    username: Optional[str] = Field(None, min_length=3, max_length=100)
    # email: Optional[EmailStr] = None # Example for later

class PlayerCreate(PlayerBase):
    username: str = Field(..., min_length=3, max_length=100) # type: ignore[override] # Make username required
    password: str = Field(..., min_length=8) # Plain password for creation

class PlayerUpdate(PlayerBase): # Not used yet, but for completeness
    username: Optional[str] = None
    password: Optional[str] = None # For password change functionality

class PlayerInDBBase(PlayerBase):
    id: uuid.UUID
    # hashed_password should not be in schemas returned to client

    class Config:
        from_attributes = True

class Player(PlayerInDBBase): # Schema for returning player info (without password)
    pass

class PlayerInDB(PlayerInDBBase): # More complete internal representation if needed
    hashed_password: str
--- END OF FILE backend/app/schemas/player.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$") # Alphanumeric + underscore
    class_name: Optional[str] = Field("Adventurer", max_length=50) # Default class

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # We'll need player_id to associate with a player account.
    # For now, the API endpoint will get this, not necessarily from client for this simple version.
    # Client just sends name and class_name.
    pass
    # player_id: uuid.UUID # This would be set by the backend service
    # initial_room_id: uuid.UUID # This would also be set by the backend service

# Properties to receive on character update (not used yet)
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None # For movement

# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass # For now, same as CharacterInDBBase

# Properties stored in DB (if different, e.g. including more internal fields)
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/crud/crud_player.py ---
# backend/app/crud/crud_player.py
from sqlalchemy.orm import Session
import uuid # Ensure uuid is imported
from typing import Optional

from .. import models, schemas # models.Player, schemas.PlayerCreate etc.
from ..core.security import get_password_hash # Our password hashing utility

def get_player(db: Session, player_id: uuid.UUID) -> Optional[models.Player]:
    return db.query(models.Player).filter(models.Player.id == player_id).first()

def get_player_by_username(db: Session, username: str) -> Optional[models.Player]:
    return db.query(models.Player).filter(models.Player.username == username).first()

def create_player(db: Session, *, player_in: schemas.PlayerCreate) -> models.Player:
    hashed_password = get_password_hash(player_in.password)
    # Create a dictionary for the DB model, excluding the plain password
    db_player_data = player_in.model_dump(exclude={'password'})
    db_player = models.Player(**db_player_data, hashed_password=hashed_password)
    
    db.add(db_player)
    db.commit()
    db.refresh(db_player)
    return db_player
--- END OF FILE backend/app/crud/crud_player.py ---

--- START OF FILE backend/app/crud/crud_character.py ---
# backend/app/crud/crud_character.py
from sqlalchemy.orm import Session
import uuid
from typing import Optional, List

from .. import models, schemas # models.Character, schemas.CharacterCreate etc.

def get_character(db: Session, character_id: uuid.UUID) -> Optional[models.Character]:
    return db.query(models.Character).filter(models.Character.id == character_id).first()

def get_character_by_name(db: Session, name: str) -> Optional[models.Character]:
    return db.query(models.Character).filter(models.Character.name == name).first()

def get_characters_by_player(db: Session, player_id: uuid.UUID, skip: int = 0, limit: int = 100) -> List[models.Character]:
    return db.query(models.Character).filter(models.Character.player_id == player_id).offset(skip).limit(limit).all()

def create_character(
    db: Session, *, 
    character_in: schemas.CharacterCreate, 
    player_id: uuid.UUID, 
    initial_room_id: uuid.UUID
) -> models.Character:
    """
    Create a new character.
    'player_id' and 'initial_room_id' are provided by the service layer, not directly from client request model.
    """
    # Create a dictionary from the Pydantic model
    db_character_data = character_in.model_dump()
    
    db_character = models.Character(
        **db_character_data, 
        player_id=player_id, 
        current_room_id=initial_room_id
    )
    
    db.add(db_character)
    db.commit()
    db.refresh(db_character)
    return db_character

def update_character_room(db: Session, character_id: uuid.UUID, new_room_id: uuid.UUID) -> Optional[models.Character]:
    """
    Updates the character's current room.
    """
    db_character = get_character(db, character_id=character_id)
    if db_character:
        # Use SQLAlchemy's update mechanism to modify the current_room_id
        db.query(models.Character).filter(models.Character.id == character_id).update(
            {models.Character.current_room_id: new_room_id}
        )
        db.commit()
        db.refresh(db_character)
        return db_character
    return None
--- END OF FILE backend/app/crud/crud_character.py ---

--- START OF FILE backend/app/api/v1/endpoints/character.py ---
# backend/app/api/v1/endpoints/character.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from sqlalchemy.orm import Session
import uuid
from typing import Any, List

from .... import schemas, crud, models
from ....db.session import get_db
# from ....crud.crud_room import get_room_by_coords # No longer needed for this file directly if only used in create
from ....api.dependencies import get_current_player
from ....game_state import active_game_sessions # <<< ADDED THIS IMPORT

router = APIRouter()


@router.post("/create", response_model=schemas.Character, status_code=status.HTTP_201_CREATED)
def create_new_character_for_current_player(
    *,
    db: Session = Depends(get_db),
    character_payload: schemas.CharacterCreate = Body(...),
    current_player: models.Player = Depends(get_current_player)
) -> Any:
    """
    Create a new character for the currently authenticated player.
    Places the character in the starting room (0,0,0).
    """
    existing_character = crud.crud_character.get_character_by_name(db, name=character_payload.name)
    if existing_character:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"A character with the name '{character_payload.name}' already exists."
        )
    
    start_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0) # Moved import to top level
    if not start_room_orm:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Starting room not found. Cannot create character. Server misconfiguration."
        )
    
    character = crud.crud_character.create_character(
        db, 
        character_in=character_payload,
        player_id=current_player.id,
        initial_room_id=start_room_orm.id
    )
    
    print(f"Character '{character.name}' created for player '{current_player.username}', starting in room '{start_room_orm.name}'.")
    return character


@router.get("/mine", response_model=List[schemas.Character])
def read_characters_for_current_player(
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
):
    """
    Retrieve all characters for the currently authenticated player.
    """
    characters = crud.crud_character.get_characters_by_player(db, player_id=current_player.id)
    return characters


@router.post("/{character_id}/select", response_model=schemas.RoomInDB) # <<< NEW ENDPOINT
def select_character_for_session(
    *,
    db: Session = Depends(get_db),
    character_id: uuid.UUID,
    current_player: models.Player = Depends(get_current_player)
) -> Any:
    """
    Selects a character to be the active character for the player's session.
    Returns the character's current room data.
    """
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Character with ID {character_id} not found."
        )
    
    if character.player_id != current_player.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Operation not permitted: This character does not belong to you."
        )

    # Set this character as active for the player's session
    active_game_sessions[current_player.id] = character.id
    
    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    if not current_room_orm:
        active_game_sessions.pop(current_player.id, None) # Clean up inconsistent state
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Character '{character.name}' (ID: {character.id}) is in an invalid room (ID: {character.current_room_id}). Data integrity error. Session not started."
        )
    
    print(f"Player '{current_player.username}' (ID: {current_player.id}) selected character '{character.name}' (ID: {character.id}).")
    print(f"Active sessions: {active_game_sessions}") # For debugging
    return current_room_orm # FastAPI will convert ORM to schemas.RoomInDB
--- END OF FILE backend/app/api/v1/endpoints/character.py ---

--- START OF FILE backend/app/models/mob_template.py ---
# backend/app/models/mob_template.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import String, Text, Integer # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class MobTemplate(Base):
    __tablename__ = "mob_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    mob_type: Mapped[Optional[str]] = mapped_column(String(50), index=True, nullable=True, comment="e.g., beast, humanoid, undead")
    
    base_health: Mapped[int] = mapped_column(Integer, nullable=False, default=10)
    # For base_attack, simple string for now. Could be JSON for more complex attacks.
    base_attack: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., 1d6") 
    base_defense: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=10, comment="e.g., Armor Class")
    
    xp_value: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    # loot_table_id: Mapped[Optional[uuid.UUID]] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("loot_tables.id"), nullable=True) # Future
    loot_table_ref: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, comment="Placeholder for loot table reference")

    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'aggression': 'neutral', 'faction': 'rats'}")
    level: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)

    # room_instances: Mapped[List["RoomMobInstance"]] = relationship(back_populates="mob_template") # If needed

    def __repr__(self) -> str:
        return f"<MobTemplate(id={self.id}, name='{self.name}')>"
--- END OF FILE backend/app/models/mob_template.py ---

--- START OF FILE backend/app/models/room_mob_instance.py ---
# backend/app/models/room_mob_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room import Room # noqa: F401
    from .mob_template import MobTemplate # noqa: F401

class RoomMobInstance(Base):
    __tablename__ = "room_mob_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    mob_template_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_templates.id"), index=True, nullable=False)
    
    current_health: Mapped[int] = mapped_column(Integer, nullable=False) # Initialized from template's base_health
    
    # Optional: if this instance has different properties than the mob template
    instance_properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    
    spawned_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_action_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True) # For AI ticks

    # Relationships
    room: Mapped["Room"] = relationship(back_populates="mobs_in_room")
    mob_template: Mapped["MobTemplate"] = relationship(lazy="joined") # Eager load template details

    def __repr__(self) -> str:
        return f"<RoomMobInstance(id={self.id}, room_id='{self.room_id}', template_id='{self.mob_template_id}', hp={self.current_health})>"
--- END OF FILE backend/app/models/room_mob_instance.py ---

--- START OF FILE backend/app/schemas/mob.py ---
# backend/app/schemas/mob.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- MobTemplate Schemas ---
class MobTemplateBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    mob_type: Optional[str] = None
    base_health: int = Field(10, gt=0)
    base_attack: Optional[str] = "1d4"
    base_defense: Optional[int] = 10
    xp_value: int = 0
    loot_table_ref: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    level: Optional[int] = None

class MobTemplateCreate(MobTemplateBase):
    pass

class MobTemplateUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    mob_type: Optional[str] = None
    base_health: Optional[int] = Field(None, gt=0)
    base_attack: Optional[str] = None
    base_defense: Optional[int] = None
    xp_value: Optional[int] = None
    loot_table_ref: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    level: Optional[int] = None

class MobTemplateInDBBase(MobTemplateBase):
    id: uuid.UUID
    class Config:
        from_attributes = True

class MobTemplate(MobTemplateInDBBase): # For returning template info
    pass


# --- RoomMobInstance Schemas ---
class RoomMobInstanceBase(BaseModel):
    mob_template_id: uuid.UUID
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None

class RoomMobInstanceCreate(BaseModel): # For service layer use
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    # current_health typically set from template by service

class RoomMobInstanceUpdate(BaseModel): # For combat updates
    current_health: Optional[int] = None
    instance_properties_override: Optional[Dict[str, Any]] = Field(None, description="Use with caution, replaces entire dict")

class RoomMobInstanceInDBBase(BaseModel): # Note: Not inheriting from RoomMobInstanceBase to control field order for MobTemplate
    id: uuid.UUID
    room_id: uuid.UUID
    mob_template_id: uuid.UUID # Keep this for reference
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None
    spawned_at: datetime
    last_action_at: Optional[datetime] = None
    
    mob_template: MobTemplate # Include full mob template details

    class Config:
        from_attributes = True

class RoomMobInstance(RoomMobInstanceInDBBase): # For returning to client
    pass

# Schema for displaying mobs in a room (could be part of a larger RoomDetail schema)
class RoomMobsView(BaseModel):
    mobs_in_room: List[RoomMobInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/mob.py ---

--- START OF FILE backend/app/crud/crud_mob.py ---
# backend/app/crud/crud_mob.py
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import Dict, List, Optional, Tuple

from .. import models, schemas, crud

# --- MobTemplate CRUD ---
def get_mob_template(db: Session, mob_template_id: uuid.UUID) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.id == mob_template_id).first()

def get_mob_template_by_name(db: Session, name: str) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.name == name).first()

def get_mob_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.MobTemplate]:
    return db.query(models.MobTemplate).offset(skip).limit(limit).all()

def create_mob_template(db: Session, *, template_in: schemas.MobTemplateCreate) -> models.MobTemplate:
    db_template = models.MobTemplate(**template_in.model_dump())
    db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

# --- RoomMobInstance CRUD ---
def get_room_mob_instance(db: Session, room_mob_instance_id: uuid.UUID) -> Optional[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template) # Eager load template
    ).filter(models.RoomMobInstance.id == room_mob_instance_id).first()

def get_mobs_in_room(db: Session, room_id: uuid.UUID) -> List[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template)
    ).filter(models.RoomMobInstance.room_id == room_id).all()

def spawn_mob_in_room(
    db: Session, *, 
    room_id: uuid.UUID, 
    mob_template_id: uuid.UUID,
    instance_properties_override: Optional[Dict] = None
) -> Optional[models.RoomMobInstance]:
    template = get_mob_template(db, mob_template_id)
    if not template:
        print(f"Error: Mob template ID {mob_template_id} not found for spawning.")
        return None
    
    room = db.query(models.Room).filter(models.Room.id == room_id).first()
    if not room:
        print(f"Error: Room ID {room_id} not found for spawning mob.")
        return None

    mob_instance = models.RoomMobInstance(
        room_id=room_id,
        mob_template_id=mob_template_id,
        current_health=template.base_health, # Initialize health from template
        instance_properties_override=instance_properties_override
    )
    db.add(mob_instance)
    db.commit()
    db.refresh(mob_instance)
    # Manually load mob_template if not automatically loaded by refresh with relationship
    # db.refresh(mob_instance, attribute_names=['mob_template']) # Or rely on lazy="joined"
    return mob_instance

def despawn_mob_from_room(db: Session, room_mob_instance_id: uuid.UUID) -> bool:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance:
        db.delete(instance)
        db.commit()
        return True
    return False

def update_mob_instance_health(
    db: Session, room_mob_instance_id: uuid.UUID, change_in_health: int
) -> Optional[models.RoomMobInstance]:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance:
        instance.current_health += change_in_health
        # Basic health clamping, can be more sophisticated (e.g. death on <=0)
        if instance.current_health < 0:
            instance.current_health = 0 
        # Max health check if applicable (e.g. instance.mob_template.base_health)
        # if instance.current_health > instance.mob_template.base_health:
        #     instance.current_health = instance.mob_template.base_health
            
        db.add(instance)
        db.commit()
        db.refresh(instance)
        return instance
    return None

# --- Seeding Initial Mob Templates ---
INITIAL_MOB_TEMPLATES = [
    {
        "name": "Giant Rat", "description": "A filthy rat, surprisingly large and aggressive.",
        "mob_type": "beast", "base_health": 8, "base_attack": "1d4", "base_defense": 11,
        "xp_value": 5, "properties": {"aggression": "aggressive_if_approached"}, "level": 1
    },
    {
        "name": "Goblin Scout", "description": "A small, green-skinned humanoid with beady eyes and a rusty dagger.",
        "mob_type": "humanoid", "base_health": 12, "base_attack": "1d6", "base_defense": 13,
        "xp_value": 10, "properties": {"aggression": "aggressive_on_sight", "faction": "goblins"}, "level": 1
    },
]

def seed_initial_mob_templates(db: Session):
    print("Attempting to seed initial mob templates...")
    seeded_count = 0
    for template_data in INITIAL_MOB_TEMPLATES:
        existing = get_mob_template_by_name(db, name=template_data["name"])
        if not existing:
            print(f"  Creating mob template: {template_data['name']}")
            create_mob_template(db, template_in=schemas.MobTemplateCreate(**template_data))
            seeded_count += 1
        else:
            print(f"  Mob template '{template_data['name']}' already exists.")
    if seeded_count > 0:
        print(f"Seeded {seeded_count} new mob templates.")
    print("Mob template seeding complete.")

# --- Spawning Mobs on Startup (Example) ---
def seed_initial_mob_spawns(db: Session):
    print("Attempting to seed initial mob spawns...")
    # Example: Spawn a Giant Rat in the Genesis Room (0,0,0) if it's empty of rats
    genesis_room = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0)
    rat_template = get_mob_template_by_name(db, name="Giant Rat")

    if genesis_room and rat_template:
        # Check if a rat of this template already exists in this room to avoid over-spawning on every startup
        # This is a simple check; a real system might have max counts per room or more complex spawn rules.
        mobs_in_genesis = get_mobs_in_room(db, room_id=genesis_room.id)
        rat_already_present = any(mob.mob_template_id == rat_template.id for mob in mobs_in_genesis)

        if not rat_already_present:
            print(f"  Spawning 'Giant Rat' in '{genesis_room.name}'...")
            spawned_rat = spawn_mob_in_room(db, room_id=genesis_room.id, mob_template_id=rat_template.id)
            if spawned_rat:
                print(f"    Spawned {spawned_rat.mob_template.name} with ID {spawned_rat.id}")
        else:
            print(f"  'Giant Rat' (or similar) already present in '{genesis_room.name}'. Skipping spawn.")
    else:
        if not genesis_room: print("  Genesis room not found for mob spawning.")
        if not rat_template: print("  Giant Rat template not found for mob spawning.")
    print("Initial mob spawning process complete.")
--- END OF FILE backend/app/crud/crud_mob.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/models/character_inventory_item.py ---
# backend/app/models/character_inventory_item.py
import uuid
from typing import TYPE_CHECKING, Optional

from sqlalchemy import ForeignKey, Integer, Boolean, String
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .character import Character  # noqa: F401
    from .item import Item  # noqa: F401


class CharacterInventoryItem(Base):
    __tablename__ = "character_inventory_items"

    # Composite Primary Key: (character_id, item_id)
    # However, SQLAlchemy prefers a single surrogate primary key for association objects
    # if they have additional attributes beyond just the foreign keys.
    # Let's add an explicit id for this table for easier reference, though character_id + item_id could form a unique constraint.
    # Or, if an item can appear multiple times (e.g. two identical non-stackable swords),
    # then an auto-incrementing ID for this table row is essential.
    # Let's assume for now a character can only have ONE "entry" for a given item_id, and quantity handles multiples if stackable.
    # If not stackable, and they have two of the same sword, they'd be two separate Item instances in the Item table (e.g. with serial numbers or unique IDs anyway).
    # For our MUD, usually an Item is a "template". If a player has two "Long Sword" (same item_id), this table handles it.
    # Okay, if Item.stackable is false, each instance is a separate row here with quantity 1.
    # If Item.stackable is true, one row with quantity > 1.
    # Let's give this table its own UUID PK for simplicity in referencing a specific *instance* in inventory.

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, comment="Unique ID for this specific instance of an item in a character's inventory")
    
    character_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Indicates if this specific inventory item instance is currently equipped
    equipped: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False, index=True)
    
    # If equipped, this specifies which of the character's equipment slots it occupies.
    # This must be one of the keys from models.item.EQUIPMENT_SLOTS.
    # Necessary for items that can fit into more than one type of slot (e.g. generic 'ring' item into 'finger_1' or 'finger_2')
    # or to distinguish main_hand vs off_hand for identical weapons.
    equipped_slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="Actual character slot occupied if equipped, e.g. 'finger_1'")

    # Relationships
    character: Mapped["Character"] = relationship(back_populates="inventory_items")
    item: Mapped["Item"] = relationship() # No back_populates needed if Item doesn't need to know all its inventory entries directly

    def __repr__(self) -> str:
        return f"<CharInvItem(id={self.id}, char_id='{self.character_id}', item_id='{self.item_id}', qty={self.quantity}, equipped={self.equipped}, slot='{self.equipped_slot}')>"
--- END OF FILE backend/app/models/character_inventory_item.py ---

--- START OF FILE backend/app/models/room_item_instance.py ---
# backend/app/models/room_item_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room import Room  # noqa: F401
    from .item import Item  # noqa: F401
    from .character import Character # noqa: F401

class RoomItemInstance(Base):
    __tablename__ = "room_item_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Optional: if this instance on the ground has different properties than the item template
    properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    
    dropped_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    dropped_by_character_id: Mapped[Optional[uuid.UUID]] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), nullable=True, index=True)

    # Relationships
    room: Mapped["Room"] = relationship(back_populates="items_on_ground")
    item: Mapped["Item"] = relationship(lazy="joined") # Eager load item template details by default
    dropped_by: Mapped[Optional["Character"]] = relationship() # Character who dropped it

    def __repr__(self) -> str:
        return f"<RoomItemInstance(id={self.id}, room_id='{self.room_id}', item_id='{self.item_id}', qty={self.quantity})>"
--- END OF FILE backend/app/models/room_item_instance.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py
import uuid
from typing import Optional, Dict, List, TYPE_CHECKING # Added List, TYPE_CHECKING

from sqlalchemy import Column, Integer, String, Text, JSON
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship # Added relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance 
    from .room_mob_instance import RoomMobInstance

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    exits: Mapped[Optional[Dict[str, str]]] = mapped_column(JSON, nullable=True, default=lambda: {})

    # --- Items on Ground Relationship --- (<<< ADDED)
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan", # If room is deleted, items on ground in it are also deleted.
        lazy="selectin" # Use selectin loading for items_on_ground when a Room is loaded
    )

    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan", # If room is deleted, mobs in it are also deleted.
        lazy="selectin" 
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', x={self.x}, y={self.y}, z={self.z})>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/schemas/item.py ---
# backend/app/schemas/item.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- Item Schemas ---
class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    item_type: str = Field(..., description="e.g., weapon, armor, potion, junk")
    slot: Optional[str] = Field(None, description="Primary equippable slot type, e.g., head, main_hand, consumable")
    properties: Optional[Dict[str, Any]] = Field(None, description="e.g., {'damage': '1d6', 'armor_class': 5}")
    weight: float = Field(0.0, ge=0)
    value: int = Field(0, ge=0)
    stackable: bool = False
    max_stack_size: Optional[int] = Field(1, ge=1)

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    item_type: Optional[str] = None
    slot: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    weight: Optional[float] = None
    value: Optional[int] = None
    stackable: Optional[bool] = None
    max_stack_size: Optional[int] = None

class ItemInDBBase(ItemBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class Item(ItemInDBBase): # For returning item info
    pass

class ItemInDB(ItemInDBBase): # More complete internal representation if needed
    pass


# --- CharacterInventoryItem Schemas ---
# This represents an item *instance* in a character's inventory

class CharacterInventoryItemBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    equipped: bool = False
    equipped_slot: Optional[str] = None # Actual character slot occupied if equipped

class CharacterInventoryItemCreate(CharacterInventoryItemBase):
    # character_id will be supplied by the service/path
    pass

class CharacterInventoryItemUpdate(BaseModel):
    quantity: Optional[int] = Field(None, ge=1)
    equipped: Optional[bool] = None
    equipped_slot: Optional[str] = None

class CharacterInventoryItemInDBBase(CharacterInventoryItemBase):
    id: uuid.UUID # The unique ID of this inventory entry
    character_id: uuid.UUID
    item: Item # Include full item details when displaying inventory

    class Config:
        from_attributes = True

class CharacterInventoryItem(CharacterInventoryItemInDBBase): # For returning to client
    pass


# --- Composite Schema for Displaying Full Inventory ---
class CharacterInventoryDisplay(BaseModel):
    equipped_items: Dict[str, CharacterInventoryItem] = Field(default_factory=dict, description="Items currently equipped, keyed by their equipped_slot")
    backpack_items: List[CharacterInventoryItem] = Field(default_factory=list, description="Items in inventory but not equipped")
    # Add more fields like total_weight, currency later

class EquipRequest(BaseModel):
    target_slot: Optional[str] = Field(None, description="Optional: The specific character slot to equip the item to, e.g., 'finger_1'")
--- END OF FILE backend/app/schemas/item.py ---

--- START OF FILE backend/app/schemas/room_item.py ---
# backend/app/schemas/room_item.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any

from .item import Item # Import the Item schema for nesting

class RoomItemInstanceBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    properties_override: Optional[Dict[str, Any]] = None

class RoomItemInstanceCreate(RoomItemInstanceBase):
    # room_id will be supplied by the service/path
    # dropped_by_character_id can be optional
    dropped_by_character_id: Optional[uuid.UUID] = None

class RoomItemInstanceUpdate(BaseModel): # For potential future use
    quantity: Optional[int] = Field(None, ge=1)
    properties_override: Optional[Dict[str, Any]] = None

class RoomItemInstanceInDBBase(RoomItemInstanceBase):
    id: uuid.UUID # The unique ID of this room item instance
    room_id: uuid.UUID
    dropped_at: datetime
    dropped_by_character_id: Optional[uuid.UUID] = None
    
    item: Item # Include full item details from the Item template

    class Config:
        from_attributes = True

class RoomItemInstance(RoomItemInstanceInDBBase): # For returning to client
    pass

# Schema for displaying items in a room (could be part of a larger RoomDetail schema)
class RoomItemsView(BaseModel):
    items_on_ground: List[RoomItemInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/room_item.py ---

--- START OF FILE backend/app/schemas/room.py ---
# backend/app/schemas/room.py
from pydantic import BaseModel, Field, field_validator # field_validator for Pydantic v2
import uuid # Import uuid
from typing import Dict, Optional, Any

class RoomBase(BaseModel):
    name: str
    description: Optional[str] = None
    x: int
    y: int
    z: int
    # Exits: keys are directions (str), values are target room UUIDs (str)
    exits: Optional[Dict[str, str]] = Field(default_factory=dict) 

class RoomCreate(RoomBase):
    # id can optionally be provided if you want to set it explicitly,
    # otherwise the DB model's default=uuid.uuid4 will handle it.
    id: Optional[uuid.UUID] = None 
    # name, description, x, y, z, exits are inherited
    pass

class RoomUpdate(BaseModel): # Not heavily used yet, but good to keep consistent
    name: Optional[str] = None
    description: Optional[str] = None
    x: Optional[int] = None
    y: Optional[int] = None
    z: Optional[int] = None
    exits: Optional[Dict[str, str]] = None

class RoomInDB(RoomBase): # This schema is used for reading rooms from DB
    id: uuid.UUID # ID from DB will definitely be a UUID

    class Config:
        from_attributes = True # For Pydantic v2 ORM mode

--- END OF FILE backend/app/schemas/room.py ---

--- START OF FILE backend/app/crud/crud_item.py ---
# backend/app/crud/crud_item.py
from sqlalchemy.orm import Session
import uuid
from typing import List, Optional

from .. import models, schemas

# --- Item CRUD ---
def get_item(db: Session, item_id: uuid.UUID) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.id == item_id).first()

def get_item_by_name(db: Session, name: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.name == name).first()

def get_items(db: Session, skip: int = 0, limit: int = 100) -> List[models.Item]:
    return db.query(models.Item).offset(skip).limit(limit).all()

def create_item(db: Session, *, item_in: schemas.ItemCreate) -> models.Item:
    db_item_data = item_in.model_dump()
    db_item = models.Item(**db_item_data)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def update_item(
    db: Session, *, db_item: models.Item, item_in: schemas.ItemUpdate
) -> models.Item:
    update_data = item_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_item, field, value)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def delete_item(db: Session, *, item_id: uuid.UUID) -> Optional[models.Item]:
    db_item = db.query(models.Item).filter(models.Item.id == item_id).first()
    if db_item:
        db.delete(db_item)
        db.commit()
    return db_item

# --- Seeding Initial Items ---
INITIAL_ITEMS_TO_SEED = [
    {
        "name": "Rusty Sword", "description": "A short sword, pitted with rust. Better than nothing.",
        "item_type": "weapon", "slot": "main_hand",
        "properties": {"damage": "1d4", "type": "slashing"}, "weight": 3.0, "value": 5,
        "stackable": False, "max_stack_size": 1
    },
    {
        "name": "Cloth Tunic", "description": "Simple, patched-up clothing.",
        "item_type": "armor", "slot": "torso",
        "properties": {"armor_class": 1}, "weight": 1.0, "value": 2,
        "stackable": False, "max_stack_size": 1
    },
    {
        "name": "Minor Healing Potion", "description": "A vial of faintly glowing red liquid. Heals minor wounds.",
        "item_type": "potion", "slot": "consumable", # 'consumable' indicates it's used, not worn
        "properties": {"healing": "1d8+1", "effect": "heal_hp"}, "weight": 0.5, "value": 10,
        "stackable": True, "max_stack_size": 5
    },
    {
        "name": "Wooden Shield", "description": "A basic round wooden shield.",
        "item_type": "armor", "slot": "off_hand", # Can be equipped in off_hand
        "properties": {"armor_class": 1, "type": "shield"}, "weight": 5.0, "value": 8,
        "stackable": False, "max_stack_size": 1
    },
    {
        "name": "Dagger", "description": "A small, easily concealable dagger.",
        "item_type": "weapon", "slot": "main_hand", # Could also be 'off_hand' if dual-wielding is a thing
        "properties": {"damage": "1d4", "type": "piercing", "finesse": True}, "weight": 1.0, "value": 2,
        "stackable": False, "max_stack_size": 1
    },
]

def seed_initial_items(db: Session):
    print("Attempting to seed initial items...")
    seeded_count = 0
    for item_data in INITIAL_ITEMS_TO_SEED:
        existing_item = get_item_by_name(db, name=item_data["name"])
        if not existing_item:
            print(f"  Creating item: {item_data['name']}")
            create_item(db, item_in=schemas.ItemCreate(**item_data))
            seeded_count += 1
        else:
            print(f"  Item '{item_data['name']}' already exists.")
    if seeded_count > 0:
        print(f"Seeded {seeded_count} new items.")
    print("Item seeding complete.")
--- END OF FILE backend/app/crud/crud_item.py ---

--- START OF FILE backend/app/crud/crud_character_inventory.py ---
# backend/app/crud/crud_character_inventory.py
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import List, Optional, Tuple

from .. import models, schemas
from ..models.item import EQUIPMENT_SLOTS # For validation

# Helper to get a specific inventory entry
def get_inventory_item_entry(db: Session, inventory_item_id: uuid.UUID) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item) # Eager load item details
    ).filter(models.CharacterInventoryItem.id == inventory_item_id).first()

# Helper to get inventory entry by character_id and item_id (useful for stackable items)
def get_inventory_item_by_character_and_item_ids(
    db: Session, character_id: uuid.UUID, item_id: uuid.UUID
) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item)
    ).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.CharacterInventoryItem.item_id == item_id
    ).first()


def get_character_inventory(db: Session, character_id: uuid.UUID) -> List[models.CharacterInventoryItem]:
    """Returns all inventory item entries for a character, with item details eager loaded."""
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item) # Eager load the related Item object
    ).filter(models.CharacterInventoryItem.character_id == character_id).all()


def add_item_to_character_inventory(
    db: Session, *, character_id: uuid.UUID, item_id: uuid.UUID, quantity: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Adds an item to a character's inventory.
    If item is stackable and already exists, increases quantity.
    If item is not stackable, creates a new entry for each quantity (e.g. two rusty swords).
    Returns the created/updated inventory item entry and a message.
    """
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    
    character = db.query(models.Character).filter(models.Character.id == character_id).first()
    if not character:
        return None, "Character not found."

    if quantity <= 0:
        return None, "Quantity must be positive."

    # Handle stackable items
    if item_template.stackable:
        existing_entry = get_inventory_item_by_character_and_item_ids(db, character_id, item_id)
        if existing_entry:
            max_stack = item_template.max_stack_size or float('inf') # Should have a default
            if existing_entry.quantity + quantity <= max_stack:
                existing_entry.quantity += quantity
                db.add(existing_entry)
                db.commit()
                db.refresh(existing_entry)
                return existing_entry, f"Added {quantity} to stack of {item_template.name}."
            else:
                # Handle overflow if necessary (e.g. create new stack or error)
                return None, f"Cannot add {quantity}; exceeds max stack size of {max_stack} for {item_template.name}."
        else: # New stackable item entry
            if quantity <= (item_template.max_stack_size or float('inf')):
                new_entry = models.CharacterInventoryItem(
                    character_id=character_id,
                    item_id=item_id,
                    quantity=quantity
                )
                db.add(new_entry)
                db.commit()
                db.refresh(new_entry)
                return new_entry, f"Added {quantity} x {item_template.name} to inventory."
            else:
                return None, f"Cannot add {quantity}; exceeds max stack size for new stack of {item_template.name}."
    else: # Handle non-stackable items (create one entry per item)
        # For non-stackable, 'quantity' means add 'quantity' distinct instances.
        # We'll return the last one created for simplicity, or a list if needed.
        created_entry = None
        for _ in range(quantity):
            new_entry = models.CharacterInventoryItem(
                character_id=character_id,
                item_id=item_id,
                quantity=1 # Non-stackable always has quantity 1 per entry
            )
            db.add(new_entry)
            created_entry = new_entry # Keep track of the last one
        db.commit()
        if created_entry: # Refresh the last created entry
             db.refresh(created_entry) # Need to refresh after commit to get generated ID
        return created_entry, f"Added {quantity} x {item_template.name} (non-stackable) to inventory."


def remove_item_from_character_inventory(
    db: Session, *, inventory_item_id: uuid.UUID, quantity_to_remove: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Removes a specific quantity of an item from an inventory entry.
    If quantity becomes zero or less, the entry is deleted.
    Returns the (potentially modified) entry or None if deleted, and a message.
    """
    entry = get_inventory_item_entry(db, inventory_item_id)
    if not entry:
        return None, "Inventory item entry not found."
    
    if entry.equipped:
        return None, f"Cannot remove '{entry.item.name}'; it is currently equipped. Unequip it first."

    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = entry.item.name # Get name before potential deletion

    if entry.quantity > quantity_to_remove:
        entry.quantity -= quantity_to_remove
        db.add(entry)
        db.commit()
        db.refresh(entry)
        return entry, f"Removed {quantity_to_remove} x {original_item_name}. {entry.quantity} remaining."
    else:
        removed_qty = entry.quantity
        db.delete(entry)
        db.commit()
        return None, f"Removed all {removed_qty} x {original_item_name} from inventory."


def equip_item_from_inventory(
    db: Session, *, character_id: uuid.UUID, inventory_item_id: uuid.UUID, target_slot: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """
    Equips an item from the character's inventory to a specified slot.
    - inventory_item_id: The ID of the CharacterInventoryItem entry.
    - target_slot: The character's equipment slot (e.g., 'main_hand', 'finger_1').
                   Required if item can go in multiple slots or if slot needs disambiguation.
    """
    char_inv_entry = get_inventory_item_entry(db, inventory_item_id)

    if not char_inv_entry:
        return None, "Item not found in your inventory."
    if char_inv_entry.character_id != character_id:
        return None, "This item does not belong to you." # Should not happen with active char
    if char_inv_entry.equipped:
        return char_inv_entry, f"{char_inv_entry.item.name} is already equipped in {char_inv_entry.equipped_slot}."

    item_template = char_inv_entry.item # Already eager loaded
    if not item_template.slot or item_template.slot == "consumable": # 'slot' on item_template is its intended use type
        return None, f"{item_template.name} is not equippable in that manner."

    # Determine the actual character slot to use
    final_target_slot = target_slot
    if not final_target_slot:
        # If item's slot is directly one of EQUIPMENT_SLOTS keys, use it
        if item_template.slot in EQUIPMENT_SLOTS:
            final_target_slot = item_template.slot
        else:
            # This logic needs refinement for items fitting multiple abstract slots.
            # E.g. item.slot = "ring", target_slot could be "finger_1" or "finger_2"
            # For now, if target_slot is not given, and item.slot isn't direct, it's an error.
            return None, f"Please specify which slot to equip {item_template.name} (e.g., 'finger_1', 'finger_2' if it's a ring)."

    if final_target_slot not in EQUIPMENT_SLOTS:
        return None, f"Invalid equipment slot: '{final_target_slot}'. Valid slots are: {', '.join(EQUIPMENT_SLOTS.keys())}."

    # Check if the slot is already occupied by another item
    # (A character can't wear two helmets, etc. Rings are an exception if slots are distinct like finger_1, finger_2)
    # This includes checking for two-handed weapons taking up main_hand and off_hand (future)
    currently_equipped_in_slot = db.query(models.CharacterInventoryItem).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.CharacterInventoryItem.equipped == True,
        models.CharacterInventoryItem.equipped_slot == final_target_slot
    ).first()

    if currently_equipped_in_slot:
        return None, f"Slot '{EQUIPMENT_SLOTS[final_target_slot]}' is already occupied by {currently_equipped_in_slot.item.name}. Unequip it first."

    # All checks passed, equip the item
    char_inv_entry.equipped = True
    char_inv_entry.equipped_slot = final_target_slot
    db.add(char_inv_entry)
    db.commit()
    db.refresh(char_inv_entry)
    return char_inv_entry, f"{item_template.name} equipped to {EQUIPMENT_SLOTS[final_target_slot]}."


def unequip_item_to_inventory(
    db: Session, *, character_id: uuid.UUID, inventory_item_id: uuid.UUID
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    """Unequips an item, moving it back to the general 'backpack' part of inventory."""
    char_inv_entry = get_inventory_item_entry(db, inventory_item_id)

    if not char_inv_entry:
        return None, "Item not found in your inventory records."
    if char_inv_entry.character_id != character_id:
        return None, "This item does not belong to you."
    if not char_inv_entry.equipped or not char_inv_entry.equipped_slot:
        return char_inv_entry, f"{char_inv_entry.item.name} is not currently equipped."

    item_name = char_inv_entry.item.name
    slot_name = EQUIPMENT_SLOTS.get(char_inv_entry.equipped_slot, char_inv_entry.equipped_slot)

    char_inv_entry.equipped = False
    char_inv_entry.equipped_slot = None
    db.add(char_inv_entry)
    db.commit()
    db.refresh(char_inv_entry)
    return char_inv_entry, f"{item_name} unequipped from {slot_name}."
--- END OF FILE backend/app/crud/crud_character_inventory.py ---

--- START OF FILE backend/app/crud/crud_room_item.py ---
# backend/app/crud/crud_room_item.py
from sqlalchemy.orm import Session, joinedload
import uuid
from typing import Dict, List, Optional, Tuple

from .. import models, schemas

def get_room_item_instance(db: Session, room_item_instance_id: uuid.UUID) -> Optional[models.RoomItemInstance]:
    return db.query(models.RoomItemInstance).options(
        joinedload(models.RoomItemInstance.item) # Eager load item details
    ).filter(models.RoomItemInstance.id == room_item_instance_id).first()

def get_items_in_room(db: Session, room_id: uuid.UUID) -> List[models.RoomItemInstance]:
    """Returns all item instances on the ground in a room, with item details eager loaded."""
    return db.query(models.RoomItemInstance).options(
        joinedload(models.RoomItemInstance.item)
    ).filter(models.RoomItemInstance.room_id == room_id).all()

def add_item_to_room(
    db: Session, *, 
    room_id: uuid.UUID, 
    item_id: uuid.UUID, 
    quantity: int = 1,
    dropped_by_character_id: Optional[uuid.UUID] = None,
    properties_override: Optional[Dict] = None
) -> Tuple[Optional[models.RoomItemInstance], str]:
    """
    Adds an item instance to a room's floor.
    If item is stackable and an identical instance (same item_id, same properties_override) exists, increases quantity.
    Otherwise, creates a new RoomItemInstance entry.
    """
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    
    room = db.query(models.Room).filter(models.Room.id == room_id).first()
    if not room:
        return None, "Room not found."

    if quantity <= 0:
        return None, "Quantity must be positive."

    # For stackable items, check if an identical stack already exists on the floor
    # Identical means same item_id AND same properties_override (usually None)
    created_entry = None
    if item_template.stackable:
        existing_stack = db.query(models.RoomItemInstance).filter(
            models.RoomItemInstance.room_id == room_id,
            models.RoomItemInstance.item_id == item_id,
            models.RoomItemInstance.properties_override == properties_override # Crucial for stacking
        ).first()

        if existing_stack:
            max_stack = item_template.max_stack_size or float('inf')
            if existing_stack.quantity + quantity <= max_stack:
                existing_stack.quantity += quantity
                db.add(existing_stack)
                db.commit()
                db.refresh(existing_stack)
                return existing_stack, f"Added {quantity} to stack of {item_template.name} on the ground."
            else:
                # Create a new stack for the overflow if needed, or error.
                # For simplicity now, let's just create a new stack for the full requested quantity
                # if the existing stack would overflow. This might lead to multiple stacks of same item.
                # A more advanced logic would fill up the existing stack then create a new one for remainder.
                pass # Fall through to create a new instance for the current quantity


    # Create a new instance (either non-stackable, or new stack for stackable)
    # For non-stackable, quantity means number of distinct instances.
    # For stackable, if we reached here, it's a new stack of 'quantity'.
    
    num_instances_to_create = quantity if not item_template.stackable else 1
    actual_quantity_per_instance = 1 if not item_template.stackable else quantity
    
    if item_template.stackable and actual_quantity_per_instance > (item_template.max_stack_size or float('inf')):
        return None, f"Cannot drop stack of {actual_quantity_per_instance}; exceeds max stack size for {item_template.name}."

    for _ in range(num_instances_to_create):
        new_instance = models.RoomItemInstance(
            room_id=room_id,
            item_id=item_id,
            quantity=actual_quantity_per_instance,
            dropped_by_character_id=dropped_by_character_id,
            properties_override=properties_override
        )
        db.add(new_instance)
        created_entry = new_instance # Keep track of the last one

    db.commit()
    if created_entry:
        db.refresh(created_entry) # Ensure IDs are loaded
    
    if item_template.stackable:
         return created_entry, f"Dropped a stack of {quantity} x {item_template.name}."
    else:
         return created_entry, f"Dropped {quantity} x {item_template.name}."


def remove_item_from_room(
    db: Session, *, 
    room_item_instance_id: uuid.UUID, 
    quantity_to_remove: int = 1
) -> Tuple[Optional[models.RoomItemInstance], str]: # Returns (remaining_instance_or_None, message)
    """
    Removes a specific quantity of an item from a RoomItemInstance.
    If quantity becomes zero or less, the instance is deleted.
    """
    instance = get_room_item_instance(db, room_item_instance_id) # This already eager loads .item
    if not instance:
        return None, "Item instance not found on the ground."

    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = instance.item.name

    if instance.quantity > quantity_to_remove:
        instance.quantity -= quantity_to_remove
        db.add(instance)
        db.commit()
        db.refresh(instance)
        return instance, f"Picked up {quantity_to_remove} x {original_item_name}. {instance.quantity} remaining on ground."
    else:
        # Removing all or more than available from this specific instance
        removed_qty = instance.quantity
        db.delete(instance)
        db.commit()
        return None, f"Picked up all {removed_qty} x {original_item_name} from the ground (this stack/instance)."
--- END OF FILE backend/app/crud/crud_room_item.py ---

--- START OF FILE backend/app/crud/crud_room.py ---
# backend/app/crud/crud_room.py
from sqlalchemy.orm import Session
import uuid # Import uuid
from typing import Optional, Dict, List
from .. import models, schemas

def get_room_by_id(db: Session, room_id: uuid.UUID) -> Optional[models.Room]: # room_id is now uuid.UUID
    """
    Retrieve a room from the database by its ID (which is a UUID).
    """
    return db.query(models.Room).filter(models.Room.id == room_id).first()

def get_room_by_coords(db: Session, *, x: int, y: int, z: int) -> Optional[models.Room]:
    return db.query(models.Room).filter(
        models.Room.x == x,
        models.Room.y == y,
        models.Room.z == z
    ).first()

def create_room(db: Session, *, room_in: schemas.RoomCreate) -> models.Room:
    """
    Create a new room in the database.
    Takes a Pydantic schema RoomCreate as input.
    If room_in.id is None (typical), a new UUID will be generated by the model's default.
    If room_in.id is provided, that UUID will be used.
    Returns the created SQLAlchemy ORM model instance.
    """
    db_room_data = room_in.model_dump(exclude_unset=True) # Exclude unset to allow DB defaults like UUID
    
    # If an ID (UUID) is provided in room_in, use it. Otherwise, DB default uuid.uuid4() kicks in.
    # The model_dump already includes 'id' if it was set in room_in.
    
    db_room = models.Room(**db_room_data)
    db.add(db_room)
    db.commit()
    db.refresh(db_room)
    return db_room

# We'll need a robust way to update room exits as well, or a general update_room
def update_room(db: Session, *, db_room: models.Room, room_in: schemas.RoomUpdate) -> models.Room:
    """
    General purpose room update.
    """
    update_data = room_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_room, field, value)
    db.add(db_room)
    db.commit()
    db.refresh(db_room)
    return db_room

# --- World Seeding Logic ---
# This will be called from main.py's startup event
# We'll define 3 rooms: Genesis (0,0,0), Chilly North (0,1,0), Overlook East (1,1,0)

# Store known UUIDs for linking (these will be generated once)
# In a real app, these might be constants or looked up if seeding is idempotent.
# For simplicity, we'll generate them if rooms don't exist.
# This global dict is a temporary hack for seeding to pass UUIDs between room creations.
_SEED_ROOM_UUIDS: Dict[str, uuid.UUID] = {}

def seed_initial_world(db: Session):
    print("Attempting to seed initial world with UUIDs...")

    room_definitions = [
        {
            "coords": {"x": 0, "y": 0, "z": 0},
            "name_tag": "genesis_room", # Internal tag for _SEED_ROOM_UUIDS
            "data": schemas.RoomCreate(
                name="The UUID Genesis of Despair",
                description="This void is now uniquely identified. The walls whisper of primary keys and existential uniqueness.",
                x=0, y=0, z=0,
                exits={} # Will be populated after all rooms are created/UUIDs known
            )
        },
        {
            "coords": {"x": 0, "y": 1, "z": 0}, # North of Genesis
            "name_tag": "chilly_north_room",
            "data": schemas.RoomCreate(
                name="The Chilly UUID Corridor",
                description="A uniquely cold passage. The air hums with the vibration of countless GUIDs.",
                x=0, y=1, z=0,
                exits={}
            )
        },
        {
            "coords": {"x": 1, "y": 1, "z": 0}, # East of Chilly North
            "name_tag": "overlook_east_room",
            "data": schemas.RoomCreate(
                name="The Overlook of Minor UUID Disappointment",
                description="From this vantage point, you can see a sea of globally unique identifiers, none of them particularly exciting.",
                x=1, y=1, z=0,
                exits={}
            )
        }
    ]

    created_rooms_this_run = False
    for room_def in room_definitions:
        coords = room_def["coords"]
        name_tag = room_def["name_tag"]
        
        existing_room = get_room_by_coords(db, **coords)
        if not existing_room:
            print(f"Creating room '{room_def['data'].name}' at {coords}...")
            # If ID is needed beforehand for linking (not in this simple exits model, but good to know):
            # room_def['data'].id = uuid.uuid4() # Pre-assign UUID if needed
            # _SEED_ROOM_UUIDS[name_tag] = room_def['data'].id
            
            created_room_orm = create_room(db, room_in=room_def["data"])
            _SEED_ROOM_UUIDS[name_tag] = created_room_orm.id # type: ignore[assignment] # Store the generated UUID
            print(f"  Created '{created_room_orm.name}' with UUID: {_SEED_ROOM_UUIDS[name_tag]}")
            created_rooms_this_run = True
        else:
            print(f"Room '{existing_room.name}' at {coords} already exists with UUID: {existing_room.id}.")
            _SEED_ROOM_UUIDS[name_tag] = existing_room.id # type: ignore[assignment] # Store existing UUID

    # If any rooms were newly created OR if we want to ensure exits are always up-to-date on startup:
    # Link rooms using their known/generated UUIDs
    # For simplicity, we'll re-fetch and update exits even if rooms existed.
    # This makes the seeding idempotent for exits too.

    print("Linking room exits with UUIDs...")
    # Genesis Room (0,0,0) exits
    if "genesis_room" in _SEED_ROOM_UUIDS and "chilly_north_room" in _SEED_ROOM_UUIDS:
        genesis_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS["genesis_room"])
        if genesis_room_orm:
            new_exits = {"north": str(_SEED_ROOM_UUIDS["chilly_north_room"])}
            if genesis_room_orm.exits != new_exits: # type: ignore[operator] # Only update if changed
                print(f"  Updating Genesis room exits to: {new_exits}")
                genesis_room_orm.exits = new_exits # type: ignore[assignment]
                db.add(genesis_room_orm) # Let SQLAlchemy track the change

    # Chilly North Room (0,1,0) exits
    if "chilly_north_room" in _SEED_ROOM_UUIDS and "genesis_room" in _SEED_ROOM_UUIDS and "overlook_east_room" in _SEED_ROOM_UUIDS:
        chilly_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS["chilly_north_room"])
        if chilly_room_orm:
            new_exits = {
                "south": str(_SEED_ROOM_UUIDS["genesis_room"]),
                "east": str(_SEED_ROOM_UUIDS["overlook_east_room"])
            }
            if chilly_room_orm.exits != new_exits: # type: ignore[operator]
                print(f"  Updating Chilly North room exits to: {new_exits}")
                chilly_room_orm.exits = new_exits # type: ignore[assignment]
                db.add(chilly_room_orm)

    # Overlook East Room (1,1,0) exits
    if "overlook_east_room" in _SEED_ROOM_UUIDS and "chilly_north_room" in _SEED_ROOM_UUIDS:
        overlook_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS["overlook_east_room"])
        if overlook_room_orm:
            new_exits = {"west": str(_SEED_ROOM_UUIDS["chilly_north_room"])}
            if overlook_room_orm.exits != new_exits: # type: ignore[operator]
                print(f"  Updating Overlook East room exits to: {new_exits}")
                overlook_room_orm.exits = new_exits # type: ignore[assignment]
                db.add(overlook_room_orm)
    
    db.commit() # Commit all exit updates at once
    print("World seeding and exit linking complete.")

# Remove the old init_first_room_if_not_exists or ensure it's not called if you keep it.
# The new seed_initial_world should be called from main.py startup.
--- END OF FILE backend/app/crud/crud_room.py ---

--- START OF FILE backend/app/api/dependencies.py ---
# backend/app/api/dependencies.py
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
import uuid

from app.core.config import settings
from app import models, schemas, crud
from app.db.session import get_db
from app.game_state import active_game_sessions # <<< ADDED THIS IMPORT

reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/users/login"
)

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY

async def get_current_player(
    db: Session = Depends(get_db), token: str = Depends(reusable_oauth2)
) -> models.Player:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username_or_player_id: Optional[str] = payload.get("sub")
        if username_or_player_id is None:
            raise credentials_exception
        
        try:
            player_uuid = uuid.UUID(username_or_player_id)
        except ValueError:
            print(f"Error: Subject '{username_or_player_id}' in token is not a valid UUID.")
            raise credentials_exception
            
    except JWTError as e:
        print(f"JWTError during token decode: {e}")
        raise credentials_exception
    
    player = crud.crud_player.get_player(db, player_id=player_uuid)
    if player is None:
        raise credentials_exception
    return player

async def get_current_active_character( # <<< NEW DEPENDENCY
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
) -> models.Character:
    character_id = active_game_sessions.get(current_player.id)
    
    if not character_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, 
            detail="No active character selected for this session. Please select a character.",
        )
    
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        # This case implies data inconsistency or character deleted after selection.
        # Clear stale entry from active_game_sessions.
        active_game_sessions.pop(current_player.id, None)
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Active character with ID {character_id} not found. Session reset.",
        )

    # This check is crucial for data integrity, though selection process should ensure it.
    if character.player_id != current_player.id:
        active_game_sessions.pop(current_player.id, None) # Clear inconsistent state
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="CRITICAL: Active character's player ID does not match authenticated player. Session reset.",
        )
        
    return character
--- END OF FILE backend/app/api/dependencies.py ---

--- START OF FILE backend/app/schemas/__init__.py ---
# File: backend/app/schemas/__init__.py

# Make the Pydantic models from room.py available directly under the schemas package
from .room import RoomBase, RoomCreate, RoomUpdate, RoomInDB
from .player import PlayerBase, PlayerCreate, PlayerUpdate, Player, PlayerInDB
from .character import CharacterBase, CharacterCreate, CharacterUpdate, Character, CharacterInDB
from .command import CommandRequest, CommandResponse
from .item import (  # <<< ADDED
    ItemBase, ItemCreate, ItemUpdate, Item, ItemInDB,
    CharacterInventoryItemBase, CharacterInventoryItemCreate, CharacterInventoryItemUpdate,
    CharacterInventoryItem, CharacterInventoryDisplay, EquipRequest
)
from .room_item import ( # <<< ADDED
    RoomItemInstanceBase, RoomItemInstanceCreate, RoomItemInstanceUpdate,
    RoomItemInstance, RoomItemsView
)
from .mob import ( # <<< ADDED
    MobTemplateBase, MobTemplateCreate, MobTemplateUpdate, MobTemplate,
    RoomMobInstanceBase, RoomMobInstanceCreate, RoomMobInstanceUpdate,
    RoomMobInstance, RoomMobsView
)
--- END OF FILE backend/app/schemas/__init__.py ---

--- START OF FILE frontend/src/script.js ---
// --- script.js (Main Orchestration & Event Listeners) ---

// --- Configuration ---
const API_BASE_URL = 'https://llmud.trazen.org/api/v1'; // For HTTP calls
const WS_HOST = window.location.host;
const WS_PROTOCOL = window.location.protocol === "https:" ? "wss:" : "ws:";

// --- Global State (Conceptual - could be in a gameState.js module) ---
const gameState = {
    currentAuthToken: null,
    selectedCharacterId: null,
    selectedCharacterName: null, // Good to have for display
    loginState: 'INIT', // INIT, PROMPT_USER, PROMPT_PASSWORD, REGISTER_*, CHAR_SELECT_*, CHAR_CREATE_*, IN_GAME
    tempUsername: '',
    tempPassword: '',
    tempCharName: '',
    availableCharacters: [],
    displayedRoomId: null,
    gameSocket: null,
    isInCombat: false, // True if server indicates ongoing combat for this player
    // No need for lastCombatCommand client-side if server drives rounds
};

// --- UI Elements (Global for simplicity, could be managed by a UI module) ---
let outputDiv, commandInput, exitsDisplayDiv, promptTextSpan, inputPromptLineDiv;

// --- UI Module (Conceptual - ui.js) ---
const UI = {
    initializeElements: function () {
        outputDiv = document.getElementById('output');
        commandInput = document.getElementById('commandInput');
        exitsDisplayDiv = document.getElementById('exits-display');
        promptTextSpan = document.getElementById('prompt-text');
        inputPromptLineDiv = document.getElementById('input-prompt-line');

        if (!outputDiv || !commandInput || !exitsDisplayDiv || !promptTextSpan || !inputPromptLineDiv) {
            console.error("CRITICAL: One or more core UI elements not found!");
            document.body.innerHTML = "Error: Core UI elements missing. App cannot start.";
            return false;
        }
        return true;
    },

    setInputCommandType: function (type) {
        if (commandInput) {
            commandInput.type = type;
            if (type === 'text') {
                commandInput.setAttribute('autocomplete', 'off');
                // Or even a bogus value sometimes works better if 'off' is ignored
                // commandInput.setAttribute('autocomplete', 'nope'); 
            } else if (type === 'password') {
                // Allow browser to help with password suggestions
                commandInput.setAttribute('autocomplete', 'current-password');
            }
        }
    },

    showAppropriateView: function () {
        console.log("UI.showAppropriateView called. Current loginState:", gameState.loginState);
        if (!exitsDisplayDiv || !inputPromptLineDiv) return;

        const isGameInputState = gameState.loginState === 'IN_GAME' ||
            gameState.loginState === 'CHAR_SELECT_PROMPT' ||
            gameState.loginState === 'CHAR_CREATE_PROMPT_NAME' ||
            gameState.loginState === 'CHAR_CREATE_PROMPT_CLASS' ||
            gameState.loginState === 'PROMPT_USER' ||
            gameState.loginState === 'PROMPT_PASSWORD' ||
            gameState.loginState === 'REGISTER_PROMPT_USER' ||
            gameState.loginState === 'REGISTER_PROMPT_PASSWORD';

        exitsDisplayDiv.style.display = (gameState.loginState === 'IN_GAME') ? 'block' : 'none';
        inputPromptLineDiv.style.display = isGameInputState ? 'flex' : 'none';
    },

    appendToOutput: function (htmlContent, options = {}) {
        const { isPrompt = false, noNewLineBefore = false, noNewLineAfter = false, styleClass = '' } = options;
        if (!outputDiv) return; // Ensure outputDiv is initialized and available

        let finalContent = '';

        // Add newline before regular messages unless suppressed or it's a prompt continuing a line
        if (!isPrompt && !noNewLineBefore && outputDiv.innerHTML !== '' &&
            !outputDiv.innerHTML.endsWith('\n') && !outputDiv.innerHTML.endsWith('<br>') &&
            !outputDiv.innerHTML.endsWith(' ')) {
            finalContent += '\n';
        }

        // Space before prompt text if not starting a new line or after space
        // CORRECTED LINE:
        if (isPrompt && outputDiv.innerHTML !== '' && !outputDiv.innerHTML.endsWith(' ') &&
            !outputDiv.innerHTML.endsWith('\n') && !outputDiv.innerHTML.endsWith('<br>')) { // Was output_innerHTML
            finalContent += ' ';
        }

        if (styleClass) {
            finalContent += `<span class="${styleClass}">${htmlContent}</span>`;
        } else {
            finalContent += htmlContent;
        }

        outputDiv.innerHTML += finalContent;

        if (!isPrompt && !noNewLineAfter) {
            outputDiv.innerHTML += '\n'; // Add newline after regular messages unless suppressed
        }
        outputDiv.scrollTop = outputDiv.scrollHeight;
    },
    clearOutput: function () { if (outputDiv) outputDiv.innerHTML = ''; },
    setInputCommandPlaceholder: function (text) { if (commandInput) commandInput.placeholder = text; },
    setInputCommandType: function (type) { if (commandInput) commandInput.type = type; },

    updateExitsDisplay: function (roomData) {
        if (!exitsDisplayDiv) return;
        if (gameState.loginState === 'IN_GAME' && roomData && roomData.exits && Object.keys(roomData.exits).length > 0) {
            exitsDisplayDiv.innerHTML = '<b>Exits:</b> ' + Object.keys(roomData.exits).map(d => d.toUpperCase()).join(' | ');
        } else if (gameState.loginState === 'IN_GAME') {
            exitsDisplayDiv.innerHTML = 'Exits: (None)';
        } else {
            exitsDisplayDiv.innerHTML = '';
        }
    },

    updateGameDisplay: function (roomData) { // For room name/description
        if (!outputDiv || !roomData) return;
        UI.appendToOutput(`\n--- ${roomData.name} ---`, { styleClass: 'room-name-header' });
        UI.appendToOutput(roomData.description || "It's eerily quiet.");
    }
};

// --- API Module (Conceptual - api.js for HTTP calls) ---
const API = {
    fetchData: async function (endpoint, options = {}) {
        if (options.headers && gameState.currentAuthToken) {
            options.headers['Authorization'] = `Bearer ${gameState.currentAuthToken}`;
        } else if (gameState.currentAuthToken && !options.headers) {
            options.headers = { 'Authorization': `Bearer ${gameState.currentAuthToken}` };
        }

        const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
        const data = await response.json();
        if (!response.ok) {
            const error = new Error(data.detail || `HTTP error! status: ${response.status}`);
            error.response = response; // Attach response for further inspection if needed
            error.data = data;
            throw error;
        }
        return data;
    },

    loginUser: function (username, password) {
        return API.fetchData('/users/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({ username, password })
        });
    },
    registerUser: function (username, password) {
        return API.fetchData('/users/register', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
        });
    },
    fetchCharacters: function () {
        return API.fetchData('/character/mine');
    },
    createCharacter: function (name, className) {
        return API.fetchData('/character/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: name, class_name: className })
        });
    },
    selectCharacterOnBackend: function (characterId) {
        return API.fetchData(`/character/${characterId}/select`, { method: 'POST' });
    },
    sendHttpCommand: async function (commandText) { // For non-combat commands
        try {
            const responseData = await API.fetchData('/command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command: commandText })
            });
            GameLogic.handleHttpCommandResponse(responseData, commandText);
        } catch (error) {
            console.error("HTTP Command Error:", error);
            UI.appendToOutput(`\n! Error: ${error.message || 'Failed to send command.'}`, { styleClass: 'error-message-inline' });
            if (error.response && error.response.status === 403 && error.data && error.data.detail.toLowerCase().includes("no active character")) {
                UI.appendToOutput("! Session expired. Please select character.", { styleClass: 'error-message-inline' });
                await GameLogic.displayCharacterSelection();
            }
        }
    }
};

// --- WebSocket Module (Conceptual - websocket.js) ---
const WebSocketService = {
    connect: function () {
        if (!gameState.currentAuthToken || !gameState.selectedCharacterId) {
            UI.appendToOutput("! Cannot connect WebSocket: Missing token or character ID.", { styleClass: "error-message-inline" });
            return;
        }
        if (gameState.gameSocket && gameState.gameSocket.readyState === WebSocket.OPEN) {
            console.log("WebSocket already open.");
            return;
        }

        const wsUrl = `${WS_PROTOCOL}//${WS_HOST}/ws?token=${gameState.currentAuthToken}&character_id=${gameState.selectedCharacterId}`;
        UI.appendToOutput("Connecting to game server...");
        console.log("Attempting WS connection to:", wsUrl);
        gameState.gameSocket = new WebSocket(wsUrl);

        gameState.gameSocket.onopen = function (event) {
            console.log("WebSocket connection established.");
            // Server will send initial welcome/room data upon successful connection & auth
        };

        gameState.gameSocket.onmessage = function (event) {
            try {
                const serverData = JSON.parse(event.data);
                console.log("WS RCV:", serverData); // Log the raw data
                GameLogic.handleWebSocketMessage(serverData);
            } catch (e) {
                console.error("Error parsing WebSocket message or processing:", e);
                UI.appendToOutput(`GS (unparsed): ${event.data}`, { styleClass: "game-message" });
            }
            if (outputDiv) outputDiv.scrollTop = outputDiv.scrollHeight;
        };

        gameState.gameSocket.onerror = function (event) {
            console.error("WebSocket error observed:", event);
            UI.appendToOutput("! WebSocket connection error.", { styleClass: "error-message-inline" });
        };

        gameState.gameSocket.onclose = function (event) {
            console.log("WebSocket connection closed:", event.code, event.reason);
            UI.appendToOutput(`! Game server connection closed. (Code: ${event.code} ${event.reason || ''})`.trim(), { styleClass: "game-message" });
            gameState.gameSocket = null;
            gameState.isInCombat = false; // Reset combat state
        };
    },

    sendMessage: function (payloadObject) { // Always send JSON objects
        if (gameState.gameSocket && gameState.gameSocket.readyState === WebSocket.OPEN) {
            gameState.gameSocket.send(JSON.stringify(payloadObject));
        } else {
            UI.appendToOutput("! Cannot send command: Not connected to game server.", { styleClass: "error-message-inline" });
        }
    },

    close: function () {
        if (gameState.gameSocket && (gameState.gameSocket.readyState === WebSocket.OPEN || gameState.gameSocket.readyState === WebSocket.CONNECTING)) {
            gameState.gameSocket.close();
        }
        gameState.gameSocket = null;
    }
};

// --- Game Logic & Command Handling (Conceptual - commandHandler.js / gameLogic.js) ---
const GameLogic = {
    startLoginProcess: function () {
        gameState.loginState = 'PROMPT_USER';
        gameState.currentAuthToken = null;
        gameState.selectedCharacterId = null;
        gameState.tempUsername = '';
        gameState.availableCharacters = [];
        gameState.isInCombat = false;
        WebSocketService.close(); // Ensure WS is closed on logout/restart
        UI.showAppropriateView();
        UI.clearOutput();
        UI.appendToOutput("Welcome to The Unholy MUD of Tron & Allen1.");
        UI.appendToOutput("Version 0.0.0.0.Alpha.Pre-Shitshow");
        UI.appendToOutput("-------------------------------------------------");
        UI.appendToOutput("Username (or type 'new' to register): ", { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter username or 'new'");
        UI.setInputCommandType('text');
        if (commandInput) commandInput.focus();
    },

    promptForPassword: async function () { /* ... */ gameState.loginState = 'PROMPT_PASSWORD'; UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true }); UI.setInputCommandPlaceholder("Enter password"); UI.setInputCommandType('password'); if (commandInput) commandInput.focus(); },
    promptForRegistrationUsername: async function () { /* ... */ gameState.loginState = 'REGISTER_PROMPT_USER'; UI.appendToOutput("Registering new user."); UI.appendToOutput("Desired username: ", { isPrompt: true }); UI.setInputCommandPlaceholder("Enter desired username"); UI.setInputCommandType('text'); if (commandInput) commandInput.focus(); },
    promptForRegistrationPassword: async function () { /* ... */ gameState.loginState = 'REGISTER_PROMPT_PASSWORD'; UI.appendToOutput("Desired password (min 8 chars): ", { isPrompt: true, noNewLineBefore: true }); UI.setInputCommandPlaceholder("Enter desired password"); UI.setInputCommandType('password'); if (commandInput) commandInput.focus(); },
    promptForNewCharacterName: async function () { /* ... */ gameState.loginState = 'CHAR_CREATE_PROMPT_NAME'; UI.appendToOutput("\n--- New Character Creation ---"); UI.appendToOutput("Enter character name: ", { isPrompt: true }); UI.setInputCommandPlaceholder("Character Name (3-50 chars)"); UI.setInputCommandType('text'); if (commandInput) commandInput.focus(); },
    promptForNewCharacterClass: async function () { /* ... */ gameState.loginState = 'CHAR_CREATE_PROMPT_CLASS'; UI.appendToOutput(`Class for ${gameState.tempCharName} (e.g., Swindler) [Adventurer]: `, { isPrompt: true, noNewLineBefore: true }); UI.setInputCommandPlaceholder("Character Class (optional)"); UI.setInputCommandType('text'); if (commandInput) commandInput.focus(); },

    displayCharacterSelection: async function () {
        gameState.loginState = 'CHAR_SELECT_PROMPT';
        UI.showAppropriateView();
        if (!gameState.currentAuthToken) { UI.appendToOutput("! Auth error.", { styleClass: 'error-message-inline' }); GameLogic.handleLogout(); return; }
        UI.appendToOutput("\nFetching character list...");
        try {
            gameState.availableCharacters = await API.fetchCharacters();
            UI.appendToOutput("\n--- Character Selection ---");
            if (gameState.availableCharacters.length === 0) {
                UI.appendToOutput("No characters found.");
            } else {
                UI.appendToOutput("Your characters:");
                gameState.availableCharacters.forEach((char, index) => {
                    UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${char.name}</span> (<span class="char-class">${char.class_name}</span>)</span>`);
                });
            }
            UI.appendToOutput("Enter character #, or 'new': ", { isPrompt: true });
            UI.setInputCommandPlaceholder("Enter #, or 'new'");
        } catch (error) {
            UI.appendToOutput(`! Error fetching characters: ${error.message}`, { styleClass: 'error-message-inline' });
            if (error.response && error.response.status === 401) GameLogic.handleLogout(); else GameLogic.startLoginProcess();
        }
        if (commandInput) commandInput.focus();
    },

    selectCharacterAndStartGame: async function (character) { // Called after player picks a char from list
        UI.appendToOutput(`\nSelecting ${character.name}...`);
        try {
            const initialRoomData = await API.selectCharacterOnBackend(character.id);
            await GameLogic.enterGameModeWithCharacter(character, initialRoomData);
        } catch (error) {
            UI.appendToOutput(`! Error selecting character: ${error.message}`, { styleClass: 'error-message-inline' });
            await GameLogic.displayCharacterSelection();
        }
    },

    enterGameModeWithCharacter: async function (character, initialRoomData) {
        gameState.selectedCharacterId = character.id;
        gameState.selectedCharacterName = character.name;
        gameState.loginState = 'IN_GAME';
        UI.showAppropriateView();
        UI.clearOutput();
        UI.appendToOutput(`Playing as: <span class="char-name">${character.name}</span>, the <span class="char-class">${character.class_name}</span>`);
        UI.setInputCommandPlaceholder("Type command...");
        UI.setInputCommandType('text');

        if (initialRoomData) { // From HTTP /select response
            UI.updateGameDisplay(initialRoomData);
            UI.updateExitsDisplay(initialRoomData);
            gameState.displayedRoomId = initialRoomData.id;
        }
        WebSocketService.connect(); // Connect WebSocket
        if (commandInput) commandInput.focus();
    },

    handleLogout: function () {
        WebSocketService.close();
        // Reset all relevant gameState properties
        gameState.currentAuthToken = null; gameState.selectedCharacterId = null; gameState.selectedCharacterName = null;
        gameState.tempUsername = ''; gameState.availableCharacters = []; gameState.isInCombat = false;
        console.log("Logged out.");
        GameLogic.startLoginProcess();
    },

    handleHttpCommandResponse: function (responseData, originalCommand) {
        // Handles responses from HTTP commands (look, move, inventory, etc.)
        if (responseData.message_to_player) {
            UI.appendToOutput(responseData.message_to_player, { styleClass: 'game-message' });
        }
        if (responseData.room_data) {
            const cmdClean = originalCommand.toLowerCase().trim();
            const isLook = cmdClean.startsWith("look") || cmdClean === "l";
            if (isLook || gameState.displayedRoomId !== responseData.room_data.id) {
                UI.updateGameDisplay(responseData.room_data);
            }
            UI.updateExitsDisplay(responseData.room_data);
            gameState.displayedRoomId = responseData.room_data.id;
        }
        // Check if HTTP response indicates combat ended (e.g. if fleeing via HTTP was a thing)
        if (responseData.combat_over === true) {
            gameState.isInCombat = false;
            // UI.appendToOutput("> Combat (via HTTP) has ended.", {styleClass: "game-message"});
        }
    },

    handleWebSocketMessage: function (serverData) {
        // Handles messages received over WebSocket (primarily combat and real-time updates)
        if (serverData.type === "combat_update") {
            if (serverData.log && serverData.log.length > 0) {
                UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            }
            if (serverData.room_data) { // Server might send room updates if combat moves player (flee) or changes room state
                const isNewRoom = gameState.displayedRoomId !== serverData.room_data.id;
                if (isNewRoom) { UI.updateGameDisplay(serverData.room_data); }
                UI.updateExitsDisplay(serverData.room_data);
                gameState.displayedRoomId = serverData.room_data.id;
            }
            gameState.isInCombat = !serverData.combat_over;
            if (serverData.combat_over) {
                // UI.appendToOutput("> Combat has ended.", {styleClass: "game-message"}); // Server log should say this
            }
        } else if (serverData.type === "initial_state" || serverData.type === "welcome_message") { // Example types
            if (serverData.message) UI.appendToOutput(`GS: ${serverData.message}`, { styleClass: "game-message" });
            if (serverData.room_data) { // Initial room data from WS connection
                UI.updateGameDisplay(serverData.room_data);
                UI.updateExitsDisplay(serverData.room_data);
                gameState.displayedRoomId = serverData.room_data.id;
            }
            // serverData.log could be an array of initial messages
            if (serverData.log && serverData.log.length > 0) {
                UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            }
        } else if (serverData.message) { // Other generic messages from WS
            UI.appendToOutput(`GS: ${serverData.message}`, { styleClass: "game-message" });
        } else { // Fallback for unhandled message structures
            UI.appendToOutput(`GS (unparsed): ${JSON.stringify(serverData)}`, { styleClass: "game-message" });
        }
    },

    handleInputSubmission: async function () {
        if (!commandInput) return;
        const inputText = commandInput.value.trim();
        let echoText = inputText;
        let echoOptions = { noNewLineBefore: true };

        if (gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
            echoText = '*'.repeat(inputText.length || 8);
        } else if (gameState.loginState === 'IN_GAME' && inputText) { // Only echo if there's text in game
            echoText = `> ${inputText}`;
            echoOptions = {};
        }

        if (inputText || gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
            UI.appendToOutput(echoText, echoOptions);
        }
        commandInput.value = '';

        switch (gameState.loginState) {
            case 'PROMPT_USER':
                if (inputText.toLowerCase() === 'new') await GameLogic.promptForRegistrationUsername();
                else if (inputText) { gameState.tempUsername = inputText; await GameLogic.promptForPassword(); }
                else UI.appendToOutput("Username (or 'new'): ", { isPrompt: true, noNewLineBefore: true });
                break;
            case 'PROMPT_PASSWORD':
                const passwordAttempt = inputText;
                // UI.setInputCommandType('text'); // Set type first
                // UI.setInputCommandPlaceholder("Enter command..."); // Then placeholder
                // Actually, better to set these AFTER the API call or when moving to next state
                UI.appendToOutput("\nAttempting login...");
                try {
                    const data = await API.loginUser(gameState.tempUsername, passwordAttempt);
                    gameState.currentAuthToken = data.access_token;
                    UI.appendToOutput("Login successful!");
                    UI.setInputCommandType('text'); // << Set to text AFTER successful login
                    UI.setInputCommandPlaceholder("Enter #, or 'new'"); // For char select
                    commandInput.setAttribute('autocomplete', 'off'); // Explicitly turn off for next phase
                    await GameLogic.displayCharacterSelection();
                } catch (error) {
                    UI.appendToOutput(`! Login failed: ${error.message || 'Incorrect credentials.'}`, {styleClass: 'error-message-inline'});
                    // Don't change type yet, re-prompt for password
                    // UI.setInputCommandType('password'); // Already password type
                    UI.setInputCommandPlaceholder("Enter password");
                    commandInput.setAttribute('autocomplete', 'current-password'); // Keep it as password field
                    // await GameLogic.promptForPassword(); // No, this is called by user hitting enter again
                }
                break;
            case 'REGISTER_PROMPT_USER':
                if (inputText) { gameState.tempUsername = inputText; await GameLogic.promptForRegistrationPassword(); }
                else UI.appendToOutput("Desired username: ", { isPrompt: true, noNewLineBefore: true });
                break;
            case 'REGISTER_PROMPT_PASSWORD':
                gameState.tempPassword = inputText;
                // UI.setInputCommandType('text'); // Set after registration attempt
                UI.appendToOutput("\nAttempting registration...");
                try {
                    await API.registerUser(gameState.tempUsername, gameState.tempPassword);
                    UI.appendToOutput("Registration successful! Please log in.");
                } catch (error) {
                    UI.appendToOutput(`! Registration failed: ${error.message || 'Error.'}`, {styleClass: 'error-message-inline'});
                } finally {
                    UI.setInputCommandType('text'); // << Set to text before going to login
                    commandInput.setAttribute('autocomplete', 'off'); // Turn off autocomplete
                    GameLogic.startLoginProcess(); // Go back to login after attempt
                }
                break;
            case 'CHAR_SELECT_PROMPT':
                if (inputText.toLowerCase() === 'new') await GameLogic.promptForNewCharacterName();
                else {
                    const charIndex = parseInt(inputText, 10) - 1;
                    if (gameState.availableCharacters && charIndex >= 0 && charIndex < gameState.availableCharacters.length) {
                        await GameLogic.selectCharacterAndStartGame(gameState.availableCharacters[charIndex]);
                    } else {
                        UI.appendToOutput("! Invalid selection.", { styleClass: 'error-message-inline' });
                        UI.appendToOutput("Enter character #, or 'new': ", { isPrompt: true, noNewLineBefore: true });
                    }
                }
                break;
            case 'CHAR_CREATE_PROMPT_NAME':
                gameState.tempCharName = inputText;
                if (!gameState.tempCharName || gameState.tempCharName.length < 3 || gameState.tempCharName.length > 50) {
                    UI.appendToOutput("! Invalid name (3-50 chars). Name: ", { isPrompt: true, styleClass: 'error-message-inline', noNewLineBefore: true });
                    break;
                }
                await GameLogic.promptForNewCharacterClass();
                break;
            case 'CHAR_CREATE_PROMPT_CLASS':
                const charClass = inputText || "Adventurer";
                UI.appendToOutput(`\nCreating ${gameState.tempCharName} the ${charClass}...`);
                try {
                    await API.createCharacter(gameState.tempCharName, charClass);
                    UI.appendToOutput("Character created!");
                    await GameLogic.displayCharacterSelection(); // Refresh list
                } catch (error) {
                    UI.appendToOutput(`! Error creating character: ${error.message}`, { styleClass: 'error-message-inline' });
                    await GameLogic.displayCharacterSelection();
                }
                break;
            case 'IN_GAME':
                if (!inputText) { // Empty input in game
                    if (gameState.isInCombat) {
                        // UI.appendToOutput("(Auto-combat active... type 'flee' or other actions)", {styleClass: "game-message"});
                        // Server is driving rounds, empty input from player might mean "pass" or do nothing.
                        // Or client could send a "continue_attack" or "default_action" message.
                        // For now, empty input does nothing if in WS combat.
                    } else {
                        // await API.sendHttpCommand("look"); // Default action for empty input if not in combat
                    }
                    break;
                }
                const lowerInputText = inputText.toLowerCase();
                // Define which commands go over WebSocket
                const wsCommands = ["attack", "atk", "kill", "k", "flee", "cast", "skill"];
                const commandVerb = lowerInputText.split(" ")[0];

                if (wsCommands.includes(commandVerb)) {
                    WebSocketService.sendMessage({ type: "command", command_text: inputText });
                    // gameState.isInCombat will be set by server responses
                } else {
                    // Other commands (look, move, inv, eq, uneq, etc.) use HTTP
                    if (gameState.isInCombat) {
                        // UI.appendToOutput("> Typing non-combat command, server will decide combat disengagement.", {styleClass:"game-message"});
                        // Server needs to handle if a player in WS combat sends an HTTP command
                        // Potentially client sends a "cancel_combat_action" over WS first
                    }
                    await API.sendHttpCommand(inputText);
                }
                break;
            default:
                UI.appendToOutput("! System error: Unknown login state.", { styleClass: 'error-message-inline' });
                GameLogic.startLoginProcess();
        }
        if (commandInput) commandInput.focus();
    }
};

// --- Initial Setup (DOMContentLoaded) ---
document.addEventListener('DOMContentLoaded', () => {
    if (!UI.initializeElements()) return; // Stop if essential elements are missing

    GameLogic.startLoginProcess();

    commandInput.addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            GameLogic.handleInputSubmission();
        }
    });
});
--- END OF FILE frontend/src/script.js ---

--- START OF FILE frontend/src/index.html ---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Unholy MUD of Tron & Allen1</title>
    <style>
        body {
            background-color: #000;
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            display: flex;
            /* For centering the container */
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            box-sizing: border-box;
        }

        .header-text {
            text-align: center;
            margin-bottom: 10px;
        }

        .header-text h1 {
            margin: 0 0 5px 0;
            font-size: 1.8em;
        }

        .header-text p {
            margin: 0;
            font-size: 0.9em;
            color: #00cc00;
        }

        .mud-container {
            width: 100%;
            max-width: 900px;
            /* Or your preferred max width */
            display: flex;
            flex-direction: column;
            border: 1px solid #005500;
            /* Border around the whole MUD interface */
        }

        .terminal-output {
            flex-grow: 1;
            /* Takes up available vertical space */
            height: 75vh;
            /* Start with a good height, flex-grow will adjust */
            overflow-y: scroll;
            background-color: #030303;
            padding: 10px;
            box-sizing: border-box;
            white-space: pre-wrap;
            line-height: 1.4;
            border-bottom: 1px solid #005500;
            /* Separator to exits bar */
        }

        .exits-bar {
            /* New bar for exits */
            background-color: #050505;
            padding: 5px 10px;
            color: #00ffff;
            /* Cyan for exits */
            font-size: 0.9em;
            border-bottom: 1px solid #005500;
            /* Separator to input line */
            min-height: 1.5em;
            /* Ensure it has some height even if empty */
            white-space: nowrap;
            overflow-x: auto;
            /* In case exits are very long */
        }

        .terminal-input-line {
            display: flex;
            align-items: center;
            background-color: #030303;
            padding: 8px 10px;
        }

        #prompt-text {
            margin-right: 8px;
            color: #00dd00;
            /* Bright green for prompt */
        }

        .terminal-output::-webkit-scrollbar {
            width: 10px;
            /* Width of the vertical scrollbar */
            height: 10px;
            /* Height of the horizontal scrollbar (if any) */
        }

        .terminal-output::-webkit-scrollbar-track {
            background: #080808;
            /* Dark background for the track (very dark grey) */
            /* border-radius: 5px; */
            /* Optional: rounded corners for the track */
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background-color: #005500;
            /* Dark green for the scrollbar thumb */
            border-radius: 5px;
            /* Rounded corners for the thumb */
            border: 2px solid #030303;
            /* Creates a small border around the thumb, using the output bg color for seamlessness */
        }

        .terminal-output::-webkit-scrollbar-thumb:hover {
            background-color: #007700;
            /* Slightly lighter green on hover */
        }

        .terminal-output::-webkit-scrollbar-corner {
            background: #030303;
            /* Background of the corner where vertical and horizontal scrollbars meet */
        }

        .terminal-input {
            scrollbar-width: thin;
            /* Options: 'auto', 'thin', 'none' */
            scrollbar-color: #005500 #080808;
            /* thumb color, track color */
            flex-grow: 1;
            background-color: transparent;
            border: none;
            color: #00ff00;
            font-family: inherit;
            font-size: 1em;
            outline: none;
            padding: 0;
        }

        /* Styling for character lists in terminal output */
        .char-list-item {
            margin-left: 20px;
        }

        .char-list-item .char-index {
            color: #ffff00;
            /* Yellow for index */
        }

        .char-list-item .char-name {
            color: #00ff00;
        }

        .char-list-item .char-class {
            color: #00aaaa;
            /* Teal for class */
        }

        /* Styling for room name in terminal output */
        .room-name-header {
            color: #ffff00;
            font-weight: bold;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }

        .error-message-inline {
            color: #ff4444;
            font-style: italic;
        }

        .game-message {
            /* <<< ADDED CLASS */
            color: #cccccc;
            /* Light grey for general game messages */
            /* For example, "You can't go that way." or "You look around." */
            /* You might want different colors for different types of messages later. */
            display: block;
            /* Ensures it takes its own line if appendToOutput's newline logic is tricky */
        }

        /* --- NEW CSS Classes for Inventory --- */
        .inv-slot-name {
            /* For [Slot Name] */
            color: #00ffff;
            /* Cyan */
            font-weight: bold;
        }

        .inv-backpack-number {
            /* For   1.   */
            color: #ffff00;
            /* Yellow */
        }

        .inv-item-name {
            /* For the item's actual name */
            color: #00ff00;
            /* Default bright green, but you could vary this by item type/rarity later */
        }

        .inv-item-qty {
            /* For (Qty: N) */
            color: #aaaaaa;
            /* Dimmer grey */
        }

        .inv-section-header {
            /* For --- Equipped --- and --- Backpack --- */
            color: #f0f0f0;
            /* Brighter white/light grey */
            font-weight: bold;
        }

        .inv-item-name {
            /* Already exists - used for mob names too */
            color: #00ff00;
        }

        .char-name {
            /* Already exists - used for player name in messages */
            color: #00ff00;
            /* Or a distinct player color */
        }

        /* --- NEW Combat Specific Styles --- */
        .combat-success {
            color: #33cc33;
            /* Bright Green for HIT */
            font-weight: bold;
        }

        .combat-miss {
            color: #ff9933;
            /* Orange for MISS */
        }

        .combat-hit {
            /* Damage player deals */
            color: #ffff00;
            /* Yellow */
            font-weight: bold;
        }

        .combat-crit {
            /* Critical damage player deals */
            color: #ff9900;
            /* Bright Orange */
            font-weight: bold;
            /* text-shadow: 0 0 5px #ff0000; Maybe a glow? */
        }

        .combat-hp {
            color: #ffdddd;
            /* Light pink for HP values */
        }

        .combat-death {
            color: #ff3333;
            /* Red for death */
            font-weight: bold;
            font-style: italic;
        }

        .combat-hit-player {
            /* Damage mob deals to player */
            color: #ff6666;
            /* Red */
            font-weight: bold;
        }

        .combat-crit-player {
            /* Critical damage mob deals to player */
            color: #cc0000;
            /* Dark Red */
            font-weight: bold;
            /* text-shadow: 0 0 5px #ff0000; */
        }

        .error-message-inline {
            /* Already exists */
            color: #ff4444;
            font-style: italic;
        }
    </style>
</head>

<body>
    <div class="header-text">
        <h1>Legend of the Solar Dragon's Tradewar<br>2002 Barrels of Food Fight<br>Over a Usurped Pit of Devastation
            (Alpha)</h1>
        <p>(UMGTWOTRDBSR_EUPFDX_TPSC for short, obviously)</p>
    </div>

    <div class="mud-container">
        <!-- Main output for telnet login, char select, game log -->
        <div id="output" class="terminal-output"></div>

        <!-- Exits bar - will be updated by JS -->
        <div id="exits-display" class="exits-bar">Exits: (None)</div>

        <!-- Command input line -->
        <div id="input-prompt-line" class="terminal-input-line">
            <span id="prompt-text">> </span>
            <input type="text" id="commandInput" class="terminal-input" name="mud_command_line" autofocus autocomplete="off">
        </div>
    </div>

    <!-- We no longer need separate HTML sections for char select/create.
         JS will handle these flows within the #output div. -->

    <script src="script.js"></script>
</body>

</html>
--- END OF FILE frontend/src/index.html ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
