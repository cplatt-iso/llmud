--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Sat Jun  7 05:03:48 PM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/character_classes.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/mob_templates.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
bundle_context.sh
frontend/src/api.js
frontend/src/config.js
frontend/src/index.html
frontend/src/main.js
frontend/src/map.js
frontend/src/script.js
frontend/src/state.js
frontend/src/style.css
frontend/src/ui.js
frontend/src/websocket.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed." >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh" # Always good to know how the sausage is made
    "README.md"         # Current state of this beautiful disaster

    # --- Backend - Core application & Logging (Still relevant for seeing if things break) ---
    "$BACKEND_APP_DIR/main.py"
    "$BACKEND_APP_DIR/core/config.py"
    "$BACKEND_APP_DIR/core/logging_config.py" # Since we just fucked with this
    "$BACKEND_APP_DIR/websocket_router.py"    # Good for overall WS flow context

    # --- Backend - PRIMARY FOCUS FOR NEXT STEPS (Loot, Spawning, Confirmation) ---
    "$BACKEND_APP_DIR/game_logic/combat/combat_round_processor.py" # CRITICAL for confirming auto-attack loot fix
    "$BACKEND_APP_DIR/game_logic/combat/combat_utils.py"       # CRITICAL for handle_mob_death_loot_and_cleanup (where loot tables are processed)
    "$BACKEND_APP_DIR/crud/crud_character_inventory.py"         # CRITICAL for confirming inventory stacking fix
    "$BACKEND_APP_DIR/commands/utils.py"                      # CRITICAL for inventory display format (needs to be perfect)
    "$BACKEND_APP_DIR/commands/inventory_parser.py"           # CRITICAL for testing inventory commands work with new display
    "$BACKEND_APP_DIR/crud/crud_mob_spawn_definition.py"      # CRITICAL for externalizing and using mob_spawn_definitions.json
    "$BACKEND_APP_DIR/crud/crud_item.py"                      # For seeding new equipment from items.json
    "$BACKEND_APP_DIR/crud/crud_mob.py"                       # For mob_templates.json (loot_table_tags)
    # "$BACKEND_APP_DIR/game_logic/combat/skill_resolver.py"   # Less critical now if loot logic is unified in combat_utils.py, but good for reference if skill kills break.

    # --- Backend - Essential Models for Loot & Spawning ---
    "$BACKEND_APP_DIR/models/item.py"               # Defines items, stackability, properties
    "$BACKEND_APP_DIR/models/mob_template.py"       # Defines loot_table_tags
    "$BACKEND_APP_DIR/models/character_inventory_item.py" # The actual inventory rows
    "$BACKEND_APP_DIR/models/character.py"          # For context on player inventory relationship
    "$BACKEND_APP_DIR/models/room_item_instance.py" # For items placed on ground / dropped
    "$BACKEND_APP_DIR/models/room.py"               # Context for placing items
    "$BACKEND_APP_DIR/models/mob_spawn_definition.py" # The model for mob spawning rules

    # --- Backend - Essential Schemas for Loot & Spawning ---
    "$BACKEND_APP_DIR/schemas/item.py"
    "$BACKEND_APP_DIR/schemas/mob.py"
    "$BACKEND_APP_DIR/schemas/mob_spawn_definition.py" # If you add a schema for the JSON file
    "$BACKEND_APP_DIR/schemas/character.py"          # For inventory display schema context
    # "$BACKEND_APP_DIR/schemas/room.py"             # Less critical unless placing many items in rooms

    # --- Backend - Supporting CRUD for Seeding (as needed) ---
    # "$BACKEND_APP_DIR/crud/crud_room.py" # For placing items if you do that

    # --- Seed Data (ABSOLUTELY CRITICAL) ---
    "$BACKEND_APP_DIR/seeds/items.json"                 # MAJOR FOCUS: Will be expanded
    "$BACKEND_APP_DIR/seeds/mob_templates.json"         # MAJOR FOCUS: For loot_table_tags
    # Consider adding:
    # "$BACKEND_APP_DIR/seeds/loot_tables.json"          # If you externalize loot tables
    # "$BACKEND_APP_DIR/seeds/mob_spawn_definitions.json" # If you externalize spawn defs
    "$BACKEND_APP_DIR/seeds/character_classes.json"     # For starting equipment context if modified

    # --- Frontend (Minimal, just enough to test if display breaks) ---
    "$FRONTEND_SRC_DIR/main.js"      # To see if WS message handling or command submission breaks
    "$FRONTEND_SRC_DIR/ui.js"        # If inventory display formatting needs frontend CSS tweaks (unlikely for this phase)
    # "$FRONTEND_SRC_DIR/map.js"     # Probably not needed for loot/spawning tasks
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (✨💰💪🧩💀🚪) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Flesh out the damn world - Gear, Loot, and More Seeds!

The map is less of an abstract nightmare, and the core gameplay loop is... loopy. Now we need to make the interactions richer and the world feel less empty.

*   **Full Equipment System:** Define all equipment slots. Implement robust `equip` and `unequip` logic. Ensure stats update correctly.
*   **Mob Loot Tables:** Mobs need to drop more than just coins. Define loot tables (specific items, random items from categories, chances).
*   **Seed More Content (Externalize ALL THE THINGS):**
    *   `mob_templates.json`
    *   `character_classes.json`
    *   `skills.json`
    *   `traits.json`
    *   `mob_spawn_definitions.json`
    *   Update corresponding CRUD seeders to load from these JSONs.
*   **Seed Initial Equipment:** Place starting gear on character creation or in initial rooms.

This will involve a lot of backend work (models, CRUD, game logic) and careful JSON schema design for the seed files.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/main.py ---
# backend/app/main.py
import asyncio
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
import sys # For detailed print statements
from app.core.config import settings
import logging # Import logging

# --- Setup Logging First ---
# This needs to happen before other modules that might use logging are imported,
# or at least before they try to log.
try:
    from app.core.logging_config import setup_logging
    setup_logging()
    print("--- MAIN.PY: setup_logging() CALLED (no exception caught) ---", flush=True)
except ImportError as e_log_setup:
    print(f"--- CRITICAL: main.py - FAILED to import or run setup_logging: {e_log_setup} ---", flush=True)
    sys.exit(1) # Exit if logging can't be set up, as it's crucial for debugging

logger = logging.getLogger(__name__) # Get a logger for this module

# --- Add these lines for immediate feedback on logger level ---
print(f"--- MAIN.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_main = logger.getEffectiveLevel()
print(f"--- MAIN.PY: Effective log level for 'app.main' logger = {effective_level_main} ({logging.getLevelName(effective_level_main)}) ---", flush=True)
logger.debug(f"--- MAIN.PY DEBUG LOG TEST: Top of file, Python version: {sys.version} ---") # Changed from logger.debug to ensure it prints if DEBUG is working
logger.info(f"--- MAIN.PY INFO LOG TEST: Top of file, Python version: {sys.version} ---")
# --- End of added lines ---

from app.api.v1.api_router import api_router as v1_api_router
logger.debug("--- main.py - Imported v1_api_router ---")
from app.websocket_router import router as ws_router
logger.debug("--- main.py - Imported ws_router ---")
from app.db.session import engine, get_db
logger.debug("--- main.py - Imported engine, get_db from app.db.session ---")
from app.db import base_class
logger.debug("--- main.py - Imported base_class from app.db ---")
from app.core.config import settings
logger.debug(f"--- main.py - Imported settings. Project Name: {settings.PROJECT_NAME} ---")
from app.crud.crud_room import seed_initial_world
logger.debug("--- main.py - Imported seed_initial_world ---")
from app.crud.crud_item import seed_initial_items 
logger.debug("--- main.py - Imported seed_initial_items ---")
from app.crud.crud_mob import seed_initial_mob_templates
logger.debug("--- main.py - Imported seed_initial_mob_templates ---")
from app.game_logic.combat import start_combat_ticker_task, stop_combat_ticker_task
logger.debug("--- main.py - Imported combat_manager tasks ---")
from app.crud.crud_character_class import seed_initial_character_class_templates 
logger.debug("--- main.py - Imported seed_initial_character_class_templates ---")
from app.crud.crud_skill import seed_initial_skill_templates 
logger.debug("--- main.py - Imported seed_initial_skill_templates ---")
from app.crud.crud_trait import seed_initial_trait_templates 
logger.debug("--- main.py - Imported seed_initial_trait_templates ---")
from app.game_logic.world_ticker import start_world_ticker_task, stop_world_ticker_task
logger.debug("--- main.py - Imported world_ticker tasks ---")
from app.crud.crud_mob_spawn_definition import seed_initial_mob_spawn_definitions 
logger.debug("--- main.py - Imported seed_initial_mob_spawn_definitions ---")

logger.debug("--- main.py - About to call Base.metadata.create_all(bind=engine) ---")
try:
    base_class.Base.metadata.create_all(bind=engine)
    logger.info("--- main.py - Base.metadata.create_all(bind=engine) COMPLETED ---")
except Exception as e:
    logger.error(f"--- main.py - ERROR during Base.metadata.create_all: {e} ---", exc_info=True)
    # Depending on the severity, you might want to sys.exit() here

logger.debug("--- main.py - Creating FastAPI app instance ---")
app = FastAPI(title=settings.PROJECT_NAME)
logger.info("--- main.py - FastAPI app instance CREATED ---")

@app.on_event("startup")
def on_startup_sync():
    logger.info("--- main.py - START of on_startup_sync event ---")
    db: Session = next(get_db())
    logger.debug("--- main.py - on_startup_sync: Acquired DB session ---")
    try:
        logger.info("--- main.py - on_startup_sync: Running startup event: Seeding initial data... ---")
        
        # CORRECT ORDER:
        # 1. Seed items FIRST
        seed_initial_items(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_items COMPLETED ---")

        # 2. THEN seed the world (rooms/exits), which might place items
        seed_initial_world(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_world COMPLETED ---")
        
        # 3. THEN other things
        seed_initial_mob_templates(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_templates COMPLETED ---")
        
        seed_initial_character_class_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_character_class_templates COMPLETED ---")
        
        seed_initial_skill_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_skill_templates COMPLETED ---")
        
        seed_initial_trait_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_trait_templates COMPLETED ---")
        
        seed_initial_mob_spawn_definitions(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_spawn_definitions COMPLETED ---")
        
        logger.info("--- main.py - on_startup_sync: Starting combat ticker... ---")
        start_combat_ticker_task()
        logger.debug("--- main.py - on_startup_sync: Combat ticker STARTED ---")      

        logger.info("--- main.py - on_startup_sync: Starting world ticker... ---") 
        start_world_ticker_task()    
        logger.debug("--- main.py - on_startup_sync: World ticker STARTED ---")     
        logger.info("--- main.py - on_startup_sync: Startup event processing FINISHED ---")
    except Exception as e_startup:
        logger.error(f"--- main.py - ERROR during on_startup_sync: {e_startup} ---", exc_info=True)
    finally:
        logger.debug("--- main.py - on_startup_sync: Closing DB session ---")
        db.close()
        logger.debug("--- main.py - on_startup_sync: DB session CLOSED ---")
    logger.info("--- main.py - END of on_startup_sync event ---")

logger.debug("--- main.py - About to include v1_api_router ---")
app.include_router(v1_api_router, prefix=settings.API_V1_STR)
logger.debug("--- main.py - v1_api_router INCLUDED ---")

logger.debug("--- main.py - About to include ws_router ---")
app.include_router(ws_router)
logger.debug("--- main.py - ws_router INCLUDED ---")

@app.get("/")
async def root():
    logger.debug("--- main.py - GET / request received ---")
    return {"message": f"Welcome to {settings.PROJECT_NAME}. Now with a World Ticker humming in the background!"}

logger.info("--- main.py - FastAPI app instance configured. End of file. ---")
--- END OF FILE backend/app/main.py ---

--- START OF FILE backend/app/core/config.py ---
# backend/app/core/config.py
import os
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict

# Check if we're likely running in an Alembic 'env.py' context BEFORE settings are needed for DB connection
# This is a heuristic. Alembic sets 'alembic.version' in its context.
# A simpler heuristic: if a specific env var for alembic is set.
IS_ALEMBIC_ENV_PY_CONTEXT = os.getenv("ALEMBIC_ENV_PY_RUNNING") == "true"

class Settings(BaseSettings):
    PROJECT_NAME: str = "MUD Project - Backend"
    API_V1_STR: str = "/api/v1"
    
    DATABASE_URL: Optional[str] = "postgresql://dummy_user:dummy_password@dummy_host:5432/dummy_db" if IS_ALEMBIC_ENV_PY_CONTEXT else os.getenv("DATABASE_URL", "postgresql://user:password@db/llmud_db") # Added os.getenv for normal case
    SECRET_KEY: str = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7" # CHANGE THIS IN PRODUCTION!
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7 # Token expires in 7 days

    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "DEBUG").upper() 
    SHOW_COMBAT_ROLLS_TO_PLAYER: bool = os.getenv("SHOW_COMBAT_ROLLS_TO_PLAYER", "True").lower() == "true"


    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8', extra='ignore')

settings = Settings() 

# After instantiation, if it was a dummy, ensure it's overridden if not in Alembic context
# and the real env var is available.
if IS_ALEMBIC_ENV_PY_CONTEXT and settings.DATABASE_URL is not None and "dummy_user" in settings.DATABASE_URL:
    # logger.info("Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.") # Can't use logger before setup
    print("INFO: Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.")
elif not IS_ALEMBIC_ENV_PY_CONTEXT and os.getenv("DATABASE_URL"):
    settings.DATABASE_URL = os.getenv("DATABASE_URL") # Ensure it's set from env if not in alembic context
elif not IS_ALEMBIC_ENV_PY_CONTEXT and not os.getenv("DATABASE_URL"):
    # This will have already failed in Settings() if '...' was used and no env var
    # logger.warning("DATABASE_URL not found in environment for normal app run!") # Can't use logger before setup
    print("WARNING: DATABASE_URL not found in environment for normal app run!")
--- END OF FILE backend/app/core/config.py ---

--- START OF FILE backend/app/core/logging_config.py ---
# backend/app/core/logging_config.py
import logging
import sys
from app.core.config import settings # For LOG_LEVEL

def setup_logging():
    """
    Configures logging for the application.
    Sets a basic configuration that logs to stdout.
    The log level is determined by the LOG_LEVEL environment variable.
    """
    print(f"--- LOGGING_CONFIG.PY: setup_logging() CALLED. Settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
    
    log_level_str = settings.LOG_LEVEL.upper()
    numeric_level = getattr(logging, log_level_str, None)

    if not isinstance(numeric_level, int):
        print(f"--- LOGGING_CONFIG.PY: Invalid log level: {log_level_str}. Defaulting to INFO. ---", flush=True)
        numeric_level = logging.INFO
    else:
        print(f"--- LOGGING_CONFIG.PY: Valid log level: {log_level_str} ({numeric_level}) ---", flush=True)

    # Basic configuration - this might be too simple if we have multiple handlers/formatters later
    # For now, let's ensure the root logger is set to the desired level.
    # Child loggers will inherit this unless they are explicitly set lower.
    
    # Create a formatter
    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(funcName)s:%(lineno)d - %(message)s"
    )

    # Create a handler (StreamHandler to output to stdout/stderr)
    stream_handler = logging.StreamHandler(sys.stdout) # Or sys.stderr
    stream_handler.setFormatter(formatter)
    
    # Get the root logger
    root_logger = logging.getLogger()
    
    # Clear any existing handlers on the root logger to avoid duplicate logs if this is called multiple times
    # (though it should only be called once at startup)
    if root_logger.hasHandlers():
        root_logger.handlers.clear()
        print("--- LOGGING_CONFIG.PY: Cleared existing root logger handlers. ---", flush=True)

    root_logger.addHandler(stream_handler)
    root_logger.setLevel(numeric_level) # Set level on the root logger

    # Test log after setup
    # We need to get a specific logger to test, not the root one directly for named loggers.
    test_logger = logging.getLogger("app.core.logging_config_test") # Use a specific name for testing
    print(f"--- LOGGING_CONFIG.PY: Effective level for 'app.core.logging_config_test' after setup: {test_logger.getEffectiveLevel()} ({logging.getLevelName(test_logger.getEffectiveLevel())}) ---", flush=True)
    test_logger.debug("--- LOGGING_CONFIG.PY DEBUG TEST: This is a debug message from setup_logging. ---")
    test_logger.info("--- LOGGING_CONFIG.PY INFO TEST: This is an info message from setup_logging. ---")
    test_logger.warning("--- LOGGING_CONFIG.PY WARNING TEST: This is a warning message from setup_logging. ---")
    
    # Print status of specific loggers we care about
    loggers_to_check = [
        "app.game_logic.combat.skill_resolver",
        "app.game_logic.combat.combat_round_processor",
        "app.crud.crud_mob",
        "app.main",
        "app.websocket_router"
    ]
    for logger_name in loggers_to_check:
        temp_logger = logging.getLogger(logger_name)
        effective_level = temp_logger.getEffectiveLevel()
        print(f"--- LOGGING_CONFIG.PY: Effective level for '{logger_name}': {effective_level} ({logging.getLevelName(effective_level)}) ---", flush=True)

    print(f"--- LOGGING_CONFIG.PY: Logging setup COMPLETE. Root logger level set to {logging.getLevelName(root_logger.level)}. ---", flush=True)

# Ensure this function is actually called at the very start of your application (e.g., in main.py)
# Example of how it's called in main.py (this is just a comment here):
#
# import logging
# from app.core.logging_config import setup_logging
# setup_logging() # Call it early!
# logger = logging.getLogger(__name__)
# logger.info("Test message from main after setup.")
--- END OF FILE backend/app/core/logging_config.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple, Union
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session # attributes removed as it's used in parsers now
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

from app.core.config import settings
from app.db.session import SessionLocal
from app import crud, models, schemas # Full app imports
from app.websocket_manager import connection_manager
from app.game_logic import combat # For access to combat.active_combats, combat.send_combat_log etc.

from app.commands.utils import ( # General utils
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message
    # resolve_mob_target is used within ws_combat_actions_parser
    # resolve_room_item_target is used within ws_interaction_parser
)
from app.game_state import is_character_resting, set_character_resting_status
# ExitDetail is used within ws_movement_parser.attempt_player_move

# Import the new WS command parsers
from app.ws_command_parsers import (
    handle_ws_movement, handle_ws_flee,
    handle_ws_attack, handle_ws_use_combat_skill,
    handle_ws_get_take, handle_ws_unlock, handle_ws_search_examine,
    handle_ws_contextual_interactable, handle_ws_use_ooc_skill,
    handle_ws_look, handle_ws_rest
)

logger = logging.getLogger(__name__)
# --- Logger setup print lines (can be removed once stable) ---
print(f"--- WEBSOCKET_ROUTER.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_ws = logger.getEffectiveLevel()
print(f"--- WEBSOCKET_ROUTER.PY: Effective log level for '{logger.name}' logger = {effective_level_ws} ({logging.getLevelName(effective_level_ws)}) ---", flush=True)
logger.info("--- WEBSOCKET_ROUTER.PY INFO LOG TEST: Module loaded (Post-Refactor) ---")
# --- End of logger setup print lines ---

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str) # Ensure player_id_str is a valid UUID string
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError): # Catch JWT errors and ValueError from UUID conversion
        return None

# _handle_websocket_move_if_not_in_combat has been moved to ws_movement_parser.attempt_player_move

@router.websocket("/ws") 
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character_orm: Optional[models.Character] = None # Renamed from 'character' to avoid confusion with character_id param

    with get_db_sync() as db_conn_init: 
        player = await get_player_from_token(token, db_conn_init)
        if not player:
            logger.warning(f"WS Connect: Invalid token for char_id: {character_id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return
        
        fetched_char = crud.crud_character.get_character(db_conn_init, character_id=character_id)
        if not fetched_char or fetched_char.player_id != player.id:
            logger.warning(f"WS Connect: Invalid char_id: {character_id} for player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character_orm = fetched_char # Assign to the correctly scoped variable
    
    await connection_manager.connect(websocket, player.id, character_orm.id)
    logger.info(f"Player {player.id} (Character {character_orm.name} - {character_orm.id}) connected via WebSocket.")
    
    # --- Welcome Package ---
    initial_messages = [f"Welcome {character_orm.name}! You are connected via WebSocket."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db_welcome: 
        initial_room_orm = crud.crud_room.get_room_by_id(db_welcome, room_id=character_orm.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.")
            items_on_ground = crud.crud_room_item.get_items_in_room(db_welcome, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: initial_messages.append(items_text)
            
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db_welcome, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: initial_messages.append(mobs_text)
            
            other_chars_in_room = crud.crud_character.get_characters_in_room(db_welcome, room_id=initial_room_orm.id, exclude_character_id=character_orm.id)
            chars_text_initial = format_room_characters_for_player_message(other_chars_in_room)
            if chars_text_initial: initial_messages.append(chars_text_initial)
    
    xp_for_next_level = crud.crud_character.get_xp_for_level(character_orm.level + 1)
    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump(exclude_none=True) if initial_room_schema else None,
        "character_vitals": {
            "current_hp": character_orm.current_health, "max_hp": character_orm.max_health,
            "current_mp": character_orm.current_mana, "max_mp": character_orm.max_mana,
            "current_xp": character_orm.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character_orm.level,
            "platinum": character_orm.platinum_coins, "gold": character_orm.gold_coins,
            "silver": character_orm.silver_coins, "copper": character_orm.copper_coins
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)
    # --- End Welcome Package ---

    try:
        while True:
            received_data = await websocket.receive_json()
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            # It's crucial to get fresh state at the beginning of each command processing loop
            with get_db_sync() as db_loop: 
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character_orm.id)
                if not current_char_state: 
                    logger.error(f"WS Loop: Character state lost for char_id: {character_orm.id}.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost in loop")
                    break 
                
                current_room_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                if not current_room_orm:
                    logger.error(f"WS Loop: Character {current_char_state.name} in invalid room {current_char_state.current_room_id}.")
                    await combat.send_combat_log(player.id, ["Error: Your current location is unstable. Please relog or contact support."], combat_ended=True)
                    continue 

                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_orm)
                
                verb_for_rest_check = command_text.split(" ", 1)[0].lower() if command_text else ""
                
                non_breaking_verbs = [ # Commands that don't break resting
                    "rest", "look", "l", "score", "sc", "status", "st", 
                    "help", "?", "skills", "sk", "traits", "tr", 
                    "inventory", "i", "ooc", "say", "'", "emote", ":" 
                ]
                
                if verb_for_rest_check and verb_for_rest_check not in non_breaking_verbs and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat.send_combat_log(player.id, ["You stop resting."], room_data=current_room_schema_for_command)

                if message_type == "command" and command_text:
                    verb = verb_for_rest_check 
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""
                    args_list = args_str.split() # For handlers that need a list

                    logger.debug(f"WS Router: Processing verb='{verb}', args='{args_str}' for char {current_char_state.name}")

                    # --- Command Dispatching ---
                    if verb == "rest":
                        await handle_ws_rest(db_loop, player, current_char_state, current_room_orm)
                    elif verb in ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]:
                        await handle_ws_movement(db_loop, player, current_char_state, current_room_schema_for_command, verb, args_str)
                    elif verb == "flee":
                        await handle_ws_flee(db_loop, player, current_char_state, current_room_schema_for_command, args_str)
                    elif verb in ["attack", "atk", "kill", "k"]:
                        await handle_ws_attack(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "use":
                        if not args_str: 
                            await combat.send_combat_log(player.id, ["Use what skill?"], room_data=current_room_schema_for_command); continue
                        
                        temp_args_list_for_skill_parse = args_str.split()
                        learned_skill_tags = current_char_state.learned_skills or []
                        if not learned_skill_tags: 
                            await combat.send_combat_log(player.id, ["You have no skills."], room_data=current_room_schema_for_command); continue

                        # Simplified skill name parsing (copied from previous) - THIS SHOULD BE A UTILITY
                        parsed_skill_template: Optional[models.SkillTemplate] = None
                        parsed_remaining_args: str = ""
                        possible_matches_temp: List[Tuple[models.SkillTemplate, str]] = []
                        for i in range(len(temp_args_list_for_skill_parse), 0, -1):
                            current_skill_input = " ".join(temp_args_list_for_skill_parse[:i]).lower()
                            potential_target_str = " ".join(temp_args_list_for_skill_parse[i:]).strip()
                            for skill_tag_loop in learned_skill_tags:
                                st_db = crud.crud_skill.get_skill_template_by_tag(db_loop, skill_id_tag=skill_tag_loop)
                                if not st_db: continue
                                if st_db.skill_id_tag.lower().startswith(current_skill_input) or st_db.name.lower().startswith(current_skill_input):
                                    if not any(em.id == st_db.id for em, _ in possible_matches_temp):
                                        possible_matches_temp.append((st_db, potential_target_str))
                            if possible_matches_temp and len(current_skill_input.split()) > 0: break
                        
                        if not possible_matches_temp: await combat.send_combat_log(player.id, [f"No skill matching '{temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else args_str}'."], room_data=current_room_schema_for_command); continue
                        elif len(possible_matches_temp) == 1: parsed_skill_template, parsed_remaining_args = possible_matches_temp[0]
                        else:
                            exact_match_s = None; s_input_first = temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else ""
                            for sm_t, sm_a in possible_matches_temp:
                                if sm_t.name.lower() == s_input_first or sm_t.skill_id_tag.lower() == s_input_first:
                                    exact_match_s = sm_t; parsed_remaining_args = sm_a; break
                            if exact_match_s: parsed_skill_template = exact_match_s
                            else: await combat.send_combat_log(player.id, [f"Multiple skills match. Specify: {', '.join(list(set([st.name for st, _ in possible_matches_temp])))}"], room_data=current_room_schema_for_command); continue
                        
                        if not parsed_skill_template: await combat.send_combat_log(player.id, ["Error selecting skill for 'use' command."], room_data=current_room_schema_for_command); continue

                        # Dispatch based on skill type
                        if parsed_skill_template.skill_type == "COMBAT_ACTIVE":
                            await handle_ws_use_combat_skill(db_loop, player, current_char_state, current_room_schema_for_command, args_str) # Pass original args_str for its own parsing
                        elif parsed_skill_template.skill_type == "UTILITY_OOC":
                            # parsed_remaining_args is the target for the OOC skill (e.g., direction string)
                            await handle_ws_use_ooc_skill(db_loop, player, current_char_state, current_room_orm, parsed_skill_template, parsed_remaining_args)
                        else:
                            await combat.send_combat_log(player.id, [f"Skill '{parsed_skill_template.name}' type ({parsed_skill_template.skill_type}) cannot be 'used' this way."], room_data=current_room_schema_for_command)
                    
                    elif verb in ["get", "take"]:
                        await handle_ws_get_take(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "unlock":
                        await handle_ws_unlock(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "search" or verb == "examine":
                        await handle_ws_search_examine(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "look" or verb == "l":
                        await handle_ws_look(db_loop, player, current_char_state, current_room_orm, args_str)
                    else: # Fallback: Try contextual interactable actions
                        is_interactable_action_handled = False
                        if current_room_orm.interactables: # Check if list is not None and not empty
                            target_interactable_name_or_id = args_str.lower()
                            for interactable_dict_ws in current_room_orm.interactables:
                                try:
                                    interactable_obj_ws = schemas.InteractableDetail(**interactable_dict_ws) # Validate from DB data
                                    is_visible = not interactable_obj_ws.is_hidden or current_char_state.id in interactable_obj_ws.revealed_to_char_ids
                                    
                                    if is_visible and verb == interactable_obj_ws.action_verb.lower():
                                        matches_this_interactable = False
                                        if not target_interactable_name_or_id: # e.g. "pull"
                                            # Count how many pullable things are visible
                                            count_with_verb = 0
                                            for other_i_d in current_room_orm.interactables:
                                                other_i = schemas.InteractableDetail(**other_i_d)
                                                other_vis = not other_i.is_hidden or current_char_state.id in other_i.revealed_to_char_ids
                                                if other_vis and other_i.action_verb.lower() == verb:
                                                    count_with_verb +=1
                                            if count_with_verb == 1: matches_this_interactable = True
                                        elif interactable_obj_ws.id_tag.lower() == target_interactable_name_or_id or \
                                             target_interactable_name_or_id in interactable_obj_ws.name.lower():
                                            matches_this_interactable = True
                                        
                                        if matches_this_interactable:
                                            await handle_ws_contextual_interactable(db_loop, player, current_char_state, current_room_orm, verb, args_list, interactable_obj_ws)
                                            is_interactable_action_handled = True; break 
                                except Exception as e_parse_interactable_ws_ctx: 
                                    logger.error(f"WS: Error parsing interactable for contextual check: {e_parse_interactable_ws_ctx}. Data: {interactable_dict_ws}")
                        
                        if not is_interactable_action_handled:
                            # If not any of the above, it's an unknown command for WebSocket
                            await combat.send_combat_log(player.id, [f"Unrecognized command via WebSocket: '{command_text}'. Try 'help' (HTTP)."], room_data=current_room_schema_for_command)
                
                    try:
                        db_loop.commit() # Commit changes made by the handler
                        logger.debug(f"WS Router: DB commit successful for command '{command_text}' by {current_char_state.name}")
                    except Exception as e_commit:
                        db_loop.rollback()
                        logger.error(f"WS Router: DB commit failed for command '{command_text}' by {current_char_state.name}: {e_commit}", exc_info=True)
                        await combat.send_combat_log(player.id, ["A glitch in the matrix occurred. Your last action may not have saved."], room_data=current_room_schema_for_command) # Send error to player
                
                elif message_type != "command": 
                    await combat.send_combat_log(player.id, [f"Unrecognized message type: {message_type}."], room_data=current_room_schema_for_command)
                elif not command_text : # Empty command string for type "command"
                     await combat.send_combat_log(player.id, ["Empty command received."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'} (Character {character_orm.id if character_orm else 'N/A'})")
        if character_orm and character_orm.id: 
            combat.end_combat_for_character(character_orm.id, reason="websocket_disconnect_main_handler")
            if is_character_resting(character_orm.id):
                set_character_resting_status(character_orm.id, False)
    except Exception as e:
        err_player_id_str = str(player.id) if player else "Unknown Player"
        err_char_id_str = str(character_orm.id) if character_orm else "Unknown Character"
        logger.error(f"Critical Error in WebSocket handler for Player {err_player_id_str} (Character {err_char_id_str}): {e}", exc_info=True)
        try:
            # Attempt to send a generic error to the client before closing
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred. Please try reconnecting."})
        except Exception as send_err: 
            logger.error(f"Failed to send critical error to WebSocket for Player {err_player_id_str}: {send_err}")
    finally:
        if player and player.id: 
            connection_manager.disconnect(player.id) 
            if character_orm and character_orm.id and is_character_resting(character_orm.id): 
                set_character_resting_status(character_orm.id, False)
        char_id_log_final = str(character_orm.id) if character_orm else "N/A"
        player_id_log_final = str(player.id) if player else "N/A"
        logger.info(f"WebSocket connection for Player {player_id_log_final} (Character {char_id_log_final}) fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/game_logic/combat/combat_round_processor.py ---
# backend/app/game_logic/combat/combat_round_processor.py
import uuid
import random
import logging
from typing import List, Optional, Tuple, Union, Dict, Any

from sqlalchemy.orm import Session, attributes

from app import crud, models, schemas
from app.commands.utils import roll_dice
from .combat_utils import handle_mob_death_loot_and_cleanup

# combat sub-package imports
from .combat_state_manager import (
    active_combats, mob_targets, character_queued_actions,
    end_combat_for_character
)
from .skill_resolver import resolve_skill_effect
from .combat_utils import (
    send_combat_log, broadcast_combat_event,
    perform_server_side_move, direction_map
)

logger = logging.getLogger(__name__)

async def process_combat_round(db: Session, character_id: uuid.UUID, player_id: uuid.UUID):
    # --- 1. Initial Character & Combat State Checks ---
    if character_id not in active_combats or not active_combats[character_id]:
        if character_id in active_combats:
            end_combat_for_character(character_id, reason="no_targets_in_active_combats_dict_proc_round")
        return

    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character: 
        logger.critical(f"PROC_ROUND: Character {character_id} not found. Cleaning combat states.")
        end_combat_for_character(character_id, reason="character_not_found_in_db_proc_round")
        return

    # Now 'character' is guaranteed to be a models.Character object.
    if character.current_health <= 0:
        # ... (dead character handling as before, 'character' is not None here) ...
        round_log_dead_char = ["You are dead and cannot act."]
        end_combat_for_character(character_id, reason="character_is_dead_proc_round")
        current_room_for_update = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
        current_room_schema_for_update = schemas.RoomInDB.from_orm(current_room_for_update) if current_room_for_update else None
        xp_for_next_lvl = crud.crud_character.get_xp_for_level(character.level + 1)
        vitals_for_payload = {
            "current_hp": character.current_health, "max_hp": character.max_health,
            "current_mp": character.current_mana, "max_mp": character.max_mana,
            "current_xp": character.experience_points,
            "next_level_xp": int(xp_for_next_lvl) if xp_for_next_lvl != float('inf') else -1,
            "level": character.level,
            "platinum": character.platinum_coins, "gold": character.gold_coins,
            "silver": character.silver_coins, "copper": character.copper_coins
        }
        await send_combat_log(player_id, round_log_dead_char, True, current_room_schema_for_update, character_vitals=vitals_for_payload)
        return

    # --- 2. Round Setup ---
    char_combat_stats = character.calculate_combat_stats()
    player_ac = char_combat_stats["effective_ac"]
    round_log: List[str] = [] 
    combat_resolved_this_round = False
    action_str = character_queued_actions.get(character_id)
    character_queued_actions[character_id] = None
    
    room_of_action_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    if not room_of_action_orm:
        logger.error(f"PROC_ROUND: Character {character.name} ({character.id}) in invalid room_id {character.current_room_id}. Ending combat.")
        end_combat_for_character(character_id, reason="character_in_invalid_room_proc_round")
        await send_combat_log(player_id, ["Error: Your location is unstable. Combat disengaged."], combat_ended=True)
        # Commit character state change if any (e.g. mana from previous turn) before returning
        db.add(character)
        db.commit()
        return
    current_room_id_for_action_broadcasts = room_of_action_orm.id

    # --- 3. Player's Action Processing ---
    if action_str:
        if action_str.startswith("flee"):
            # ... (flee logic as before, perform_server_side_move itself should handle None rooms) ...
            action_parts = action_str.split(" ", 1)
            flee_direction_canonical = action_parts[1] if len(action_parts) > 1 and action_parts[1] else "random"
            if random.random() < 0.6: 
                new_room_id, flee_departure_msg, flee_arrival_msg, _ = await perform_server_side_move(
                    db, character, flee_direction_canonical, player_id
                )
                if new_room_id:
                    round_log.append(f"<span class='combat-success'>{flee_departure_msg}</span>")
                    if flee_arrival_msg: round_log.append(flee_arrival_msg)
                    combat_resolved_this_round = True 
                else: 
                    round_log.append(f"<span class='combat-miss'>You try to flee {flee_direction_canonical if flee_direction_canonical != 'random' else ''}, but there's nowhere to go! ({flee_departure_msg})</span>") # Include flee_departure_msg if it's an error
            else: 
                round_log.append("<span class='combat-miss'>Your attempt to flee fails! You stumble.</span>")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='char-name'>{character.name}</span> tries to flee, but stumbles!")
        
        elif action_str.startswith("attack"):
            target_mob_id: Optional[uuid.UUID] = None
            try:
                target_mob_id_str = action_str.split(" ", 1)[1]
                target_mob_id = uuid.UUID(target_mob_id_str)
            except (IndexError, ValueError):
                round_log.append("Invalid attack target format in queue.")
            
            if target_mob_id and target_mob_id in active_combats.get(character_id, set()):
                mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_id)
                if mob_instance and mob_instance.mob_template: # CRUCIAL: Check mob_template exists
                    if mob_instance.current_health > 0: # Check health AFTER confirming mob_instance and template
                        mob_template = mob_instance.mob_template # Now safe to access
                        mob_ac = mob_template.base_defense if mob_template.base_defense is not None else 10
                        player_attack_bonus = char_combat_stats["attack_bonus"]
                        player_damage_dice = char_combat_stats["damage_dice"]
                        player_damage_bonus = char_combat_stats["damage_bonus"]
                        to_hit_roll = roll_dice("1d20")

                        updated_mob = None  # Ensure updated_mob is always defined

                        if (to_hit_roll + player_attack_bonus) >= mob_ac:
                            damage = max(1, roll_dice(player_damage_dice) + player_damage_bonus)
                            round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>HITS</span> <span class='inv-item-name'>{mob_template.name}</span> for <span class='combat-hit'>{damage}</span> damage.")
                            await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"<span class='char-name'>{character.name}</span> HITS <span class='inv-item-name'>{mob_template.name}</span> for {damage} damage!")
                            updated_mob = crud.crud_mob.update_mob_instance_health(db, mob_instance.id, -damage)
                        if updated_mob and updated_mob.current_health <= 0:
                            round_log.append(f"<span class='combat-death'>The {mob_template.name} DIES! Fucking finally.</span>")
                            """ await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"The <span class='inv-item-name'>{mob_template.name}</span> DIES!")
                            
                            # XP Award
                            if mob_template.xp_value > 0:
                                char_obj_after_xp, xp_msgs = crud.crud_character.add_experience(db, character.id, mob_template.xp_value)
                                if char_obj_after_xp : character = char_obj_after_xp 
                                round_log.extend(xp_msgs)

                            # >>> ADD CURRENCY DROP LOGIC HERE (copied from skill_resolver) <<<
                            platinum_dropped, gold_dropped, silver_dropped, copper_dropped = 0, 0, 0, 0
                            if mob_template.currency_drop: # mob_template is already confirmed to exist
                                cd = mob_template.currency_drop
                                copper_dropped = random.randint(cd.get("c_min", 0), cd.get("c_max", 0))
                                if random.randint(1, 100) <= cd.get("s_chance", 0):
                                    silver_dropped = random.randint(cd.get("s_min", 0), cd.get("s_max", 0))
                                if random.randint(1, 100) <= cd.get("g_chance", 0):
                                    gold_dropped = random.randint(cd.get("g_min", 0), cd.get("g_max", 0))
                                if random.randint(1, 100) <= cd.get("p_chance", 0):
                                    platinum_dropped = random.randint(cd.get("p_min", 0), cd.get("p_max", 0))
                            
                            if platinum_dropped > 0 or gold_dropped > 0 or silver_dropped > 0 or copper_dropped > 0:
                                char_obj_after_currency, currency_message = crud.crud_character.update_character_currency(
                                    db, character.id, platinum_dropped, gold_dropped, silver_dropped, copper_dropped
                                )
                                if char_obj_after_currency:
                                     character = char_obj_after_currency # Update local character
                                
                                drop_msg_parts_attack = []
                                if platinum_dropped > 0: drop_msg_parts_attack.append(f"{platinum_dropped}p")
                                if gold_dropped > 0: drop_msg_parts_attack.append(f"{gold_dropped}g")
                                if silver_dropped > 0: drop_msg_parts_attack.append(f"{silver_dropped}s")
                                if copper_dropped > 0: drop_msg_parts_attack.append(f"{copper_dropped}c")
                                
                                if drop_msg_parts_attack:
                                     round_log.append(f"The {mob_template.name} drops: {', '.join(drop_msg_parts_attack)}.")
                                     round_log.append(currency_message) # "You gained X. Current balance: Y"
                            # >>> END CURRENCY DROP LOGIC <<< """

                            character_after_attack_loot = await handle_mob_death_loot_and_cleanup(
                                db,
                                character, # The character who made the kill
                                updated_mob, # The mob instance that just died
                                round_log, # The list of log messages for this round
                                player_id, # The player_id
                                current_room_id_for_action_broadcasts # The room ID
                            )
                            if character_after_attack_loot:
                                character = character_after_attack_loot 

                            # crud.crud_mob.despawn_mob_from_room(db, updated_mob.id)
                            active_combats.get(character_id, set()).discard(updated_mob.id)
                            if updated_mob.id in mob_targets: mob_targets.pop(updated_mob.id, None)
                            elif updated_mob:
                                round_log.append(f"  {mob_template.name} HP: <span class='combat-hp'>{updated_mob.current_health}/{mob_template.base_health}</span>.")
                        else: 
                            round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the <span class='inv-item-name'>{mob_template.name}</span>.")
                            await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                          f"<span class='char-name'>{character.name}</span> MISSES the <span class='inv-item-name'>{mob_template.name}</span>.")
                    else: # Mob is dead or has 0 HP
                        round_log.append(f"Your target, {mob_instance.mob_template.name if mob_instance.mob_template else 'the creature'}, is already defeated.")
                        if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
                elif mob_instance: # Mob instance exists but mob_template is None (data issue)
                    logger.error(f"PROC_ROUND: Mob instance {mob_instance.id} missing mob_template. Cannot process attack.")
                    round_log.append(f"Your target is an unrecognizable entity. Attack fails.")
                    if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
                else: # Mob instance not found in DB
                    round_log.append(f"Your target (ID: {target_mob_id}) seems to have vanished utterly.")
                    if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
            elif target_mob_id: # Target mob ID was valid UUID but not in this character's combat
                round_log.append("You try to attack, but your target isn't part of this fight.")
            else: # target_mob_id was None (parsing error from queue)
                 round_log.append("You flail at the air, unsure who to attack. What a loser.")
        
        elif action_str.startswith("use_skill"):
            parts = action_str.split(" ", 2) 
            skill_id_tag_from_queue = parts[1] if len(parts) > 1 else None
            target_identifier_from_queue = parts[2] if len(parts) > 2 else "NONE"
            
            target_entity_for_skill_resolution: Optional[Union[models.RoomMobInstance, str]] = None
            skill_template_to_use = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_id_tag_from_queue) if skill_id_tag_from_queue else None
            valid_target_context_for_skill = False

            if skill_template_to_use:
                if skill_template_to_use.target_type == "ENEMY_MOB":
                    if target_identifier_from_queue.lower() not in ["none", "self"]:
                        try:
                            target_mob_uuid = uuid.UUID(target_identifier_from_queue)
                            if target_mob_uuid in active_combats.get(character_id, set()):
                                mob_for_skill = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_uuid)
                                # CRITICAL: Check mob_for_skill AND mob_for_skill.mob_template
                                if mob_for_skill and mob_for_skill.mob_template and mob_for_skill.current_health > 0:
                                    target_entity_for_skill_resolution = mob_for_skill
                                    valid_target_context_for_skill = True
                                else: round_log.append(f"Skill target '{mob_for_skill.mob_template.name if mob_for_skill and mob_for_skill.mob_template else 'creature'}' is invalid or dead.")
                            else: round_log.append(f"You can't use '{skill_template_to_use.name}' on something you're not actively fighting ({target_identifier_from_queue}).")
                        except ValueError: round_log.append(f"Invalid target ID '{target_identifier_from_queue}' for skill.")
                    else: round_log.append(f"'{skill_template_to_use.name}' requires an enemy target.")
                
                elif skill_template_to_use.target_type == "DOOR":
                    if target_identifier_from_queue.lower() not in ["none", "self"]:
                        target_entity_for_skill_resolution = target_identifier_from_queue 
                        valid_target_context_for_skill = True
                    else: round_log.append(f"You need to specify a direction for '{skill_template_to_use.name}'.")

                elif skill_template_to_use.target_type in ["SELF", "NONE"]:
                    target_entity_for_skill_resolution = None 
                    valid_target_context_for_skill = True
                
                if valid_target_context_for_skill:
                    skill_messages, action_was_taken_by_skill, char_after_skill = await resolve_skill_effect(
                        db, character, skill_template_to_use, target_entity_for_skill_resolution, 
                        player_id, current_room_id_for_action_broadcasts
                    )
                    round_log.extend(skill_messages)
                    if char_after_skill: character = char_after_skill 
                    
                    if not action_was_taken_by_skill and not any("enough mana" in m.lower() for m in skill_messages) and \
                       not any("already unlocked" in m.lower() for m in skill_messages):
                        round_log.append(f"Your attempt to use {skill_template_to_use.name} fizzles.")
                elif not round_log: 
                    round_log.append(f"Could not determine a valid target or context for '{skill_template_to_use.name}'.")
            else:
                round_log.append(f"You try to use a skill '{skill_id_tag_from_queue}', but it's invalid or unknown.")
    else: 
        round_log.append("You pause, bewildered by the chaos.")

    # --- 4. Check if Player's Targets Are Defeated (Post-Player Action) ---
    current_targets_for_player = list(active_combats.get(character_id, set()))
    all_targets_down_after_player_action = True
    if not current_targets_for_player:
        all_targets_down_after_player_action = True
    else:
        for mob_target_id in current_targets_for_player:
            mob_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_target_id)
            if mob_check and mob_check.current_health > 0: # Ensure mob exists AND is alive
                all_targets_down_after_player_action = False; break
    
    if all_targets_down_after_player_action and not combat_resolved_this_round:
        round_log.append("All your targets are defeated or gone. Combat ends.")
        combat_resolved_this_round = True

    # --- 5. Mobs' Actions (Retaliation) ---
    if not combat_resolved_this_round and character.current_health > 0:
        mobs_attacking_character_this_round: List[models.RoomMobInstance] = []
        for mob_id, targeted_char_id in list(mob_targets.items()): # Iterate copy
            if targeted_char_id == character_id:
                mob_instance_to_act = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id)
                if mob_instance_to_act and mob_instance_to_act.mob_template and \
                   mob_instance_to_act.current_health > 0 and \
                   mob_instance_to_act.room_id == character.current_room_id:
                    mobs_attacking_character_this_round.append(mob_instance_to_act)
        
        for mob_instance in mobs_attacking_character_this_round:
            if character.current_health <= 0: break 
            mob_template = mob_instance.mob_template # Safe due to check above
            # ... (mob attack logic as before, character health is updated directly) ...
            mob_attack_bonus = mob_template.level or 1 
            mob_damage_dice = mob_template.base_attack or "1d4"
            mob_to_hit_roll = roll_dice("1d20")

            if (mob_to_hit_roll + mob_attack_bonus) >= player_ac:
                damage_to_player = max(1, roll_dice(mob_damage_dice))
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-success'>HITS</span> <span class='char-name'>{character.name}</span> for <span class='combat-hit-player'>{damage_to_player}</span> damage.")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> HITS <span class='char-name'>{character.name}</span> for {damage_to_player} damage!")
                character.current_health -= damage_to_player 
                round_log.append(f"  Your HP: <span class='combat-hp'>{character.current_health}/{character.max_health}</span>.")
                if character.current_health <= 0:
                    character.current_health = 0 
                    round_log.append("<span class='combat-death'>YOU HAVE DIED! How utterly predictable.</span>")
                    await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                                  f"<span class='char-name'>{character.name}</span> <span class='combat-death'>HAS DIED!</span>")
                    combat_resolved_this_round = True 
                    max_health_at_death = character.max_health
                    respawn_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0)
                    if respawn_room_orm:
                        char_after_respawn = crud.crud_character.update_character_room(db, character_id=character.id, new_room_id=respawn_room_orm.id)
                        if char_after_respawn: 
                            character = char_after_respawn # Update local character
                            round_log.append(f"A mystical force whisks your fading spirit away. You awaken, gasping, in <span class='room-name'>{respawn_room_orm.name}</span>.")
                        else: round_log.append("Error: Failed to update character room during respawn."); break 
                    else: round_log.append("Error: Respawn room (0,0,0) not found."); break 
                    character.current_health = max_health_at_death 
                    round_log.append("You feel a surge of life, your wounds miraculously healed.")
                    break 
            else: 
                round_log.append(f"<span class='inv-item-name'>{mob_template.name}</span> <span class='combat-miss'>MISSES</span> <span class='char-name'>{character.name}</span>.")
                await broadcast_combat_event(db, current_room_id_for_action_broadcasts, player_id,
                                              f"<span class='inv-item-name'>{mob_template.name}</span> MISSES <span class='char-name'>{character.name}</span>.")
    
    # --- 6. End of Round Cleanup & Next Action Queuing ---
    if combat_resolved_this_round:
        end_combat_for_character(character_id, reason="combat_resolved_this_round_proc_round")
    elif character.current_health > 0 and character_id in active_combats:
        if not action_str or action_str.startswith("attack") or (action_str.startswith("flee") and not combat_resolved_this_round):
            remaining_targets_for_next_round = list(active_combats.get(character_id, set()))
            first_valid_target_id_for_next_round = None
            if remaining_targets_for_next_round:
                for mob_id_check in remaining_targets_for_next_round:
                    mob_next_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id_check)
                    if mob_next_check and mob_next_check.current_health > 0:
                        first_valid_target_id_for_next_round = mob_id_check; break 
            if first_valid_target_id_for_next_round:
                character_queued_actions[character_id] = f"attack {first_valid_target_id_for_next_round}"
            else: 
                if not combat_resolved_this_round : 
                    round_log.append("No valid targets remain for next round. Combat ends.")
                end_combat_for_character(character_id, reason="no_valid_targets_remain_proc_round")
                combat_resolved_this_round = True 
    
    # --- 7. Final DB Commit & Send Log ---
    db.add(character) # Ensure character changes are staged
    # Room changes (e.g. from lockpicking) are staged by resolve_skill_effect
    db.commit()
    db.refresh(character) 
    
    # Send log with potentially updated room (if fled/died)
    final_room_for_payload_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    final_room_schema_for_payload = schemas.RoomInDB.from_orm(final_room_for_payload_orm) if final_room_for_payload_orm else None
    
    xp_for_next_level_final = crud.crud_character.get_xp_for_level(character.level + 1)
    final_vitals_payload = {
        "current_hp": character.current_health, "max_hp": character.max_health,
        "current_mp": character.current_mana, "max_mp": character.max_mana,
        "current_xp": character.experience_points,
        "next_level_xp": int(xp_for_next_level_final) if xp_for_next_level_final != float('inf') else -1,
        "level": character.level,
        "platinum": character.platinum_coins, "gold": character.gold_coins,
        "silver": character.silver_coins, "copper": character.copper_coins
    }
    
    await send_combat_log(
        player_id, round_log, combat_resolved_this_round, 
        final_room_schema_for_payload, character_vitals=final_vitals_payload
    )
--- END OF FILE backend/app/game_logic/combat/combat_round_processor.py ---

--- START OF FILE backend/app/game_logic/combat/combat_utils.py ---
# backend/app/game_logic/combat/combat_utils.py
import logging
import random
import uuid
from typing import List, Optional, Any, Dict, Tuple

from sqlalchemy.orm import Session

from app import schemas, models, crud # For ORM types and CRUD access
from app.websocket_manager import connection_manager as ws_manager
# Avoid direct imports from other combat submodules here if possible to prevent circular deps.
# If a util needs specific combat state, it might belong elsewhere or state should be passed.

logger = logging.getLogger(__name__) # Assuming logging is set up

direction_map = {"n": "north", "s": "south", "e": "east", "w": "west", "u": "up", "d": "down"}

OPPOSITE_DIRECTIONS_MAP = {
    "north": "south", "south": "north", "east": "west", "west": "east",
    "up": "down", "down": "up",
    "northeast": "southwest", "southwest": "northeast",
    "northwest": "southeast", "southeast": "northwest"
    # Example of a problematic entry if it were a dict:
    # "north": {"name": "south", "description": "the chilly south"} 
}

PLACEHOLDER_LOOT_TABLES: Dict[str, List[Tuple[str, int, int, int]]] = {
    "vermin_common": [("Rat Tail", 50, 1, 1), ("Cracked Tooth", 25, 1, 1)],
    "small_beast_parts": [("Beast Pelt (Small)", 30, 1, 1), ("Animal Bone", 60, 1, 2)],
    "tier1_trash": [("Old Boot", 10, 1, 1), ("Rusty Tin Can", 15, 1, 1)],
    "goblin_common": [("Goblin Ear", 40, 1, 2), ("Crude Dagger Scrap", 20, 1, 1), ("Torn Pouch", 30, 1, 1)],
    "crude_gear": [("Rusty Sword", 5, 1, 1), ("Dagger", 8, 1, 1), ("Wooden Shield", 3, 1, 1)],
    "construct_parts_common": [("Bent Gear", 50, 1, 3), ("Frayed Wire", 40, 1, 2), ("Small Lens", 15, 1, 1)],
    "tech_scrap": [("Scrap Metal", 60, 1, 5)],
    "spider_parts": [("Spider Silk Gland", 35, 1, 1), ("Spider Fang", 25, 1, 2)],
    "tier1_beast_loot": [("Beast Meat", 40, 1, 1)],
    "ectoplasm": [("Ectoplasmic Residue", 70, 1, 3)],
    "spirit_essence": [("Faint Spirit Essence", 25, 1, 1)],
    "tier2_ethereal": [("Ghostly Shroud Scrap", 10, 1, 1)],
    "elemental_mote_air": [("Whirling Dust Mote", 60, 1, 2)],
    "tier1_elemental": [("Charged Sand", 20, 1, 1)],
    "bandit_gear": [("Tarnished Ring", 5, 1, 1), ("Patched Leather Jerkin", 10, 1, 1)], # Item names
    "stolen_goods_common": [("Cheap Locket", 15, 1, 1), ("Bent Silver Spoon", 20, 1, 1)],
    "tier2_humanoid": [("Sharpened Bone", 30, 1, 1)],
    "bat_parts": [("Bat Wing", 70, 1, 2)],
    "tier1_swarm_remains": [("Guano", 20, 1, 3)], # Charming
    "construct_parts_rare": [("Intact Servomotor", 10, 1, 1)],
    "enchanted_metal_shards": [("Faintly Glowing Shard", 20, 1, 2)],
    "tier2_construct": [("Polished Steel Plate", 5, 1, 1)],
    "dire_wolf_pelt": [("Dire Wolf Pelt", 60, 1, 1)],
    "large_beast_trophy": [("Large Wolf Fang", 30, 1, 1)],
    "tier3_beast_loot": [("Prime Beast Meat", 15, 1, 1)]
}

async def handle_mob_death_loot_and_cleanup(
    db: Session,
    character: models.Character, 
    killed_mob_instance: models.RoomMobInstance,
    log_messages_list: List[str], 
    player_id: uuid.UUID, 
    current_room_id_for_broadcast: uuid.UUID
) -> models.Character:
    mob_template = killed_mob_instance.mob_template 
    character_after_loot = character # Start with the character passed in

    logger.debug(f"LOOT: Handling death of {mob_template.name if mob_template else 'Unknown Mob'} in room {current_room_id_for_broadcast}")

    if not mob_template:
        logger.warning(f"LOOT: No mob_template for killed_mob_instance {killed_mob_instance.id}")
        crud.crud_mob.despawn_mob_from_room(db, killed_mob_instance.id) # Despawn and commit handled by despawn_mob_from_room
        return character_after_loot

    # --- XP Award ---
    if mob_template.xp_value > 0:
        logger.debug(f"LOOT: Awarding {mob_template.xp_value} XP to {character.name}.")
        # add_experience commits internally
        updated_char_for_xp, xp_messages = crud.crud_character.add_experience(
            db, character_after_loot.id, mob_template.xp_value
        )
        if updated_char_for_xp:
            character_after_loot = updated_char_for_xp # Use the character returned by add_experience
        log_messages_list.extend(xp_messages)

    # --- Currency Drop ---
    platinum_dropped, gold_dropped, silver_dropped, copper_dropped = 0, 0, 0, 0
    if mob_template.currency_drop:
        cd = mob_template.currency_drop
        copper_dropped = random.randint(cd.get("c_min", 0), cd.get("c_max", 0))
        if random.randint(1, 100) <= cd.get("s_chance", 0):
            silver_dropped = random.randint(cd.get("s_min", 0), cd.get("s_max", 0))
        if random.randint(1, 100) <= cd.get("g_chance", 0):
            gold_dropped = random.randint(cd.get("g_min", 0), cd.get("g_max", 0))
        if random.randint(1, 100) <= cd.get("p_chance", 0):
            platinum_dropped = random.randint(cd.get("p_min", 0), cd.get("p_max", 0))
    
    if platinum_dropped > 0 or gold_dropped > 0 or silver_dropped > 0 or copper_dropped > 0:
        # update_character_currency commits internally
        updated_char_for_currency, currency_message = crud.crud_character.update_character_currency(
            db, character_after_loot.id, platinum_dropped, gold_dropped, silver_dropped, copper_dropped
        )
        if updated_char_for_currency:
             character_after_loot = updated_char_for_currency # Use the character returned by update_character_currency
        
        drop_messages_parts = []
        if platinum_dropped > 0: drop_messages_parts.append(f"{platinum_dropped}p")
        if gold_dropped > 0: drop_messages_parts.append(f"{gold_dropped}g")
        if silver_dropped > 0: drop_messages_parts.append(f"{silver_dropped}s")
        if copper_dropped > 0: drop_messages_parts.append(f"{copper_dropped}c")
        
        if drop_messages_parts:
             log_messages_list.append(f"The {mob_template.name} drops: {', '.join(drop_messages_parts)}.")
             log_messages_list.append(currency_message) 

    # --- Item Loot Drop ---
    items_dropped_this_kill_details: List[str] = [] # For logging
    if mob_template.loot_table_tags:
        logger.debug(f"LOOT: Processing loot_table_tags: {mob_template.loot_table_tags} for {mob_template.name}")
        for loot_tag in mob_template.loot_table_tags:
            if loot_tag in PLACEHOLDER_LOOT_TABLES:
                potential_drops = PLACEHOLDER_LOOT_TABLES[loot_tag]
                for item_name_or_tag_from_loot_def, chance, min_qty, max_qty in potential_drops:
                    if random.randint(1, 100) <= chance:
                        item_template_to_drop = crud.crud_item.get_item_by_name(db, name=item_name_or_tag_from_loot_def)
                        if not item_template_to_drop: # Fallback to item_tag if name lookup fails
                             item_template_to_drop = crud.crud_item.get_item_by_item_tag(db, item_tag=item_name_or_tag_from_loot_def)

                        if item_template_to_drop:
                            quantity_to_drop = random.randint(min_qty, max_qty)
                            logger.debug(f"LOOT: Attempting to drop {quantity_to_drop}x {item_template_to_drop.name} in room {current_room_id_for_broadcast}")
                            
                            # crud.crud_room_item.add_item_to_room commits internally.
                            # This is not ideal for batching operations within a single combat round.
                            # For now, we proceed, accepting multiple small commits if many items drop.
                            added_room_item, add_msg = crud.crud_room_item.add_item_to_room(
                                db=db, room_id=current_room_id_for_broadcast, 
                                item_id=item_template_to_drop.id, quantity=quantity_to_drop
                            )
                            if added_room_item:
                                items_dropped_this_kill_details.append(f"{quantity_to_drop}x {item_template_to_drop.name}")
                            else:
                                logger.error(f"LOOT: crud.crud_room_item.add_item_to_room failed for {item_template_to_drop.name}: {add_msg}")
                        else:
                            logger.warning(f"LOOT: Item template '{item_name_or_tag_from_loot_def}' (from loot_tag '{loot_tag}') not found in DB.")
            else:
                logger.warning(f"LOOT: Loot table tag '{loot_tag}' for mob '{mob_template.name}' not defined in PLACEHOLDER_LOOT_TABLES.")
        
        if items_dropped_this_kill_details:
            log_messages_list.append(f"The {mob_template.name} also drops: {', '.join(items_dropped_this_kill_details)} on the ground.")
            await broadcast_to_room_participants(
                db, current_room_id_for_broadcast,
                f"The {mob_template.name} drops {', '.join(items_dropped_this_kill_details)}!",
                exclude_player_id=player_id
            )

    # --- Despawn Mob ---
    logger.debug(f"LOOT: Despawning mob instance {killed_mob_instance.id} for {mob_template.name}.")
    # despawn_mob_from_room handles its own commit if it updates a spawn definition.
    crud.crud_mob.despawn_mob_from_room(db, killed_mob_instance.id) 
    
    # The overall commit for the combat round (including character mana/health changes from the skill itself)
    # will be handled by the calling function (process_combat_round).
    # We return character_after_loot which has been updated by XP and currency.
    return character_after_loot

def get_opposite_direction(direction: str) -> str:
    """
    Returns the opposite cardinal or intercardinal direction name as a string.
    If the map contains a dictionary for a direction, it attempts to extract
    a 'name' key, otherwise defaults.
    """
    if not direction: # Handle empty string case
        return "an unknown direction"

    value = OPPOSITE_DIRECTIONS_MAP.get(direction.lower())

    if value is None:
        return "somewhere" # Default if direction not in map

    if isinstance(value, dict):
        # If the map value is a dictionary, try to get a 'name' key.
        # This makes the function resilient if the map was changed.
        return str(value.get("name", "an undefined direction"))
    
    # Otherwise, the value should already be a string (or convertible to one)
    return str(value)

async def send_combat_log(
    player_id: uuid.UUID, 
    messages: List[str], 
    combat_ended: bool = False, 
    room_data: Optional[schemas.RoomInDB] = None,
    character_vitals: Optional[Dict[str, Any]] = None,
    transient: bool = False
):
    if not messages and not combat_ended and not room_data and not character_vitals: # Added vitals check
        return # Avoid sending empty updates unless explicitly combat_ended=True
    
    payload = {
        "type": "combat_update",
        "log": messages,
        "combat_over": combat_ended,
        "room_data": room_data.model_dump(exclude_none=True) if room_data else None,
        "character_vitals": character_vitals,
        "is_transient_log": transient
    }
    await ws_manager.send_personal_message(payload, player_id)

async def broadcast_to_room_participants( # Renamed from _broadcast_to_room_participants
    db: Session, 
    room_id: uuid.UUID, 
    message_text: str, 
    message_type: str = "game_event",
    exclude_player_id: Optional[uuid.UUID] = None
):
    excluded_character_id: Optional[uuid.UUID] = None
    if exclude_player_id:
        excluded_character_id = ws_manager.get_character_id(exclude_player_id)

    characters_to_notify = crud.crud_character.get_characters_in_room(
        db, 
        room_id=room_id, 
        exclude_character_id=excluded_character_id
    )
    
    player_ids_to_send_to = [
        char.player_id for char in characters_to_notify 
        if ws_manager.is_player_connected(char.player_id) and (exclude_player_id is None or char.player_id != exclude_player_id)
    ]
            
    if player_ids_to_send_to:
        payload = {"type": message_type, "message": message_text}
        await ws_manager.broadcast_to_players(payload, player_ids_to_send_to)

async def broadcast_combat_event(db: Session, room_id: uuid.UUID, acting_player_id: uuid.UUID, message: str): # Renamed
    acting_char_id: Optional[uuid.UUID] = ws_manager.get_character_id(acting_player_id)
    
    # Ensure acting_char_id is valid before using in exclude for get_characters_in_room
    # This prevents sending the event to the acting player if they are the only one.
    # The logic in broadcast_to_players already handles not sending to self if exclude_player_id is correctly derived.

    player_ids_to_notify = [
        char.player_id for char in crud.crud_character.get_characters_in_room(db, room_id=room_id, exclude_character_id=acting_char_id)
        if ws_manager.is_player_connected(char.player_id) and char.player_id != acting_player_id # Double ensure not sending to self
    ]
    if player_ids_to_notify:
        await ws_manager.broadcast_to_players({"type": "game_event", "message": message}, player_ids_to_notify)


async def perform_server_side_move( # Renamed from _perform_server_side_move
    db: Session,
    character: models.Character,
    direction_canonical: str,
    player_id_for_broadcast: uuid.UUID
) -> Tuple[Optional[uuid.UUID], str, str, Optional[models.Room]]:
    # This function's logic from the old combat_manager.py
    # It needs access to crud.crud_room, crud.crud_character, get_opposite_direction
    old_room_id = character.current_room_id
    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=old_room_id)
    
    departure_message = f"You flee {direction_canonical}."
    arrival_message = "" 

    if not current_room_orm:
        return None, "You are in a void and cannot move.", "", None

    actual_direction_moved = direction_canonical
    if direction_canonical == "random":
        available_exits_data = current_room_orm.exits or {}
        # Filter for valid, unlocked exits
        valid_directions_to_flee = []
        for direction, exit_data_dict in available_exits_data.items():
            if isinstance(exit_data_dict, dict):
                try:
                    exit_detail = schemas.ExitDetail(**exit_data_dict)
                    if not exit_detail.is_locked:
                        valid_directions_to_flee.append(direction)
                except Exception:
                    pass # Ignore malformed exits for random flee
        
        if not valid_directions_to_flee:
            return None, "You look around frantically, but there's no obvious way to flee!", "", None
        actual_direction_moved = random.choice(valid_directions_to_flee)
        departure_message = f"You scramble away, fleeing {actual_direction_moved}!"

    # Re-fetch exit data for the chosen actual_direction_moved
    chosen_exit_data_dict = (current_room_orm.exits or {}).get(actual_direction_moved)
    if not isinstance(chosen_exit_data_dict, dict):
        # This implies internal inconsistency if a direction was chosen from exits
        logger.error(f"perform_server_side_move: Chosen direction '{actual_direction_moved}' from room {current_room_orm.id} has malformed exit data: {chosen_exit_data_dict}")
        return None, f"The path {actual_direction_moved} has dissolved!", "", None
        
    try:
        chosen_exit_detail = schemas.ExitDetail(**chosen_exit_data_dict)
    except Exception as e_parse:
        logger.error(f"perform_server_side_move: Pydantic error parsing chosen exit detail for {actual_direction_moved} in room {current_room_orm.id}: {e_parse}")
        return None, f"The way {actual_direction_moved} is corrupted!", "", None

    if chosen_exit_detail.is_locked: # Should not happen if valid_directions_to_flee was used for random
        return None, chosen_exit_detail.description_when_locked, "", None

    target_room_uuid = chosen_exit_detail.target_room_id
    target_room_orm = crud.crud_room.get_room_by_id(db, room_id=target_room_uuid)
    if not target_room_orm:
        return None, f"The path {actual_direction_moved} seems to vanish into nothingness.", "", None

    await broadcast_to_room_participants(db, old_room_id, f"<span class='char-name'>{character.name}</span> flees {actual_direction_moved}.", exclude_player_id=player_id_for_broadcast)

    updated_char = crud.crud_character.update_character_room(db, character_id=character.id, new_room_id=target_room_orm.id)
    if not updated_char: return None, "A strange force prevents your escape.", "", None
    
    character.current_room_id = target_room_orm.id 
    
    arrival_message = f"You burst into <span class='room-name'>{target_room_orm.name}</span>."
    
    opposite_dir = get_opposite_direction(actual_direction_moved)
    await broadcast_to_room_participants(db, target_room_orm.id, f"<span class='char-name'>{character.name}</span> arrives from the {opposite_dir}.", exclude_player_id=player_id_for_broadcast)
    
    return target_room_orm.id, departure_message, arrival_message, target_room_orm
--- END OF FILE backend/app/game_logic/combat/combat_utils.py ---

--- START OF FILE backend/app/crud/crud_character_inventory.py ---
# backend/app/crud/crud_character_inventory.py
from sqlalchemy.orm import Session, joinedload, attributes
import uuid
from typing import List, Optional, Tuple, Dict # Added Dict
import logging

from .. import models, schemas # models.Item, models.Character, models.CharacterInventoryItem
from ..models.item import EQUIPMENT_SLOTS # For validation

logger = logging.getLogger(__name__)

def get_inventory_item_entry_by_id(db: Session, inventory_item_id: uuid.UUID) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item)
    ).filter(models.CharacterInventoryItem.id == inventory_item_id).first()

def get_character_inventory(db: Session, character_id: uuid.UUID) -> List[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item)
    ).filter(models.CharacterInventoryItem.character_id == character_id).all()

def character_has_item_with_tag(db: Session, character_id: uuid.UUID, item_tag: str) -> bool:
    count = db.query(models.CharacterInventoryItem.id).join(
        models.Item, models.CharacterInventoryItem.item_id == models.Item.id
    ).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.Item.properties["item_tag"].astext == item_tag
    ).count()
    return count > 0

def add_item_to_character_inventory(
    db: Session, *, character_obj: models.Character, item_id: uuid.UUID, quantity: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    if quantity <= 0:
        return None, "Quantity must be positive."

    # Ensure character_obj has an ID, important if it's a new character in the same transaction
    if not character_obj.id:
        logger.warning("Character object does not have an ID yet. Flushing session to assign ID before adding inventory.")
        try:
            db.flush([character_obj]) # Flush only this object to get an ID if it's new
            if not character_obj.id: # Still no ID after flush
                logger.error("Failed to obtain character ID even after flush. Cannot add item to inventory.")
                return None, "Cannot add item: Character ID missing."
        except Exception as e_flush:
            logger.error(f"Error flushing character to get ID: {e_flush}")
            db.rollback() # Rollback potential partial flush
            return None, "Error obtaining character ID for inventory."

    first_created_or_updated_entry: Optional[models.CharacterInventoryItem] = None
    total_added_successfully = 0
    messages: List[str] = []

    if item_template.stackable:
        remaining_quantity_to_add = quantity
        
        # Get the max_stack_size from the item template.
        # If it's None, this item has no defined stack limit from the template.
        effective_max_stack_template: Optional[int] = item_template.max_stack_size

        # Attempt to add to an existing unequipped stack first
        existing_unequipped_stack = db.query(models.CharacterInventoryItem).filter(
            models.CharacterInventoryItem.character_id == character_obj.id,
            models.CharacterInventoryItem.item_id == item_id,
            models.CharacterInventoryItem.equipped == False
        ).first()

        if existing_unequipped_stack:
            space_in_existing_stack: int
            if effective_max_stack_template is None: # No defined limit on the item template
                # If no limit, it can take all remaining quantity.
                space_in_existing_stack = remaining_quantity_to_add
            else:
                # Calculate space based on the defined limit.
                space_in_existing_stack = effective_max_stack_template - existing_unequipped_stack.quantity
            
            # Ensure we don't try to add a negative amount if stack is somehow overfull (data integrity issue)
            space_in_existing_stack = max(0, space_in_existing_stack)
            
            can_add_to_this_stack = min(remaining_quantity_to_add, space_in_existing_stack)

            if can_add_to_this_stack > 0:
                existing_unequipped_stack.quantity += can_add_to_this_stack
                db.add(existing_unequipped_stack) # Mark as changed
                if not first_created_or_updated_entry:
                    first_created_or_updated_entry = existing_unequipped_stack
                total_added_successfully += can_add_to_this_stack
                remaining_quantity_to_add -= can_add_to_this_stack
                messages.append(f"Added {can_add_to_this_stack} to existing stack of {item_template.name}.")

        # Add any remaining quantity to new stacks
        while remaining_quantity_to_add > 0:
            current_add_amount: int
            if effective_max_stack_template is None: # No limit for new stacks either
                current_add_amount = remaining_quantity_to_add # Create one new stack with all remaining
            elif remaining_quantity_to_add > effective_max_stack_template:
                current_add_amount = effective_max_stack_template # Fill one new stack to max
            else:
                current_add_amount = remaining_quantity_to_add # New stack with the rest

            new_entry = models.CharacterInventoryItem(
                character_id=character_obj.id,
                item_id=item_id,
                quantity=current_add_amount
            )
            db.add(new_entry)
            if not first_created_or_updated_entry:
                first_created_or_updated_entry = new_entry
            total_added_successfully += current_add_amount
            remaining_quantity_to_add -= current_add_amount
            messages.append(f"Created new stack of {item_template.name} with {current_add_amount}.")
    
    else: # Not stackable, create individual entries
        for _ in range(quantity):
            new_entry = models.CharacterInventoryItem(
                character_id=character_obj.id,
                item_id=item_id,
                quantity=1 # Non-stackable items always have quantity 1 per entry
            )
            db.add(new_entry)
            if not first_created_or_updated_entry:
                first_created_or_updated_entry = new_entry
            total_added_successfully += 1
        if total_added_successfully > 0:
             messages.append(f"Added {total_added_successfully} individual {item_template.name}(s).")

    # Construct final message based on operations
    final_message = ""
    if total_added_successfully == quantity and quantity > 0:
        # Consolidate messages if only one operation occurred
        if len(messages) == 1:
            final_message = messages[0].replace("Staged ", "").capitalize() # Cleaner message
        elif len(messages) > 1:
            final_message = f"Successfully added {quantity}x {item_template.name}. Details: {' '.join(messages)}"
        else: # Should not happen if total_added_successfully > 0
            final_message = f"Staged addition of {quantity}x {item_template.name}."
    elif total_added_successfully > 0 and total_added_successfully < quantity:
        final_message = f"Partially added {item_template.name}: {total_added_successfully} of {quantity} due to limits. Details: {' '.join(messages)}"
    elif total_added_successfully == 0 and quantity > 0:
        final_message = f"Could not add any {item_template.name}; likely due to stack limits or other constraints. Details: {' '.join(messages)}"
    elif quantity == 0 : # Explicitly adding zero quantity
        final_message = f"No {item_template.name} added (quantity was zero)."


    return first_created_or_updated_entry, final_message


def remove_item_from_character_inventory(
    db: Session, *, inventory_item_id: uuid.UUID, quantity_to_remove: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    entry = get_inventory_item_entry_by_id(db, inventory_item_id)
    if not entry:
        return None, "Inventory item entry not found."
    if entry.equipped:
        item_name = entry.item.name if entry.item else "item"
        return None, f"Cannot remove '{item_name}'; it is currently equipped. Unequip it first."
    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = entry.item.name if entry.item else "Unknown Item"

    if entry.quantity > quantity_to_remove:
        entry.quantity -= quantity_to_remove
        db.add(entry)
        return entry, f"Staged removal of {quantity_to_remove} x {original_item_name}. {entry.quantity} remaining."
    elif entry.quantity <= quantity_to_remove: # Remove the whole stack/item
        removed_qty = entry.quantity
        db.delete(entry)
        # If quantity_to_remove was > entry.quantity, we only removed what was there.
        # The message should reflect the actual amount removed.
        message = f"Staged deletion of all {removed_qty} x {original_item_name} from inventory."
        if quantity_to_remove > removed_qty:
            message += f" (Tried to remove {quantity_to_remove}, only {removed_qty} available)."
        return None, message # Return None because the entry is deleted
    return None, "Error in remove item logic." # Should not reach here


def equip_item_from_inventory(
    db: Session, *, character_obj: models.Character, inventory_item_id: uuid.UUID, target_slot: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    logger.debug(f"[CRUD_EQUIP] Attempting to equip item_id: {inventory_item_id} for char: {character_obj.name} to slot: {target_slot}")
    char_inv_entry = get_inventory_item_entry_by_id(db, inventory_item_id)

    if not char_inv_entry:
        logger.warning(f"[CRUD_EQUIP_FAIL] Item instance {inventory_item_id} not found.")
        return None, "Item instance not found in your inventory records."
    if char_inv_entry.character_id != character_obj.id:
        logger.warning(f"[CRUD_EQUIP_FAIL] Ownership mismatch: Item {inventory_item_id} (owner: {char_inv_entry.character_id}) vs Char {character_obj.id}")
        return None, "This item does not belong to you."

    item_name_for_log = char_inv_entry.item.name if char_inv_entry.item else "UnknownItem"
    if char_inv_entry.equipped:
        logger.info(f"[CRUD_EQUIP_FAIL] Item '{item_name_for_log}' ({inventory_item_id}) already equipped in {char_inv_entry.equipped_slot}.")
        return char_inv_entry, f"{item_name_for_log} is already equipped in {char_inv_entry.equipped_slot}."

    item_template = char_inv_entry.item
    if not item_template:
        logger.error(f"[CRUD_EQUIP_FAIL] Inventory item {char_inv_entry.id} is missing its item_template relationship.")
        return None, "Item template data missing for this inventory item."

    if not item_template.slot or item_template.slot in ["consumable", "inventory", "junk", "key", "tool", "crafting_material"]:
        logger.warning(f"[CRUD_EQUIP_FAIL] Item '{item_template.name}' (type: {item_template.item_type}, defined slot: {item_template.slot}) is not equippable.")
        return None, f"{item_template.name} is not equippable in a character slot."

    final_target_slot = target_slot
    item_defined_slot_type = item_template.slot

    if not final_target_slot:
        if item_defined_slot_type in EQUIPMENT_SLOTS:
            final_target_slot = item_defined_slot_type
            logger.debug(f"[CRUD_EQUIP] Auto-determined slot for '{item_template.name}' to be '{final_target_slot}' based on item.slot '{item_defined_slot_type}'.")
        elif item_defined_slot_type == "ring":
             logger.warning(f"[CRUD_EQUIP_FAIL] Specific finger slot not provided for ring '{item_template.name}'.")
             return None, f"Please specify which finger slot to equip {item_template.name} (e.g., equip {item_template.name} finger_1)."
        else:
            logger.warning(f"[CRUD_EQUIP_FAIL] Cannot auto-determine slot for '{item_template.name}' (type: {item_defined_slot_type}). User must specify.")
            return None, f"Cannot automatically determine slot for {item_template.name} (defined slot type: {item_defined_slot_type}). Please specify a target slot."

    if final_target_slot not in EQUIPMENT_SLOTS:
        logger.warning(f"[CRUD_EQUIP_FAIL] Invalid target_slot '{final_target_slot}' specified by user or logic.")
        return None, f"Invalid equipment slot: '{final_target_slot}'. Valid slots are: {', '.join(EQUIPMENT_SLOTS.keys())}."

    # Compatibility checks
    if item_defined_slot_type == "ring" and not final_target_slot.startswith("finger"):
        return None, f"{item_template.name} (a ring) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."
    if item_defined_slot_type == "main_hand" and final_target_slot not in ["main_hand", "off_hand"]:
        return None, f"{item_template.name} (main_hand weapon) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."
    if item_defined_slot_type == "off_hand" and final_target_slot != "off_hand": # Shields, etc.
        return None, f"{item_template.name} (off_hand item) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."
    # Ensure a general item (e.g. item.slot = "torso") is being equipped to the correct slot
    if item_defined_slot_type != "ring" and item_defined_slot_type not in ["main_hand", "off_hand"] and item_defined_slot_type != final_target_slot:
        return None, f"{item_template.name} (for {item_defined_slot_type}) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."


    # Fetch current inventory directly from DB within this transaction for most up-to-date view
    current_character_inventory_snapshot = get_character_inventory(db, character_obj.id)

    # 1. Unequip item(s) currently in the final_target_slot
    for item_to_unequip_orm in current_character_inventory_snapshot:
        if item_to_unequip_orm.id == char_inv_entry.id: continue # Don't try to unequip the item we are trying to equip
        if item_to_unequip_orm.equipped and item_to_unequip_orm.equipped_slot == final_target_slot:
            logger.info(f"[CRUD_EQUIP] Unequipping '{item_to_unequip_orm.item.name if item_to_unequip_orm.item else 'item'}' from slot '{final_target_slot}' to make space.")
            item_to_unequip_orm.equipped = False
            item_to_unequip_orm.equipped_slot = None
            db.add(item_to_unequip_orm)

    # 2. Handle two-handed items: if equipping a two-handed item, unequip from the other hand slot
    if item_template.properties and item_template.properties.get("two_handed", False):
        other_hand_slot = None
        if final_target_slot == "main_hand": other_hand_slot = "off_hand"
        elif final_target_slot == "off_hand": other_hand_slot = "main_hand" # Equipping two-hander in off_hand implies main is also used

        if other_hand_slot:
            for other_hand_item_orm in current_character_inventory_snapshot:
                if other_hand_item_orm.id == char_inv_entry.id: continue
                if other_hand_item_orm.equipped and other_hand_item_orm.equipped_slot == other_hand_slot:
                    logger.info(f"[CRUD_EQUIP] Unequipping '{other_hand_item_orm.item.name if other_hand_item_orm.item else 'item'}' from '{other_hand_slot}' for two-handed '{item_template.name}'.")
                    other_hand_item_orm.equipped = False
                    other_hand_item_orm.equipped_slot = None
                    db.add(other_hand_item_orm)

    # 3. Equip the new item
    # If the item being equipped is stackable and quantity > 1, we need to split it.
    # One item gets equipped, the rest (quantity - 1) remains/becomes an unequipped stack.
    if item_template.stackable and char_inv_entry.quantity > 1:
        # Create a new inventory entry for the remainder
        remainder_quantity = char_inv_entry.quantity - 1
        new_unequipped_stack = models.CharacterInventoryItem(
            character_id=character_obj.id,
            item_id=item_template.id,
            quantity=remainder_quantity
        )
        db.add(new_unequipped_stack)
        logger.debug(f"Split stack for equipping: {remainder_quantity} of {item_template.name} remains in backpack.")
        # Modify the current entry to be quantity 1 and equipped
        char_inv_entry.quantity = 1

    logger.info(f"[CRUD_EQUIP] Setting item '{item_template.name}' (ID: {char_inv_entry.id}): equipped=True, equipped_slot='{final_target_slot}'")
    char_inv_entry.equipped = True
    char_inv_entry.equipped_slot = final_target_slot
    db.add(char_inv_entry)

    return char_inv_entry, f"Staged equipping of {item_template.name} to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."

def unequip_item_to_inventory(
    db: Session, *, character_obj: models.Character, inventory_item_id: Optional[uuid.UUID] = None, slot_to_unequip: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    char_inv_entry_to_unequip: Optional[models.CharacterInventoryItem] = None

    current_character_inventory_snapshot = get_character_inventory(db, character_obj.id)


    if inventory_item_id:
        # Find the specific item instance from the snapshot
        for item_instance in current_character_inventory_snapshot:
            if item_instance.id == inventory_item_id:
                if item_instance.character_id == character_obj.id:
                    char_inv_entry_to_unequip = item_instance
                else: # Ownership mismatch
                    logger.warning(f"Attempt to unequip item {inventory_item_id} by char {character_obj.name} but item belongs to char_id {item_instance.character_id}")
                    return None, "This item instance does not belong to you."
                break
    elif slot_to_unequip:
        if slot_to_unequip not in EQUIPMENT_SLOTS:
             return None, f"Invalid equipment slot: '{slot_to_unequip}'."
        for item_instance in current_character_inventory_snapshot:
            if item_instance.equipped and item_instance.equipped_slot == slot_to_unequip:
                char_inv_entry_to_unequip = item_instance
                break
    else:
        return None, "Must specify an item ID or a slot to unequip."

    if not char_inv_entry_to_unequip:
        return None, "No equipped item found for the given criteria."

    if not char_inv_entry_to_unequip.item:
        logger.error(f"Equipped item {char_inv_entry_to_unequip.id} is missing its item_template data.")
        return None, "Item template data missing for this equipped item."

    if not char_inv_entry_to_unequip.equipped or not char_inv_entry_to_unequip.equipped_slot:
        return char_inv_entry_to_unequip, f"{char_inv_entry_to_unequip.item.name} is not currently equipped."

    item_name_unequipped = char_inv_entry_to_unequip.item.name
    slot_display_name = EQUIPMENT_SLOTS.get(char_inv_entry_to_unequip.equipped_slot, char_inv_entry_to_unequip.equipped_slot)

    char_inv_entry_to_unequip.equipped = False
    char_inv_entry_to_unequip.equipped_slot = None
    db.add(char_inv_entry_to_unequip)

    # After unequipping, if the item is stackable, try to merge it with an existing unequipped stack
    if char_inv_entry_to_unequip.item.stackable:
        # Query again for an unequipped stack of the same item_id (excluding the one we just unequipped if it's still in session with old state)
        # This logic needs to be careful about the object identity of char_inv_entry_to_unequip
        # It might be simpler to let a subsequent "cleanup/compact inventory" function handle this,
        # or ensure the `add_item_to_character_inventory` logic is robust enough to merge when items are re-added.
        # For now, we'll just unequip it. The next time an item of this type is added, add_item logic should find this unequipped one.
        
        # Let's try to merge:
        potential_merge_stack = db.query(models.CharacterInventoryItem).filter(
            models.CharacterInventoryItem.character_id == character_obj.id,
            models.CharacterInventoryItem.item_id == char_inv_entry_to_unequip.item_id,
            models.CharacterInventoryItem.equipped == False,
            models.CharacterInventoryItem.id != char_inv_entry_to_unequip.id # Exclude the item we just unequipped itself
        ).first()

        if potential_merge_stack:
            max_stack = char_inv_entry_to_unequip.item.max_stack_size if char_inv_entry_to_unequip.item.max_stack_size is not None else float('inf')
            if potential_merge_stack.quantity + char_inv_entry_to_unequip.quantity <= max_stack:
                logger.debug(f"Merging unequipped {item_name_unequipped} (qty {char_inv_entry_to_unequip.quantity}) into existing stack (qty {potential_merge_stack.quantity})")
                potential_merge_stack.quantity += char_inv_entry_to_unequip.quantity
                db.add(potential_merge_stack)
                db.delete(char_inv_entry_to_unequip) # Delete the now-merged original entry
                char_inv_entry_to_unequip = potential_merge_stack # The ORM object to return is now the merged stack
            # else: cannot merge, leave as separate stack (already handled by unequipping)
    
    return char_inv_entry_to_unequip, f"Staged unequipping of {item_name_unequipped} from {slot_display_name}."
--- END OF FILE backend/app/crud/crud_character_inventory.py ---

--- START OF FILE backend/app/commands/utils.py ---
# backend/app/commands/utils.py
import re
import logging
from typing import Any, List, Optional, Tuple, Dict
import uuid
import random

from app import models, schemas # Group app-level imports
from app.models.item import EQUIPMENT_SLOTS
from app.schemas.common_structures import ExitDetail


logger_utils = logging.getLogger(__name__)


def get_visible_length(s: str) -> int:
    """Removes HTML tags and returns the length of the visible string."""
    return len(re.sub(r'<[^>]+>', '', s))


def format_room_items_for_player_message(
    room_items: List[models.RoomItemInstance]
) -> Tuple[str, Dict[int, uuid.UUID]]:
    """Formats items on the ground into a readable string, numbered, and returns a map."""
    lines = []
    item_map: Dict[int, uuid.UUID] = {}

    if room_items:
        lines.append("\nYou also see on the ground:")
        # Sort room items by name before displaying and mapping
        # This ensures consistent numbering if the order from DB isn't guaranteed
        sorted_room_items = sorted(room_items, key=lambda ri: ri.item.name if ri.item else "")

        for idx, room_item_instance in enumerate(sorted_room_items):
            item_name = room_item_instance.item.name if room_item_instance.item else "Unknown Item"
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            item_name_html = f"<span class='inv-item-name'>{item_name}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {room_item_instance.quantity})</span>"
            prefix_html = f"  {item_number_html} "

            lines.append(f"{prefix_html}{item_name_html} {item_qty_html}")
            item_map[idx + 1] = room_item_instance.id # Map display number to original instance ID

    return "\n".join(lines), item_map


def _format_ambiguity_prompt(
    target_ref: str,
    matches: List[models.RoomItemInstance],
    match_type_desc: str
) -> str:
    """Helper to create a prompt when multiple items match a target reference."""
    prompt_lines = [f"Multiple items {match_type_desc} '{target_ref}'. Which did you mean?"]
    # Sort matches for consistent numbering in prompt.
    display_sorted_matches = sorted(matches, key=lambda inst: inst.item.name if inst.item else "")

    for i, item_match in enumerate(display_sorted_matches):
        item_name = item_match.item.name if item_match.item else "Unknown Item"
        prompt_lines.append(f"  - {item_name}") # Consider adding numbers if commands will use them

    return "\n".join(prompt_lines)


def resolve_room_item_target(
    target_ref: str,
    items_on_ground: List[models.RoomItemInstance]
) -> Tuple[Optional[models.RoomItemInstance], Optional[str]]:
    """
    Resolves a target reference (name, number, tag) to a specific RoomItemInstance.
    Handles ambiguity by returning a prompt message.
    """
    if not items_on_ground:
        return None, "There is nothing on the ground here."

    target_ref_lower = target_ref.lower().strip()
    if not target_ref_lower:
        return None, "Get what?"

    # To match format_room_items_for_player_message, resolve numbers based on the sorted order
    sorted_items_for_resolution = sorted(items_on_ground, key=lambda ri: ri.item.name if ri.item else "")

    try:
        num_ref = int(target_ref_lower)
        if 1 <= num_ref <= len(sorted_items_for_resolution):
            return sorted_items_for_resolution[num_ref - 1], None
    except ValueError:
        # Not a number, proceed to name/tag matching
        pass

    exact_name_matches: List[models.RoomItemInstance] = []
    exact_tag_matches: List[models.RoomItemInstance] = []
    keyword_matches: List[models.RoomItemInstance] = [] # e.g., for "key" type
    partial_name_matches: List[models.RoomItemInstance] = []

    # For name/tag matching, iterate through the original list.
    # Order doesn't matter for these match types until ambiguity resolution.
    for item_instance in items_on_ground:
        if not item_instance.item or not item_instance.item.name:
            continue

        item_name_lower = item_instance.item.name.lower()
        item_type_lower = item_instance.item.item_type.lower() if item_instance.item.item_type else ""
        item_properties = item_instance.item.properties or {}
        item_tag_from_prop = item_properties.get("item_tag", "").lower()

        if item_name_lower == target_ref_lower:
            exact_name_matches.append(item_instance)
        if item_tag_from_prop and item_tag_from_prop == target_ref_lower:
            if item_instance not in exact_tag_matches: # Avoid duplicates if name and tag are same
                exact_tag_matches.append(item_instance)
        if target_ref_lower == "key" and "key" in item_type_lower: # Special handling for "key"
            if item_instance not in keyword_matches:
                keyword_matches.append(item_instance)
        if item_name_lower.startswith(target_ref_lower):
            # Add to partial matches only if not already an exact match by name or tag
            if item_instance not in exact_name_matches and \
               item_instance not in exact_tag_matches and \
               item_instance not in partial_name_matches:
                partial_name_matches.append(item_instance)

    # Prioritize match types
    if len(exact_name_matches) == 1:
        return exact_name_matches[0], None
    if len(exact_name_matches) > 1:
        return None, _format_ambiguity_prompt(target_ref, exact_name_matches, "exactly named")

    if len(exact_tag_matches) == 1:
        return exact_tag_matches[0], None
    if len(exact_tag_matches) > 1:
        return None, _format_ambiguity_prompt(target_ref, exact_tag_matches, "tagged as")

    if target_ref_lower == "key" and keyword_matches: # Check keyword matches for "key"
        if len(keyword_matches) == 1:
            return keyword_matches[0], None
        if len(keyword_matches) > 1:
            return None, _format_ambiguity_prompt("key", keyword_matches, "of type 'key'")

    if len(partial_name_matches) == 1:
        return partial_name_matches[0], None
    if len(partial_name_matches) > 1:
        return None, _format_ambiguity_prompt(target_ref, partial_name_matches, "partially named")

    return None, f"You don't see anything like '{target_ref}' on the ground here."


def format_room_mobs_for_player_message(
    room_mobs: List[models.RoomMobInstance]
) -> Tuple[str, Dict[int, uuid.UUID]]:
    """Formats mobs in the room into a readable string, numbered, and returns a map."""
    lines = []
    mob_map: Dict[int, uuid.UUID] = {}

    if room_mobs:
        lines.append("\nAlso here:")
        # Sort mobs by name for consistent display numbering
        sorted_room_mobs = sorted(room_mobs, key=lambda m: m.mob_template.name if m.mob_template else "")

        for idx, mob_instance in enumerate(sorted_room_mobs):
            template = mob_instance.mob_template
            mob_name = template.name if template else "Unknown Creature"
            mob_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            mob_name_html = f"<span class='inv-item-name'>{mob_name}</span>"

            lines.append(f"  {mob_number_html} {mob_name_html}")
            mob_map[idx + 1] = mob_instance.id # Map display number to original instance ID

    return "\n".join(lines), mob_map


def format_inventory_for_player_message(
    inventory_display_schema: schemas.CharacterInventoryDisplay
) -> str:
    """Formats a character's complete inventory for display."""
    lines = []

    # --- Equipped Items ---
    equipped_item_parts = []
    max_visible_equipped_prefix_len = 0

    if inventory_display_schema.equipped_items:
        equipped_list_for_sorting = []
        for slot_key, inv_item_schema in inventory_display_schema.equipped_items.items():
            processed_slot_key = str(slot_key).strip()
            display_slot_name_raw = EQUIPMENT_SLOTS.get(processed_slot_key, processed_slot_key.capitalize())
            equipped_list_for_sorting.append((display_slot_name_raw, slot_key, inv_item_schema))
        
        equipped_list_for_sorting.sort(key=lambda x: x[0]) # Sort by display_slot_name_raw

        for display_slot_name_raw, _slot_key, inv_item_schema in equipped_list_for_sorting:
            slot_name_html = f"<span class='inv-slot-name'>{display_slot_name_raw}</span>"
            prefix_html = f"  [{slot_name_html}]"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_equipped_prefix_len = max(max_visible_equipped_prefix_len, visible_prefix_len)

            item_name_raw = inv_item_schema.item.name.strip() if inv_item_schema.item else "Unknown Item"
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {inv_item_schema.quantity})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"

            equipped_item_parts.append({
                'sort_key': display_slot_name_raw,
                'prefix_html': prefix_html,
                'visible_prefix_len': visible_prefix_len,
                'suffix_html': suffix_html
            })

    lines.append(f"<span class='inv-section-header'>--- Equipped ---</span>")
    if equipped_item_parts:
        for parts in equipped_item_parts: # Already sorted by sort_key (display_slot_name_raw)
            padding_needed = max(0, (max_visible_equipped_prefix_len + 2) - parts['visible_prefix_len'])
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else:
        lines.append("  Nothing equipped. You're practically naked, you degenerate.")

    # --- Backpack Items ---
    lines.append(f"\n<span class='inv-section-header'>--- Backpack ---</span>")

    aggregated_stackable_items: Dict[uuid.UUID, Dict[str, Any]] = {}
    individual_non_stackable_items: List[schemas.CharacterInventoryItem] = []

    if inventory_display_schema.backpack_items:
        for inv_item_schema in inventory_display_schema.backpack_items:
            if not inv_item_schema.item:
                logger_utils.warning(
                    f"Inventory item schema (ID: {inv_item_schema.id if hasattr(inv_item_schema, 'id') else 'N/A'}) "
                    "missing nested item details."
                )
                continue

            item_template = inv_item_schema.item # This is schemas.Item
            if item_template.stackable:
                item_template_id = item_template.id
                if item_template_id not in aggregated_stackable_items:
                    aggregated_stackable_items[item_template_id] = {
                        "name": item_template.name,
                        "total_quantity": 0,
                    }
                aggregated_stackable_items[item_template_id]["total_quantity"] += inv_item_schema.quantity
            else:
                individual_non_stackable_items.append(inv_item_schema)

    final_backpack_display_entries = []
    for data in aggregated_stackable_items.values():
        final_backpack_display_entries.append({
            "name": data["name"],
            "quantity": data["total_quantity"]
        })
    for inv_item_schema in individual_non_stackable_items:
        if inv_item_schema.item: # Should always be true due to earlier check
            final_backpack_display_entries.append({
                "name": inv_item_schema.item.name,
                "quantity": inv_item_schema.quantity
            })

    final_backpack_display_entries.sort(key=lambda x: x["name"])

    backpack_item_parts = []
    max_visible_backpack_prefix_len = 0
    if final_backpack_display_entries:
        for idx, entry_data in enumerate(final_backpack_display_entries):
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            prefix_html = f"  {item_number_html}"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_backpack_prefix_len = max(max_visible_backpack_prefix_len, visible_prefix_len)

            item_name_raw = entry_data["name"].strip()
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {entry_data['quantity']})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"

            backpack_item_parts.append({
                'prefix_html': prefix_html,
                'visible_prefix_len': visible_prefix_len,
                'suffix_html': suffix_html
            })

        for parts in backpack_item_parts:
            padding_needed = max(0, (max_visible_backpack_prefix_len + 1) - parts['visible_prefix_len'])
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else:
        lines.append("  Your backpack is as empty as your skull.")

    # --- Currency ---
    lines.append(f"\n<span class='inv-section-header'>--- Currency ---</span>")
    currency_parts = []
    if inventory_display_schema.platinum > 0:
        currency_parts.append(f"<span class='currency platinum'>{inventory_display_schema.platinum}p</span>")
    if inventory_display_schema.gold > 0:
        currency_parts.append(f"<span class='currency gold'>{inventory_display_schema.gold}g</span>")
    if inventory_display_schema.silver > 0:
        currency_parts.append(f"<span class='currency silver'>{inventory_display_schema.silver}s</span>")
    # Always show copper if it's the only currency or if other currencies are present
    if currency_parts or inventory_display_schema.copper > 0:
        currency_parts.append(f"<span class='currency copper'>{inventory_display_schema.copper}c</span>")

    if currency_parts:
        lines.append(f"  {' '.join(currency_parts)}")
    else: # Only if all currency types are zero
        lines.append("  You are utterly destitute. Not a single coin to your pathetic name.")

    return "\n".join(lines)


def roll_dice(dice_str: str):
    """Rolls dice based on a string like '2d6+3'."""
    if not dice_str:
        return 0

    dice_str = dice_str.replace(" ", "").lower()
    parts = dice_str.split('d')
    num_dice = 1

    if not parts[0] and len(parts) > 1: # Handles "d6" case
        num_dice = 1
    elif parts[0]:
        try:
            num_dice = int(parts[0])
        except ValueError:
            # If the first part is not 'd' and not a number, it might be a flat number
            try:
                return int(parts[0])
            except ValueError:
                return 0 # Invalid format

    if len(parts) < 2: # Only a number was provided, e.g., "5"
        return num_dice

    dice_spec = parts[1]
    modifier = 0
    dice_sides_str = dice_spec

    if '+' in dice_spec:
        sides_mod = dice_spec.split('+', 1)
        dice_sides_str = sides_mod[0]
        try:
            modifier = int(sides_mod[1])
        except (ValueError, IndexError):
            return 0 # Invalid modifier
    elif '-' in dice_spec:
        sides_mod_neg = dice_spec.split('-', 1)
        dice_sides_str = sides_mod_neg[0]
        try:
            modifier = -int(sides_mod_neg[1])
        except (ValueError, IndexError):
            return 0 # Invalid modifier

    try:
        dice_sides = int(dice_sides_str)
    except ValueError:
        return 0 # Invalid dice sides

    if dice_sides <= 0:
        return 0 # Cannot roll zero or negative-sided dice

    total_roll = sum(random.randint(1, dice_sides) for _ in range(num_dice))
    return total_roll + modifier


def resolve_mob_target(
    target_ref: str,
    mobs_in_room: List[models.RoomMobInstance]
) -> Tuple[Optional[models.RoomMobInstance], Optional[str]]:
    """Resolves a target reference (name or number) to a specific RoomMobInstance."""
    if not mobs_in_room:
        return None, f"There is nothing called '{target_ref}' here to target." # More specific

    target_ref_lower = target_ref.lower().strip()
    if not target_ref_lower:
        return None, "Attack what?" # Or "Target what?"

    # Sort mobs for consistent numbering, matching format_room_mobs_for_player_message
    sorted_mobs_for_resolution = sorted(
        mobs_in_room,
        key=lambda m: m.mob_template.name if m.mob_template else ""
    )

    try:
        num_ref = int(target_ref_lower) # Use target_ref_lower for consistency
        if 1 <= num_ref <= len(sorted_mobs_for_resolution):
            return sorted_mobs_for_resolution[num_ref - 1], None
    except ValueError:
        pass # Not a number

    exact_matches: List[models.RoomMobInstance] = []
    for mob_instance in sorted_mobs_for_resolution:
        if mob_instance.mob_template and mob_instance.mob_template.name.lower() == target_ref_lower:
            exact_matches.append(mob_instance)

    if len(exact_matches) == 1:
        return exact_matches[0], None
    if len(exact_matches) > 1:
        prompt_lines = [f"Multiple exact matches for '{target_ref}'. Which did you mean?"]
        for i, mob_match in enumerate(exact_matches): # Already sorted
            mob_name = mob_match.mob_template.name if mob_match.mob_template else "Unknown Mob"
            prompt_lines.append(f"  {i + 1}. {mob_name} (Exact)")
        return None, "\n".join(prompt_lines)

    partial_matches: List[models.RoomMobInstance] = []
    # Use a set to avoid adding the same mob multiple times if it matches different criteria
    matched_mob_ids_for_partial = set()
    for mob_instance in sorted_mobs_for_resolution: # Iterate sorted list for consistent partial match order
        if not (mob_instance.mob_template and mob_instance.mob_template.name):
            continue

        mob_name_lower = mob_instance.mob_template.name.lower()
        mob_name_words = mob_name_lower.split()
        matched_this_instance = False

        if mob_name_lower.startswith(target_ref_lower):
            matched_this_instance = True
        if not matched_this_instance:
            for word in mob_name_words:
                if word.startswith(target_ref_lower):
                    matched_this_instance = True
                    break
        if not matched_this_instance: # Check if target is a word in the name
            if target_ref_lower in mob_name_words:
                matched_this_instance = True
        
        if matched_this_instance and mob_instance.id not in matched_mob_ids_for_partial:
            partial_matches.append(mob_instance)
            matched_mob_ids_for_partial.add(mob_instance.id)

    if len(partial_matches) == 1:
        return partial_matches[0], None
    if len(partial_matches) > 1:
        prompt_lines = [f"Which '{target_ref}' did you mean?"]
        for i, mob_match in enumerate(partial_matches): # Already sorted
            mob_name = mob_match.mob_template.name if mob_match.mob_template else "Unknown Mob"
            prompt_lines.append(f"  {i + 1}. {mob_name}")
        return None, "\n".join(prompt_lines)

    return None, f"Cannot find anything called '{target_ref}' here to target."


def format_room_characters_for_player_message(
    room_characters: List[models.Character]
) -> str:
    """Formats other characters in the room into a readable string."""
    if not room_characters:
        return ""

    lines = ["\nAlso present:"]
    # Sort characters by name for consistent display
    sorted_room_characters = sorted(room_characters, key=lambda c: c.name)

    for char_orm in sorted_room_characters:
        char_name_html = f"<span class='char-name'>{char_orm.name}</span>"
        char_class_html = f"<span class='char-class'>({char_orm.class_name or 'Unknown Class'})</span>"
        lines.append(f"  {char_name_html} {char_class_html}")

    return "\n".join(lines)


def get_dynamic_room_description(room_orm: models.Room) -> str:
    """
    Processes a room's base description, replacing dynamic exit placeholders
    with their current locked/unlocked status descriptions.
    """
    base_description = room_orm.description or "You see nothing remarkable."
    if not room_orm.exits:
        return base_description

    processed_description = base_description
    for direction, exit_data_dict in room_orm.exits.items():
        if not isinstance(exit_data_dict, dict):
            logger_utils.warning(f"Exit data for '{direction}' in room '{room_orm.name}' is not a dict. Skipping.")
            continue
        try:
            exit_detail = schemas.ExitDetail(**exit_data_dict) # Use Pydantic model for validation and defaults
            placeholder = f"[DYNAMIC_EXIT_{direction.upper()}]"

            status_description = ""
            if exit_detail.is_locked:
                status_description = exit_detail.description_when_locked or f"The way {direction} is locked."
            elif exit_detail.description_when_unlocked:
                status_description = exit_detail.description_when_unlocked
            else: # Not locked, and no specific unlocked description
                status_description = f"The way {direction} is open."

            if placeholder in processed_description:
                processed_description = processed_description.replace(placeholder, status_description)
            # else:
                # logger_utils.debug(f"Placeholder '{placeholder}' not found in description for room '{room_orm.name}'.")

        except Exception as e_parse: # Catch Pydantic validation errors or others
            logger_utils.error(
                f"Error parsing exit detail for dynamic desc in room '{room_orm.name}', exit '{direction}': {e_parse}",
                exc_info=True
            )
            continue

    return processed_description
--- END OF FILE backend/app/commands/utils.py ---

--- START OF FILE backend/app/commands/inventory_parser.py ---
# backend/app/commands/inventory_parser.py
from typing import Any, Optional, List, Dict # Added Any, not strictly needed here but fine
import uuid
import logging

from app import schemas, crud, models
from .command_args import CommandContext
from .utils import format_inventory_for_player_message # Used by handle_inventory
from app.models.item import EQUIPMENT_SLOTS

logger = logging.getLogger(__name__)

async def handle_inventory(context: CommandContext) -> schemas.CommandResponse:
    # ... (This function seems fine, it prepares data for format_inventory_for_player_message)
    character_orm = context.active_character
    all_inv_items_orm = crud.crud_character_inventory.get_character_inventory(context.db, character_id=character_orm.id)
    
    equipped_items_dict: Dict[str, schemas.CharacterInventoryItem] = {}
    backpack_items_list: List[schemas.CharacterInventoryItem] = []

    for inv_item_orm in all_inv_items_orm:
        if not inv_item_orm.item:
            logger.warning(f"Inventory item {inv_item_orm.id} missing item details for char {character_orm.id}")
            continue
        try:
            item_schema = schemas.CharacterInventoryItem.from_orm(inv_item_orm)
            if inv_item_orm.equipped and inv_item_orm.equipped_slot:
                equipped_items_dict[inv_item_orm.equipped_slot] = item_schema
            else:
                backpack_items_list.append(item_schema)
        except Exception as e:
            logger.error(f"Pydantic from_orm failed for CharacterInventoryItem {inv_item_orm.id}: {e}", exc_info=True)
            
    inventory_display_data = schemas.CharacterInventoryDisplay(
        equipped_items=equipped_items_dict,
        backpack_items=backpack_items_list,
        platinum=character_orm.platinum_coins,
        gold=character_orm.gold_coins,
        silver=character_orm.silver_coins,
        copper=character_orm.copper_coins
    )
    message_to_player = format_inventory_for_player_message(inventory_display_data) # This now uses the improved utils function
    return schemas.CommandResponse(
        room_data=context.current_room_schema,
        message_to_player=message_to_player
    )

async def handle_equip(context: CommandContext) -> schemas.CommandResponse:
    logger.info(f"[HANDLER_EQUIP] Char: {context.active_character.name}, Command: '{context.original_command}'")
    message_to_player: str
    preliminary_message: Optional[str] = None
    
    # ... (Argument parsing for item_ref_str and target_slot_arg - this part is fine) ...
    if not context.args:
        message_to_player = "Equip/Eq what? (e.g., 'equip Rusty Sword' or 'eq 1 main_hand')"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    item_ref_str: str = ""
    target_slot_arg: Optional[str] = None
    args_list = list(context.args) 

    if args_list:
        potential_slot_word = args_list[-1].lower()
        is_last_word_a_slot = False
        for slot_key_iter, slot_display_iter in EQUIPMENT_SLOTS.items():
            if potential_slot_word == slot_key_iter.lower() or \
               potential_slot_word == slot_display_iter.lower().replace(" ", ""):
                target_slot_arg = slot_key_iter 
                item_ref_str = " ".join(args_list[:-1]).strip()
                is_last_word_a_slot = True
                break
        if not is_last_word_a_slot:
            item_ref_str = " ".join(args_list).strip()
    
    if not item_ref_str: 
        message_to_player = "Equip what item?"
        if target_slot_arg: message_to_player = f"Equip what item to {EQUIPMENT_SLOTS.get(target_slot_arg, target_slot_arg)}?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


    # Get fresh inventory ORM objects
    char_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    )

    # --- REPLICATE DISPLAY LOGIC FOR NUMBER MAPPING (This is your new block) ---
    aggregated_stackable_for_map: Dict[uuid.UUID, Dict[str, Any]] = {}
    individual_non_stackable_for_map: List[models.CharacterInventoryItem] = []

    unequipped_items_orm: List[models.CharacterInventoryItem] = [
        item for item in char_inventory_items_orm if not item.equipped and item.item
    ]

    for inv_item_orm in unequipped_items_orm:
        item_template = inv_item_orm.item
        if not item_template: continue

        if item_template.stackable:
            item_template_id = item_template.id
            if item_template_id not in aggregated_stackable_for_map:
                aggregated_stackable_for_map[item_template_id] = {
                    "name": item_template.name,
                    "total_quantity": 0,
                    "instance_ids": [] 
                }
            aggregated_stackable_for_map[item_template_id]["total_quantity"] += inv_item_orm.quantity
            aggregated_stackable_for_map[item_template_id]["instance_ids"].append(inv_item_orm.id)
        else:
            individual_non_stackable_for_map.append(inv_item_orm)

    map_build_list: List[Dict[str, Any]] = []
    for data in aggregated_stackable_for_map.values():
        if data["instance_ids"]:
            map_build_list.append({
                "name": data["name"],
                "inventory_item_id_to_equip": data["instance_ids"][0] 
            })
    for inv_item_orm in individual_non_stackable_for_map:
        map_build_list.append({
            "name": inv_item_orm.item.name,
            "inventory_item_id_to_equip": inv_item_orm.id
        })

    map_build_list.sort(key=lambda x: x["name"]) # Crucial sort!

    temp_backpack_map_by_display_number: Dict[int, uuid.UUID] = {}
    for idx, entry_data in enumerate(map_build_list):
        temp_backpack_map_by_display_number[idx + 1] = entry_data["inventory_item_id_to_equip"]
    
    unequipped_items_by_name: Dict[str, List[models.CharacterInventoryItem]] = {}
    for inv_item_orm in unequipped_items_orm:
        if inv_item_orm.item:
            item_name_lower = inv_item_orm.item.name.lower()
            if item_name_lower not in unequipped_items_by_name:
                unequipped_items_by_name[item_name_lower] = []
            unequipped_items_by_name[item_name_lower].append(inv_item_orm)
    # --- END OF REPLICATED DISPLAY LOGIC ---

    found_inv_item_entry: Optional[models.CharacterInventoryItem] = None # This will hold the ORM object
    target_inventory_item_id_for_crud: Optional[uuid.UUID] = None

    try:
        ref_num = int(item_ref_str)
        if ref_num in temp_backpack_map_by_display_number:
            target_inventory_item_id_for_crud = temp_backpack_map_by_display_number[ref_num]
            # Now, find the actual ORM object using this ID from our fresh unequipped_items_orm list
            found_inv_item_entry = next((item for item in unequipped_items_orm if item.id == target_inventory_item_id_for_crud), None)
    except ValueError:
        if item_ref_str:
            matching_items_by_name_list = unequipped_items_by_name.get(item_ref_str.lower())
            if matching_items_by_name_list:
                found_inv_item_entry = matching_items_by_name_list[0] # Pick the first one by name
                target_inventory_item_id_for_crud = found_inv_item_entry.id
                if len(matching_items_by_name_list) > 1 and found_inv_item_entry.item:
                    preliminary_message = f"(You have multiple unequipped '{found_inv_item_entry.item.name}'. Equipping one.)\n"
    
    if found_inv_item_entry and target_inventory_item_id_for_crud and found_inv_item_entry.item: # Check found_inv_item_entry.item too
        logger.info(f"[HANDLER_EQUIP] Target to equip: {found_inv_item_entry.item.name} (InvEntry ID: {target_inventory_item_id_for_crud}). Slot: {target_slot_arg}")
        
        equipped_item_orm, crud_message = crud.crud_character_inventory.equip_item_from_inventory(
            context.db,
            character_obj=context.active_character,
            inventory_item_id=target_inventory_item_id_for_crud,
            target_slot=target_slot_arg
        )

        logger.info(f"[HANDLER_EQUIP] CRUD response: Msg='{crud_message}', ORM ID: {equipped_item_orm.id if equipped_item_orm else 'None'}")

        if equipped_item_orm and "Staged equipping" in crud_message:
            message_to_player = (preliminary_message or "") + f"You equip the {found_inv_item_entry.item.name}." # Use name from initially found entry
            # The explicit commit was for debugging, ideally FastAPI handles this.
            # If issues persist, it can be re-added TEMPORARILY.
            # try:
            #     context.db.commit()
            # except Exception as e:
            #     context.db.rollback(); message_to_player = "Error committing equip."; logger.error(f"Equip commit error: {e}")
        else:
            message_to_player = (preliminary_message or "") + crud_message
            logger.warning(f"[HANDLER_EQUIP] Equip failed for '{found_inv_item_entry.item.name}': {crud_message}")
    else:
        message_to_player = f"You don't have an unequipped item matching '{item_ref_str}'."
        logger.info(f"[HANDLER_EQUIP] Item not found for ref: '{item_ref_str}'")
        
    return schemas.CommandResponse(
        room_data=context.current_room_schema,
        message_to_player=message_to_player
    )

async def handle_unequip(context: CommandContext) -> schemas.CommandResponse:
    # ... (This function uses similar logic for identifying item by slot or name.
    # If you want to allow unequip by displayed backpack number, similar replicated logic would be needed,
    # but typically unequip targets equipped slots or names of equipped items, which is simpler.)
    # For now, I'll assume its current logic is what you want for unequip.
    # If not, we can refactor it too.
    message_to_player: str
    preliminary_message: Optional[str] = None
    target_to_unequip_str = " ".join(context.args).strip()

    if not target_to_unequip_str:
        message_to_player = "Unequip/Uneq what? (e.g. 'unequip main_hand' or 'unequip Rusty Sword')"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    char_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    ) # Always get fresh

    found_inv_item_entry: Optional[models.CharacterInventoryItem] = None
    
    # Try matching by slot name first
    for slot_key_iter, slot_display_iter in EQUIPMENT_SLOTS.items():
        if target_to_unequip_str.lower() == slot_key_iter.lower() or \
           target_to_unequip_str.lower() == slot_display_iter.lower().replace(" ", ""):
            for inv_item in char_inventory_items_orm:
                if inv_item.equipped and inv_item.equipped_slot == slot_key_iter:
                    found_inv_item_entry = inv_item
                    break
            if found_inv_item_entry: break 
    
    # If not found by slot, try by name of an equipped item
    if not found_inv_item_entry:
        equipped_items_by_name: Dict[str, List[models.CharacterInventoryItem]] = {}
        for inv_item in char_inventory_items_orm:
            if inv_item.equipped and inv_item.item:
                item_name_lower = inv_item.item.name.lower()
                if item_name_lower not in equipped_items_by_name: 
                    equipped_items_by_name[item_name_lower] = []
                equipped_items_by_name[item_name_lower].append(inv_item)
        
        matching_equipped_items = equipped_items_by_name.get(target_to_unequip_str.lower())
        if matching_equipped_items:
            found_inv_item_entry = matching_equipped_items[0] 
            if len(matching_equipped_items) > 1 and found_inv_item_entry.item :
                 preliminary_message = f"(Multiple items named '{found_inv_item_entry.item.name}' are equipped. Unequipping one from slot {found_inv_item_entry.equipped_slot}.)\n"

    if found_inv_item_entry and found_inv_item_entry.item:
        unequipped_item_orm, crud_message = crud.crud_character_inventory.unequip_item_to_inventory(
            context.db, 
            character_obj=context.active_character, 
            inventory_item_id=found_inv_item_entry.id
            # slot_to_unequip is implicitly handled by finding the item_id of what's in a slot or by name
        )
        if unequipped_item_orm and "Staged unequipping" in crud_message: # Check for success message from CRUD
             message_to_player = (preliminary_message or "") + f"You unequip the {found_inv_item_entry.item.name}."
        else:
            message_to_player = (preliminary_message or "") + crud_message
    else:
        message_to_player = f"You don't have an item equipped matching '{target_to_unequip_str}'."
    
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_drop(context: CommandContext) -> schemas.CommandResponse:
    # This function needs the same replicated display logic as handle_equip
    # if you want "drop <number>" to work based on the sorted, aggregated display.
    # I'll add it here.
    logger.info(f"[HANDLER_DROP] Char: {context.active_character.name}, Command: '{context.original_command}'")
    message_to_player: str
    preliminary_message: Optional[str] = None
    item_ref_to_drop = " ".join(context.args).strip()

    if not item_ref_to_drop:
        message_to_player = "Drop what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    char_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    )

    # --- REPLICATE DISPLAY LOGIC FOR NUMBER MAPPING (for drop) ---
    aggregated_stackable_for_map: Dict[uuid.UUID, Dict[str, Any]] = {}
    individual_non_stackable_for_map: List[models.CharacterInventoryItem] = []
    unequipped_items_orm: List[models.CharacterInventoryItem] = [
        item for item in char_inventory_items_orm if not item.equipped and item.item
    ]

    for inv_item_orm in unequipped_items_orm:
        item_template = inv_item_orm.item
        if not item_template: continue
        if item_template.stackable:
            item_template_id = item_template.id
            if item_template_id not in aggregated_stackable_for_map:
                aggregated_stackable_for_map[item_template_id] = {"name": item_template.name, "total_quantity": 0, "instance_ids": []}
            aggregated_stackable_for_map[item_template_id]["total_quantity"] += inv_item_orm.quantity
            aggregated_stackable_for_map[item_template_id]["instance_ids"].append(inv_item_orm.id)
        else:
            individual_non_stackable_for_map.append(inv_item_orm)

    map_build_list: List[Dict[str, Any]] = []
    for data in aggregated_stackable_for_map.values():
        if data["instance_ids"]:
            map_build_list.append({"name": data["name"], "inventory_item_id_to_drop": data["instance_ids"][0], "is_stack": True, "full_stack_qty": data["total_quantity"]})
    for inv_item_orm in individual_non_stackable_for_map:
        map_build_list.append({"name": inv_item_orm.item.name, "inventory_item_id_to_drop": inv_item_orm.id, "is_stack": False, "full_stack_qty": 1})
    
    map_build_list.sort(key=lambda x: x["name"])

    temp_backpack_map_by_display_number: Dict[int, Dict[str, Any]] = {} # Store more info
    for idx, entry_data in enumerate(map_build_list):
        temp_backpack_map_by_display_number[idx + 1] = entry_data
    
    backpack_items_by_name_lower: Dict[str, List[models.CharacterInventoryItem]] = {}
    for inv_item_orm in unequipped_items_orm:
        if inv_item_orm.item:
            item_name_lower = inv_item_orm.item.name.lower()
            if item_name_lower not in backpack_items_by_name_lower: backpack_items_by_name_lower[item_name_lower] = []
            backpack_items_by_name_lower[item_name_lower].append(inv_item_orm)
    # --- END OF REPLICATED DISPLAY LOGIC ---

    item_to_drop_instance: Optional[models.CharacterInventoryItem] = None
    target_inventory_item_id_for_crud: Optional[uuid.UUID] = None
    quantity_to_actually_drop = 1 # Default for non-stackable or if dropping one from a stack by name

    try:
        ref_num = int(item_ref_to_drop)
        if ref_num in temp_backpack_map_by_display_number:
            selected_entry_data = temp_backpack_map_by_display_number[ref_num]
            target_inventory_item_id_for_crud = selected_entry_data["inventory_item_id_to_drop"]
            item_to_drop_instance = next((item for item in unequipped_items_orm if item.id == target_inventory_item_id_for_crud), None)
            if item_to_drop_instance and item_to_drop_instance.item and item_to_drop_instance.item.stackable:
                # If user says "drop 3" and item 3 is "Potion (Qty: 5)", we drop the whole stack.
                quantity_to_actually_drop = item_to_drop_instance.quantity
    except ValueError:
        if item_ref_to_drop:
            matching_items_by_name_list = backpack_items_by_name_lower.get(item_ref_to_drop.lower())
            if matching_items_by_name_list:
                item_to_drop_instance = matching_items_by_name_list[0]
                target_inventory_item_id_for_crud = item_to_drop_instance.id
                quantity_to_actually_drop = item_to_drop_instance.quantity # Drop the whole stack if named
                if len(matching_items_by_name_list) > 1 and item_to_drop_instance.item:
                    preliminary_message = f"(Multiple items named '{item_to_drop_instance.item.name}'. Dropping one stack/item.)\n"

    if not item_to_drop_instance or not item_to_drop_instance.item or not target_inventory_item_id_for_crud:
        message_to_player = f"You don't have '{item_ref_to_drop}' in your backpack to drop."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # Use the determined quantity_to_actually_drop
    _, removal_msg = crud.crud_character_inventory.remove_item_from_character_inventory(
        context.db, inventory_item_id=target_inventory_item_id_for_crud, quantity_to_remove=quantity_to_actually_drop
    )

    if "Error" in removal_msg or "Cannot" in removal_msg or "not found" in removal_msg:
        message_to_player = (preliminary_message or "") + removal_msg
    else:
        _, drop_msg_room = crud.crud_room_item.add_item_to_room(
            context.db, room_id=context.current_room_orm.id, item_id=item_to_drop_instance.item_id,
            quantity=quantity_to_actually_drop, dropped_by_character_id=context.active_character.id
        )
        message_to_player = (preliminary_message or "") + f"You drop {item_to_drop_instance.item.name}"
        if quantity_to_actually_drop > 1:
            message_to_player += f" (x{quantity_to_actually_drop})."
        else:
            message_to_player += "."
            
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_get(context: CommandContext) -> schemas.CommandResponse:
    # This also needs the replicated display logic from utils.format_room_items_for_player_message
    # if "get <number>" is to work based on the sorted display.
    logger.info(f"[HANDLER_GET] Char: {context.active_character.name}, Command: '{context.original_command}'")
    message_to_player: str
    preliminary_message: Optional[str] = None
    item_ref_to_get = " ".join(context.args).strip()

    if not item_ref_to_get:
        message_to_player = "Get what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
    if not items_on_ground_orm:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="There is nothing on the ground here.")

    # --- REPLICATE DISPLAY LOGIC FOR NUMBER MAPPING (for get) ---
    # This logic mirrors format_room_items_for_player_message to ensure numbers match display
    sorted_ground_items_for_map = sorted(items_on_ground_orm, key=lambda ri: ri.item.name if ri.item else "")
    
    temp_ground_map_by_display_number: Dict[int, models.RoomItemInstance] = {}
    for idx, item_instance in enumerate(sorted_ground_items_for_map):
        temp_ground_map_by_display_number[idx + 1] = item_instance
        
    ground_items_by_name_lower: Dict[str, List[models.RoomItemInstance]] = {}
    for room_item_inst_orm in items_on_ground_orm: # Original list for name matching
        if room_item_inst_orm.item:
            item_name_lower = room_item_inst_orm.item.name.lower()
            if item_name_lower not in ground_items_by_name_lower: ground_items_by_name_lower[item_name_lower] = []
            ground_items_by_name_lower[item_name_lower].append(room_item_inst_orm)
    # --- END OF REPLICATED DISPLAY LOGIC ---

    item_to_get_instance: Optional[models.RoomItemInstance] = None
    try:
        ref_num = int(item_ref_to_get)
        if ref_num in temp_ground_map_by_display_number:
            item_to_get_instance = temp_ground_map_by_display_number[ref_num]
    except ValueError:
        if item_ref_to_get: # Name-based matching (using the more detailed resolve_room_item_target might be better)
            # Simple name match for now, like original logic.
            # For a more robust solution, could call a modified resolve_room_item_target that doesn't return a message for ambiguity
            # but rather returns all matches, and this handler decides.
            # This current name matching is simpler than resolve_room_item_target.
            matching_items_by_name_list = ground_items_by_name_lower.get(item_ref_to_get.lower())
            if matching_items_by_name_list:
                item_to_get_instance = matching_items_by_name_list[0] # Pick first
                if len(matching_items_by_name_list) > 1 and item_to_get_instance.item:
                    preliminary_message = f"(Getting one of multiple '{item_to_get_instance.item.name}'.)\n"
    
    if not item_to_get_instance or not item_to_get_instance.item:
        message_to_player = f"No '{item_ref_to_get}' on the ground here."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    quantity_picked_up = item_to_get_instance.quantity # Get the full stack from ground
    item_id_picked_up = item_to_get_instance.item_id
    item_name_picked_up = item_to_get_instance.item.name

    # Attempt to remove from room
    _, removal_msg = crud.crud_room_item.remove_item_from_room(
        context.db, room_item_instance_id=item_to_get_instance.id, quantity_to_remove=quantity_picked_up
    )

    if "Error" in removal_msg or "not found" in removal_msg:
        message_to_player = (preliminary_message or "") + removal_msg
    else:
        # Attempt to add to character inventory
        _, add_msg_inv = crud.crud_character_inventory.add_item_to_character_inventory(
            context.db,
            character_obj=context.active_character,
            item_id=item_id_picked_up, # Use the ID from the item instance
            quantity=quantity_picked_up
        )
        if "Error" in add_msg_inv or "Cannot" in add_msg_inv or "Could not add" in add_msg_inv:
            message_to_player = (preliminary_message or "") + f"You try to pick up {item_name_picked_up}, but {add_msg_inv.lower().replace('staged addition of', 'could not add to inventory:')}"
            logger.error(f"Failed to add item {item_name_picked_up} to char {context.active_character.name} inv after picking up. Item was REMOVED from room. Attempting to re-drop.")
            # Attempt to re-drop the item if adding to inventory failed
            _, redrop_msg = crud.crud_room_item.add_item_to_room(
                context.db, room_id=context.current_room_orm.id, item_id=item_id_picked_up,
                quantity=quantity_picked_up 
            )
            if "Error" in redrop_msg:
                logger.critical(f"CRITICAL ERROR: Failed to re-drop item {item_name_picked_up} after inventory add failure. Item lost from world. Redrop message: {redrop_msg}")
                message_to_player += " ...and it vanished in a puff of logic!"
            else:
                message_to_player += " ...so you leave it on the ground."
        else:
            message_to_player = (preliminary_message or "") + f"You pick up {item_name_picked_up}"
            if quantity_picked_up > 1:
                message_to_player += f" (x{quantity_picked_up})."
            else:
                message_to_player += "."

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/inventory_parser.py ---

--- START OF FILE backend/app/crud/crud_mob_spawn_definition.py ---
# backend/app/crud/crud_mob_spawn_definition.py
from sqlalchemy.orm import Session
import uuid
from datetime import datetime, timedelta, timezone # Added timezone
from typing import List, Optional

from .. import models, schemas # Uses new MobSpawnDefinition schemas
from ..crud import crud_room, crud_mob # For seeder

# --- MobSpawnDefinition CRUD ---

def get_mob_spawn_definition(db: Session, definition_id: uuid.UUID) -> Optional[models.MobSpawnDefinition]:
    return db.query(models.MobSpawnDefinition).filter(models.MobSpawnDefinition.id == definition_id).first()

def get_mob_spawn_definition_by_name(db: Session, definition_name: str) -> Optional[models.MobSpawnDefinition]:
    return db.query(models.MobSpawnDefinition).filter(models.MobSpawnDefinition.definition_name == definition_name).first()

def get_definitions_ready_for_check(db: Session, current_time: datetime, limit: int = 1000) -> List[models.MobSpawnDefinition]:
    """
    Gets active spawn definitions whose next_respawn_check_at is due.
    Or where next_respawn_check_at is NULL (meaning they haven't been processed yet or need immediate check).
    """
    return db.query(models.MobSpawnDefinition).filter(
        models.MobSpawnDefinition.is_active == True,
        (models.MobSpawnDefinition.next_respawn_check_at == None) | (models.MobSpawnDefinition.next_respawn_check_at <= current_time)
    ).limit(limit).all()

def create_mob_spawn_definition(db: Session, *, definition_in: schemas.MobSpawnDefinitionCreate) -> models.MobSpawnDefinition:
    # Basic validation
    if definition_in.quantity_min > definition_in.quantity_max:
        raise ValueError("quantity_min cannot be greater than quantity_max")

    existing = get_mob_spawn_definition_by_name(db, definition_name=definition_in.definition_name)
    if existing:
        # Handle error or return existing one; for now, let's assume names should be unique
        raise ValueError(f"MobSpawnDefinition with name '{definition_in.definition_name}' already exists.")

    db_definition_data = definition_in.model_dump()
    # Set initial next_respawn_check_at to now to make it eligible for first check
    db_definition_data["next_respawn_check_at"] = datetime.now(timezone.utc)
    
    db_definition = models.MobSpawnDefinition(**db_definition_data)
    db.add(db_definition)
    db.commit()
    db.refresh(db_definition)
    return db_definition

def update_mob_spawn_definition_next_check_time(
    db: Session, *, 
    definition_id: uuid.UUID, 
    next_check_time: datetime
) -> Optional[models.MobSpawnDefinition]:
    db_definition = get_mob_spawn_definition(db, definition_id)
    if db_definition:
        db_definition.next_respawn_check_at = next_check_time
        db.add(db_definition)
        db.commit() # Commit immediately as this is a frequent state update
        db.refresh(db_definition)
        return db_definition
    return None

def update_mob_spawn_definition(
    db: Session, *,
    db_definition: models.MobSpawnDefinition,
    definition_in: schemas.MobSpawnDefinitionUpdate
) -> models.MobSpawnDefinition:
    update_data = definition_in.model_dump(exclude_unset=True)
    if "quantity_min" in update_data and "quantity_max" in update_data:
        if update_data["quantity_min"] > update_data["quantity_max"]:
            raise ValueError("quantity_min cannot be greater than quantity_max")
    elif "quantity_min" in update_data:
        if update_data["quantity_min"] > db_definition.quantity_max:
            raise ValueError("quantity_min cannot be greater than current quantity_max")
    elif "quantity_max" in update_data:
        if db_definition.quantity_min > update_data["quantity_max"]:
            raise ValueError("current quantity_min cannot be greater than new quantity_max")

    for field, value in update_data.items():
        setattr(db_definition, field, value)
    db.add(db_definition)
    db.commit()
    db.refresh(db_definition)
    return db_definition


# --- Seeding ---
def seed_initial_mob_spawn_definitions(db: Session):
    print("Attempting to seed initial mob spawn definitions...")
    cpu_room = crud_room.get_room_by_coords(db, x=0, y=0, z=0)
    rat_template = crud_mob.get_mob_template_by_name(db, name="Giant Rat")
    goblin_template = crud_mob.get_mob_template_by_name(db, name="Goblin Scout")
    personnel_room = crud_room.get_room_by_coords(db, x=2, y=0, z=0) 
    
    definitions_to_seed = []
    if cpu_room and rat_template:
        definitions_to_seed.append(schemas.MobSpawnDefinitionCreate(
            definition_name="CPURatsMain", room_id=cpu_room.id, mob_template_id=rat_template.id,
            quantity_min=1, quantity_max=2, respawn_delay_seconds=60,
            roaming_behavior={"type": "random_adjacent", "move_chance_percent": 40, "max_distance_from_spawn": 2} # <<< ADD ROAMING
        ))
    if personnel_room and goblin_template:
        definitions_to_seed.append(schemas.MobSpawnDefinitionCreate(
            definition_name="PersonnelIntakeGoblinSentry", room_id=personnel_room.id, mob_template_id=goblin_template.id,
            quantity_min=1, quantity_max=1, respawn_delay_seconds=180 
            # Goblin is AGGRESSIVE_ON_SIGHT from its template, no specific roaming here.
        ))

    seeded_count = 0
    for def_in in definitions_to_seed:
        existing_def = get_mob_spawn_definition_by_name(db, definition_name=def_in.definition_name)
        if not existing_def:
            create_mob_spawn_definition(db, definition_in=def_in)
            print(f"  Created mob spawn definition: {def_in.definition_name}")
            seeded_count += 1
        else:
            # Optionally update existing definitions
            print(f"  Mob spawn definition '{def_in.definition_name}' already exists. Current roaming: {existing_def.roaming_behavior}, Seeded: {def_in.roaming_behavior}")
            if existing_def.roaming_behavior != def_in.roaming_behavior: # Simple dict comparison
                print(f"    Updating roaming behavior for {existing_def.definition_name}")
                existing_def.roaming_behavior = def_in.roaming_behavior
                db.add(existing_def)
                db.commit() # Commit update
    
    if seeded_count > 0: print(f"Seeded {seeded_count} new mob spawn definitions.")
    print("Mob spawn definition seeding complete.")
--- END OF FILE backend/app/crud/crud_mob_spawn_definition.py ---

--- START OF FILE backend/app/crud/crud_item.py ---
# backend/app/crud/crud_item.py
import json
import os
import uuid
import logging # Import logging
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session

from .. import models, schemas

logger = logging.getLogger(__name__) # Get a logger for this module

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_for_items(filename: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"Seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {filepath}: {e}")
        return []

def get_item_by_id(db: Session, item_id: uuid.UUID) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.id == item_id).first()

def get_item_by_name(db: Session, name: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.name == name).first()

def get_item_by_item_tag(db: Session, item_tag: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.properties["item_tag"].astext == item_tag).first()

def get_all_items(db: Session, skip: int = 0, limit: int = 100) -> List[models.Item]:
    return db.query(models.Item).offset(skip).limit(limit).all()

def create_item(db: Session, *, item_in: schemas.ItemCreate) -> models.Item:
    db_item = models.Item(**item_in.model_dump())
    db.add(db_item)
    # Caller should handle commit/flush
    return db_item

def seed_initial_items(db: Session):
    logger.info("Attempting to seed initial items from JSON...")
    item_definitions = _load_seed_data_for_items("items.json")

    if not item_definitions:
        logger.warning("No item definitions found or error loading items.json. Aborting item seeding.")
        return

    seeded_count = 0
    skipped_count = 0
    updated_count = 0 # For clarity

    for item_data in item_definitions:
        item_name = item_data.get("name")
        if not item_name:
            logger.warning(f"Skipping item entry due to missing name: {item_data}")
            skipped_count += 1
            continue

        existing_item = get_item_by_name(db, name=item_name)
        
        try:
            if existing_item:
                logger.debug(f"Item '{item_name}' already exists. Attempting update...")
                item_update_schema = schemas.ItemUpdate(**item_data) 
                changed = False
                for field, value in item_update_schema.model_dump(exclude_unset=True).items():
                    if getattr(existing_item, field) != value:
                        setattr(existing_item, field, value)
                        changed = True
                if changed:
                    db.add(existing_item)
                    logger.info(f"Updated item: {item_name}")
                    updated_count += 1
                else:
                    # logger.debug(f"Item '{item_name}' exists and no changes detected. Skipping update.")
                    skipped_count +=1 # Not really skipped, but not "newly seeded" or "updated"
            else:
                item_create_schema = schemas.ItemCreate(**item_data)
                logger.info(f"Creating item: {item_create_schema.name}")
                create_item(db, item_in=item_create_schema)
                seeded_count += 1
        except Exception as e_pydantic:
            logger.error(f"Pydantic validation or DB operation failed for item '{item_name}': {e_pydantic}. Data: {item_data}")
            skipped_count += 1
            continue
    
    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new items and {updated_count} updated items.")
            db.commit() 
            logger.info("Item seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing item seeds: {e_commit}. Rolling back.")
            db.rollback()
    else:
        logger.info("No new items to seed or items to update. No commit needed for items.")

    logger.info(f"Item seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")


def update_item(db: Session, *, db_item: models.Item, item_in: schemas.ItemUpdate) -> models.Item:
    update_data = item_in.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_item, key, value)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def delete_item(db: Session, *, item_id: uuid.UUID) -> Optional[models.Item]:
    db_item = db.query(models.Item).filter(models.Item.id == item_id).first()
    if db_item:
        db.delete(db_item)
        db.commit()
    return db_item
--- END OF FILE backend/app/crud/crud_item.py ---

--- START OF FILE backend/app/crud/crud_mob.py ---
# backend/app/crud/crud_mob.py
import json # For loading JSON
import os   # For path joining
import logging # For logging (finally!)
from datetime import datetime, timezone
from sqlalchemy.orm import Session, joinedload, attributes
import uuid
from typing import Dict, List, Optional, Tuple, Any # Added Any for seed data

from .. import models, schemas, crud

logger = logging.getLogger(__name__)

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_generic(filename: str, data_type_name: str) -> List[Dict[str, Any]]: # Made generic
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"{data_type_name} seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {data_type_name} seed file {filepath}: {e}")
        return []

# --- MobTemplate CRUD ---
def get_mob_template(db: Session, mob_template_id: uuid.UUID) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.id == mob_template_id).first()

def get_mob_template_by_name(db: Session, name: str) -> Optional[models.MobTemplate]:
    return db.query(models.MobTemplate).filter(models.MobTemplate.name == name).first()

def get_mob_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.MobTemplate]:
    return db.query(models.MobTemplate).offset(skip).limit(limit).all()

def create_mob_template(db: Session, *, template_in: schemas.MobTemplateCreate) -> models.MobTemplate:
    db_template = models.MobTemplate(**template_in.model_dump())
    db.add(db_template)
    return db_template

def update_mob_template(db: Session, *, db_template: models.MobTemplate, template_in: schemas.MobTemplateUpdate) -> models.MobTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    changed = False
    for field, value in update_data.items():
        if getattr(db_template, field) != value:
            setattr(db_template, field, value)
            # For JSONB fields, ensure they are flagged if necessary
            if field in ['currency_drop', 'special_abilities', 'loot_table_tags', 'dialogue_lines', 'faction_tags', 'properties']:
                attributes.flag_modified(db_template, field)
            changed = True
    if changed:
        db.add(db_template)
    return db_template # Return template whether changed or not, caller might need it


# --- RoomMobInstance CRUD ---
def get_room_mob_instance(db: Session, room_mob_instance_id: uuid.UUID) -> Optional[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template) 
    ).filter(models.RoomMobInstance.id == room_mob_instance_id).first()

def get_mobs_in_room(db: Session, room_id: uuid.UUID) -> List[models.RoomMobInstance]:
    return db.query(models.RoomMobInstance).options(
        joinedload(models.RoomMobInstance.mob_template)
    ).filter(models.RoomMobInstance.room_id == room_id).all()

def spawn_mob_in_room(
    db: Session, *, 
    room_id: uuid.UUID, 
    mob_template_id: uuid.UUID,
    instance_properties_override: Optional[Dict] = None,
    originating_spawn_definition_id: Optional[uuid.UUID] = None 
) -> Optional[models.RoomMobInstance]:
    template = get_mob_template(db, mob_template_id)
    if not template: 
        logger.error(f"spawn_mob_in_room: Mob template ID {mob_template_id} not found.")
        return None
    room = db.query(models.Room).filter(models.Room.id == room_id).first() # Consider using crud.crud_room.get_room_by_id
    if not room: 
        logger.error(f"spawn_mob_in_room: Room ID {room_id} not found.")
        return None

    mob_instance = models.RoomMobInstance(
        room_id=room_id,
        mob_template_id=mob_template_id,
        current_health=template.base_health,
        instance_properties_override=instance_properties_override,
        spawn_definition_id=originating_spawn_definition_id 
    )
    db.add(mob_instance)
    # db.commit() # Caller of spawn_mob_in_room should commit, esp. if part of larger transaction (e.g. mob_respawner)
    # db.refresh(mob_instance) # Also by caller if needed immediately after commit
    logger.info(f"Staged spawn of mob '{template.name}' (Template ID: {template.id}) in room '{room.name}' (Room ID: {room_id}). Instance ID will be assigned on commit.")
    return mob_instance # Return uncommitted instance

def despawn_mob_from_room(db: Session, room_mob_instance_id: uuid.UUID) -> bool:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance:
        spawn_def_id_to_update = instance.spawn_definition_id 
        mob_name_for_log = instance.mob_template.name if instance.mob_template else "Unknown Mob"
        logger.info(f"Despawning mob '{mob_name_for_log}' (Instance ID: {room_mob_instance_id}).")

        db.delete(instance)
        
        if spawn_def_id_to_update:
            crud.crud_mob_spawn_definition.update_mob_spawn_definition_next_check_time(
                db, 
                definition_id=spawn_def_id_to_update, 
                next_check_time=datetime.now(timezone.utc) # Trigger immediate re-check
            )
            logger.debug(f"Flagged immediate re-check for spawn definition {spawn_def_id_to_update} due to mob despawn.")
        
        # db.commit() # Caller of despawn (e.g. combat processor) should handle commit
        return True
    logger.warning(f"despawn_mob_from_room: Mob instance ID {room_mob_instance_id} not found.")
    return False

def update_mob_instance_health(
    db: Session, room_mob_instance_id: uuid.UUID, change_in_health: int
) -> Optional[models.RoomMobInstance]:
    instance = get_room_mob_instance(db, room_mob_instance_id)
    if instance and instance.mob_template:
        instance.current_health += change_in_health
        instance.current_health = max(0, min(instance.current_health, instance.mob_template.base_health))
            
        db.add(instance)
        # db.commit() # Caller (combat processor) handles commit
        # db.refresh(instance) # Caller handles refresh
        return instance
    elif instance: # Mob instance exists, but template somehow missing (should not happen with joinedload)
        logger.warning(f"update_mob_instance_health: Mob instance {room_mob_instance_id} missing mob_template. Health update might be unreliable.")
        instance.current_health += change_in_health # Apply change without cap
        instance.current_health = max(0, instance.current_health)
        db.add(instance)
        return instance
    else: # Instance not found
        logger.warning(f"update_mob_instance_health: Mob instance ID {room_mob_instance_id} not found.")
    return None

# --- Seeding Initial Mob Templates ---
def seed_initial_mob_templates(db: Session):
    logger.info("Attempting to seed initial mob templates from mob_templates.json...")
    mob_template_definitions = _load_seed_data_generic("mob_templates.json", "Mob template")

    if not mob_template_definitions:
        logger.warning("No mob template definitions found or error loading mob_templates.json. Aborting mob template seeding.")
        return

    seeded_count = 0
    updated_count = 0
    skipped_count = 0 # For items that exist and have no changes

    for template_data in mob_template_definitions:
        template_name = template_data.get("name")
        if not template_name:
            logger.warning(f"Skipping mob template entry due to missing name: {template_data}")
            skipped_count += 1
            continue
        
        existing_template = get_mob_template_by_name(db, name=template_name)
        
        try:
            if existing_template:
                template_update_schema = schemas.MobTemplateUpdate(**template_data)
                # Pass the ORM object and the Pydantic update schema to the update function
                updated_template = update_mob_template(db, db_template=existing_template, template_in=template_update_schema)
                # Check if update_mob_template actually staged a change by checking session dirty status or a flag.
                # For now, we'll assume if no exception, it's either updated or was identical.
                # To be more precise, compare dicts or check db.is_modified(existing_template) before commit
                
                # A simple way to check if changes were made for logging purposes:
                original_dump = schemas.MobTemplate.from_orm(existing_template).model_dump(exclude={'id'}) # Exclude id for comparison
                updated_dump_from_data = schemas.MobTemplateCreate(**template_data).model_dump() # Create a full model from data

                # Compare relevant fields. This is a bit verbose.
                # A better way might be for update_mob_template to return a boolean indicating change.
                is_actually_changed = False
                for key, value_from_json in updated_dump_from_data.items():
                    if original_dump.get(key) != value_from_json:
                        is_actually_changed = True
                        break
                
                if is_actually_changed: # If update_mob_template would have made changes
                    logger.info(f"Updating mob template: {template_name}")
                    updated_count += 1
                else:
                    # logger.debug(f"Mob template '{template_name}' exists and no changes detected.")
                    skipped_count +=1
            else: # Template does not exist, create it
                template_create_schema = schemas.MobTemplateCreate(**template_data)
                logger.info(f"Creating mob template: {template_create_schema.name}")
                create_mob_template(db, template_in=template_create_schema)
                seeded_count += 1
        except Exception as e_pydantic_or_db: # Catch broader exceptions
            logger.error(f"Validation or DB operation failed for mob template '{template_name}': {e_pydantic_or_db}. Data: {template_data}", exc_info=True)
            skipped_count += 1
            db.rollback() # Rollback this specific item's attempt
            continue # Continue to next item

    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new and {updated_count} updated mob templates.")
            db.commit()
            logger.info("Mob template seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing mob template seeds: {e_commit}. Rolling back.", exc_info=True)
            db.rollback()
    else:
        logger.info("No new mob templates to seed or templates to update. No commit needed for mob templates.")

    logger.info(f"Mob template seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")
--- END OF FILE backend/app/crud/crud_mob.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/models/mob_template.py ---
# backend/app/models/mob_template.py
import uuid
from typing import Optional, Dict, Any, List # Added List

from sqlalchemy import String, Text, Integer, Float # Keep Column, Add Float
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class MobTemplate(Base):
    __tablename__ = "mob_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # mob_type: Mapped[Optional[str]] = mapped_column(String(50), index=True, nullable=True, comment="e.g., beast, humanoid, undead") # Replaced by faction_tags

    level: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1)
    base_health: Mapped[int] = mapped_column(Integer, nullable=False, default=10)
    base_mana: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) # <<< MODIFIED
    base_attack: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., 1d6") 
    base_defense: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=10, comment="e.g., Armor Class")
    
    attack_speed_secs: Mapped[Optional[float]] = mapped_column(Float, nullable=True, default=3.0) # <<< MODIFIED
    aggro_radius: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=5) # <<< MODIFIED
    roam_radius: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) # <<< MODIFIED
    
    xp_value: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    
    # loot_table_ref: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, comment="Placeholder for loot table reference") # Replaced by loot_table_tags
    loot_table_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED (JSONB for list of strings)
    
    currency_drop: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB, 
        nullable=True,
        comment="Defines currency drop. E.g., {'c_min':0, ...}"
    ) # Default can be set by Pydantic model if not provided in JSON
    
    dialogue_lines: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    faction_tags: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    special_abilities: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: []) # <<< MODIFIED
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, default=lambda: {})
    
    # aggression_type: Mapped[Optional[str]] = mapped_column(String(50), default="NEUTRAL", nullable=True, index=True, comment="e.g., NEUTRAL, AGGRESSIVE_ON_SIGHT, AGGRESSIVE_IF_APPROACHED") 
    # Decided to remove this, as aggro_radius and faction logic should cover it.
    # If you reinstate it in schemas/JSON, add it back here too.

    def __repr__(self) -> str:
        return f"<MobTemplate(id={self.id}, name='{self.name}', level='{self.level}')>"
--- END OF FILE backend/app/models/mob_template.py ---

--- START OF FILE backend/app/models/character_inventory_item.py ---
# backend/app/models/character_inventory_item.py
import uuid
from typing import TYPE_CHECKING, Optional

from sqlalchemy import ForeignKey, Integer, Boolean, String
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .character import Character  # noqa: F401
    from .item import Item  # noqa: F401


class CharacterInventoryItem(Base):
    __tablename__ = "character_inventory_items"

    # Composite Primary Key: (character_id, item_id)
    # However, SQLAlchemy prefers a single surrogate primary key for association objects
    # if they have additional attributes beyond just the foreign keys.
    # Let's add an explicit id for this table for easier reference, though character_id + item_id could form a unique constraint.
    # Or, if an item can appear multiple times (e.g. two identical non-stackable swords),
    # then an auto-incrementing ID for this table row is essential.
    # Let's assume for now a character can only have ONE "entry" for a given item_id, and quantity handles multiples if stackable.
    # If not stackable, and they have two of the same sword, they'd be two separate Item instances in the Item table (e.g. with serial numbers or unique IDs anyway).
    # For our MUD, usually an Item is a "template". If a player has two "Long Sword" (same item_id), this table handles it.
    # Okay, if Item.stackable is false, each instance is a separate row here with quantity 1.
    # If Item.stackable is true, one row with quantity > 1.
    # Let's give this table its own UUID PK for simplicity in referencing a specific *instance* in inventory.

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, comment="Unique ID for this specific instance of an item in a character's inventory")
    
    character_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Indicates if this specific inventory item instance is currently equipped
    equipped: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False, index=True)
    
    # If equipped, this specifies which of the character's equipment slots it occupies.
    # This must be one of the keys from models.item.EQUIPMENT_SLOTS.
    # Necessary for items that can fit into more than one type of slot (e.g. generic 'ring' item into 'finger_1' or 'finger_2')
    # or to distinguish main_hand vs off_hand for identical weapons.
    equipped_slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="Actual character slot occupied if equipped, e.g. 'finger_1'")

    # Relationships
    character: Mapped["Character"] = relationship(back_populates="inventory_items")
    item: Mapped["Item"] = relationship() # No back_populates needed if Item doesn't need to know all its inventory entries directly

    def __repr__(self) -> str:
        return f"<CharInvItem(id={self.id}, char_id='{self.character_id}', item_id='{self.item_id}', qty={self.quantity}, equipped={self.equipped}, slot='{self.equipped_slot}')>"
--- END OF FILE backend/app/models/character_inventory_item.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    owner: Mapped["Player"] = relationship(back_populates="characters")

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)

    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/room_item_instance.py ---
# backend/app/models/room_item_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room import Room  # noqa: F401
    from .item import Item  # noqa: F401
    from .character import Character # noqa: F401

class RoomItemInstance(Base):
    __tablename__ = "room_item_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Optional: if this instance on the ground has different properties than the item template
    properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    
    dropped_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    dropped_by_character_id: Mapped[Optional[uuid.UUID]] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), nullable=True, index=True)

    # Relationships
    room: Mapped["Room"] = relationship(back_populates="items_on_ground")
    item: Mapped["Item"] = relationship(lazy="joined") # Eager load item template details by default
    dropped_by: Mapped[Optional["Character"]] = relationship() # Character who dropped it

    def __repr__(self) -> str:
        return f"<RoomItemInstance(id={self.id}, room_id='{self.room_id}', item_id='{self.item_id}', qty={self.quantity})>"
--- END OF FILE backend/app/models/room_item_instance.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py

import uuid
from typing import Optional, Dict, List, TYPE_CHECKING, Any 
from enum import Enum as PyEnum # To avoid conflict with potential future 'Enum' table

from sqlalchemy import Column, Integer, String, Text, Enum as SQLEnum # Enum for DB
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance 
    from .room_mob_instance import RoomMobInstance

# NEW RoomType Enum
class RoomTypeEnum(PyEnum):
    STANDARD = "standard"
    SANCTUARY = "sanctuary" # No combat, perhaps faster regen
    SHOP = "shop"
    TRAINER = "trainer"
    DUNGEON_ENTRANCE = "dungeon_entrance"
    PUZZLE = "puzzle"
    # Add more as needed

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    
    room_type: Mapped[RoomTypeEnum] = mapped_column( # <<< NEW FIELD
        SQLEnum(RoomTypeEnum, name="roomtypeenum", create_type=True), # create_type=True for SQLAlchemy to manage Enum in DB
        default=RoomTypeEnum.STANDARD, 
        nullable=False,
        index=True
    )

    exits: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB, 
        nullable=True, 
        default=lambda: {}
    )
    interactables: Mapped[Optional[List[Dict[str, Any]]]] = mapped_column(
        JSONB, 
        nullable=True, 
        default=lambda: []
    )
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin"
    )
    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin" 
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', type='{self.room_type.value}', x={self.x}, y={self.y}, z={self.z})>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/models/mob_spawn_definition.py ---
# backend/app/models/mob_spawn_definition.py
import uuid
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, DateTime, func, String, Boolean 
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room import Room 
    from .mob_template import MobTemplate
    from .room_mob_instance import RoomMobInstance

class MobSpawnDefinition(Base):
    __tablename__ = "mob_spawn_definitions" 

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    definition_name: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False,
                                                 comment="Unique descriptive name, e.g., 'CellarRatsNorthCorner'")
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False,
                                             comment="Primary room this definition is tied to / origin room for roamers.")
    mob_template_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_templates.id"), index=True, nullable=False)
    
    quantity_min: Mapped[int] = mapped_column(Integer, default=1, nullable=False,
                                             comment="Spawner tries to maintain at least this many alive from this definition.")
    quantity_max: Mapped[int] = mapped_column(Integer, default=1, nullable=False,
                                             comment="Spawner won't spawn more than this many from this definition if min is met.")
    
    respawn_delay_seconds: Mapped[int] = mapped_column(Integer, default=300, nullable=False, 
                                                      comment="Delay after population drops below min, or after individual kill.")
    
    chance_to_spawn_percent: Mapped[int] = mapped_column(Integer, default=100, nullable=False,
                                                        comment="0-100 percent chance to spawn when conditions are met.")
    
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False,
                                           comment="Whether this spawn definition is currently active.")

    next_respawn_check_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True, index=True,
                                                                   comment="Next time the ticker should evaluate this spawner.")

    roaming_behavior: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True,
                                                                    comment="e.g., {'type': 'random_adjacent', 'move_chance_percent': 25, 'max_distance_from_spawn': 5}")
    
    # Relationships
    room: Mapped[Optional["Room"]] = relationship() 
    mob_template: Mapped[Optional["MobTemplate"]] = relationship()

    spawned_mob_instances: Mapped[List["RoomMobInstance"]] = relationship( 
        back_populates="originating_spawn_definition" 
    )

    def __repr__(self) -> str:
        return f"<MobSpawnDefinition(id={self.id}, name='{self.definition_name}', mob='{self.mob_template_id}', room='{self.room_id}', qty='{self.quantity_min}-{self.quantity_max}')>"
--- END OF FILE backend/app/models/mob_spawn_definition.py ---

--- START OF FILE backend/app/schemas/item.py ---
# backend/app/schemas/item.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- Item Schemas ---
class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    item_type: str = Field(..., description="e.g., weapon, armor, potion, junk")
    slot: Optional[str] = Field(None, description="Primary equippable slot type, e.g., head, main_hand, consumable")
    properties: Optional[Dict[str, Any]] = Field(None, description="e.g., {'damage': '1d6', 'armor_class': 5}")
    weight: float = Field(0.0, ge=0)
    value: int = Field(0, ge=0)
    stackable: bool = False
    max_stack_size: Optional[int] = Field(1, ge=1)

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    item_type: Optional[str] = None
    slot: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    weight: Optional[float] = None
    value: Optional[int] = None
    stackable: Optional[bool] = None
    max_stack_size: Optional[int] = None

class ItemInDBBase(ItemBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class Item(ItemInDBBase): # For returning item info
    pass

class ItemInDB(ItemInDBBase): # More complete internal representation if needed
    pass


# --- CharacterInventoryItem Schemas ---
# This represents an item *instance* in a character's inventory

class CharacterInventoryItemBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    equipped: bool = False
    equipped_slot: Optional[str] = None # Actual character slot occupied if equipped

class CharacterInventoryItemCreate(CharacterInventoryItemBase):
    # character_id will be supplied by the service/path
    pass

class CharacterInventoryItemUpdate(BaseModel):
    quantity: Optional[int] = Field(None, ge=1)
    equipped: Optional[bool] = None
    equipped_slot: Optional[str] = None

class CharacterInventoryItemInDBBase(CharacterInventoryItemBase):
    id: uuid.UUID # The unique ID of this inventory entry
    character_id: uuid.UUID
    item: Item # Include full item details when displaying inventory

    class Config:
        from_attributes = True

class CharacterInventoryItem(CharacterInventoryItemInDBBase): # For returning to client
    pass


# --- Composite Schema for Displaying Full Inventory ---
class CharacterInventoryDisplay(BaseModel):
    equipped_items: Dict[str, CharacterInventoryItem] = Field(default_factory=dict, description="Items currently equipped, keyed by their equipped_slot")
    backpack_items: List[CharacterInventoryItem] = Field(default_factory=list, description="Items in inventory but not equipped")
    platinum: int = 0
    gold: int = 0
    silver: int = 0
    copper: int = 0
    # Add more fields like total_weight, currency later

class EquipRequest(BaseModel):
    target_slot: Optional[str] = Field(None, description="Optional: The specific character slot to equip the item to, e.g., 'finger_1'")
--- END OF FILE backend/app/schemas/item.py ---

--- START OF FILE backend/app/schemas/mob.py ---
# backend/app/schemas/mob.py
import uuid
from datetime import datetime
from pydantic import BaseModel, Field, validator
from typing import Optional, Dict, Any, List

# --- MobTemplate Schemas ---
class MobTemplateBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    
    level: Optional[int] = Field(1, ge=0) 
    base_health: int = Field(10, gt=0)
    base_mana: Optional[int] = Field(0, ge=0) # <<< MODIFIED
    base_attack: Optional[str] = Field("1d4") 
    base_defense: Optional[int] = Field(10, ge=0)
    
    attack_speed_secs: Optional[float] = Field(3.0, gt=0, description="Time in seconds between attacks.") # <<< MODIFIED
    aggro_radius: Optional[int] = Field(5, ge=0, description="Radius in map units for auto-aggression.") # <<< MODIFIED
    roam_radius: Optional[int] = Field(0, ge=0, description="Radius from spawn point for roaming behavior. 0 means stationary unless pulled.") # <<< MODIFIED
    
    xp_value: int = Field(0, ge=0)
    
    loot_table_tags: Optional[List[str]] = Field(default_factory=list, description="Tags to determine loot drops, e.g., ['goblin_common', 'small_treasure']") # <<< MODIFIED
    currency_drop: Optional[Dict[str, Any]] = Field(None, description="Defines currency drop amounts and chances.") # <<< MODIFIED
    
    dialogue_lines: Optional[List[str]] = Field(default_factory=list, description="Lines the mob might say.") # <<< MODIFIED
    faction_tags: Optional[List[str]] = Field(default_factory=list, description="Faction affiliations, e.g., ['goblins', 'undead']") # <<< MODIFIED
    special_abilities: Optional[List[str]] = Field(default_factory=list, description="List of skill/ability tags the mob possesses.") # <<< MODIFIED
    
    properties: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Generic properties bag for future expansion.")
    
    @validator('currency_drop', pre=True, always=True)
    def check_currency_drop(cls, v):
        if v is None: # If the input JSON doesn't have currency_drop, this sets a default structure
            return {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        # If v is provided, ensure all keys are present, defaulting to 0 if missing
        # This makes downstream access safer (e.g. mob_template.currency_drop.get("c_min", 0) will always work)
        default_keys = {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        if isinstance(v, dict):
            for key, default_val in default_keys.items():
                v.setdefault(key, default_val)
        return v

class MobTemplateCreate(MobTemplateBase):
    pass

class MobTemplateUpdate(BaseModel): # Does NOT inherit from MobTemplateBase
    name: Optional[str] = Field(None, min_length=1, max_length=100) # All fields are optional
    description: Optional[str] = None
    level: Optional[int] = Field(None, ge=0) 
    base_health: Optional[int] = Field(None, gt=0)
    base_mana: Optional[int] = Field(None, ge=0) 
    base_attack: Optional[str] = None
    base_defense: Optional[int] = Field(None, ge=0)
    attack_speed_secs: Optional[float] = Field(None, gt=0)
    aggro_radius: Optional[int] = Field(None, ge=0)
    roam_radius: Optional[int] = Field(None, ge=0)
    xp_value: Optional[int] = Field(None, ge=0)
    loot_table_tags: Optional[List[str]] = None
    currency_drop: Optional[Dict[str, Any]] = None
    dialogue_lines: Optional[List[str]] = None
    faction_tags: Optional[List[str]] = None
    special_abilities: Optional[List[str]] = None
    properties: Optional[Dict[str, Any]] = None
    
    @validator('currency_drop', pre=True, always=True)
    def check_currency_drop_update(cls, v): # Validator for update too
        if v is None:
            return None # If not provided in update, it remains None, won't overwrite with defaults
        
        default_keys = {"c_min": 0, "c_max": 0, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0}
        if isinstance(v, dict):
            # For update, only fill missing keys if the currency_drop field itself is provided
            # This allows partial updates like just changing 'c_min'
            # No, this is wrong. If 'currency_drop' is provided, it should be a complete structure or pydantic will complain.
            # The validator should ensure that IF 'currency_drop' is given, it's valid.
            # The BaseSettings with `extra='ignore'` for `model_config` is for the top-level Settings, not for these Pydantic models.
            # The current validator on MobTemplateBase already handles setting defaults IF currency_drop is provided.
            # For updates, if currency_drop is in the payload, it must be valid. If it's not, it's not updated.
            # This validator needs to be smarter or removed for Update, relying on the Base validator if the field is present.
            # Let's simplify: if it's present, it's validated by MobTemplateBase's logic if inherited, or by its own Field types.
            # The goal is to ensure that IF currency_drop is being set/updated, it's a valid structure.
            # Let's stick to the original validator on MobTemplateBase. Pydantic will handle validation on update if the field is present.
            # The `always=True` and `pre=True` means it runs even if the field is not in the input data for `Create`.
            # For `Update`, if the field is not in the input, the validator for `currency_drop` (inherited or direct) won't run.
            # So, the validator on MobTemplateBase is what we need for creation. For update, it's fine.
            pass # No specific validator needed for Update if fields are optional.
                 # Relies on field constraints.
        return v


class MobTemplateInDBBase(MobTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class MobTemplate(MobTemplateInDBBase): 
    pass


# --- RoomMobInstance Schemas ---
class RoomMobInstanceBase(BaseModel):
    mob_template_id: uuid.UUID
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None

class RoomMobInstanceCreate(BaseModel): 
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    instance_properties_override: Optional[Dict[str, Any]] = None 
    spawn_definition_id: Optional[uuid.UUID] = None
    
class RoomMobInstanceUpdate(BaseModel): 
    current_health: Optional[int] = None
    instance_properties_override: Optional[Dict[str, Any]] = Field(None, description="Use with caution, replaces entire dict")

class RoomMobInstanceInDBBase(BaseModel): 
    id: uuid.UUID
    room_id: uuid.UUID
    mob_template_id: uuid.UUID 
    current_health: int
    instance_properties_override: Optional[Dict[str, Any]] = None
    spawn_definition_id: Optional[uuid.UUID] = None
    spawned_at: datetime
    last_action_at: Optional[datetime] = None
    
    mob_template: MobTemplate # Changed from MobTemplateInDB to MobTemplate for consistency

    class Config:
        from_attributes = True

class RoomMobInstance(RoomMobInstanceInDBBase): 
    pass

class RoomMobsView(BaseModel):
    mobs_in_room: List[RoomMobInstance] = Field(default_factory=list)
--- END OF FILE backend/app/schemas/mob.py ---

--- START OF FILE backend/app/schemas/mob_spawn_definition.py ---
# backend/app/schemas/mob_spawn_definition.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any

from pydantic import BaseModel, Field

class MobSpawnDefinitionBase(BaseModel):
    definition_name: str = Field(..., min_length=3, max_length=255)
    room_id: uuid.UUID
    mob_template_id: uuid.UUID
    quantity_min: int = Field(default=1, ge=1)
    quantity_max: int = Field(default=1, ge=1) # Should validate quantity_max >= quantity_min later
    respawn_delay_seconds: int = Field(default=300, ge=5)
    chance_to_spawn_percent: int = Field(default=100, ge=0, le=100)
    is_active: bool = True
    roaming_behavior: Optional[Dict[str, Any]] = None
    # next_respawn_check_at is usually managed by the system, not set on create/update by user

class MobSpawnDefinitionCreate(MobSpawnDefinitionBase):
    pass

class MobSpawnDefinitionUpdate(BaseModel): # Allow partial updates
    definition_name: Optional[str] = Field(None, min_length=3, max_length=255)
    room_id: Optional[uuid.UUID] = None
    mob_template_id: Optional[uuid.UUID] = None
    quantity_min: Optional[int] = Field(None, ge=1)
    quantity_max: Optional[int] = Field(None, ge=1)
    respawn_delay_seconds: Optional[int] = Field(None, ge=5)
    chance_to_spawn_percent: Optional[int] = Field(None, ge=0, le=100)
    is_active: Optional[bool] = None
    roaming_behavior: Optional[Dict[str, Any]] = None
    next_respawn_check_at: Optional[datetime] = None # Allow admin to set/reset this

class MobSpawnDefinitionInDBBase(MobSpawnDefinitionBase):
    id: uuid.UUID
    next_respawn_check_at: Optional[datetime] = None

    class Config:
        from_attributes = True

class MobSpawnDefinition(MobSpawnDefinitionInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/mob_spawn_definition.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)

    # Currency: Optional at creation, with defaults
    platinum_coins: Optional[int] = Field(0, description="Platinum coins owned by the character")
    gold_coins: Optional[int] = Field(0, description="Gold coins owned by the character")
    silver_coins: Optional[int] = Field(0, description="Silver coins owned by the character")
    copper_coins: Optional[int] = Field(100, description="Copper coins owned by the character, default 100 for new chars")

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):  # Inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    platinum_coins: int # type: ignore
    gold_coins: int # type: ignore
    silver_coins: int # type: ignore
    copper_coins: int # type: ignore

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/seeds/items.json ---

[
  {
    "name": "Rusty Sword",
    "description": "A short sword, pitted with rust. Better than nothing.",
    "item_type": "weapon",
    "slot": "main_hand",
    "properties": { "damage": "1d6", "damage_type": "slashing", "weapon_type": "sword" },
    "weight": 3.0, "value": 5, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Cloth Tunic",
    "description": "Simple, patched-up clothing.",
    "item_type": "armor", "slot": "torso",
    "properties": { "armor_class_bonus": 1 },
    "weight": 1.0, "value": 2, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Wooden Shield",
    "description": "A basic round wooden shield.",
    "item_type": "armor", "slot": "off_hand",
    "properties": { "armor_class_bonus": 2, "item_subtype": "shield" },
    "weight": 5.0, "value": 8, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Dagger",
    "description": "A small, easily concealable dagger.",
    "item_type": "weapon", "slot": "main_hand",
    "properties": { "damage": "1d4", "damage_type": "piercing", "weapon_type": "dagger", "finesse": true },
    "weight": 1.0, "value": 2, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Archive Key Alpha",
    "description": "A small, intricately carved metal key. Sector 42.",
    "item_type": "key", "slot": null,
    "properties": { "item_tag": "archive_key_alpha" },
    "weight": 0.1, "value": 0, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Basic Healing Draught",
    "description": "A common herbal brew that knits minor wounds.",
    "item_type": "potion", "slot": "consumable",
    "properties": { "effect_type": "heal_direct", "heal_amount_dice": "2d4", "heal_amount_bonus": 2, "cooldown_group": "potion", "cooldown_seconds": 30 },
    "weight": 0.5, "value": 25, "stackable": true, "max_stack_size": 5
  },
  {
    "name": "Lockpicks",
    "description": "A set of fine tools for bypassing simple locks.",
    "item_type": "tool", "slot": null,
    "properties": { "item_tag": "basic_lockpicks", "provides_skill_bonus": { "skill_id_tag": "pick_lock_basic", "bonus_amount": 2 } },
    "weight": 0.2, "value": 50, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Rat Tail",
    "description": "A long, scaly rat tail. Gross.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "rat_tail_junk" },
    "weight": 0.1, "value": 1, "stackable": true, "max_stack_size": 20
  },
  {
    "name": "Cracked Tooth",
    "description": "A small, cracked animal tooth.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "cracked_tooth_junk" },
    "weight": 0.05, "value": 0, "stackable": true, "max_stack_size": 50
  },
  {
    "name": "Beast Pelt (Small)",
    "description": "The pelt of a small, furry creature. Could be useful.",
    "item_type": "crafting_material", "slot": null,
    "properties": { "item_tag": "pelt_small_beast" },
    "weight": 0.5, "value": 3, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Animal Bone",
    "description": "A sturdy animal bone, perhaps from a leg or rib.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "animal_bone_generic" },
    "weight": 0.3, "value": 0, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Old Boot",
    "description": "A single, waterlogged leather boot. Seen better days.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "old_boot_junk" },
    "weight": 1.0, "value": 0, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Rusty Tin Can",
    "description": "An old, rusty tin can. Empty, of course.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "rusty_can_junk" },
    "weight": 0.2, "value": 0, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Goblin Ear",
    "description": "A severed goblin ear. A common, if gruesome, trophy.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "goblin_ear_trophy" },
    "weight": 0.1, "value": 2, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Crude Dagger Scrap",
    "description": "A piece of a crudely made goblin dagger, broken and useless.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "crude_dagger_scrap" },
    "weight": 0.3, "value": 1, "stackable": true, "max_stack_size": 5
  },
  {
    "name": "Torn Pouch",
    "description": "A small leather pouch, torn and empty.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "torn_pouch_junk" },
    "weight": 0.1, "value": 0, "stackable": false, "max_stack_size": 1
  }

]
--- END OF FILE backend/app/seeds/items.json ---

--- START OF FILE backend/app/seeds/mob_templates.json ---
[
  {
    "name": "Giant Rat",
    "description": "A rodent of unusual size, its fur matted and its eyes glinting with a feral hunger.",
    "level": 1,
    "base_health": 12,
    "base_mana": 0,
    "base_attack": "1d4",
    "base_defense": 11,
    "xp_value": 5,
    "attack_speed_secs": 2.5,
    "aggro_radius": 4,
    "roam_radius": 3,
    "dialogue_lines": ["*Squeak!*", "Hisss...", "*Chitters angrily*"],
    "faction_tags": ["vermin", "beast", "neutral_critter"],
    "loot_table_tags": ["vermin_common", "small_beast_parts", "tier1_trash"],
    "special_abilities": [],
    "currency_drop": {
        "c_min": 1, "c_max": 5, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Goblin Scout",
    "description": "A small, wiry goblin with shifty eyes and a crude spear. Looks like it would rather be anywhere else.",
    "level": 2,
    "base_health": 18,
    "base_mana": 5,
    "base_attack": "1d6",
    "base_defense": 13,
    "xp_value": 15,
    "attack_speed_secs": 3.0,
    "aggro_radius": 7,
    "roam_radius": 5,
    "dialogue_lines": ["Sneaky sneaky!", "You see shiny?", "Me take that!", "Yark! Intruder!"],
    "faction_tags": ["goblinoid", "scout", "hostile_humanoid"],
    "loot_table_tags": ["goblin_common", "crude_gear", "tier1_basic"],
    "special_abilities": ["evasive_maneuver_passive"],
    "currency_drop": {
        "c_min": 5, "c_max": 15, "s_chance": 10, "s_min": 1, "s_max": 2, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Security Drone MK I",
    "description": "A hovering metallic drone, its single optical sensor glowing ominously. It emits a low whirring sound.",
    "level": 3,
    "base_health": 25,
    "base_mana": 0,
    "base_attack": "2d4", 
    "base_defense": 14,
    "xp_value": 25,
    "attack_speed_secs": 2.0,
    "aggro_radius": 10,
    "roam_radius": 0, 
    "faction_tags": ["construct", "security", "neutral_guard"],
    "loot_table_tags": ["construct_parts_common", "tech_scrap", "tier1_tech"],
    "special_abilities": ["self_repair_protocol_passive", "arc_discharge_active"],
    "currency_drop": {
        "c_min": 0, "c_max": 0, "s_chance": 20, "s_min": 1, "s_max": 5, "g_chance": 5, "g_min": 1, "g_max": 1, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Forest Spider",
    "description": "A large, hairy spider with too many eyes. It scuttles menacingly.",
    "level": 2,
    "base_health": 15,
    "base_mana": 10,
    "base_attack": "1d6",
    "base_defense": 12,
    "xp_value": 12,
    "attack_speed_secs": 2.8,
    "aggro_radius": 6,
    "roam_radius": 4,
    "dialogue_lines": ["*Hiss*", "*Clicking mandibles*"],
    "faction_tags": ["arachnid", "beast", "hostile_critter"],
    "loot_table_tags": ["spider_parts", "tier1_beast_loot"],
    "special_abilities": ["poison_bite_active", "web_shot_utility"],
    "currency_drop": {
        "c_min": 2, "c_max": 8, "s_chance": 5, "s_min": 1, "s_max": 1, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Lost Soul",
    "description": "A shimmering, translucent figure that wails mournfully. It seems trapped between worlds.",
    "level": 4,
    "base_health": 30,
    "base_mana": 20,
    "base_attack": "1d8", 
    "base_defense": 10, 
    "xp_value": 35,
    "attack_speed_secs": 3.5,
    "aggro_radius": 5,
    "roam_radius": 2,
    "dialogue_lines": ["Why...?", "So cold...", "Lost... forever..."],
    "faction_tags": ["undead", "spirit", "neutral_ethereal"],
    "loot_table_tags": ["ectoplasm", "spirit_essence", "tier2_ethereal"],
    "special_abilities": ["ethereal_form_passive", "chilling_touch_active"],
    "properties": {"damage_type_override": "cold"},
    "currency_drop": {
        "c_min": 0, "c_max": 0, "s_chance": 15, "s_min": 3, "s_max": 7, "g_chance": 2, "g_min": 1, "g_max": 1, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Dust Devil",
    "description": "A small whirlwind of sand and grit, animated by some unknown force.",
    "level": 3,
    "base_health": 22,
    "base_mana": 0,
    "base_attack": "1d6",
    "base_defense": 15,
    "xp_value": 20,
    "attack_speed_secs": 2.2,
    "aggro_radius": 6,
    "roam_radius": 6,
    "dialogue_lines": ["*Whirls angrily*", "*Grinding noises*"],
    "faction_tags": ["elemental", "air_elemental", "neutral_elemental"],
    "loot_table_tags": ["elemental_mote_air", "tier1_elemental"],
    "special_abilities": ["sand_blast_active", "evasion_aura_passive"],
    "currency_drop": {
        "c_min": 10, "c_max": 25, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Bandit Thug",
    "description": "A burly human with a scarred face and a mean-looking club. Smells of stale ale and desperation.",
    "level": 4,
    "base_health": 35,
    "base_mana": 0,
    "base_attack": "1d8",
    "base_defense": 12,
    "xp_value": 30,
    "attack_speed_secs": 3.2,
    "aggro_radius": 8,
    "roam_radius": 3,
    "dialogue_lines": ["Your money or your life!", "Stand and deliver!", "Shouldn't have come here!"],
    "faction_tags": ["humanoid", "bandit", "hostile_humanoid"],
    "loot_table_tags": ["bandit_gear", "stolen_goods_common", "tier2_humanoid"],
    "special_abilities": ["intimidating_shout_active"],
    "currency_drop": {
        "c_min": 15, "c_max": 40, "s_chance": 25, "s_min": 2, "s_max": 5, "g_chance": 5, "g_min": 1, "g_max": 2, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Cave Bat Swarm",
    "description": "A disorienting cloud of screeching bats, their tiny teeth glinting.",
    "level": 3,
    "base_health": 20, 
    "base_mana": 0,
    "base_attack": "1d3", 
    "base_defense": 14,
    "xp_value": 18,
    "attack_speed_secs": 1.5, 
    "aggro_radius": 5,
    "roam_radius": 2,
    "dialogue_lines": ["*High-pitched screeches*"],
    "faction_tags": ["beast", "swarm", "hostile_critter"],
    "loot_table_tags": ["bat_parts", "tier1_swarm_remains"],
    "special_abilities": ["disorienting_flutter_passive", "multi_attack_swarm_passive"],
    "properties": {"is_swarm": true, "swarm_attacks_count": 3},
    "currency_drop": {
        "c_min": 3, "c_max": 10, "s_chance": 0, "s_min": 0, "s_max": 0, "g_chance": 0, "g_min": 0, "g_max": 0, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Animated Armor",
    "description": "An empty suit of plate armor that moves with an eerie, clanking grace. No one appears to be inside.",
    "level": 5,
    "base_health": 45,
    "base_mana": 0,
    "base_attack": "1d10",
    "base_defense": 18,
    "xp_value": 50,
    "attack_speed_secs": 3.8,
    "aggro_radius": 6,
    "roam_radius": 0,
    "dialogue_lines": ["*Clank*", "*Scrape*", "*Whirr*"],
    "faction_tags": ["construct", "guardian", "neutral_guard"],
    "loot_table_tags": ["construct_parts_rare", "enchanted_metal_shards", "tier2_construct"],
    "special_abilities": ["damage_resistance_physical_passive", "magic_immunity_partial_passive"],
    "currency_drop": {
        "c_min": 0, "c_max": 0, "s_chance": 30, "s_min": 5, "s_max": 10, "g_chance": 10, "g_min": 1, "g_max": 3, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  },
  {
    "name": "Dire Wolf",
    "description": "A massive wolf with fur as dark as night and eyes that burn with a primal fury. Its growl is a promise of pain.",
    "level": 6,
    "base_health": 60,
    "base_mana": 10,
    "base_attack": "2d6",
    "base_defense": 15,
    "xp_value": 75,
    "attack_speed_secs": 3.0,
    "aggro_radius": 9,
    "roam_radius": 7,
    "dialogue_lines": ["*Snarl*", "*Deep Growl*", "*Howl*"],
    "faction_tags": ["beast", "canine", "predator", "hostile_alpha"],
    "loot_table_tags": ["dire_wolf_pelt", "large_beast_trophy", "tier3_beast_loot"],
    "special_abilities": ["pack_tactics_passive", "powerful_bite_active", "howl_buff_aura_active"],
    "currency_drop": {
        "c_min": 0, "c_max": 0, "s_chance": 5, "s_min": 10, "s_max": 20, "g_chance": 1, "g_min": 1, "g_max": 2, "p_chance": 0, "p_min": 0, "p_max": 0
    }
  }
]
--- END OF FILE backend/app/seeds/mob_templates.json ---

--- START OF FILE backend/app/seeds/character_classes.json ---
[
  {
    "name": "Warrior",
    "description": "A stalwart fighter, skilled in the arts of melee combat and enduring hardship. Warriors excel at both dealing and absorbing damage on the front lines.",
    "base_stat_modifiers": {"strength": 2, "constitution": 1, "intelligence": -1, "charisma": -1},
    "starting_health_bonus": 10,
    "starting_mana_bonus": -5,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch"],
            "2": ["power_attack_melee"],
            "3": ["shield_bash_active"],
            "5": ["cleave_melee_active"]
        },
        "core_traits_by_level": {
            "1": ["tough_hide"],
            "2": ["weapon_focus_swords_passive"],
            "4": ["improved_vitality_passive"]
        }
    },
    "starting_equipment_refs": ["Rusty Sword", "Wooden Shield", "Cloth Tunic"],
    "playstyle_tags": ["melee", "tank", "physical_dps", "durable"],
    "stat_gains_per_level": {
        "hp": 6, 
        "mp": 1, 
        "base_attack_bonus": 0.75
    }
  },
  {
    "name": "Swindler",
    "description": "A cunning rogue who relies on wit, agility, and a sharp blade. Swindlers are masters of stealth, deception, and exploiting weaknesses.",
    "base_stat_modifiers": {"dexterity": 2, "luck": 1, "strength": -1, "wisdom": -1},
    "starting_health_bonus": -5,
    "starting_mana_bonus": 5,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch", "pick_lock_basic"],
            "2": ["backstab_melee_active"],
            "4": ["hide_in_shadows_utility"]
        },
        "core_traits_by_level": {
            "1": ["nimble_fingers_passive"],
            "3": ["opportunist_passive"],
            "5": ["evasion_expert_passive"]
        }
    },
    "starting_equipment_refs": ["Dagger", "Lockpicks", "Cloth Tunic"],
    "playstyle_tags": ["melee", "stealth", "utility", "debuff", "skill_monkey"],
    "stat_gains_per_level": {
        "hp": 4, 
        "mp": 2, 
        "base_attack_bonus": 0.5 
    }
  },
  {
    "name": "Acolyte",
    "description": "A devout follower of a divine power, wielding faith as both shield and weapon. Acolytes can mend wounds, bolster allies, and smite the unholy.",
    "base_stat_modifiers": {"wisdom": 2, "charisma": 1, "dexterity": -1, "strength": -1},
    "starting_health_bonus": 0,
    "starting_mana_bonus": 10,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["minor_heal_active", "bless_buff_active"],
            "3": ["smite_evil_active"],
            "5": ["turn_undead_active"]
        },
        "core_traits_by_level": {
            "1": ["divine_fortitude_passive"],
            "2": ["healing_touch_improved_passive"],
            "4": ["divine_guidance_passive"]
        }
    },
    "starting_equipment_refs": ["Wooden Mace", "Holy Symbol", "Cloth Robes"],
    "playstyle_tags": ["caster", "healer", "support", "divine", "anti_undead"],
    "stat_gains_per_level": {
        "hp": 3, 
        "mp": 3, 
        "base_attack_bonus": 0.33 
    }
  },
  {
    "name": "Hedge Wizard",
    "description": "A self-taught practitioner of the arcane arts, drawing power from raw talent and forbidden lore. Hedge Wizards command elemental forces and subtle illusions.",
    "base_stat_modifiers": {"intelligence": 2, "wisdom": 1, "constitution": -1, "strength": -1},
    "starting_health_bonus": -5,
    "starting_mana_bonus": 15,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["magic_missile_active", "light_cantrip_utility"],
            "3": ["fireball_small_active"],
            "5": ["invisibility_short_utility"]
        },
        "core_traits_by_level": {
            "1": ["arcane_attunement_passive"],
            "2": ["spell_penetration_minor_passive"],
            "4": ["elemental_focus_fire_passive"]
        }
    },
    "starting_equipment_refs": ["Quarterstaff", "Spellbook (Blank)", "Cloth Robes"],
    "playstyle_tags": ["caster", "arcane", "elemental_dps", "utility_magic", "glass_cannon"],
    "stat_gains_per_level": {
        "hp": 2, 
        "mp": 4, 
        "base_attack_bonus": 0.33
    }
  },
  {
    "name": "Adventurer",
    "description": "A jack-of-all-trades, master of none. Ready for anything, prepared for nothing. The path of the Adventurer is one of versatility and adaptability.",
    "base_stat_modifiers": {}, 
    "starting_health_bonus": 0,
    "starting_mana_bonus": 0,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch"],
            "2": ["first_aid_basic_utility"] 
        },
        "core_traits_by_level": {
            "1": ["jack_of_all_trades_xp_bonus_passive"],
            "3": ["hardy_survivor_passive"]
        }
    },
    "starting_equipment_refs": ["Dagger", "Cloth Tunic", "Basic Healing Draught"],
    "playstyle_tags": ["versatile", "generalist", "beginner_friendly"],
    "stat_gains_per_level": {
        "hp": 4, 
        "mp": 2, 
        "base_attack_bonus": 0.5
    }
  }
]
--- END OF FILE backend/app/seeds/character_classes.json ---

--- START OF FILE frontend/src/main.js ---
// frontend/src/main.js
import { UI } from './ui.js';
import { API } from './api.js';
import { WebSocketService } from './websocket.js';
import { MapDisplay } from './map.js';
import { gameState, saveSession, loadSession, clearSession, updateGameState } from './state.js';

export function handleWebSocketMessage(serverData) {
    let charVitals = null; 

    if (serverData.type === "welcome_package" && serverData.character_vitals) charVitals = serverData.character_vitals;
    else if (serverData.type === "combat_update" && serverData.character_vitals) charVitals = serverData.character_vitals;
    else if (serverData.type === "vitals_update") charVitals = serverData; 

    if (charVitals) {
        UI.updatePlayerVitals(
            charVitals.current_hp, charVitals.max_hp,
            charVitals.current_mp, charVitals.max_mp,
            charVitals.current_xp, charVitals.next_level_xp
        );
        UI.updateCharacterInfoBar(gameState.selectedCharacterName, gameState.selectedCharacterClass, charVitals.level);
        if (charVitals.platinum !== undefined) { 
            UI.updateCurrencyDisplay(charVitals.platinum, charVitals.gold, charVitals.silver, charVitals.copper);
        }
    }

    switch (serverData.type) {
        case "welcome_package":
            if (serverData.log && serverData.log.length > 0) UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            if (serverData.room_data) {
                const currentRoom = serverData.room_data;
                UI.updateGameDisplay(currentRoom);
                UI.updateExitsDisplay(currentRoom);
                updateGameState({ displayedRoomId: currentRoom.id });
                // Pass currentRoom data for immediate title/highlight and to determine target Z
                MapDisplay.fetchAndDrawMap(currentRoom); 
            }
            break;
        case "combat_update": 
            if (serverData.room_data) {
                const currentRoom = serverData.room_data; 
                const movedRoom = gameState.displayedRoomId !== currentRoom.id;
                const zLevelChanged = MapDisplay.currentZLevel !== currentRoom.z;
                
                UI.updateGameDisplay(currentRoom); 
                UI.updateExitsDisplay(currentRoom);
                updateGameState({ displayedRoomId: currentRoom.id });

                if (movedRoom || zLevelChanged || !MapDisplay.mapDataCache[currentRoom.z]) {
                    // console.log(`Map update triggered: moved=${movedRoom}, zChanged=${zLevelChanged}, notCached=${!MapDisplay.mapDataCache[currentRoom.z]}`);
                    MapDisplay.fetchAndDrawMap(currentRoom);
                } else {
                    MapDisplay.redrawMapForCurrentRoom(currentRoom.id, currentRoom);
                }
            }
            if (serverData.log && serverData.log.length > 0) UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            updateGameState({ isInCombat: !serverData.combat_over });
            break;
        case "vitals_update": break;
        case "ooc_message": UI.appendToOutput(serverData.message, { styleClass: "ooc-chat-message" }); break;
        case "game_event": if (serverData.message) UI.appendToOutput(serverData.message, { styleClass: "game-message" }); break;
        default:
            if (serverData.message) UI.appendToOutput(`GS (${serverData.type}): ${serverData.message}`, { styleClass: "game-message" });
            else UI.appendToOutput(`GS (unparsed type: ${serverData.type}): ${JSON.stringify(serverData)}`, { styleClass: "game-message" });
            break;
    }
}

// ... (startLoginProcess, promptForPassword, etc. remain largely unchanged from previous correct version) ...
// Make sure they call UI.showAppropriateView() AFTER updateGameState loginState changes.

async function startLoginProcess() {
    clearSession(); 
    updateGameState({ loginState: 'PROMPT_USER' }); 
    WebSocketService.close();
    MapDisplay.clearMap(); 
    MapDisplay.currentMapDisplayData = null; // Clear current display data
    MapDisplay.currentZLevel = 0; // Reset Z
    MapDisplay.drawMap();  
    UI.showAppropriateView(); 
    UI.clearOutput();
    UI.appendToOutput("Welcome to The Unholy MUD of Tron & Allen1.");
    UI.appendToOutput("Version: Refactored & Ready to Rumble!"); 
    UI.appendToOutput("-------------------------------------------------");
    UI.appendToOutput("Username (or type 'new' to register): ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Enter username or 'new'");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function promptForPassword() {
    updateGameState({ loginState: 'PROMPT_PASSWORD' });
    UI.showAppropriateView(); 
    UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true });
    UI.setInputCommandPlaceholder("Enter password");
    UI.setInputCommandType('password');
    UI.focusCommandInput();
}

async function promptForRegistrationUsername() {
    updateGameState({ loginState: 'REGISTER_PROMPT_USER' });
    UI.showAppropriateView(); 
    UI.appendToOutput("Registering new user.");
    UI.appendToOutput("Desired username: ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Enter desired username");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function promptForRegistrationPassword() {
    updateGameState({ loginState: 'REGISTER_PROMPT_PASSWORD' });
    UI.showAppropriateView(); 
    UI.appendToOutput("Desired password (min 8 chars): ", { isPrompt: true, noNewLineBefore: true });
    UI.setInputCommandPlaceholder("Enter desired password");
    UI.setInputCommandType('password');
    UI.focusCommandInput();
}

async function displayCharacterSelection() {
    updateGameState({ loginState: 'CHAR_SELECT_PROMPT' });
    UI.showAppropriateView(); 
    if (!gameState.currentAuthToken) {
        UI.appendToOutput("! Authentication token missing. Please log in.", { styleClass: 'error-message-inline' });
        handleLogout(); return;
    }
    UI.appendToOutput("\nFetching character list...");
    try {
        const characters = await API.fetchCharacters();
        updateGameState({ availableCharacters: characters });
        UI.appendToOutput("\n--- Character Selection ---");
        if (characters.length === 0) UI.appendToOutput("No characters found for your account.");
        else {
            UI.appendToOutput("Your characters:");
            characters.forEach((char, index) => UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${char.name}</span> (<span class="char-class">${char.class_name}</span> - Lvl ${char.level})</span>`));
        }
        UI.appendToOutput("Enter character # to play, or type 'new' to create one: ", { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter # or 'new'");
    } catch (error) {
        UI.appendToOutput(`! Error fetching characters: ${error.message}`, { styleClass: 'error-message-inline' });
        if (error.response && error.response.status === 401) handleLogout();
        else startLoginProcess(); 
    }
    UI.focusCommandInput();
}

async function promptForNewCharacterName() {
    updateGameState({ loginState: 'CHAR_CREATE_PROMPT_NAME', tempCharName: '' });
    UI.showAppropriateView(); 
    UI.appendToOutput("\n--- New Character Creation ---");
    UI.appendToOutput("Enter character name: ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Character Name (3-50 chars)");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function displayClassSelection() {
    updateGameState({ loginState: 'CHAR_CREATE_PROMPT_CLASS' });
    UI.showAppropriateView(); 
    UI.appendToOutput(`\nFetching available classes for ${gameState.tempCharName}...`);
    try {
        const classes = await API.fetchAvailableClasses();
        updateGameState({ availableClasses: classes });
        if (classes.length === 0) {
            UI.appendToOutput("! No character classes available. Defaulting to 'Adventurer'.", { styleClass: 'error-message-inline' });
            updateGameState({ tempCharClassName: 'Adventurer' });
            await createCharacterWithSelectedClass(); return;
        }
        UI.appendToOutput("Available Classes:");
        classes.forEach((charClass, index) => UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${charClass.name}</span> - <span class="char-class-desc">${charClass.description || 'A mysterious path.'}</span></span>`));
        UI.appendToOutput(`Select class for '${gameState.tempCharName}' by number: `, { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter class #");
    } catch (error) {
        UI.appendToOutput(`! Error fetching classes: ${error.message}. Defaulting to 'Adventurer'.`, { styleClass: 'error-message-inline' });
        updateGameState({ tempCharClassName: 'Adventurer' });
        await createCharacterWithSelectedClass();
    }
    UI.focusCommandInput();
}

async function createCharacterWithSelectedClass() {
    const charName = gameState.tempCharName;
    const charClassName = gameState.tempCharClassName || "Adventurer";
    UI.appendToOutput(`\nCreating ${charName} the ${charClassName}...`);
    try {
        await API.createCharacter(charName, charClassName);
        UI.appendToOutput("Character created successfully!");
        await displayCharacterSelection(); 
    } catch (error) {
        UI.appendToOutput(`! Error creating character: ${error.data?.detail || error.message}`, { styleClass: 'error-message-inline' });
        await displayCharacterSelection(); 
    }
}

async function selectCharacterAndStartGame(character) {
    UI.appendToOutput(`\nSelecting character: ${character.name}...`);
    try {
        const initialRoomData = await API.selectCharacterOnBackend(character.id);
        saveSession(gameState.currentAuthToken, character.id, character.name, character.class_name || 'Adventurer');
        await enterGameModeWithCharacter(character, initialRoomData);
    } catch (error) {
        UI.appendToOutput(`! Error selecting character: ${error.message}`, { styleClass: 'error-message-inline' });
        await displayCharacterSelection();
    }
}

async function enterGameModeWithCharacter(character, initialRoomDataFromHttpSelect) {
    updateGameState({
        selectedCharacterId: character.id,
        selectedCharacterName: character.name,
        selectedCharacterClass: character.class_name || 'Adventurer',
        loginState: 'IN_GAME' 
    });
    UI.showAppropriateView(); 
    
    UI.updateCharacterInfoBar(character.name, character.class_name, character.level); 
    UI.updateCurrencyDisplay(character.platinum_coins || 0, character.gold_coins || 0, character.silver_coins || 0, character.copper_coins || 0); 

    UI.clearOutput();
    UI.appendToOutput(`Playing as: <span class="char-name">${character.name}</span>, the <span class="char-class">${character.class_name || 'Adventurer'}</span> (Lvl ${character.level || 1})`);
    UI.setInputCommandPlaceholder("Type command...");
    UI.setInputCommandType('text');

    // Pass initialRoomData to fetchAndDrawMap. It will use its Z to fetch if not cached.
    MapDisplay.fetchAndDrawMap(initialRoomDataFromHttpSelect); 
    
    WebSocketService.connect(); 
    UI.focusCommandInput();
}

function handleLogout() {
    WebSocketService.close();
    MapDisplay.clearMap();
    MapDisplay.currentMapDisplayData = null; // Also clear this on logout
    MapDisplay.currentZLevel = 0;
    clearSession(); 
    startLoginProcess(); 
}

async function handleHttpCommandResponse(responseData, originalCommand) {
    if (responseData.message_to_player) UI.appendToOutput(responseData.message_to_player, { styleClass: 'game-message' });
    if (responseData.room_data) {
        const currentRoom = responseData.room_data; 
        const cmdClean = originalCommand.toLowerCase().trim();
        const isLook = cmdClean.startsWith("look") || cmdClean === "l"; 
        const movedRoom = gameState.displayedRoomId !== currentRoom.id;
        const zLevelChanged = MapDisplay.currentZLevel !== currentRoom.z;

        if (isLook || movedRoom) UI.updateGameDisplay(currentRoom);
        UI.updateExitsDisplay(currentRoom);
        updateGameState({ displayedRoomId: currentRoom.id });
        
        if (movedRoom || zLevelChanged || !MapDisplay.mapDataCache[currentRoom.z]) {
            MapDisplay.fetchAndDrawMap(currentRoom); 
        } else {
            MapDisplay.redrawMapForCurrentRoom(currentRoom.id, currentRoom);
        }
    }
}

async function handleInputSubmission() {
    const commandInputEl = UI.getCommandInput();
    if (!commandInputEl) return;
    const inputText = commandInputEl.value.trim();
    let echoText = inputText;
    let echoOptions = { isPrompt: false };

    if (gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
        echoText = '*'.repeat(inputText.length || 8);
        echoOptions.noNewLineBefore = true;
    } else if (gameState.loginState === 'IN_GAME' && inputText) {
        echoText = `> ${inputText}`;
    } else if (inputText) { 
        echoOptions.noNewLineBefore = true; 
    }

    if (inputText || gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
        UI.appendToOutput(echoText, echoOptions);
    }
    commandInputEl.value = '';

    try {
        switch (gameState.loginState) {
            case 'PROMPT_USER':
                if (inputText.toLowerCase() === 'new') await promptForRegistrationUsername();
                else if (inputText) { updateGameState({ tempUsername: inputText }); await promptForPassword(); }
                else { UI.appendToOutput("Username (or 'new'): ", { isPrompt: true, noNewLineBefore: true }); UI.focusCommandInput(); } 
                break;
            case 'PROMPT_PASSWORD':
                UI.appendToOutput("\nAttempting login...");
                const loginData = await API.loginUser(gameState.tempUsername, inputText);
                saveSession(loginData.access_token, null, null, null); 
                UI.appendToOutput("Login successful!");
                UI.setInputCommandType('text');
                await displayCharacterSelection();
                break;
            case 'REGISTER_PROMPT_USER':
                if (inputText) { updateGameState({ tempUsername: inputText }); await promptForRegistrationPassword(); }
                else { UI.appendToOutput("Desired username: ", { isPrompt: true, noNewLineBefore: true }); UI.focusCommandInput(); }
                break;
            case 'REGISTER_PROMPT_PASSWORD':
                updateGameState({ tempPassword: inputText });
                UI.appendToOutput("\nAttempting registration...");
                await API.registerUser(gameState.tempUsername, gameState.tempPassword);
                UI.appendToOutput("Registration successful!");
                UI.appendToOutput(`Now, please log in as '${gameState.tempUsername}'.`);
                updateGameState({ loginState: 'PROMPT_PASSWORD' }); 
                UI.showAppropriateView(); 
                UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true });
                UI.setInputCommandPlaceholder("Enter password");
                UI.setInputCommandType('password');
                UI.focusCommandInput(); 
                break;
            case 'CHAR_SELECT_PROMPT':
                if (inputText.toLowerCase() === 'new') await promptForNewCharacterName();
                else {
                    const charIndex = parseInt(inputText, 10) - 1;
                    if (gameState.availableCharacters && charIndex >= 0 && charIndex < gameState.availableCharacters.length) {
                        await selectCharacterAndStartGame(gameState.availableCharacters[charIndex]);
                    } else {
                        UI.appendToOutput("! Invalid selection.", { styleClass: 'error-message-inline' });
                        UI.appendToOutput("Enter character #, or 'new': ", { isPrompt: true, noNewLineBefore: true });
                        UI.focusCommandInput();
                    }
                }
                break;
            case 'CHAR_CREATE_PROMPT_NAME':
                if (!inputText || inputText.length < 3 || inputText.length > 50) {
                    UI.appendToOutput("! Invalid name (3-50 chars). Name: ", { isPrompt: true, styleClass: 'error-message-inline', noNewLineBefore: true });
                    UI.focusCommandInput(); break;
                }
                updateGameState({ tempCharName: inputText });
                await displayClassSelection();
                break;
            case 'CHAR_CREATE_PROMPT_CLASS':
                const classIndex = parseInt(inputText, 10) - 1;
                if (gameState.availableClasses && classIndex >= 0 && classIndex < gameState.availableClasses.length) {
                    const selectedClass = gameState.availableClasses[classIndex];
                    updateGameState({ tempCharClassName: selectedClass.name });
                    await createCharacterWithSelectedClass();
                } else {
                    UI.appendToOutput("! Invalid class selection. Please enter a valid number.", { styleClass: 'error-message-inline' });
                    UI.appendToOutput(`Select class for ${gameState.tempCharName} by number: `, { isPrompt: true, noNewLineBefore: true });
                    UI.focusCommandInput();
                }
                break;
            case 'IN_GAME':
                if (!inputText) { UI.focusCommandInput(); break; } 
                const lowerInputText = inputText.toLowerCase();
                const commandVerb = lowerInputText.split(" ")[0];

                if (commandVerb === "logout") { handleLogout(); break; }

                const webSocketHandledVerbs = ["attack","atk","kill","k","flee","look","l","rest","use","skill","cast","get","take","unlock","search","examine","pull","push","turn","pry","activate","n","s","e","w","north","south","east","west","up","down","u","d","go"];
                if (webSocketHandledVerbs.includes(commandVerb)) {
                    WebSocketService.sendMessage({ type: "command", command_text: inputText });
                } else {
                    const httpOkayVerbs = ["spawnmob","mod_xp","set_hp","help","ooc","say","score","inventory","i","skills","traits","status","st","sc","sk","tr","?","equip","unequip","wear","remove","eq"];
                    if (httpOkayVerbs.includes(commandVerb)) {
                        const httpResponse = await API.sendHttpCommand(inputText);
                        handleHttpCommandResponse(httpResponse, inputText);
                    } else {
                        UI.appendToOutput(`Unrecognized command: '${inputText}'. Try 'help'.`);
                    }
                }
                break;
            default:
                UI.appendToOutput("! System error: Unknown login state.", { styleClass: 'error-message-inline' });
                startLoginProcess();
        }
    } catch (error) {
        console.error("Error during input submission:", error);
        UI.appendToOutput(`\n! Error: ${error.data?.detail || error.message || 'An unknown error occurred.'}`, { styleClass: 'error-message-inline' });
        if (gameState.loginState === 'PROMPT_PASSWORD') await promptForPassword();
        else if (gameState.loginState.includes('CHAR_')) await displayCharacterSelection();
        else if (gameState.loginState.includes('REGISTER_')) await promptForRegistrationUsername();
    }
}

async function attemptSessionResume() {
    if (loadSession() && gameState.currentAuthToken && gameState.selectedCharacterId) {
        UI.clearOutput(); 
        UI.appendToOutput("Attempting to resume session...");
        try {
            // For resume, we don't call selectCharacterOnBackend as the session token implies selection.
            // We directly construct a partial character and enter game mode.
            // enterGameModeWithCharacter will then call MapDisplay.fetchAndDrawMap(null)
            // and the WebSocket welcome_package will provide the definitive current room.
            UI.appendToOutput(`Resumed session as ${gameState.selectedCharacterName}.`);
            const resumedCharacter = { 
                id: gameState.selectedCharacterId,
                name: gameState.selectedCharacterName,
                class_name: gameState.selectedCharacterClass,
                level: 1, 
                platinum_coins: 0, gold_coins: 0, silver_coins: 0, copper_coins: 0 
            };
            await enterGameModeWithCharacter(resumedCharacter, null); // Pass null for initialRoomData
            return true;
        } catch (error) { // This catch might not be hit if error is in async enterGameMode calls
            UI.appendToOutput(`! Session resume failed: ${error.data?.detail || error.message}. Please log in.`, { styleClass: 'error-message-inline' });
            clearSession(); 
        }
    }
    return false;
}

document.addEventListener('DOMContentLoaded', async () => {
    if (!UI.initializeElements()) return; 
    MapDisplay.initialize();

    const commandInputEl = UI.getCommandInput();
    if (commandInputEl) {
        commandInputEl.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleInputSubmission();
            }
        });
    } else {
        console.error("Command input not found during DOMContentLoaded setup. Input will not work.");
    }

    if (!(await attemptSessionResume())) {
        startLoginProcess();
    }
});
--- END OF FILE frontend/src/main.js ---

--- START OF FILE frontend/src/ui.js ---
// frontend/src/ui.js
import { gameState } from './state.js';

export const UI = {
    // Existing elements
    outputElement: null,
    commandInputElement: null,
    promptTextElement: null,
    characterNameElement: null,
    characterClassElement: null,
    characterLevelElement: null,
    exitsTextElement: null,
    playerHpBar: null,
    playerHpText: null,
    playerMpBar: null,
    playerMpText: null,
    playerXpBar: null,
    playerXpText: null,
    currencyPlatinumElement: null,
    currencyGoldElement: null,
    currencySilverElement: null,
    currencyCopperElement: null,
    copyOutputButton: null,

    // Map related UI elements
    mapTitleBarElement: null,
    mapTitleTextElement: null,
    mapCoordsTextElement: null,
    mapZLevelValueElement: null,    // NEW for Z-level display
    mapZoneNameTextElement: null,   // NEW for Zone Name
    mapZoneLevelsTextElement: null, // NEW for Zone Levels

    // View state control
    gameViewElements: [],
    inputPromptLineElement: null,

    initializeElements: function () {
        this.outputElement = document.getElementById('output');
        this.commandInputElement = document.getElementById('commandInput');
        this.promptTextElement = document.getElementById('prompt-text');
        this.inputPromptLineElement = document.getElementById('input-prompt-line');

        this.characterNameElement = document.getElementById('char-info-name');
        this.characterClassElement = document.getElementById('char-info-class');
        this.characterLevelElement = document.getElementById('char-info-level');

        this.exitsTextElement = document.getElementById('exits-text');

        this.playerHpBar = document.getElementById('player-hp-bar');
        this.playerHpText = document.getElementById('player-hp-text');
        this.playerMpBar = document.getElementById('player-mp-bar');
        this.playerMpText = document.getElementById('player-mp-text');
        this.playerXpBar = document.getElementById('player-xp-bar');
        this.playerXpText = document.getElementById('player-xp-text');

        this.currencyPlatinumElement = document.querySelector('#currency-display-container .currency.platinum');
        this.currencyGoldElement = document.querySelector('#currency-display-container .currency.gold');
        this.currencySilverElement = document.querySelector('#currency-display-container .currency.silver');
        this.currencyCopperElement = document.querySelector('#currency-display-container .currency.copper');

        this.copyOutputButton = document.getElementById('copy-output-button');
        if (this.copyOutputButton) {
            this.copyOutputButton.addEventListener('click', () => this.copyOutputToClipboard());
        }

        this.mapTitleBarElement = document.getElementById('map-title-bar');
        this.mapTitleTextElement = document.getElementById('map-title-text');
        this.mapCoordsTextElement = document.getElementById('map-coords-text');

        // NEW elements for Z-level and Zone
        this.mapZLevelValueElement = document.getElementById('map-z-level-value');
        this.mapZoneNameTextElement = document.getElementById('map-zone-name-text');
        this.mapZoneLevelsTextElement = document.getElementById('map-zone-levels-text');


        this.gameViewElements = [
            document.getElementById('character-info-bar'),
            document.getElementById('bottom-info-bar'),
            document.getElementById('vitals-monitor'),
            document.getElementById('map-column'),
        ];

        if (!this.outputElement || !this.commandInputElement || !this.characterNameElement ||
            !this.mapTitleBarElement || !this.inputPromptLineElement || !this.mapZLevelValueElement ||
            !this.mapZoneNameTextElement || !this.mapZoneLevelsTextElement) { // Added new elements to check
            console.error("Fatal Error: Essential UI elements not found. The application cannot start.");
            document.body.innerHTML = "Error: UI elements missing. Please check console.";
            return false;
        }
        return true;
    },

    showAppropriateView: function () {
        const isGameActive = gameState.loginState === 'IN_GAME';
        this.gameViewElements.forEach(el => {
            if (el) {
                let currentDisplay = 'block';
                if (el.id === 'vitals-monitor' || el.id === 'bottom-info-bar' || el.id === 'character-info-bar' || el.id === 'map-column') {
                    currentDisplay = 'flex';
                }
                el.style.display = isGameActive ? currentDisplay : 'none';
            }
        });

        if (this.inputPromptLineElement) {
            const showInputPromptLine = gameState.loginState === 'IN_GAME' ||
                gameState.loginState === 'CHAR_SELECT_PROMPT' ||
                gameState.loginState === 'CHAR_CREATE_PROMPT_NAME' ||
                gameState.loginState === 'CHAR_CREATE_PROMPT_CLASS' ||
                gameState.loginState === 'PROMPT_USER' ||
                gameState.loginState === 'PROMPT_PASSWORD' ||
                gameState.loginState === 'REGISTER_PROMPT_USER' ||
                gameState.loginState === 'REGISTER_PROMPT_PASSWORD';
            this.inputPromptLineElement.style.display = showInputPromptLine ? 'flex' : 'none';
        }
    },

    clearOutput: function () { /* Unchanged */ if (this.outputElement) this.outputElement.innerHTML = ''; },
    appendToOutput: function (message, options = {}) { /* Unchanged */
        if (!this.outputElement) return; const { styleClass = '' } = options;
        const lineElement = document.createElement('div');
        if (styleClass) lineElement.classList.add(styleClass);
        lineElement.innerHTML = message;
        this.outputElement.insertBefore(lineElement, this.outputElement.firstChild);
        this.outputElement.scrollTop = 0;
    },
    updateCharacterInfoBar: function (name, className, level) { /* Unchanged */
        if (this.characterNameElement) this.characterNameElement.textContent = name || 'Unknown';
        if (this.characterClassElement) this.characterClassElement.textContent = className || 'Adventurer';
        if (this.characterLevelElement) this.characterLevelElement.textContent = (level !== undefined && level !== null) ? String(level) : '1';
    },

    updateMapTitleBar: function (x, y, z) { // Removed zoneName from here, handled by updateMapZoneBar
        if (this.mapCoordsTextElement) {
            if (x !== undefined && y !== undefined && z !== undefined) {
                this.mapCoordsTextElement.textContent = `${x}, ${y}, ${z}`;
            } else if (z !== undefined) {
                this.mapCoordsTextElement.textContent = `?, ?, ${z}`;
            } else {
                this.mapCoordsTextElement.textContent = "?, ?, ?";
            }
        }
        // Update Z-Level display box separately
        if (this.mapZLevelValueElement) {
            this.mapZLevelValueElement.textContent = (z !== undefined && z !== null) ? String(z) : "-";
        }
    },

    // NEW function for Zone Bar
    updateMapZoneBar: function (zoneName, zoneLevels) {
        if (this.mapZoneNameTextElement) {
            this.mapZoneNameTextElement.textContent = zoneName || "[Unknown Zone]";
        }
        if (this.mapZoneLevelsTextElement) {
            this.mapZoneLevelsTextElement.textContent = zoneLevels || "[Lvl ?-?]";
        }
    },

    updatePlayerVitals: function (currentHp, maxHp, currentMp, maxMp, currentXp, nextLevelXp) { /* Unchanged */
        if (this.playerHpBar && this.playerHpText) {
            const hpPercent = maxHp > 0 ? (currentHp / maxHp) * 100 : 0;
            this.playerHpBar.style.width = `${Math.max(0, Math.min(100, hpPercent))}%`;
            this.playerHpText.textContent = `${currentHp} / ${maxHp}`;
        }
        if (this.playerMpBar && this.playerMpText) {
            const mpPercent = maxMp > 0 ? (currentMp / maxMp) * 100 : 0;
            this.playerMpBar.style.width = `${Math.max(0, Math.min(100, mpPercent))}%`;
            this.playerMpText.textContent = `${currentMp} / ${maxMp}`;
        }
        if (this.playerXpBar && this.playerXpText) {
            const xpPercent = nextLevelXp > 0 && nextLevelXp !== -1 ? (currentXp / nextLevelXp) * 100 : (nextLevelXp === -1 ? 100 : 0);
            const displayNextLevelXp = (nextLevelXp === -1) ? "MAX" : nextLevelXp;
            this.playerXpBar.style.width = `${Math.max(0, Math.min(100, xpPercent))}%`;
            this.playerXpText.textContent = `${currentXp} / ${displayNextLevelXp}`;
        }
    },
    updateExitsDisplay: function (roomData) { /* Unchanged */
        if (this.exitsTextElement && roomData && roomData.exits) {
            const exitNames = Object.keys(roomData.exits).map(dir => dir.toUpperCase());
            this.exitsTextElement.textContent = exitNames.length > 0 ? exitNames.join(' | ') : 'None';
        } else if (this.exitsTextElement) { this.exitsTextElement.textContent = 'Unknown'; }
    },
    updateCurrencyDisplay: function (platinum, gold, silver, copper) { /* Unchanged */
        if (this.currencyPlatinumElement) this.currencyPlatinumElement.textContent = `${platinum || 0}p`;
        if (this.currencyGoldElement) this.currencyGoldElement.textContent = `${gold || 0}g`;
        if (this.currencySilverElement) this.currencySilverElement.textContent = `${silver || 0}s`;
        if (this.currencyCopperElement) this.currencyCopperElement.textContent = `${copper || 0}c`;
    },
    updateGameDisplay: function (roomData) { /* Unchanged */
        if (!roomData) return; let lines = [];
        lines.push(`<span class="room-name-header">--- ${roomData.name || 'Unknown Room'} ---</span>`);
        lines.push(roomData.description || 'An empty space.');
        if (roomData.dynamic_description_additions?.length > 0) roomData.dynamic_description_additions.forEach(line => lines.push(line));
        if (roomData.items_on_ground?.length > 0) {
            lines.push("You see here:");
            roomData.items_on_ground.forEach(item => lines.push(`  <span class="inv-item-name">${item.item_template.name}</span>${item.quantity > 1 ? ' (x' + item.quantity + ')' : ''}`));
        }
        if (roomData.mobs_in_room?.length > 0) {
            lines.push("Also here:");
            roomData.mobs_in_room.forEach((mob, index) => lines.push(`  ${index + 1}. <span class="inv-item-name">${mob.mob_template.name}</span>`));
        }
        if (roomData.other_characters?.length > 0) {
            lines.push("Others here:");
            roomData.other_characters.forEach(char => lines.push(`  <span class="char-name">${char.name}</span>`));
        }
        this.appendToOutput(lines.join('\n'), { styleClass: "game-message" });
    },
    getCommandInput: function () { return this.commandInputElement; },
    setInputCommandPlaceholder: function (text) { if (this.commandInputElement) this.commandInputElement.placeholder = text; },
    setInputCommandType: function (type) { if (this.commandInputElement) this.commandInputElement.type = type; },
    focusCommandInput: function () { if (this.commandInputElement) this.commandInputElement.focus(); },
    copyOutputToClipboard: function () { /* Unchanged */
        if (!this.outputElement) return; const textToCopy = this.outputElement.innerText || this.outputElement.textContent;
        navigator.clipboard.writeText(textToCopy)
            .then(() => this.appendToOutput("Log copied to clipboard.", { styleClass: "system-message-inline" }))
            .catch(err => { console.error('Failed to copy output: ', err); this.appendToOutput("! Failed to copy log.", { styleClass: "error-message-inline" }); });
    }
};
--- END OF FILE frontend/src/ui.js ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
