--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Wed Jun 11 03:47:26 AM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_npc.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/npc_dialogue_ticker.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/npc_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/abilities.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/npc.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/character_classes.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/loot_tables.json
backend/app/seeds/mob_spawn_definitions.json
backend/app/seeds/mob_templates.json
backend/app/seeds/npcs.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_admin_parser.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
backend/app/ws_command_parsers/ws_shop_parser.py
bundle_context.sh
frontend/src/components/AbilityList.css
frontend/src/components/BottomInfoBar.css
frontend/src/components/CharacterCreationScreen.css
frontend/src/components/CharacterInfoBar.css
frontend/src/components/CharacterSelectionScreen.css
frontend/src/components/GroundItems.css
frontend/src/components/Inventory.css
frontend/src/components/ItemName.css
frontend/src/components/LoginScreen.css
frontend/src/components/LookResult.css
frontend/src/components/Map.css
frontend/src/components/Modal.css
frontend/src/components/ScoreSheet.css
frontend/src/components/TabBar.css
frontend/src/components/TabbedWindow.css
frontend/src/components/Terminal.css
frontend/src/components/VitalsMonitor.css
frontend/src/index.css
frontend/src/index.html
frontend/src/services/apiService.js
frontend/src/services/webSocketService.js
frontend/src/state/gameStore.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed." >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh"
    "README.md"

    # --- Backend - Core Command & Control Logic (THE CRIME SCENE) ---
    "backend/app/websocket_router.py"
    "backend/app/api/v1/endpoints/command.py"
    "backend/app/commands/command_args.py"
    "backend/app/schemas/command.py"
    "backend/app/websocket_manager.py"
    
    # --- Backend - Example Parsers (THE WITNESSES) ---
    "backend/app/commands/movement_parser.py"
    "backend/app/commands/social_parser.py"
    "backend/app/commands/inventory_parser.py"

    # --- Backend - Foundational Models & Schemas ---
    "backend/app/models/character.py"
    "backend/app/models/room.py"
    "backend/app/schemas/character.py"
    "backend/app/schemas/room.py"

    # --- Backend - The Future: Skills & Traits Schemas ---
    "backend/app/schemas/skill.py"
    "backend/app/schemas/trait.py"
    "backend/app/crud/crud_skill.py"
    "backend/app/crud/crud_trait.py"

    # --- Backend - Key Seed Data ---
    "backend/app/seeds/skills.json"
    "backend/app/seeds/traits.json"
    "backend/app/seeds/character_classes.json"

    # --- Frontend - The User's Point of Interaction ---
    "frontend/src/state/gameStore.js"
    "frontend/src/services/webSocketService.js"
    "frontend/src/components/CommandInput.jsx"
    "frontend/src/components/TerminalOutput.jsx"
    "frontend/src/components/GameLayout.jsx"
    "frontend/src/components/TabbedWindow.jsx"
    
    # --- Frontend - The Future: New UI Components (Placeholders) ---
    "frontend/src/components/SkillsList.jsx"
    "frontend/src/components/TraitsList.jsx"
    "frontend/src/components/ChatWindow.jsx"
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (✨💰💪🧩💀🚪) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Flesh out the damn world - Gear, Loot, and More Seeds!

The map is less of an abstract nightmare, and the core gameplay loop is... loopy. Now we need to make the interactions richer and the world feel less empty.

*   **Full Equipment System:** Define all equipment slots. Implement robust `equip` and `unequip` logic. Ensure stats update correctly.
*   **Mob Loot Tables:** Mobs need to drop more than just coins. Define loot tables (specific items, random items from categories, chances).
*   **Seed More Content (Externalize ALL THE THINGS):**
    *   `mob_templates.json`
    *   `character_classes.json`
    *   `skills.json`
    *   `traits.json`
    *   `mob_spawn_definitions.json`
    *   Update corresponding CRUD seeders to load from these JSONs.
*   **Seed Initial Equipment:** Place starting gear on character creation or in initial rooms.

This will involve a lot of backend work (models, CRUD, game logic) and careful JSON schema design for the seed files.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple, Union
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

from app.core.config import settings
from app.db.session import SessionLocal
from app import crud, models, schemas
from app.websocket_manager import connection_manager
from app.game_logic import combat

from app.commands.utils import (
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message,
    format_room_npcs_for_player_message
)
from app.game_state import is_character_resting, set_character_resting_status
from app.ws_command_parsers.ws_info_parser import handle_ws_brief

# Import all our glorious command parsers
from app.ws_command_parsers import (
    handle_ws_movement, handle_ws_flee,
    handle_ws_attack, handle_ws_use_combat_skill,
    handle_ws_get_take, handle_ws_unlock, handle_ws_search_examine,
    handle_ws_contextual_interactable, handle_ws_use_ooc_skill,
    handle_ws_look, handle_ws_rest,
    handle_ws_list, handle_ws_buy, handle_ws_sell, ws_shop_parser,
    # --- OUR NEWLY ANOINTED HANDLERS ---
    handle_ws_equip, handle_ws_unequip,
    # Need this for the inventory push
    _send_inventory_update_to_player
)
# --- AND OUR HOLY ADMIN PARSER ---
from app.ws_command_parsers import ws_admin_parser

logger = logging.getLogger(__name__)

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token:
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str:
            return None
        player_uuid = uuid.UUID(player_id_str)
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError):
        return None

@router.websocket("/ws")
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character_orm: Optional[models.Character] = None

    with get_db_sync() as db_conn_init:
        player = await get_player_from_token(token, db_conn_init)
        if not player:
            logger.warning(f"WS Connect: Invalid token provided.")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return

        fetched_char = crud.crud_character.get_character(db_conn_init, character_id=character_id)
        if not fetched_char or fetched_char.player_id != player.id:
            logger.warning(f"WS Connect: Invalid char_id: {character_id} for player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character_orm = fetched_char

    await connection_manager.connect(websocket, player.id, character_orm.id)
    logger.info(f"Player {player.username} ({player.id}) | Character {character_orm.name} ({character_orm.id}) connected via WebSocket.")

    # --- Welcome Package (largely unchanged) ---
    initial_messages = [f"Welcome {character_orm.name}! You are connected via WebSocket."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db_welcome:
        initial_room_orm = crud.crud_room.get_room_by_id(db_welcome, room_id=character_orm.current_room_id)
        if initial_room_orm:
            # ... a bunch of formatting for the welcome message ...
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            # ... etc ...
    
    xp_for_next_level = crud.crud_character.get_xp_for_level(character_orm.level + 1)
    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump(exclude_none=True) if initial_room_schema else None,
        "character_vitals": {
            "current_hp": character_orm.current_health, "max_hp": character_orm.max_health,
            "current_mp": character_orm.current_mana, "max_mp": character_orm.max_mana,
            "current_xp": character_orm.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character_orm.level,
            "platinum": character_orm.platinum_coins, "gold": character_orm.gold_coins,
            "silver": character_orm.silver_coins, "copper": character_orm.copper_coins
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)
    # --- End Welcome Package ---

    try:
        while True:
            received_data = await websocket.receive_json()
            command_text = received_data.get("command_text", "").strip()

            with get_db_sync() as db_loop:
                # --- THIS IS THE MOST IMPORTANT PART OF THE REFACTOR ---
                # Get FRESH state for player and character at the START of every command loop.
                fresh_player = crud.crud_player.get_player(db_loop, player_id=player.id)
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character_orm.id)

                if not current_char_state or not fresh_player:
                    logger.error(f"WS Loop: State lost for char_id: {character_orm.id} or player_id: {player.id}.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character or Player state lost in loop")
                    break
                
                # Our divine key.
                is_sysop = fresh_player.is_sysop

                current_room_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                if not current_room_orm:
                    logger.error(f"WS Loop: Character {current_char_state.name} in invalid room {current_char_state.current_room_id}.")
                    await combat.send_combat_log(fresh_player.id, ["Error: Your current location is unstable."])
                    continue
                
                current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)
                verb = command_text.split(" ", 1)[0].lower() if command_text else ""
                args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""

                # --- Rest check (unchanged) ---
                if verb and verb not in ["rest", "look", "l"] and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat.send_combat_log(fresh_player.id, ["You stop resting."], room_data=current_room_schema)

                if received_data.get("type") == "command" and command_text:
                    logger.debug(f"WS Router: User '{fresh_player.username}' (is_sysop={is_sysop}) sent verb='{verb}' for char '{current_char_state.name}'")

                    # --- COMMAND DISPATCHING (RE-ORDERED AND REFACTORED) ---
                    # Sysop commands are checked FIRST.
                    if verb in ["giveme", "setgod"]:
                        if is_sysop:
                            if verb == "giveme":
                                await ws_admin_parser.handle_ws_giveme(db_loop, fresh_player, current_char_state, args_str)
                            elif verb == "setgod":
                                await ws_admin_parser.handle_ws_set_god(db_loop, fresh_player, current_char_state, args_str)
                        else:
                            await combat.send_combat_log(fresh_player.id, ["A strange force prevents you from using that command."])
                    
                    # New player commands
                    elif verb in ["equip", "eq"]:
                        await handle_ws_equip(db_loop, fresh_player, current_char_state, args_str)
                    elif verb in ["unequip", "uneq"]:
                        await handle_ws_unequip(db_loop, fresh_player, current_char_state, args_str)

                    # Existing command handlers (now using fresh_player and current_char_state)
                    elif verb == "rest":
                        await handle_ws_rest(db_loop, fresh_player, current_char_state, current_room_orm)
                    elif verb in ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]:
                        await handle_ws_movement(db_loop, fresh_player, current_char_state, current_room_schema, verb, args_str)
                    elif verb == "flee":
                        await handle_ws_flee(db_loop, fresh_player, current_char_state, current_room_schema, args_str)
                    elif verb in ["attack", "atk", "kill", "k"]:
                        await handle_ws_attack(db_loop, fresh_player, current_char_state, current_room_orm, args_str)
                    elif verb == "use":
                        # This complex parsing logic remains, but we use the fresh objects
                        await handle_ws_use_combat_skill(db_loop, fresh_player, current_char_state, current_room_schema, args_str) # Example, assuming use logic is complex
                    elif verb in ["get", "take"]:
                        await handle_ws_get_take(db_loop, fresh_player, current_char_state, current_room_orm, args_str)
                    elif verb == "look" or verb == "l":
                        await handle_ws_look(db_loop, fresh_player, current_char_state, current_room_orm, args_str)
                    elif verb == "brief":
                        await handle_ws_brief(db_loop, fresh_player, current_char_state)
                    elif verb == "list":
                        await ws_shop_parser.handle_ws_list(db_loop, fresh_player, current_char_state, current_room_orm)
                    elif verb == "buy":
                        await ws_shop_parser.handle_ws_buy(db_loop, fresh_player, current_char_state, current_room_orm, args_str)
                    elif verb == "sell": # <<< THIS IS THE NEW UNIFIED BLOCK
                        await ws_shop_parser.handle_ws_sell(db_loop, fresh_player, current_char_state, current_room_orm, args_str)
                    # ... other commands like unlock, search, shop commands would follow the same pattern ...
                    
                    else:
                        await combat.send_combat_log(fresh_player.id, [f"Unrecognized command: '{verb}'."], room_data=current_room_schema)

                # --- TRANSACTION AND POST-ACTION PUSHES ---
                try:
                    db_loop.commit()
                    logger.debug(f"WS Router: DB commit successful for command '{command_text}' by {current_char_state.name}")

                    # After a successful commit, if the command could have changed inventory, push an update.
                    inventory_modifying_verbs = ["giveme", "equip", "eq", "unequip", "uneq", "get", "take", "buy", "sell"]
                    if any(v in verb for v in inventory_modifying_verbs):
                       # We need the absolute latest state after the commit
                       refreshed_char_for_push = crud.crud_character.get_character(db_loop, character_id=current_char_state.id)
                       if refreshed_char_for_push:
                           await _send_inventory_update_to_player(db_loop, refreshed_char_for_push)
                       
                except Exception as e_commit:
                    db_loop.rollback()
                    logger.error(f"WS Router: DB commit failed for command '{command_text}': {e_commit}", exc_info=True)
                    await combat.send_combat_log(fresh_player.id, ["A glitch in the matrix occurred. Your last action may not have saved."])

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'}")
        if character_orm:
            combat.end_combat_for_character(character_orm.id, reason="websocket_disconnect")
            if is_character_resting(character_orm.id):
                set_character_resting_status(character_orm.id, False)
    except Exception as e:
        logger.error(f"Critical Error in WebSocket handler: {e}", exc_info=True)
    finally:
        if player and player.id:
            connection_manager.disconnect(player.id)
        logger.info(f"WebSocket connection for Player {player.id if player else 'N/A'} fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/api/v1/endpoints/command.py ---
# backend/app/api/v1/endpoints/command.py
from fastapi import APIRouter, Depends, Body
from sqlalchemy.orm import Session
from typing import Dict, Callable, Awaitable # For typing the registry

from app import schemas, models, crud # app.
from app.db.session import get_db
from app.api.dependencies import get_current_active_character # app.api.dependencies
from app.commands.command_args import CommandContext # app.commands.command_args

# Import handler modules
from app.commands import movement_parser
from app.commands import inventory_parser
from app.commands import social_parser
from app.commands import debug_parser
from app.commands import meta_parser
# from app.commands import combat_parser 
from app.commands import interaction_parser

import logging
logger = logging.getLogger(__name__)


router = APIRouter()

# Define the type for our handler functions
CommandHandler = Callable[[CommandContext], Awaitable[schemas.CommandResponse]] # If handlers are async
# Or if synchronous: CommandHandler = Callable[[CommandContext], schemas.CommandResponse]
# Let's assume handlers can be async for future flexibility, even if current ones are not.

COMMAND_REGISTRY: Dict[str, CommandHandler] = {
    # Movement and Perception
    "look": movement_parser.handle_look,
    "l": movement_parser.handle_look,
    "north": movement_parser.handle_move,
    "n": movement_parser.handle_move,
    "south": movement_parser.handle_move,
    "s": movement_parser.handle_move,
    "east": movement_parser.handle_move,
    "e": movement_parser.handle_move,   
    "west": movement_parser.handle_move,
    "w": movement_parser.handle_move,
    "up": movement_parser.handle_move,
    "u": movement_parser.handle_move,
    "down": movement_parser.handle_move,
    "d": movement_parser.handle_move,
    "go": movement_parser.handle_move, # "go north" will be handled by move knowing original command

    # Inventory Management
    "inventory": inventory_parser.handle_inventory,
    "i": inventory_parser.handle_inventory,
    "equip": inventory_parser.handle_equip,
    "eq": inventory_parser.handle_equip,
    "unequip": inventory_parser.handle_unequip,
    "uneq": inventory_parser.handle_unequip,
    "drop": inventory_parser.handle_drop,
    "get": inventory_parser.handle_get,
    "take": inventory_parser.handle_get,

    # Combat >>> moved to websockets
    # "attack": combat_parser.handle_attack, 
    # "atk": combat_parser.handle_attack,    
    # "kill": combat_parser.handle_attack,    

    # interactions
    "unlock": interaction_parser.handle_unlock,
    "search": interaction_parser.handle_search,    
    "examine": interaction_parser.handle_search,
    "ex": interaction_parser.handle_search, # Alias for examine
    "exa": interaction_parser.handle_search,

    # Social
    "fart": social_parser.handle_fart,

    # Debug
    "giveme": debug_parser.handle_giveme,
    "spawnmob": debug_parser.handle_spawnmob,
    "set_hp": debug_parser.handle_set_hp,       # <<< NEW
    "mod_xp": debug_parser.handle_mod_xp,       # <<< NEW
    "set_level": debug_parser.handle_set_level, # <<< NEW
    "setmoney": debug_parser.handle_set_money,     # <<< NEW
    "addmoney": debug_parser.handle_add_money, 

    # Meta
    "score": meta_parser.handle_score, # <<< ADDED
    "sc": meta_parser.handle_score, # <<< ADDED
    "skills": meta_parser.handle_skills,     # <<< NEW
    "sk": meta_parser.handle_skills,     # <<< NEW
    "traits": meta_parser.handle_traits,     # <<< NEW
    "tr": meta_parser.handle_traits,     # <<< NEW
    "status": meta_parser.handle_score, # Alias for score
    "st": meta_parser.handle_score, # Alias for score
    "help": meta_parser.handle_help,
    "?": meta_parser.handle_help,

    # Social
    "say": social_parser.handle_say,
    "'": social_parser.handle_say, # Common alias for say
    "emote": social_parser.handle_emote,
    ":": social_parser.handle_emote, # Common alias for emote
    "ooc": social_parser.handle_ooc,
    "fart": social_parser.handle_fart,
}

@router.post("", response_model=schemas.CommandResponse)
async def process_command_for_character(
    payload: schemas.CommandRequest = Body(...),
    db: Session = Depends(get_db),
    active_character: models.Character = Depends(get_current_active_character)
):
    original_command_text = payload.command.strip()
    if not original_command_text:
        return schemas.CommandResponse(message_to_player="Please type a command.")

    command_parts = original_command_text.split()
    command_verb = command_parts[0].lower()
    args = command_parts[1:]
    # target_of_verb = " ".join(args) # Potential target string

    current_room_orm = crud.crud_room.get_room_by_id(db, room_id=active_character.current_room_id)
    if not current_room_orm:
        return schemas.CommandResponse(message_to_player="CRITICAL ERROR: Character in void.")
    current_room_schema = schemas.RoomInDB.from_orm(current_room_orm)

    logger.info(f"[COMMAND_ENDPOINT] DB Session ID: {id(db)}")
    context = CommandContext(
        db=db, active_character=active_character, current_room_orm=current_room_orm,
        current_room_schema=current_room_schema, original_command=original_command_text,
        command_verb=command_verb, args=args
    )

    # 1. Check standard command registry first
    handler = COMMAND_REGISTRY.get(command_verb)
    if handler:
        return await handler(context)
    
    # 2. If not in standard registry, check for interactable action verbs
    if current_room_orm.interactables:
        target_interactable_name_or_id_from_args = " ".join(args).lower()
        for interactable_dict in current_room_orm.interactables:
            try:
                interactable = schemas.InteractableDetail(**interactable_dict)
                # Check if interactable is visible to this character
                is_visible = not interactable.is_hidden or active_character.id in interactable.revealed_to_char_ids
                
                if is_visible and command_verb == interactable.action_verb.lower():
                    # Potential match! Now check if the args specify this interactable.
                    # Player might type "pull lever" or "pull rusty_lever" or just "pull" if only one thing is pullable.
                    # This needs a robust target resolution for interactables.
                    
                    # Simple match: if args match id_tag or part of the name, or if no args and it's the only one with this verb
                    matches_this_interactable = False
                    if not target_interactable_name_or_id_from_args: 
                        # Check if this is the *only* visible interactable with this action_verb
                        count_with_verb = 0
                        for other_i_dict in current_room_orm.interactables:
                            other_i = schemas.InteractableDetail(**other_i_dict)
                            other_is_visible = not other_i.is_hidden or active_character.id in other_i.revealed_to_char_ids
                            if other_is_visible and other_i.action_verb.lower() == command_verb:
                                count_with_verb += 1
                        if count_with_verb == 1:
                            matches_this_interactable = True
                    elif interactable.id_tag.lower() == target_interactable_name_or_id_from_args or \
                         target_interactable_name_or_id_from_args in interactable.name.lower():
                        matches_this_interactable = True

                    if matches_this_interactable:
                        # Pass the specific interactable to the handler context or directly
                        return await interaction_parser.handle_contextual_interactable_action(context, interactable)
                        
            except Exception as e_parse_interactable:
                print(f"ERROR: Could not parse interactable in room {current_room_orm.id} for contextual command: {e_parse_interactable}. Data: {interactable_dict}")
                continue # Skip this malformed interactable

    # 3. If still not found, default to unknown command or combat check
    if command_verb in ["attack", "atk", "kill", "kil", "ki", "k", "use"]: # "use" also goes to WS
            return schemas.CommandResponse(
            room_data=current_room_schema,
            message_to_player=f"Actions like '{command_verb}' are handled in real-time. (Use game interface / WebSocket)"
        )
    return schemas.CommandResponse(
        room_data=current_room_schema,
        message_to_player=f"I don't understand the command: '{original_command_text}'. Type 'help' or '?'."
    )
--- END OF FILE backend/app/api/v1/endpoints/command.py ---

--- START OF FILE backend/app/commands/command_args.py ---
# backend/app/commands/command_args.py
from typing import List, Optional
from sqlalchemy.orm import Session
from pydantic import BaseModel, Field

from app import models, schemas # Ensure these are accessible from app root

class CommandContext(BaseModel):
    db: Session
    active_character: models.Character
    current_room_orm: models.Room 
    current_room_schema: schemas.RoomInDB
    original_command: str 
    command_verb: str
    args: List[str] # The rest of the command words after the verb
    # For more complex parsing, args could be a pre-parsed Pydantic model itself

    class Config:
        arbitrary_types_allowed = True # For SQLAlchemy Session and ORM models
--- END OF FILE backend/app/commands/command_args.py ---

--- START OF FILE backend/app/schemas/command.py ---
# backend/app/schemas/command.py
from pydantic import BaseModel
from typing import Optional
from .room import RoomInDB

class CommandRequest(BaseModel):
    command: str

class CommandResponse(BaseModel):
    room_data: Optional[RoomInDB] = None
    message_to_player: Optional[str] = None
    combat_over: bool = False # True if combat resolved (death, flee)
    # Add other potential fields for game state updates if needed for HTTP path
--- END OF FILE backend/app/schemas/command.py ---

--- START OF FILE backend/app/websocket_manager.py ---
# backend/app/websocket_manager.py
import uuid
import logging # <<<< MAKE SURE LOGGING IS IMPORTED
from typing import Dict, List, Optional
from fastapi import WebSocket
from fastapi.encoders import jsonable_encoder

# We need access to the database to find out where characters are.
from app.db.session import SessionLocal
from app import crud

logger = logging.getLogger(__name__) # <<<< GET A LOGGER

class ConnectionManager:
    def __init__(self):
        # player_id -> WebSocket mapping
        self.active_player_connections: Dict[uuid.UUID, WebSocket] = {}
        # player_id -> active_character_id mapping
        self.player_active_characters: Dict[uuid.UUID, uuid.UUID] = {}
        # character_id -> room_id mapping (CACHE)
        self.character_locations: Dict[uuid.UUID, uuid.UUID] = {}

    async def connect(self, websocket: WebSocket, player_id: uuid.UUID, character_id: uuid.UUID):
        await websocket.accept()
        self.active_player_connections[player_id] = websocket
        self.player_active_characters[player_id] = character_id
        
        with SessionLocal() as db:
            character = crud.crud_character.get_character(db, character_id=character_id)
            if character:
                self.character_locations[character_id] = character.current_room_id
        
        logger.info(f"Player {player_id} (Character {character_id}) connected via WebSocket.")

    def disconnect(self, player_id: uuid.UUID):
        character_id = self.player_active_characters.get(player_id)
        if character_id and character_id in self.character_locations:
            del self.character_locations[character_id]
        if player_id in self.active_player_connections:
            del self.active_player_connections[player_id]
        if player_id in self.player_active_characters:
            del self.player_active_characters[player_id]
        
        logger.info(f"Player {player_id} disconnected from WebSocket.")

    def get_character_id(self, player_id: uuid.UUID) -> Optional[uuid.UUID]:
        return self.player_active_characters.get(player_id)
        
    def update_character_location(self, character_id: uuid.UUID, room_id: uuid.UUID):
        self.character_locations[character_id] = room_id

    def get_all_player_locations(self) -> Dict[uuid.UUID, uuid.UUID]:
        return self.character_locations

    def is_character_online(self, character_id: uuid.UUID) -> bool:
        return character_id in self.character_locations

    def is_player_connected(self, player_id: uuid.UUID) -> bool:
        return player_id in self.active_player_connections

    async def send_personal_message(self, message_payload: dict, player_id: uuid.UUID):
        if player_id in self.active_player_connections:
            websocket = self.active_player_connections[player_id]
            try:
                encoded_payload = jsonable_encoder(message_payload)
                await websocket.send_json(encoded_payload)
            except Exception as e:
                logger.error(f"Error sending personal WS message to {player_id}: {e}")

    async def broadcast_to_players(self, message_payload: dict, player_ids: List[uuid.UUID]):
        encoded_payload = jsonable_encoder(message_payload)
        for player_id in player_ids:
            if player_id in self.active_player_connections:
                websocket = self.active_player_connections[player_id]
                try:
                    await websocket.send_json(encoded_payload)
                except Exception as e:
                    logger.error(f"Error broadcasting to player {player_id}: {e}")
    
    # --- THIS IS THE NEW METHOD THAT MY BROKEN CODE WAS TRYING TO CALL ---
    async def broadcast(self, message_payload: dict):
        """Sends a message to every single connected WebSocket client."""
        logger.info(f"Broadcasting global message: {message_payload.get('message', 'No message content')}")
        encoded_payload = jsonable_encoder(message_payload)
        # We iterate over the WebSocket objects directly
        for connection in self.active_player_connections.values():
            try:
                await connection.send_json(encoded_payload)
            except Exception as e:
                # Log the error but continue trying to send to others. One bad client shouldn't stop a broadcast.
                logger.warning(f"Failed to broadcast to a client: {e}")
    # --- END OF NEW METHOD ---

    def get_all_active_player_ids(self) -> List[uuid.UUID]:
        return list(self.active_player_connections.keys())

# Global instance
connection_manager = ConnectionManager()
--- END OF FILE backend/app/websocket_manager.py ---

--- START OF FILE backend/app/commands/movement_parser.py ---
# backend/app/commands/movement_parser.py
import uuid
from typing import Dict, List, Optional, Tuple # Ensure all are imported

from app import schemas, crud, models 
from .command_args import CommandContext
from .utils import ( # Assuming these are all in utils.py now
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message # Make sure this is imported
)
from app.websocket_manager import connection_manager # For broadcasting
from app.schemas.common_structures import ExitDetail 


async def handle_look(context: CommandContext) -> schemas.CommandResponse:
    message_to_player_parts: List[str] = []
    look_target_name = " ".join(context.args).strip() if context.args else None

    if look_target_name:
        # ... (existing logic for looking at specific items/mobs) ...
        # Ensure this section also lists other characters if looking at a target
        # For brevity, I'll skip repeating the full "look at target" block, but add char listing there too.

        # At the end of "look at target", after item/mob description, add other entities:
        # ... (after specific target description)
        # message_to_player_parts.append(f"\n\n{context.current_room_schema.name}\n{context.current_room_schema.description}")
        
        # List other items, mobs, AND characters
        other_items_on_ground = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
        if other_items_on_ground:
            ground_items_text, _ = format_room_items_for_player_message(other_items_on_ground)
            if ground_items_text: message_to_player_parts.append(ground_items_text)

        other_mobs_in_room = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
        if other_mobs_in_room:
            mobs_text, _ = format_room_mobs_for_player_message(
                room_mobs=other_mobs_in_room, 
                character=context.active_character
            )
            if mobs_text: message_to_player_parts.append(mobs_text)
        
        # <<< NEW: List other characters (excluding self) when looking at a target
        other_characters_in_room = crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.current_room_orm.id, 
            exclude_character_id=context.active_character.id
        )
        if other_characters_in_room:
            chars_text = format_room_characters_for_player_message(other_characters_in_room)
            if chars_text: message_to_player_parts.append(chars_text)

        final_message = "\n".join(filter(None, message_to_player_parts)).strip()
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=final_message if final_message else None)


    # Default "look" (general room look)
    items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
    ground_items_text, _ = format_room_items_for_player_message(items_on_ground_orm)
    if ground_items_text:
        message_to_player_parts.append(ground_items_text)
        
    mobs_in_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=context.current_room_orm.id)
    mobs_text, _ = format_room_mobs_for_player_message(
        room_mobs=mobs_in_room_orm, 
        character=context.active_character
    )
    if mobs_text:
        message_to_player_parts.append(mobs_text)

    # <<< NEW: List other characters (excluding self) for general look
    characters_in_room_orm = crud.crud_character.get_characters_in_room(
        context.db, 
        room_id=context.current_room_orm.id, 
        exclude_character_id=context.active_character.id
    )
    if characters_in_room_orm:
        chars_text = format_room_characters_for_player_message(characters_in_room_orm)
        if chars_text: message_to_player_parts.append(chars_text)
        
    final_message = "\n".join(filter(None, message_to_player_parts)).strip()
    return schemas.CommandResponse(
        room_data=context.current_room_schema,
        message_to_player=final_message if final_message else None # Send only if there's something to say
    )

async def handle_move(context: CommandContext) -> schemas.CommandResponse:
    message_to_player: Optional[str] = None 
    moved = False
    target_room_orm_for_move: Optional[models.Room] = None
    
    direction_map = {"n": "north", "s": "south", "e": "east", "w": "west", "u": "up", "d": "down"}
    target_direction_str_raw = ""

    if context.command_verb == "go":
        if context.args: 
            target_direction_str_raw = context.args[0].lower()
        else:
            message_to_player = "Go where?"
            return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
    else: 
        target_direction_str_raw = context.command_verb.lower()
        
    target_direction = direction_map.get(target_direction_str_raw, target_direction_str_raw)

    if target_direction not in direction_map.values():
        message_to_player = "That's not a valid direction to move."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    old_room_id = context.active_character.current_room_id
    character_name_for_broadcast = context.active_character.name

    current_exits_dict_of_dicts = context.current_room_orm.exits if context.current_room_orm.exits is not None else {}
    
    if target_direction in current_exits_dict_of_dicts:
        exit_data_as_dict = current_exits_dict_of_dicts.get(target_direction) # This is an ExitDetail-like dict
        
        if isinstance(exit_data_as_dict, dict):
            try:
                # Parse the dict into an ExitDetail Pydantic model
                exit_detail_model = ExitDetail(**exit_data_as_dict)
            except Exception as e_parse:
                message_to_player = f"The exit '{target_direction}' seems corrupted ({e_parse})."
                # Log e_parse for server-side debugging
                print(f"ERROR parsing ExitDetail for {target_direction} in room {context.current_room_orm.id}: {e_parse}, Data: {exit_data_as_dict}")
                return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

            if exit_detail_model.is_locked:
                message_to_player = exit_detail_model.description_when_locked
                # No movement, message_to_player is set.
            else:
                # Exit is not locked, proceed to get target room
                # target_room_id from the model is already a UUID object
                target_room_uuid_obj = exit_detail_model.target_room_id
                potential_target_room_orm = crud.crud_room.get_room_by_id(context.db, room_id=target_room_uuid_obj)
                if potential_target_room_orm:
                    target_room_orm_for_move = potential_target_room_orm
                    moved = True
                else: 
                    message_to_player = "The path ahead seems to vanish into thin air. Spooky."
        else:
            message_to_player = f"The exit data for '{target_direction}' is malformed."
            print(f"ERROR: Exit data for {target_direction} in room {context.current_room_orm.id} is not a dict: {exit_data_as_dict}")
    else: 
        message_to_player = "You can't go that way."

    # If the move was successful
    if moved and target_room_orm_for_move:
        # ... (rest of the successful move logic - broadcasting, formatting messages, etc.)
        # This part should be largely okay from previous versions, ensure it uses target_room_orm_for_move
        crud.crud_character.update_character_room(
            context.db, character_id=context.active_character.id, new_room_id=target_room_orm_for_move.id
        )
        new_room_schema = schemas.RoomInDB.from_orm(target_room_orm_for_move)

        # Broadcast "leaves" message
        player_ids_in_old_room = [
            char.player_id for char in crud.crud_character.get_characters_in_room(
                context.db, room_id=old_room_id, exclude_character_id=context.active_character.id
            ) if connection_manager.is_player_connected(char.player_id)
        ]
        if player_ids_in_old_room:
            leave_message_payload = {
                "type": "game_event", 
                "message": f"<span class='char-name'>{character_name_for_broadcast}</span> leaves, heading {target_direction}."
            }
            await connection_manager.broadcast_to_players(leave_message_payload, player_ids_in_old_room)

        # Broadcast "arrives" message
        player_ids_in_new_room_others = [
            char.player_id for char in crud.crud_character.get_characters_in_room(
                context.db, room_id=target_room_orm_for_move.id, exclude_character_id=context.active_character.id
            ) if connection_manager.is_player_connected(char.player_id)
        ]
        if player_ids_in_new_room_others:
            # TODO: Arrival direction
            arrive_message_payload = {
                "type": "game_event", 
                "message": f"<span class='char-name'>{character_name_for_broadcast}</span> arrives."
            }
            await connection_manager.broadcast_to_players(arrive_message_payload, player_ids_in_new_room_others)
        
        arrival_message_parts: List[str] = []
        items_in_new_room_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=target_room_orm_for_move.id)
        ground_items_text, _ = format_room_items_for_player_message(items_in_new_room_orm)
        if ground_items_text: arrival_message_parts.append(ground_items_text)
            
        mobs_in_new_room_orm = crud.crud_mob.get_mobs_in_room(context.db, room_id=target_room_orm_for_move.id)
        mobs_text, _ = format_room_mobs_for_player_message(
            room_mobs=mobs_in_new_room_orm, 
            character=context.active_character
        )
        if mobs_text: arrival_message_parts.append(mobs_text)

        other_characters_in_new_room = crud.crud_character.get_characters_in_room(
            context.db, room_id=target_room_orm_for_move.id, exclude_character_id=context.active_character.id
        )
        if other_characters_in_new_room:
            chars_text_for_mover = format_room_characters_for_player_message(other_characters_in_new_room)
            if chars_text_for_mover: arrival_message_parts.append(chars_text_for_mover)
            
        final_arrival_message = "\n".join(filter(None, arrival_message_parts)).strip()
        
        return schemas.CommandResponse(
            room_data=new_room_schema, 
            message_to_player=final_arrival_message if final_arrival_message else None
        )
            
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/movement_parser.py ---

--- START OF FILE backend/app/commands/social_parser.py ---
# backend/app/commands/social_parser.py
import random
from app import schemas, models, crud # app.
from .command_args import CommandContext # app.commands.command_args
from app.websocket_manager import connection_manager


async def handle_fart(context: CommandContext) -> schemas.CommandResponse:
    character_name = context.active_character.name

    # --- Diverse Onomatopoeia & Descriptions ---
    fart_sounds = [
        "*Pfffft!*", "*Braaap!*", "*Thrrrip!*", "*Squelch...*", "*Poot.*", "*Brrrt!*", 
        "*Toot!*", "*Phhhht.*", "*SBD (Silent But Deadly)*", "*Flrph*", "*Thwapp!*",
        "*Poo-tee-weet?*", "*A high-pitched whistle*", "*A low, bassy rumble*"
    ]
    
    actor_descriptions = [ # What the farter experiences/thinks
        "You feel a sudden pressure release.",
        "You subtly (or not so subtly) let one rip.",
        "A fragrant cloud emanates from your being.",
        "You add your unique aroma to the room's ambiance.",
        "Ah, sweet relief!",
        "You check discreetly to see if anyone noticed. They did.",
        "You try to blame the dog, but there is no dog.",
        "A moment of internal rebellion, now externalized.",
        "You punctuate the silence with a personal statement."
    ]

    observer_actions = [ # What others see/hear the farter DOING
        "bends over slightly", "winces momentarily", "shifts uncomfortably in their britches",
        "looks around innocently", "grins mischievously", "lets out a sigh of contentment",
        "fans the air nonchalantly", "suddenly seems very interested in a cobweb on the ceiling",
        "blushes faintly", "chuckles to themselves"
    ]

    observer_smells_or_sounds = [ # The sensory experience for others
        "A suspicious noise emanates from their direction.",
        "The distinct sound of escaping gas is heard.",
        "A foul wind blows from where they stand.",
        "The air suddenly becomes... heavier.",
        "A faint (or not so faint) odor permeates the area.",
        "It sounds like a small, trapped animal finally escaped.",
        "Someone should probably open a window."
    ]

    # --- Constructing the Messages ---
    chosen_sound = random.choice(fart_sounds)
    actor_desc_part = random.choice(actor_descriptions)
    observer_action_part = random.choice(observer_actions)
    observer_smell_sound_part = random.choice(observer_smells_or_sounds)

    # Message to the player who farted
    # Player sees the sound, their internal monologue/action, and perhaps a general observation.
    message_to_player = f"You {observer_action_part}. {chosen_sound} {actor_desc_part}"

    # Message to everyone else in the room
    # Others see the player's action, the sound, and the sensory result.
    message_to_others = (
        f"<span class='char-name'>{character_name}</span> {observer_action_part}. "
        f"{chosen_sound} {observer_smell_sound_part}"
    )

    # --- Broadcasting ---
    others_message_payload = {
        "type": "game_event", # Or a more specific "social_event" or "emote"
        "message": message_to_others
    }

    player_ids_in_room_to_notify = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Don't send broadcast to self
        ) if connection_manager.is_player_connected(char.player_id)
    ]

    if player_ids_in_room_to_notify:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room_to_notify)
    
    return schemas.CommandResponse(
        room_data=context.current_room_schema, 
        message_to_player=message_to_player
    )

async def handle_say(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Say what?")

    message_text = " ".join(context.args)
    character_name = context.active_character.name

    # Message to self (echo)
    self_message = f"You say, \"{message_text}\""
    
    # Message to others in the room
    others_message_payload = {
        "type": "game_event", # Or "chat_message"
        "message": f"<span class='char-name'>{character_name}</span> says, \"{message_text}\""
    }

    player_ids_in_room = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Exclude self from broadcast
        ) if connection_manager.is_player_connected(char.player_id)
    ]

    if player_ids_in_room:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room)

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=self_message)


async def handle_emote(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="Emote what? (e.g., emote grins)")

    emote_text = " ".join(context.args)
    character_name = context.active_character.name

    # Message to self (echo) - may or may not include your own name based on MUD style
    self_message = f"<span class='char-name'>{character_name}</span> {emote_text}" # Or "You {emote_text}"
    
    # Message to others in the room
    others_message_payload = {
        "type": "game_event", # Or "emote_message"
        "message": f"<span class='char-name'>{character_name}</span> {emote_text}"
    }

    player_ids_in_room = [
        char.player_id for char in crud.crud_character.get_characters_in_room(
            context.db, 
            room_id=context.active_character.current_room_id, 
            exclude_character_id=context.active_character.id # Exclude self from broadcast
        ) if connection_manager.is_player_connected(char.player_id)
    ]
    
    # Send to others first, then construct self_message which might be slightly different for some MUDs
    if player_ids_in_room:
        await connection_manager.broadcast_to_players(others_message_payload, player_ids_in_room)
    
    # For emote, the player also sees the "CharacterName emotes..." message
    # So, we send the same payload to self, but via send_personal_message
    # Or, if the command response message_to_player handles the self-echo:
    # self_message_for_command_response = f"You {emote_text}." # if you want "You emote"
    self_message_for_command_response = self_message # Echo the same as others see

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=self_message_for_command_response)

async def handle_ooc(context: CommandContext) -> schemas.CommandResponse:
    if not context.args:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="OOC what? (Out Of Character global chat)")

    message_text = " ".join(context.args)
    character_name = context.active_character.name
    player_username = context.active_character.owner.username if hasattr(context.active_character, 'owner') and context.active_character.owner else "UnknownPlayer" 
    # To get player_username, Character model needs `owner: Mapped["Player"] = relationship(back_populates="characters")` 
    # and it needs to be loaded. For now, let's stick to character name or a generic.
    # Let's use Character Name for simplicity in OOC for now.

    # Message for global broadcast
    # Using a distinct style for OOC messages is good.
    ooc_message_payload = {
        "type": "ooc_message", # A new type for the frontend to potentially style differently
        "message": f"[OOC] <span class='char-name'>{character_name}</span>: {message_text}"
    }

    # Get ALL active player_ids from ConnectionManager
    all_player_ids = connection_manager.get_all_active_player_ids() # Needs to be implemented in ConnectionManager
    
    # Broadcast to everyone, including self
    if all_player_ids:
        await connection_manager.broadcast_to_players(ooc_message_payload, all_player_ids)
    
    # No direct message_to_player in CommandResponse needed if the broadcast includes self.
    # Or, you can have a self-echo: "You OOC: message"
    # For now, assume the broadcast handles echoing to self too.
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=None) # Or "OOC message sent."
--- END OF FILE backend/app/commands/social_parser.py ---

--- START OF FILE backend/app/commands/inventory_parser.py ---
# backend/app/commands/inventory_parser.py
from typing import Any, Optional, List, Dict # Added Any, not strictly needed here but fine
import uuid
import logging

from app import schemas, crud, models
from .command_args import CommandContext
from .utils import format_inventory_for_player_message # Used by handle_inventory
from app.models.item import EQUIPMENT_SLOTS

logger = logging.getLogger(__name__)

async def handle_inventory(context: CommandContext) -> schemas.CommandResponse:
    # ... (This function seems fine, it prepares data for format_inventory_for_player_message)
    character_orm = context.active_character
    all_inv_items_orm = crud.crud_character_inventory.get_character_inventory(context.db, character_id=character_orm.id)
    
    equipped_items_dict: Dict[str, schemas.CharacterInventoryItem] = {}
    backpack_items_list: List[schemas.CharacterInventoryItem] = []

    for inv_item_orm in all_inv_items_orm:
        if not inv_item_orm.item:
            logger.warning(f"Inventory item {inv_item_orm.id} missing item details for char {character_orm.id}")
            continue
        try:
            item_schema = schemas.CharacterInventoryItem.from_orm(inv_item_orm)
            if inv_item_orm.equipped and inv_item_orm.equipped_slot:
                equipped_items_dict[inv_item_orm.equipped_slot] = item_schema
            else:
                backpack_items_list.append(item_schema)
        except Exception as e:
            logger.error(f"Pydantic from_orm failed for CharacterInventoryItem {inv_item_orm.id}: {e}", exc_info=True)
            
    inventory_display_data = schemas.CharacterInventoryDisplay(
        equipped_items=equipped_items_dict,
        backpack_items=backpack_items_list,
        platinum=character_orm.platinum_coins,
        gold=character_orm.gold_coins,
        silver=character_orm.silver_coins,
        copper=character_orm.copper_coins
    )
    message_to_player = format_inventory_for_player_message(inventory_display_data) # This now uses the improved utils function
    return schemas.CommandResponse(
        room_data=context.current_room_schema,
        message_to_player=message_to_player
    )

async def handle_equip(context: CommandContext) -> schemas.CommandResponse:
    logger.info(f"[HANDLER_EQUIP] Char: {context.active_character.name}, Command: '{context.original_command}'")
    message_to_player: str
    preliminary_message: Optional[str] = None

    if not context.args:
        message_to_player = "Equip/Eq what? (e.g., 'equip Rusty Sword' or 'eq 1 main_hand')"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # --- Argument parsing (from old version, it's good) ---
    item_ref_str: str = ""
    target_slot_arg: Optional[str] = None
    args_list = list(context.args)

    if args_list:
        potential_slot_word = args_list[-1].lower()
        is_last_word_a_slot = False
        for slot_key_iter, slot_display_iter in EQUIPMENT_SLOTS.items():
            if potential_slot_word == slot_key_iter.lower() or \
               potential_slot_word == slot_display_iter.lower().replace(" ", ""):
                target_slot_arg = slot_key_iter
                item_ref_str = " ".join(args_list[:-1]).strip()
                is_last_word_a_slot = True
                break
        if not is_last_word_a_slot:
            item_ref_str = " ".join(args_list).strip()

    if not item_ref_str:
        message_to_player = "Equip what item?"
        if target_slot_arg: message_to_player = f"Equip what item to {EQUIPMENT_SLOTS.get(target_slot_arg, target_slot_arg)}?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # --- NEW, CORRECTED, UNIFIED LOGIC FOR NUMBER MAPPING ---
    char_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    )
    unequipped_items_orm: List[models.CharacterInventoryItem] = [
        item for item in char_inventory_items_orm if not item.equipped and item.item
    ]

    aggregated_backpack_for_map: Dict[str, List[models.CharacterInventoryItem]] = {}
    for inv_item_orm in unequipped_items_orm:
        item_name = inv_item_orm.item.name
        if item_name not in aggregated_backpack_for_map:
            aggregated_backpack_for_map[item_name] = []
        aggregated_backpack_for_map[item_name].append(inv_item_orm)
    
    sorted_item_names = sorted(aggregated_backpack_for_map.keys())

    temp_backpack_map_by_display_number: Dict[int, models.CharacterInventoryItem] = {}
    for idx, item_name in enumerate(sorted_item_names):
        first_instance_for_name = aggregated_backpack_for_map[item_name][0]
        temp_backpack_map_by_display_number[idx + 1] = first_instance_for_name
    # --- END OF NEW LOGIC ---

    # --- Item resolution (from old version, but using new map) ---
    found_inv_item_entry: Optional[models.CharacterInventoryItem] = None
    try:
        ref_num = int(item_ref_str)
        found_inv_item_entry = temp_backpack_map_by_display_number.get(ref_num)
    except ValueError:
        matching_instances = aggregated_backpack_for_map.get(item_ref_str.lower())
        if matching_instances:
            found_inv_item_entry = matching_instances[0]
            if len(matching_instances) > 1 and found_inv_item_entry.item:
                preliminary_message = f"(You have multiple unequipped '{found_inv_item_entry.item.name}'. Equipping one.)\n"

    # --- Final equip logic and response (from old version, this is crucial) ---
    if found_inv_item_entry and found_inv_item_entry.item:
        logger.info(f"[HANDLER_EQUIP] Target to equip: {found_inv_item_entry.item.name} (InvEntry ID: {found_inv_item_entry.id}). Slot: {target_slot_arg}")

        equipped_item_orm, crud_message = crud.crud_character_inventory.equip_item_from_inventory(
            context.db,
            character_obj=context.active_character,
            inventory_item_id=found_inv_item_entry.id,
            target_slot=target_slot_arg
        )

        logger.info(f"[HANDLER_EQUIP] CRUD response: Msg='{crud_message}', ORM ID: {equipped_item_orm.id if equipped_item_orm else 'None'}")

        if equipped_item_orm and "Staged equipping" in crud_message:
            message_to_player = (preliminary_message or "") + f"You equip the {found_inv_item_entry.item.name}."
            context.db.commit() # This is the money shot
        else:
            message_to_player = (preliminary_message or "") + crud_message
            logger.warning(f"[HANDLER_EQUIP] Equip failed for '{found_inv_item_entry.item.name}': {crud_message}")
    else:
        message_to_player = f"You don't have an unequipped item matching '{item_ref_str}'."
        logger.info(f"[HANDLER_EQUIP] Item not found for ref: '{item_ref_str}'")

    return schemas.CommandResponse(
        room_data=context.current_room_schema,
        message_to_player=message_to_player
    )

async def handle_unequip(context: CommandContext) -> schemas.CommandResponse:
    # ... (This function uses similar logic for identifying item by slot or name.
    # If you want to allow unequip by displayed backpack number, similar replicated logic would be needed,
    # but typically unequip targets equipped slots or names of equipped items, which is simpler.)
    # For now, I'll assume its current logic is what you want for unequip.
    # If not, we can refactor it too.
    message_to_player: str
    preliminary_message: Optional[str] = None
    target_to_unequip_str = " ".join(context.args).strip()

    if not target_to_unequip_str:
        message_to_player = "Unequip/Uneq what? (e.g. 'unequip main_hand' or 'unequip Rusty Sword')"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    char_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    ) # Always get fresh

    found_inv_item_entry: Optional[models.CharacterInventoryItem] = None
    
    # Try matching by slot name first
    for slot_key_iter, slot_display_iter in EQUIPMENT_SLOTS.items():
        if target_to_unequip_str.lower() == slot_key_iter.lower() or \
           target_to_unequip_str.lower() == slot_display_iter.lower().replace(" ", ""):
            for inv_item in char_inventory_items_orm:
                if inv_item.equipped and inv_item.equipped_slot == slot_key_iter:
                    found_inv_item_entry = inv_item
                    break
            if found_inv_item_entry: break 
    
    # If not found by slot, try by name of an equipped item
    if not found_inv_item_entry:
        equipped_items_by_name: Dict[str, List[models.CharacterInventoryItem]] = {}
        for inv_item in char_inventory_items_orm:
            if inv_item.equipped and inv_item.item:
                item_name_lower = inv_item.item.name.lower()
                if item_name_lower not in equipped_items_by_name: 
                    equipped_items_by_name[item_name_lower] = []
                equipped_items_by_name[item_name_lower].append(inv_item)
        
        matching_equipped_items = equipped_items_by_name.get(target_to_unequip_str.lower())
        if matching_equipped_items:
            found_inv_item_entry = matching_equipped_items[0] 
            if len(matching_equipped_items) > 1 and found_inv_item_entry.item :
                 preliminary_message = f"(Multiple items named '{found_inv_item_entry.item.name}' are equipped. Unequipping one from slot {found_inv_item_entry.equipped_slot}.)\n"

    if found_inv_item_entry and found_inv_item_entry.item:
        unequipped_item_orm, crud_message = crud.crud_character_inventory.unequip_item_to_inventory(
            context.db, 
            character_obj=context.active_character, 
            inventory_item_id=found_inv_item_entry.id
            # slot_to_unequip is implicitly handled by finding the item_id of what's in a slot or by name
        )
        if unequipped_item_orm and "Staged unequipping" in crud_message: # Check for success message from CRUD
             message_to_player = (preliminary_message or "") + f"You unequip the {found_inv_item_entry.item.name}."
        else:
            message_to_player = (preliminary_message or "") + crud_message
    else:
        message_to_player = f"You don't have an item equipped matching '{target_to_unequip_str}'."
    
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_drop(context: CommandContext) -> schemas.CommandResponse:
    # This function needs the same replicated display logic as handle_equip
    # if you want "drop <number>" to work based on the sorted, aggregated display.
    # I'll add it here.
    logger.info(f"[HANDLER_DROP] Char: {context.active_character.name}, Command: '{context.original_command}'")
    message_to_player: str
    preliminary_message: Optional[str] = None
    item_ref_to_drop = " ".join(context.args).strip()

    if not item_ref_to_drop:
        message_to_player = "Drop what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    char_inventory_items_orm = crud.crud_character_inventory.get_character_inventory(
        context.db, character_id=context.active_character.id
    )

    # --- REPLICATE DISPLAY LOGIC FOR NUMBER MAPPING (for drop) ---
    aggregated_stackable_for_map: Dict[uuid.UUID, Dict[str, Any]] = {}
    individual_non_stackable_for_map: List[models.CharacterInventoryItem] = []
    unequipped_items_orm: List[models.CharacterInventoryItem] = [
        item for item in char_inventory_items_orm if not item.equipped and item.item
    ]

    for inv_item_orm in unequipped_items_orm:
        item_template = inv_item_orm.item
        if not item_template: continue
        if item_template.stackable:
            item_template_id = item_template.id
            if item_template_id not in aggregated_stackable_for_map:
                aggregated_stackable_for_map[item_template_id] = {"name": item_template.name, "total_quantity": 0, "instance_ids": []}
            aggregated_stackable_for_map[item_template_id]["total_quantity"] += inv_item_orm.quantity
            aggregated_stackable_for_map[item_template_id]["instance_ids"].append(inv_item_orm.id)
        else:
            individual_non_stackable_for_map.append(inv_item_orm)

    map_build_list: List[Dict[str, Any]] = []
    for data in aggregated_stackable_for_map.values():
        if data["instance_ids"]:
            map_build_list.append({"name": data["name"], "inventory_item_id_to_drop": data["instance_ids"][0], "is_stack": True, "full_stack_qty": data["total_quantity"]})
    for inv_item_orm in individual_non_stackable_for_map:
        map_build_list.append({"name": inv_item_orm.item.name, "inventory_item_id_to_drop": inv_item_orm.id, "is_stack": False, "full_stack_qty": 1})
    
    map_build_list.sort(key=lambda x: x["name"])

    temp_backpack_map_by_display_number: Dict[int, Dict[str, Any]] = {} # Store more info
    for idx, entry_data in enumerate(map_build_list):
        temp_backpack_map_by_display_number[idx + 1] = entry_data
    
    backpack_items_by_name_lower: Dict[str, List[models.CharacterInventoryItem]] = {}
    for inv_item_orm in unequipped_items_orm:
        if inv_item_orm.item:
            item_name_lower = inv_item_orm.item.name.lower()
            if item_name_lower not in backpack_items_by_name_lower: backpack_items_by_name_lower[item_name_lower] = []
            backpack_items_by_name_lower[item_name_lower].append(inv_item_orm)
    # --- END OF REPLICATED DISPLAY LOGIC ---

    item_to_drop_instance: Optional[models.CharacterInventoryItem] = None
    target_inventory_item_id_for_crud: Optional[uuid.UUID] = None
    quantity_to_actually_drop = 1 # Default for non-stackable or if dropping one from a stack by name

    try:
        ref_num = int(item_ref_to_drop)
        if ref_num in temp_backpack_map_by_display_number:
            selected_entry_data = temp_backpack_map_by_display_number[ref_num]
            target_inventory_item_id_for_crud = selected_entry_data["inventory_item_id_to_drop"]
            item_to_drop_instance = next((item for item in unequipped_items_orm if item.id == target_inventory_item_id_for_crud), None)
            if item_to_drop_instance and item_to_drop_instance.item and item_to_drop_instance.item.stackable:
                # If user says "drop 3" and item 3 is "Potion (Qty: 5)", we drop the whole stack.
                quantity_to_actually_drop = item_to_drop_instance.quantity
    except ValueError:
        if item_ref_to_drop:
            matching_items_by_name_list = backpack_items_by_name_lower.get(item_ref_to_drop.lower())
            if matching_items_by_name_list:
                item_to_drop_instance = matching_items_by_name_list[0]
                target_inventory_item_id_for_crud = item_to_drop_instance.id
                quantity_to_actually_drop = item_to_drop_instance.quantity # Drop the whole stack if named
                if len(matching_items_by_name_list) > 1 and item_to_drop_instance.item:
                    preliminary_message = f"(Multiple items named '{item_to_drop_instance.item.name}'. Dropping one stack/item.)\n"

    if not item_to_drop_instance or not item_to_drop_instance.item or not target_inventory_item_id_for_crud:
        message_to_player = f"You don't have '{item_ref_to_drop}' in your backpack to drop."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    # Use the determined quantity_to_actually_drop
    _, removal_msg = crud.crud_character_inventory.remove_item_from_character_inventory(
        context.db, inventory_item_id=target_inventory_item_id_for_crud, quantity_to_remove=quantity_to_actually_drop
    )

    if "Error" in removal_msg or "Cannot" in removal_msg or "not found" in removal_msg:
        message_to_player = (preliminary_message or "") + removal_msg
    else:
        _, drop_msg_room = crud.crud_room_item.add_item_to_room(
            context.db, room_id=context.current_room_orm.id, item_id=item_to_drop_instance.item_id,
            quantity=quantity_to_actually_drop, dropped_by_character_id=context.active_character.id
        )
        message_to_player = (preliminary_message or "") + f"You drop {item_to_drop_instance.item.name}"
        if quantity_to_actually_drop > 1:
            message_to_player += f" (x{quantity_to_actually_drop})."
        else:
            message_to_player += "."
            
    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)


async def handle_get(context: CommandContext) -> schemas.CommandResponse:
    # This also needs the replicated display logic from utils.format_room_items_for_player_message
    # if "get <number>" is to work based on the sorted display.
    logger.info(f"[HANDLER_GET] Char: {context.active_character.name}, Command: '{context.original_command}'")
    message_to_player: str
    preliminary_message: Optional[str] = None
    item_ref_to_get = " ".join(context.args).strip()

    if not item_ref_to_get:
        message_to_player = "Get what?"
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    items_on_ground_orm = crud.crud_room_item.get_items_in_room(context.db, room_id=context.current_room_orm.id)
    if not items_on_ground_orm:
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player="There is nothing on the ground here.")

    # --- REPLICATE DISPLAY LOGIC FOR NUMBER MAPPING (for get) ---
    # This logic mirrors format_room_items_for_player_message to ensure numbers match display
    sorted_ground_items_for_map = sorted(items_on_ground_orm, key=lambda ri: ri.item.name if ri.item else "")
    
    temp_ground_map_by_display_number: Dict[int, models.RoomItemInstance] = {}
    for idx, item_instance in enumerate(sorted_ground_items_for_map):
        temp_ground_map_by_display_number[idx + 1] = item_instance
        
    ground_items_by_name_lower: Dict[str, List[models.RoomItemInstance]] = {}
    for room_item_inst_orm in items_on_ground_orm: # Original list for name matching
        if room_item_inst_orm.item:
            item_name_lower = room_item_inst_orm.item.name.lower()
            if item_name_lower not in ground_items_by_name_lower: ground_items_by_name_lower[item_name_lower] = []
            ground_items_by_name_lower[item_name_lower].append(room_item_inst_orm)
    # --- END OF REPLICATED DISPLAY LOGIC ---

    item_to_get_instance: Optional[models.RoomItemInstance] = None
    try:
        ref_num = int(item_ref_to_get)
        if ref_num in temp_ground_map_by_display_number:
            item_to_get_instance = temp_ground_map_by_display_number[ref_num]
    except ValueError:
        if item_ref_to_get: # Name-based matching (using the more detailed resolve_room_item_target might be better)
            # Simple name match for now, like original logic.
            # For a more robust solution, could call a modified resolve_room_item_target that doesn't return a message for ambiguity
            # but rather returns all matches, and this handler decides.
            # This current name matching is simpler than resolve_room_item_target.
            matching_items_by_name_list = ground_items_by_name_lower.get(item_ref_to_get.lower())
            if matching_items_by_name_list:
                item_to_get_instance = matching_items_by_name_list[0] # Pick first
                if len(matching_items_by_name_list) > 1 and item_to_get_instance.item:
                    preliminary_message = f"(Getting one of multiple '{item_to_get_instance.item.name}'.)\n"
    
    if not item_to_get_instance or not item_to_get_instance.item:
        message_to_player = f"No '{item_ref_to_get}' on the ground here."
        return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)

    quantity_picked_up = item_to_get_instance.quantity # Get the full stack from ground
    item_id_picked_up = item_to_get_instance.item_id
    item_name_picked_up = item_to_get_instance.item.name

    # Attempt to remove from room
    _, removal_msg = crud.crud_room_item.remove_item_from_room(
        context.db, room_item_instance_id=item_to_get_instance.id, quantity_to_remove=quantity_picked_up
    )

    if "Error" in removal_msg or "not found" in removal_msg:
        message_to_player = (preliminary_message or "") + removal_msg
    else:
        # Attempt to add to character inventory
        _, add_msg_inv = crud.crud_character_inventory.add_item_to_character_inventory(
            context.db,
            character_obj=context.active_character,
            item_id=item_id_picked_up, # Use the ID from the item instance
            quantity=quantity_picked_up
        )
        if "Error" in add_msg_inv or "Cannot" in add_msg_inv or "Could not add" in add_msg_inv:
            message_to_player = (preliminary_message or "") + f"You try to pick up {item_name_picked_up}, but {add_msg_inv.lower().replace('staged addition of', 'could not add to inventory:')}"
            logger.error(f"Failed to add item {item_name_picked_up} to char {context.active_character.name} inv after picking up. Item was REMOVED from room. Attempting to re-drop.")
            # Attempt to re-drop the item if adding to inventory failed
            _, redrop_msg = crud.crud_room_item.add_item_to_room(
                context.db, room_id=context.current_room_orm.id, item_id=item_id_picked_up,
                quantity=quantity_picked_up 
            )
            if "Error" in redrop_msg:
                logger.critical(f"CRITICAL ERROR: Failed to re-drop item {item_name_picked_up} after inventory add failure. Item lost from world. Redrop message: {redrop_msg}")
                message_to_player += " ...and it vanished in a puff of logic!"
            else:
                message_to_player += " ...so you leave it on the ground."
        else:
            message_to_player = (preliminary_message or "") + f"You pick up {item_name_picked_up}"
            if quantity_picked_up > 1:
                message_to_player += f" (x{quantity_picked_up})."
            else:
                message_to_player += "."

    return schemas.CommandResponse(room_data=context.current_room_schema, message_to_player=message_to_player)
--- END OF FILE backend/app/commands/inventory_parser.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Boolean, Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    is_brief_mode: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    owner: Mapped["Player"] = relationship(back_populates="characters", lazy="joined") 

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    god_level: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="0 for mortals, 1-10 for gods")
    titles: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [], comment="e.g., ['The Godslayer', 'Cheesewheel Enthusiast']")
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)
    is_brief_mode: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py
import uuid
from typing import Optional, Dict, List, TYPE_CHECKING, Any
from enum import Enum as PyEnum

from sqlalchemy import Column, Integer, String, Text, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance
    from .room_mob_instance import RoomMobInstance

class RoomTypeEnum(PyEnum):
    STANDARD = "standard"
    SANCTUARY = "sanctuary"
    SHOP = "shop"
    TRAINER = "trainer"
    DUNGEON_ENTRANCE = "dungeon_entrance"
    PUZZLE = "puzzle"

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    
    # --- THE MISSING FIELDS GO HERE ---
    zone_name: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, index=True)
    zone_level_range: Mapped[Optional[str]] = mapped_column(String(20), nullable=True, comment="e.g., 1-5 or 10-15")
    # --- END OF MISSING FIELDS ---
    
    room_type: Mapped[RoomTypeEnum] = mapped_column(
        SQLEnum(RoomTypeEnum, name="roomtypeenum", create_type=True),
        default=RoomTypeEnum.STANDARD,
        nullable=False,
        index=True
    )

    exits: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB,
        nullable=True,
        default=lambda: {}
    )
    interactables: Mapped[Optional[List[Dict[str, Any]]]] = mapped_column(
        JSONB,
        nullable=True,
        default=lambda: []
    )
    npc_placements: Mapped[Optional[List[str]]] = mapped_column(
        JSONB,
        nullable=True,
        comment="List of unique_name_tags for NPC templates to be placed in this room."
    )
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin"
    )
    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin"
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', zone='{self.zone_name}', x={self.x}, y={self.y}, z={self.z}, type='{self.room_type.value}')>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)

    # Currency: Optional at creation, with defaults
    platinum_coins: Optional[int] = Field(0, description="Platinum coins owned by the character")
    gold_coins: Optional[int] = Field(0, description="Gold coins owned by the character")
    silver_coins: Optional[int] = Field(0, description="Silver coins owned by the character")
    copper_coins: Optional[int] = Field(100, description="Copper coins owned by the character, default 100 for new chars")

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):  # Inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    platinum_coins: int # type: ignore
    gold_coins: int # type: ignore
    silver_coins: int # type: ignore
    copper_coins: int # type: ignore
    is_brief_mode: bool

    god_level: int
    titles: Optional[List[str]] = None

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/schemas/room.py ---
# backend/app/schemas/room.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

from ..models.room import RoomTypeEnum
from .common_structures import ExitDetail, InteractableDetail
from .npc import NpcTemplateInDB # Import this properly now
from .item import RoomItemInstanceInDB
from .mob import RoomMobInstance
from .character import Character


# --- Room Schemas ---

# This is the base for what constitutes a "Room" in its simplest form.
class RoomBase(BaseModel):
    name: str
    description: Optional[str] = None
    x: int
    y: int
    z: int
    room_type: RoomTypeEnum = Field(default=RoomTypeEnum.STANDARD)
    zone_name: Optional[str] = None
    zone_level_range: Optional[str] = None

# This schema is specifically for CREATING rooms from the seeder JSON.
# It must match the structure of the "data" block in rooms_z0.json exactly.
class RoomCreate(RoomBase):
    exits: Optional[Dict[str, Any]] = Field(default_factory=dict)
    interactables: Optional[List[Dict[str, Any]]] = Field(default_factory=list)
    npc_placements: Optional[List[str]] = Field(default_factory=list)
    # Note: We use Dict[str, Any] for exits/interactables here because the seeder
    # does its own detailed Pydantic validation later. This schema is just for capture.

# This is for PARTIAL updates, e.g., via an API endpoint.
class RoomUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    exits: Optional[Dict[str, ExitDetail]] = None
    interactables: Optional[List[InteractableDetail]] = None
    room_type: Optional[RoomTypeEnum] = None
    npc_placements: Optional[List[str]] = None # Allow updating placements via API too

# This is the full representation of a Room as it exists in the database,
# including all relationships, for sending to the client.
class RoomInDB(RoomBase):
    id: uuid.UUID
    exits: Optional[Dict[str, ExitDetail]] = Field(default_factory=dict)
    interactables: Optional[List[InteractableDetail]] = Field(default_factory=list)
    items_on_ground: List[RoomItemInstanceInDB] = []
    mobs_in_room: List[RoomMobInstance] = []
    other_characters: List[Character] = []
    npcs_in_room: List[NpcTemplateInDB] = [] # This is now correct because of the import
    dynamic_description_additions: List[str] = []

    class Config:
        from_attributes = True
--- END OF FILE backend/app/schemas/room.py ---

--- START OF FILE backend/app/schemas/skill.py ---
# backend/app/schemas/skill.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List # Added List

class SkillTemplateBase(BaseModel):
    skill_id_tag: str = Field(..., min_length=3, max_length=100, pattern="^[a-z0-9_]+$",
                               description="Unique internal identifier, e.g., 'power_attack'. Lowercase, numbers, underscores.")
    name: str = Field(..., min_length=3, max_length=100, description="Player-facing name, e.g., 'Power Attack'")
    description: Optional[str] = None
    skill_type: str = Field(..., description="e.g., 'COMBAT_ACTIVE', 'PASSIVE', 'UTILITY_OOC'")
    target_type: str = Field(default="NONE", description="e.g., 'SELF', 'ENEMY_MOB', 'NONE'")
    effects_data: Dict[str, Any] = Field(default_factory=dict)
    requirements_data: Optional[Dict[str, Any]] = Field(default_factory=dict)
    rank: Optional[int] = Field(1, ge=1)
    cooldown: Optional[int] = Field(0, ge=0)

class SkillTemplateCreate(SkillTemplateBase):
    pass

class SkillTemplateUpdate(BaseModel): # For partial updates
    skill_id_tag: Optional[str] = Field(None, min_length=3, max_length=100, pattern="^[a-z0-9_]+$")
    name: Optional[str] = Field(None, min_length=3, max_length=100)
    description: Optional[str] = None
    skill_type: Optional[str] = None
    target_type: Optional[str] = None
    effects_data: Optional[Dict[str, Any]] = None
    requirements_data: Optional[Dict[str, Any]] = None
    rank: Optional[int] = Field(None, ge=1)
    cooldown: Optional[int] = Field(None, ge=0)

class SkillTemplateInDBBase(SkillTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class SkillTemplate(SkillTemplateInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/skill.py ---

--- START OF FILE backend/app/schemas/trait.py ---
# backend/app/schemas/trait.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List # Added List

class TraitTemplateBase(BaseModel):
    trait_id_tag: str = Field(..., min_length=3, max_length=100, pattern="^[a-z0-9_]+$",
                                description="Unique internal identifier, e.g., 'nimble_fingers'. Lowercase, numbers, underscores.")
    name: str = Field(..., min_length=3, max_length=100, description="Player-facing name, e.g., 'Nimble Fingers'")
    description: Optional[str] = None
    trait_type: str = Field(default="PASSIVE", description="e.g., 'PASSIVE', 'SOCIAL'")
    effects_data: Dict[str, Any] = Field(default_factory=dict)
    mutually_exclusive_with: Optional[List[str]] = Field(default_factory=list)

class TraitTemplateCreate(TraitTemplateBase):
    pass

class TraitTemplateUpdate(BaseModel): # For partial updates
    trait_id_tag: Optional[str] = Field(None, min_length=3, max_length=100, pattern="^[a-z0-9_]+$")
    name: Optional[str] = None
    description: Optional[str] = None
    trait_type: Optional[str] = None
    effects_data: Optional[Dict[str, Any]] = None
    mutually_exclusive_with: Optional[List[str]] = None

class TraitTemplateInDBBase(TraitTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class TraitTemplate(TraitTemplateInDBBase): # For returning to client
    pass
--- END OF FILE backend/app/schemas/trait.py ---

--- START OF FILE backend/app/crud/crud_skill.py ---
# backend/app/crud/crud_skill.py
import json # For loading JSON
import os   # For path joining
import logging # For logging
from sqlalchemy.orm import Session, attributes # Added attributes
import uuid
from typing import List, Optional, Dict, Any # Added Dict, Any

from .. import models, schemas

logger = logging.getLogger(__name__)

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_generic(filename: str, data_type_name: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"{data_type_name} seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {data_type_name} seed file {filepath}: {e}")
        return []

def get_skill_template(db: Session, skill_template_id: uuid.UUID) -> Optional[models.SkillTemplate]:
    return db.query(models.SkillTemplate).filter(models.SkillTemplate.id == skill_template_id).first()

def get_skill_template_by_tag(db: Session, skill_id_tag: str) -> Optional[models.SkillTemplate]:
    return db.query(models.SkillTemplate).filter(models.SkillTemplate.skill_id_tag == skill_id_tag).first()

def get_skill_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.SkillTemplate]:
    return db.query(models.SkillTemplate).offset(skip).limit(limit).all()

def create_skill_template(db: Session, *, template_in: schemas.SkillTemplateCreate) -> models.SkillTemplate:
    # Removed unique check here as seeder will handle it before calling create.
    # For direct API calls, a unique constraint on DB + try/except IntegrityError is better.
    db_template = models.SkillTemplate(**template_in.model_dump())
    db.add(db_template)
    # Commit and refresh handled by caller, e.g., the seeder.
    return db_template

def update_skill_template(
    db: Session, *, 
    db_template: models.SkillTemplate, 
    template_in: schemas.SkillTemplateUpdate
) -> models.SkillTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    changed = False
    
    if "skill_id_tag" in update_data and update_data["skill_id_tag"] != db_template.skill_id_tag:
        existing_with_new_tag = get_skill_template_by_tag(db, skill_id_tag=update_data["skill_id_tag"])
        if existing_with_new_tag and existing_with_new_tag.id != db_template.id:
            logger.warning(f"Cannot update skill_id_tag for '{db_template.name}' to '{update_data['skill_id_tag']}', it's already in use by '{existing_with_new_tag.name}'. Skipping tag update.")
            del update_data["skill_id_tag"] # Don't attempt to update the tag
        elif "skill_id_tag" in update_data : # If tag can be updated (not caught by above)
            setattr(db_template, "skill_id_tag", update_data["skill_id_tag"])
            changed = True

    for field, value in update_data.items():
        if field == "skill_id_tag": continue # Already handled

        if getattr(db_template, field) != value:
            setattr(db_template, field, value)
            if field in ['effects_data', 'requirements_data']: # JSONB fields
                attributes.flag_modified(db_template, field)
            changed = True
            
    if changed:
        db.add(db_template)
    return db_template

def delete_skill_template(db: Session, skill_template_id: uuid.UUID) -> Optional[models.SkillTemplate]:
    db_template = get_skill_template(db, skill_template_id)
    if db_template:
        db.delete(db_template)
        db.commit() # Deletion is usually a direct action, commit immediately.
    return db_template

# --- Seeding Initial Skill Templates ---
def seed_initial_skill_templates(db: Session):
    logger.info("Attempting to seed initial skill templates from skills.json...")
    skill_template_definitions = _load_seed_data_generic("skills.json", "Skill template")

    if not skill_template_definitions:
        logger.warning("No skill template definitions found or error loading skills.json. Aborting skill template seeding.")
        return

    seeded_count = 0
    updated_count = 0
    skipped_count = 0

    for template_data in skill_template_definitions:
        template_tag = template_data.get("skill_id_tag")
        template_name = template_data.get("name") 
        if not template_tag or not template_name:
            logger.warning(f"Skipping skill template entry due to missing skill_id_tag or name: {template_data}")
            skipped_count += 1
            continue
        
        existing_template = get_skill_template_by_tag(db, skill_id_tag=template_tag)
        
        try:
            if existing_template:
                template_update_schema = schemas.SkillTemplateUpdate(**template_data)
                update_skill_template(db, db_template=existing_template, template_in=template_update_schema)
                
                # Simplified check for logging updates
                # A more robust check would compare dicts before and after potential update_skill_template modifications
                # For now, if the object is in session and dirty, it's an update.
                # Or, if update_skill_template itself indicated a change.
                # Let's assume a change if any field in template_data differs from existing_template
                original_dump = schemas.SkillTemplate.from_orm(existing_template).model_dump(exclude={'id'})
                current_data_dump = schemas.SkillTemplateCreate(**template_data).model_dump() # Use Create schema for full data
                
                is_actually_changed = False
                for key, value_from_json in current_data_dump.items():
                    if original_dump.get(key) != value_from_json:
                        is_actually_changed = True
                        break
                if is_actually_changed:
                    logger.info(f"Updating skill template: {template_name} ({template_tag})")
                    updated_count += 1
                else:
                    # logger.debug(f"Skill template '{template_name}' ({template_tag}) exists and no changes detected.")
                    skipped_count +=1
            else: 
                template_create_schema = schemas.SkillTemplateCreate(**template_data)
                logger.info(f"Creating skill template: {template_create_schema.name} ({template_create_schema.skill_id_tag})")
                create_skill_template(db, template_in=template_create_schema)
                seeded_count += 1
        except Exception as e_pydantic_or_db:
            logger.error(f"Validation or DB operation failed for skill template '{template_name}' ({template_tag}): {e_pydantic_or_db}. Data: {template_data}", exc_info=True)
            skipped_count += 1
            db.rollback()
            continue

    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new and {updated_count} updated skill templates.")
            db.commit()
            logger.info("Skill template seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing skill template seeds: {e_commit}. Rolling back.", exc_info=True)
            db.rollback()
    else:
        logger.info("No new skill templates to seed or templates to update. No commit needed for skill templates.")

    logger.info(f"Skill template seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")
--- END OF FILE backend/app/crud/crud_skill.py ---

--- START OF FILE backend/app/crud/crud_trait.py ---
# backend/app/crud/crud_trait.py
import json # For loading JSON
import os   # For path joining
import logging # For logging
from sqlalchemy.orm import Session, attributes # Added attributes
import uuid
from typing import List, Optional, Dict, Any # Added Dict, Any

from .. import models, schemas

logger = logging.getLogger(__name__)

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_generic(filename: str, data_type_name: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"{data_type_name} seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {data_type_name} seed file {filepath}: {e}")
        return []

def get_trait_template(db: Session, trait_template_id: uuid.UUID) -> Optional[models.TraitTemplate]:
    return db.query(models.TraitTemplate).filter(models.TraitTemplate.id == trait_template_id).first()

def get_trait_template_by_tag(db: Session, trait_id_tag: str) -> Optional[models.TraitTemplate]:
    return db.query(models.TraitTemplate).filter(models.TraitTemplate.trait_id_tag == trait_id_tag).first()

def get_trait_templates(db: Session, skip: int = 0, limit: int = 100) -> List[models.TraitTemplate]:
    return db.query(models.TraitTemplate).offset(skip).limit(limit).all()

def create_trait_template(db: Session, *, template_in: schemas.TraitTemplateCreate) -> models.TraitTemplate:
    # Unique check handled by seeder.
    db_template = models.TraitTemplate(**template_in.model_dump())
    db.add(db_template)
    # Commit and refresh handled by caller.
    return db_template

def update_trait_template(
    db: Session, *, 
    db_template: models.TraitTemplate, 
    template_in: schemas.TraitTemplateUpdate
) -> models.TraitTemplate:
    update_data = template_in.model_dump(exclude_unset=True)
    changed = False

    if "trait_id_tag" in update_data and update_data["trait_id_tag"] != db_template.trait_id_tag:
        existing_with_new_tag = get_trait_template_by_tag(db, trait_id_tag=update_data["trait_id_tag"])
        if existing_with_new_tag and existing_with_new_tag.id != db_template.id:
            logger.warning(f"Cannot update trait_id_tag for '{db_template.name}' to '{update_data['trait_id_tag']}', it's already in use by '{existing_with_new_tag.name}'. Skipping tag update.")
            del update_data["trait_id_tag"]
        elif "trait_id_tag" in update_data: # If tag can be updated
             setattr(db_template, "trait_id_tag", update_data["trait_id_tag"])
             changed = True
             
    for field, value in update_data.items():
        if field == "trait_id_tag": continue

        if getattr(db_template, field) != value:
            setattr(db_template, field, value)
            if field in ['effects_data', 'mutually_exclusive_with']: # JSONB fields
                attributes.flag_modified(db_template, field)
            changed = True

    if changed:
        db.add(db_template)
    return db_template

def delete_trait_template(db: Session, trait_template_id: uuid.UUID) -> Optional[models.TraitTemplate]:
    db_template = get_trait_template(db, trait_template_id)
    if db_template:
        db.delete(db_template)
        db.commit() # Deletion is usually a direct action.
    return db_template

# --- Seeding Initial Trait Templates ---
def seed_initial_trait_templates(db: Session):
    logger.info("Attempting to seed initial trait templates from traits.json...")
    trait_template_definitions = _load_seed_data_generic("traits.json", "Trait template")

    if not trait_template_definitions:
        logger.warning("No trait template definitions found or error loading traits.json. Aborting trait template seeding.")
        return

    seeded_count = 0
    updated_count = 0
    skipped_count = 0

    for template_data in trait_template_definitions:
        template_tag = template_data.get("trait_id_tag")
        template_name = template_data.get("name")
        if not template_tag or not template_name:
            logger.warning(f"Skipping trait template entry due to missing trait_id_tag or name: {template_data}")
            skipped_count += 1
            continue
        
        existing_template = get_trait_template_by_tag(db, trait_id_tag=template_tag)
        
        try:
            if existing_template:
                template_update_schema = schemas.TraitTemplateUpdate(**template_data)
                update_trait_template(db, db_template=existing_template, template_in=template_update_schema)

                original_dump = schemas.TraitTemplate.from_orm(existing_template).model_dump(exclude={'id'})
                current_data_dump = schemas.TraitTemplateCreate(**template_data).model_dump()
                is_actually_changed = False
                for key, value_from_json in current_data_dump.items():
                    if original_dump.get(key) != value_from_json:
                        is_actually_changed = True
                        break
                if is_actually_changed:
                    logger.info(f"Updating trait template: {template_name} ({template_tag})")
                    updated_count += 1
                else:
                    # logger.debug(f"Trait template '{template_name}' ({template_tag}) exists and no changes detected.")
                    skipped_count +=1
            else:
                template_create_schema = schemas.TraitTemplateCreate(**template_data)
                logger.info(f"Creating trait template: {template_create_schema.name} ({template_create_schema.trait_id_tag})")
                create_trait_template(db, template_in=template_create_schema)
                seeded_count += 1
        except Exception as e_pydantic_or_db:
            logger.error(f"Validation or DB operation failed for trait template '{template_name}' ({template_tag}): {e_pydantic_or_db}. Data: {template_data}", exc_info=True)
            skipped_count += 1
            db.rollback()
            continue

    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new and {updated_count} updated trait templates.")
            db.commit()
            logger.info("Trait template seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing trait template seeds: {e_commit}. Rolling back.", exc_info=True)
            db.rollback()
    else:
        logger.info("No new trait templates to seed or templates to update. No commit needed for trait templates.")

    logger.info(f"Trait template seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")
--- END OF FILE backend/app/crud/crud_trait.py ---

--- START OF FILE backend/app/seeds/skills.json ---
[
  {
    "skill_id_tag": "basic_punch",
    "name": "Basic Punch",
    "description": "A simple, untrained punch. It's better than harsh language. Usually.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {"mana_cost": 0, "damage_dice_override": "1d2", "attack_bonus_add": 0, "damage_bonus_add": 0, "uses_strength_for_bonus": true},
    "requirements_data": {"min_level": 1},
    "cooldown": 0
  },
  {
    "skill_id_tag": "power_attack_melee",
    "name": "Power Attack",
    "description": "A forceful melee attack that is harder to land but deals more damage with your equipped weapon.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 5, 
        "attack_roll_modifier": -2,
        "damage_modifier_flat": 3,
        "uses_equipped_weapon": true 
    },
    "requirements_data": {"min_level": 2, "required_stats": {"strength": 12}},
    "cooldown": 2
  },
  {
    "skill_id_tag": "pick_lock_basic",
    "name": "Pick Lock (Basic)",
    "description": "Attempt to pick a simple lock on a door or container. Requires lockpicks.",
    "skill_type": "UTILITY_OOC",
    "target_type": "DOOR", 
    "effects_data": {
        "check_attribute": "dexterity", 
        "base_dc_override_for_skill": null,
        "requires_item_tag_equipped_or_inventory": "basic_lockpicks"
    },
    "requirements_data": {"min_level": 1},
    "cooldown": 10 
  },
  {
    "skill_id_tag": "shield_bash_active",
    "name": "Shield Bash",
    "description": "Slam your shield into an opponent, potentially dazing them.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 8,
        "damage_dice_override": "1d4",
        "attack_bonus_add": 0,
        "damage_bonus_add_from_stat": "strength",
        "status_effect_apply": {"effect_tag": "dazed", "duration_rounds": 1, "chance_percent": 30},
        "requires_item_type_equipped": "shield"
    },
    "requirements_data": {"min_level": 3, "required_stats": {"strength": 13}},
    "cooldown": 3
  },
  {
    "skill_id_tag": "cleave_melee_active",
    "name": "Cleave",
    "description": "Swing your weapon in a wide arc, hitting an additional nearby enemy if one is present.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 10,
        "uses_equipped_weapon": true,
        "aoe_targets_additional": 1, 
        "aoe_shape": "arc_front"
    },
    "requirements_data": {"min_level": 5, "required_stats": {"strength": 14}},
    "cooldown": 4
  },
  {
    "skill_id_tag": "backstab_melee_active",
    "name": "Backstab",
    "description": "Exploit an opponent's distraction for a devastating attack. Requires stealth or target to be unaware.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {
        "mana_cost": 7,
        "damage_multiplier": 2.0, 
        "uses_equipped_weapon": true,
        "requires_condition": ["target_unaware", "user_stealthed"] 
    },
    "requirements_data": {"min_level": 2, "required_stats": {"dexterity": 13}},
    "cooldown": 1
  },
  {
    "skill_id_tag": "hide_in_shadows_utility",
    "name": "Hide in Shadows",
    "description": "Attempt to melt into the shadows, becoming harder to detect.",
    "skill_type": "UTILITY_OOC", 
    "target_type": "SELF",
    "effects_data": {
        "mana_cost": 5,
        "status_effect_apply": {"effect_tag": "stealthed", "duration_seconds": 60, "check_vs_perception_dc": 10}
    },
    "requirements_data": {"min_level": 4, "required_stats": {"dexterity": 14}},
    "cooldown": 30
  },
  {
    "skill_id_tag": "minor_heal_active",
    "name": "Minor Heal",
    "description": "A weak divine spell that mends minor wounds.",
    "skill_type": "COMBAT_ACTIVE", 
    "target_type": "FRIENDLY_CHAR_OR_SELF",
    "effects_data": {"mana_cost": 6, "heal_dice": "1d6", "heal_bonus_from_stat": "wisdom"},
    "requirements_data": {"min_level": 1},
    "cooldown": 1
  },
  {
    "skill_id_tag": "bless_buff_active",
    "name": "Bless",
    "description": "Invoke divine favor upon an ally, improving their combat prowess.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "FRIENDLY_CHAR_OR_SELF",
    "effects_data": {
        "mana_cost": 10,
        "status_effect_apply": {"effect_tag": "blessed_buff", "duration_rounds": 5, "bonuses": {"attack_roll": 1, "damage_roll": 1}}
    },
    "requirements_data": {"min_level": 1, "required_stats": {"wisdom": 12}},
    "cooldown": 0
  },
  {
    "skill_id_tag": "magic_missile_active",
    "name": "Magic Missile",
    "description": "Launch a missile of magical energy that unerringly strikes its target.",
    "skill_type": "COMBAT_ACTIVE",
    "target_type": "ENEMY_MOB",
    "effects_data": {"mana_cost": 4, "damage_dice_override": "1d4+1", "damage_type": "force", "always_hits": true},
    "requirements_data": {"min_level": 1},
    "cooldown": 0
  },
  {
    "skill_id_tag": "light_cantrip_utility",
    "name": "Light",
    "description": "Create a hovering light source that illuminates the area.",
    "skill_type": "UTILITY_OOC",
    "target_type": "SELF",
    "effects_data": {"mana_cost": 2, "status_effect_apply": {"effect_tag": "magical_light", "duration_seconds": 300}},
    "requirements_data": {"min_level": 1},
    "cooldown": 5
  },
  {
    "skill_id_tag": "first_aid_basic_utility",
    "name": "Basic First Aid",
    "description": "Apply basic bandaging to stop bleeding and slightly mend wounds outside of combat.",
    "skill_type": "UTILITY_OOC",
    "target_type": "SELF", 
    "effects_data": {"heal_amount_fixed": 5, "cooldown_seconds": 60, "requires_item_tag_consumed": "bandages_basic", "consume_chance": 75},
    "requirements_data": {"min_level": 2},
    "cooldown": 60
  }
]
--- END OF FILE backend/app/seeds/skills.json ---

--- START OF FILE backend/app/seeds/traits.json ---
[
  {
    "trait_id_tag": "tough_hide",
    "name": "Tough Hide",
    "description": "Your skin is naturally resilient, granting a small bonus to your Armor Class.",
    "trait_type": "PASSIVE", 
    "effects_data": {"ac_bonus_natural": 1}
  },
  {
    "trait_id_tag": "weapon_focus_swords_passive",
    "name": "Weapon Focus (Swords)",
    "description": "You are more accurate when wielding swords.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_bonus": {"condition_item_type_equipped": "sword", "attack_bonus": 1}}
  },
  {
    "trait_id_tag": "improved_vitality_passive",
    "name": "Improved Vitality",
    "description": "You gain more health points per level.",
    "trait_type": "PASSIVE",
    "effects_data": {"hp_gain_per_level_bonus": 1}
  },
  {
    "trait_id_tag": "nimble_fingers_passive",
    "name": "Nimble Fingers",
    "description": "You are adept at tasks requiring fine motor skills, such as picking locks.",
    "trait_type": "PASSIVE",
    "effects_data": {"skill_check_bonus": {"skill_type_tags": ["lockpicking", "disarm_trap"], "bonus_amount": 2}}
  },
  {
    "trait_id_tag": "opportunist_passive",
    "name": "Opportunist",
    "description": "You deal extra damage against distracted or flanked opponents.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_damage_bonus_flat": {"condition_target_status": ["dazed", "stunned", "flanked"], "damage_bonus": 2}}
  },
  {
    "trait_id_tag": "evasion_expert_passive",
    "name": "Evasion Expert",
    "description": "You are skilled at avoiding area attacks.",
    "trait_type": "PASSIVE",
    "effects_data": {"save_bonus_vs_aoe_type": {"effect_type_tags": ["area_effect", "trap_damage"], "bonus_amount": 2}}
  },
  {
    "trait_id_tag": "divine_fortitude_passive",
    "name": "Divine Fortitude",
    "description": "Your faith grants you enhanced resilience to negative effects.",
    "trait_type": "PASSIVE",
    "effects_data": {"save_bonus_vs_negative_status": {"status_tags": ["disease", "poison", "curse"], "bonus_amount": 1}}
  },
  {
    "trait_id_tag": "healing_touch_improved_passive",
    "name": "Improved Healing Touch",
    "description": "Your healing spells are more potent.",
    "trait_type": "PASSIVE",
    "effects_data": {"healing_spell_potency_bonus_flat": 2}
  },
  {
    "trait_id_tag": "divine_guidance_passive",
    "name": "Divine Guidance",
    "description": "Your connection to the divine enhances your wisdom.",
    "trait_type": "PASSIVE",
    "effects_data": {"stat_bonus_permanent": {"wisdom": 1}}
  },
  {
    "trait_id_tag": "arcane_attunement_passive",
    "name": "Arcane Attunement",
    "description": "You have a greater pool of magical energy.",
    "trait_type": "PASSIVE",
    "effects_data": {"max_mana_bonus_flat": 10}
  },
  {
    "trait_id_tag": "spell_penetration_minor_passive",
    "name": "Minor Spell Penetration",
    "description": "Your offensive spells are slightly more effective against resistant foes.",
    "trait_type": "PASSIVE",
    "effects_data": {"spell_penetration_value": 1}
  },
  {
    "trait_id_tag": "elemental_focus_fire_passive",
    "name": "Elemental Focus (Fire)",
    "description": "Your fire-based spells deal more damage.",
    "trait_type": "PASSIVE",
    "effects_data": {"conditional_damage_bonus_percent": {"spell_damage_type": "fire", "bonus_percent": 10}}
  },
  {
    "trait_id_tag": "jack_of_all_trades_xp_bonus_passive",
    "name": "Jack of All Trades",
    "description": "You learn quickly from a variety of experiences, gaining a small bonus to all experience earned.",
    "trait_type": "PASSIVE",
    "effects_data": {"xp_gain_modifier_percent": 3}
  },
  {
    "trait_id_tag": "hardy_survivor_passive",
    "name": "Hardy Survivor",
    "description": "Years of adventuring have made you tougher, granting a small bonus to your maximum health.",
    "trait_type": "PASSIVE",
    "effects_data": {"max_health_bonus_flat": 5}
  }
]
--- END OF FILE backend/app/seeds/traits.json ---

--- START OF FILE backend/app/seeds/character_classes.json ---
[
  {
    "name": "Warrior",
    "description": "A stalwart fighter, skilled in the arts of melee combat and enduring hardship. Warriors excel at both dealing and absorbing damage on the front lines.",
    "base_stat_modifiers": {"strength": 2, "constitution": 1, "intelligence": -1, "charisma": -1},
    "starting_health_bonus": 10,
    "starting_mana_bonus": -5,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch"],
            "2": ["power_attack_melee"],
            "3": ["shield_bash_active"],
            "5": ["cleave_melee_active"]
        },
        "core_traits_by_level": {
            "1": ["tough_hide"],
            "2": ["weapon_focus_swords_passive"],
            "4": ["improved_vitality_passive"]
        }
    },
    "starting_equipment_refs": ["Rusty Sword", "Wooden Shield", "Cloth Tunic"],
    "playstyle_tags": ["melee", "tank", "physical_dps", "durable"],
    "stat_gains_per_level": {
        "hp": 6, 
        "mp": 1, 
        "base_attack_bonus": 0.75
    }
  },
  {
    "name": "Swindler",
    "description": "A cunning rogue who relies on wit, agility, and a sharp blade. Swindlers are masters of stealth, deception, and exploiting weaknesses.",
    "base_stat_modifiers": {"dexterity": 2, "luck": 1, "strength": -1, "wisdom": -1},
    "starting_health_bonus": -5,
    "starting_mana_bonus": 5,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch", "pick_lock_basic"],
            "2": ["backstab_melee_active"],
            "4": ["hide_in_shadows_utility"]
        },
        "core_traits_by_level": {
            "1": ["nimble_fingers_passive"],
            "3": ["opportunist_passive"],
            "5": ["evasion_expert_passive"]
        }
    },
    "starting_equipment_refs": ["Dagger", "Lockpicks", "Cloth Tunic"],
    "playstyle_tags": ["melee", "stealth", "utility", "debuff", "skill_monkey"],
    "stat_gains_per_level": {
        "hp": 4, 
        "mp": 2, 
        "base_attack_bonus": 0.5 
    }
  },
  {
    "name": "Acolyte",
    "description": "A devout follower of a divine power, wielding faith as both shield and weapon. Acolytes can mend wounds, bolster allies, and smite the unholy.",
    "base_stat_modifiers": {"wisdom": 2, "charisma": 1, "dexterity": -1, "strength": -1},
    "starting_health_bonus": 0,
    "starting_mana_bonus": 10,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["minor_heal_active", "bless_buff_active"],
            "3": ["smite_evil_active"],
            "5": ["turn_undead_active"]
        },
        "core_traits_by_level": {
            "1": ["divine_fortitude_passive"],
            "2": ["healing_touch_improved_passive"],
            "4": ["divine_guidance_passive"]
        }
    },
    "starting_equipment_refs": ["Wooden Mace", "Holy Symbol", "Cloth Robes"],
    "playstyle_tags": ["caster", "healer", "support", "divine", "anti_undead"],
    "stat_gains_per_level": {
        "hp": 3, 
        "mp": 3, 
        "base_attack_bonus": 0.33 
    }
  },
  {
    "name": "Hedge Wizard",
    "description": "A self-taught practitioner of the arcane arts, drawing power from raw talent and forbidden lore. Hedge Wizards command elemental forces and subtle illusions.",
    "base_stat_modifiers": {"intelligence": 2, "wisdom": 1, "constitution": -1, "strength": -1},
    "starting_health_bonus": -5,
    "starting_mana_bonus": 15,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["magic_missile_active", "light_cantrip_utility"],
            "3": ["fireball_small_active"],
            "5": ["invisibility_short_utility"]
        },
        "core_traits_by_level": {
            "1": ["arcane_attunement_passive"],
            "2": ["spell_penetration_minor_passive"],
            "4": ["elemental_focus_fire_passive"]
        }
    },
    "starting_equipment_refs": ["Quarterstaff", "Spellbook (Blank)", "Cloth Robes"],
    "playstyle_tags": ["caster", "arcane", "elemental_dps", "utility_magic", "glass_cannon"],
    "stat_gains_per_level": {
        "hp": 2, 
        "mp": 4, 
        "base_attack_bonus": 0.33
    }
  },
  {
    "name": "Adventurer",
    "description": "A jack-of-all-trades, master of none. Ready for anything, prepared for nothing. The path of the Adventurer is one of versatility and adaptability.",
    "base_stat_modifiers": {}, 
    "starting_health_bonus": 0,
    "starting_mana_bonus": 0,
    "skill_tree_definition": {
        "core_skills_by_level": {
            "1": ["basic_punch"],
            "2": ["first_aid_basic_utility"] 
        },
        "core_traits_by_level": {
            "1": ["jack_of_all_trades_xp_bonus_passive"],
            "3": ["hardy_survivor_passive"]
        }
    },
    "starting_equipment_refs": ["Dagger", "Cloth Tunic", "Basic Healing Draught"],
    "playstyle_tags": ["versatile", "generalist", "beginner_friendly"],
    "stat_gains_per_level": {
        "hp": 4, 
        "mp": 2, 
        "base_attack_bonus": 0.5
    }
  }
]
--- END OF FILE backend/app/seeds/character_classes.json ---

--- START OF FILE frontend/src/state/gameStore.js ---
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { apiService } from '../services/apiService';
import { v4 as uuidv4 } from 'uuid'; // You need to have run 'npm install uuid'

// This helper function creates the structured log object our frontend now expects.
// It needs to be defined at the top level of the module so it's accessible.
const createLogLine = (data, type = 'html') => ({
  id: uuidv4(),
  type,
  data,
});

const initialState = {
  sessionState: 'LOGGED_OUT',
  token: null,
  characterId: null,
  characterName: '',
  characterClass: '',
  characterLevel: 1,
  characterList: [],
  classTemplates: [],
  logLines: [
    createLogLine('<span class="system-message-inline">Zustand brain is online. Please log in.</span>')
  ],
  vitals: {
    hp: { current: 100, max: 100 },
    mp: { current: 50, max: 50 },
    xp: { current: 0, max: 100 },
    platinum: 0, gold: 0, silver: 0, copper: 0,
  },
  mapData: null,
  currentRoomId: null,
  activeTab: 'Terminal',
  characterStats: null,
  inventory: null,
  abilities: null,
  whoListData: null,
};


const useGameStore = create(
  immer((set, get) => ({
    ...initialState,

    // === ACTIONS ===
    setSessionState: (newState) => set({ sessionState: newState }),
    login: (token) => set({ token: token, sessionState: 'CHAR_SELECT' }),
    startCharacterCreation: () => set({ sessionState: 'CHAR_CREATE' }),
    setClassTemplates: (templates) => set({ classTemplates: templates }),
    finishCharacterCreation: () => set({ sessionState: 'CHAR_SELECT' }),
    setCharacterList: (characters) => set({ characterList: characters }),

    selectCharacter: (character) => {
      set((state) => {
        state.characterId = character.id;
        state.characterName = character.name;
        state.characterClass = character.class_name;
        state.characterLevel = character.level;
        state.currentRoomId = character.current_room_id;
        state.sessionState = 'IN_GAME';
        state.logLines = [createLogLine(`<span class="system-message-inline">Welcome, ${character.name}!</span>`)];
      });
      get().fetchMapData();
    },

    addLogLine: (data, type = 'html') => {
      set((state) => {
        state.logLines.push(createLogLine(data, type));
      });
    },

    setVitals: (vitalsUpdate) => {
      set((state) => {
        if (vitalsUpdate.current_hp !== undefined) state.vitals.hp.current = vitalsUpdate.current_hp;
        if (vitalsUpdate.max_hp !== undefined) state.vitals.hp.max = vitalsUpdate.max_hp;
        if (vitalsUpdate.current_mp !== undefined) state.vitals.mp.current = vitalsUpdate.current_mp;
        if (vitalsUpdate.max_mp !== undefined) state.vitals.mp.max = vitalsUpdate.max_mp;
        if (vitalsUpdate.current_xp !== undefined) state.vitals.xp.current = vitalsUpdate.current_xp;
        if (vitalsUpdate.next_level_xp !== undefined) state.vitals.xp.max = vitalsUpdate.next_level_xp;
        if (vitalsUpdate.platinum !== undefined) state.vitals.platinum = vitalsUpdate.platinum;
        if (vitalsUpdate.gold !== undefined) state.vitals.gold = vitalsUpdate.gold;
        if (vitalsUpdate.silver !== undefined) state.vitals.silver = vitalsUpdate.silver;
        if (vitalsUpdate.copper !== undefined) state.vitals.copper = vitalsUpdate.copper;
        if (vitalsUpdate.level !== undefined) state.characterLevel = vitalsUpdate.level;
      });
    },

    setInventory: (inventoryData) => {
      set({ inventory: inventoryData });
    },

    setActiveTab: (tabName) => {
      set({ activeTab: tabName });
      const state = get();
      if (tabName === 'Score' && !state.characterStats) {
        state.fetchScoreSheet();
      }
      if ((tabName === 'Backpack' || tabName === 'Equipment') && !state.inventory) {
        state.fetchInventory();
      }
      if ((tabName === 'Skills/Spells' || tabName === 'Traits') && !state.abilities) {
        state.fetchAbilities();
      }
    },

    fetchAbilities: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const abilitiesData = await apiService.fetchAbilities(token);
        set({ abilities: abilitiesData });
      } catch (error) {
        console.error("Failed to fetch abilities:", error);
        get().addLogLine("! Could not retrieve skills and traits list.");
      }
    },

    fetchScoreSheet: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const charDetails = await apiService.fetchCharacterDetails(token);
        set({ characterStats: charDetails });
      } catch (error) {
        console.error("Failed to fetch score sheet:", error);
        get().addLogLine("! Could not retrieve character score sheet.");
      }
    },

    fetchInventory: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const inventoryData = await apiService.fetchInventory(token);
        set({ inventory: inventoryData });
      } catch (error) {
        console.error("Failed to fetch inventory:", error);
        get().addLogLine("! Could not retrieve inventory.");
      }
    },

    fetchMapData: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const mapData = await apiService.fetchMapData(token);
        set({ mapData: mapData });
      } catch (error) {
        console.error("Failed to fetch map data:", error);
        get().addLogLine("! Failed to load map data.");
      }
    },

    fetchWhoList: async () => {
      get().addLogLine("! 'Who' command not yet implemented.");
    },

    logout: () => {
      set({ ...initialState, logLines: [createLogLine('<span class="system-message-inline">You have been logged out. Please log in again.</span>')] });
    },
  }))
);

export default useGameStore;
--- END OF FILE frontend/src/state/gameStore.js ---

--- START OF FILE frontend/src/services/webSocketService.js ---
import useGameStore from '../state/gameStore';

const WS_PROTOCOL = 'wss:';
const WS_HOST = 'llmud.trazen.org';

const { getState, setState } = useGameStore;    

let socket = null;

// --- THE NEW MASTER SCRIBE FOR LOGS ---
// This ensures every log entry is an object with a unique, stable ID.
// This is CRITICAL for React performance.
let logIdCounter = 0;
const createLogEntry = (type, data) => ({
  id: `log-${logIdCounter++}`,
  type: type,
  data: data,
});

const handleMessage = (event) => {
    try {
        const serverData = JSON.parse(event.data);
        console.log("WS RCV:", serverData); // Keep this for debugging, it's invaluable

        switch (serverData.type) {
            case "welcome_package":
                setState((state) => {
                    // Welcome package logs are also just HTML
                    if (serverData.log && serverData.log.length > 0) {
                        const newLogEntries = serverData.log.map(line => createLogEntry('html', line));
                        state.logLines.push(...newLogEntries);
                    }
                    if (serverData.character_vitals) {
                        state.vitals.hp.current = serverData.character_vitals.current_hp;
                        state.vitals.hp.max = serverData.character_vitals.max_hp;
                        state.vitals.mp.current = serverData.character_vitals.current_mp;
                        state.vitals.mp.max = serverData.character_vitals.max_mp;
                        state.vitals.xp.current = serverData.character_vitals.current_xp;
                        if (serverData.character_vitals.next_level_xp !== undefined) {
                            state.vitals.xp.max = serverData.character_vitals.next_level_xp;
                        }
                        state.characterLevel = serverData.character_vitals.level;
                    }
                    if (serverData.room_data) {
                        state.currentRoomId = serverData.room_data.id;
                    }
                });
                break;

            case "combat_update":
                setState((state) => {
                    // Combat logs are arrays of HTML strings
                    if (serverData.log && serverData.log.length > 0) {
                        const newLogEntries = serverData.log.map(line => createLogEntry('html', line));
                        state.logLines.push(...newLogEntries);
                    }
                    if (serverData.character_vitals) {
                        state.vitals.hp.current = serverData.character_vitals.current_hp;
                        state.vitals.hp.max = serverData.character_vitals.max_hp;
                        state.vitals.mp.current = serverData.character_vitals.current_mp;
                        state.vitals.mp.max = serverData.character_vitals.max_mp;
                        state.vitals.xp.current = serverData.character_vitals.current_xp;
                        if (serverData.character_vitals.next_level_xp !== undefined) {
                            state.vitals.xp.max = serverData.character_vitals.next_level_xp;
                        }
                        state.characterLevel = serverData.character_vitals.level;
                    }
                    if (serverData.room_data) {
                        state.currentRoomId = serverData.room_data.id;
                        if (state.mapData && state.mapData.z_level !== serverData.room_data.z) {
                            state.needsNewMap = true;
                        }
                    }
                    state.isInCombat = !serverData.combat_over;
                });
                if (getState().needsNewMap) {
                    setState({ needsNewMap: false });
                    getState().fetchMapData();
                }
                break;

            case "look_response":
                setState(state => {
                    // This is our special structured log object
                    state.logLines.push(createLogEntry('look', serverData)); 
                });
                break;

            case "vitals_update":
                setState((state) => {
                    state.vitals.hp.current = serverData.current_hp;
                    state.vitals.hp.max = serverData.max_hp;
                    state.vitals.mp.current = serverData.current_mp;
                    state.vitals.mp.max = serverData.max_mp;
                    if (serverData.next_level_xp !== undefined) {
                        state.vitals.xp.max = serverData.next_level_xp;
                    }
                    state.vitals.xp.current = serverData.current_xp;
                    state.characterLevel = serverData.level;
                });
                break;
            
            case "inventory_update":
                console.log("[WS] Received real-time inventory_update.");
                setState(state => {
                    state.inventory = serverData.inventory_data;
                });
                break;

            case "game_event":
            case "ooc_message":
                setState((state) => {
                    // These are single HTML strings
                    state.logLines.push(createLogEntry('html', serverData.message));
                });
                break;

            default:
                console.warn("Unhandled WS message type:", serverData.type);
                // Even for unhandled types, let's log them as plain text
                setState(state => {
                    state.logLines.push(createLogEntry('html', `<span class="system-message-inline">Unhandled event: ${serverData.type}</span>`));
                });
                break;
        }

    } catch (e) {
        console.error("Error parsing or handling WebSocket message:", e);
    }
};

const handleClose = (event) => {
    console.log("WebSocket connection closed:", event.code, event.reason);
    setState({ isInCombat: false });
    socket = null;
    setState(state => {
        const closeMessage = `! Game server connection closed. (Code: ${event.code} ${event.reason || ''})`.trim();
        state.logLines.push(createLogEntry('html', `<span class="system-message-inline">${closeMessage}</span>`));
    });
};

const handleError = (event) => {
    console.error("WebSocket error observed:", event);
    setState(state => {
        state.logLines.push(createLogEntry('html', '<span class="system-message-inline">! WebSocket connection error.</span>'));
    });
};

export const webSocketService = {
    connect: () => {
        const token = getState().token;
        const characterId = getState().characterId;

        if (!token || !characterId) {
            console.error("WS Connect: Missing token or character ID.");
            return;
        }

        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log("WebSocket already open.");
            return;
        }

        const wsUrl = `${WS_PROTOCOL}//${WS_HOST}/ws?token=${token}&character_id=${characterId}`;
        console.log("Attempting WS connection to:", wsUrl);

        socket = new WebSocket(wsUrl);

        socket.onopen = () => console.log("WebSocket connection established.");
        socket.onmessage = handleMessage;
        socket.onclose = handleClose;
        socket.onerror = handleError;
    },

    disconnect: () => {
        if (socket) {
            socket.close();
        }
    },

    sendMessage: (payload) => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(payload));
        } else {
            console.error("Cannot send WS message: Not connected.");
            setState(state => {
                state.logLines.push(createLogEntry('html', '<span class="system-message-inline">! Cannot send command: Not connected to game server.</span>'));
            });
        }
    },
    
    // This is a new helper function we can call from CommandInput.jsx
    // to keep the log creation logic consistent.
    addClientLog: (type, data) => {
        setState(state => {
            state.logLines.push(createLogEntry(type, data));
        })
    }
};
--- END OF FILE frontend/src/services/webSocketService.js ---

--- START OF FILE frontend/src/components/CommandInput.jsx ---
import React, { useState } from 'react';
import { webSocketService } from '../services/webSocketService';
import useGameStore from '../state/gameStore';

function CommandInput() {
  const [inputValue, setInputValue] = useState('');
  const addLogLine = useGameStore((state) => state.addLogLine);
  // Get the action we actually need from the store
  const setActiveTab = useGameStore((state) => state.setActiveTab);

  const handleInputChange = (event) => {
    setInputValue(event.target.value);
  };

  const handleKeyPress = async (event) => {
    if (event.key === 'Enter') {
      const command = inputValue.trim();
      setInputValue('');

      if (!command) return;

      webSocketService.addClientLog('echo', `> ${command}`);
      const [verb] = command.toLowerCase().split(' ');

      // --- CLIENT-SIDE COMMAND INTERCEPTION (NOW WITH WORKING LOGIC) ---
      switch (verb) {
        case 'logout':
          useGameStore.getState().logout();
          return;

        // <<< THIS IS THE FIX. IT NOW CALLS setActiveTab >>>
        case 'terminal':
        case 't':
          setActiveTab('Terminal');
          return;

        case 'score':
        case 'sc':
          setActiveTab('Score');
          return;

        case 'skills':
        case 'skill':
        case 'sk':
          setActiveTab('Skills/Spells');
          return;

        case 'traits':
        case 'trait':
        case 'tr':
          setActiveTab('Traits');
          return;


        // <<< THIS IS THE OTHER FIX. >>>
        case 'backpack':        
        case 'bac':
        case 'ba':
        case 'b':
          setActiveTab('Backpack');
          return;
        
        // <<< ADDED NEW COMMANDS FOR OTHER TABS >>>
        case 'equipment':
        case 'eq':
          setActiveTab('Equipment');
          return;
          
        case 'who':
          setActiveTab('Who');
          return;

        default:
          // If it's not a client-side command, send it to the server.
          webSocketService.sendMessage({ type: "command", command_text: command });
          break;
      }
    }
  };

  return (
    <div id="input-prompt-line" className="terminal-input-line">
      {/* This span is now empty. The '>' is handled entirely by CSS. */}
      <span id="prompt-text"></span>
      <input
        type="text"
        id="commandInput"
        className="terminal-input"
        name="mud_command_line"
        autoFocus
        autoComplete="off"
        placeholder="Type command..."
        value={inputValue}
        onChange={handleInputChange}
        onKeyPress={handleKeyPress}
      />
    </div>
  );
}

export default CommandInput;
--- END OF FILE frontend/src/components/CommandInput.jsx ---

--- START OF FILE frontend/src/components/TerminalOutput.jsx ---
import React from 'react';
import LookResult from './LookResult';

// Use React.forwardRef to allow the parent to get a ref to the inner div
const TerminalOutput = React.forwardRef(function TerminalOutput({ logLines }, ref) {
  return (
    // Attach the forwarded ref to the div that actually scrolls
    <div id="output" className="terminal-output" ref={ref}>
      {logLines.map((line) => {
        const key = line.id || Math.random(); // Use a fallback key just in case

        // Your existing rendering logic is correct
        if (typeof line.data === 'object' && line.data !== null && line.type === 'look') {
          return (
            <div key={key} className="terminal-line look-result-wrapper">
              <LookResult data={line.data} />
            </div>
          );
        }
        
        return (
          <div
            key={key}
            className="terminal-line"
            dangerouslySetInnerHTML={{ __html: line.data }}
          />
        );
      })}
    </div>
  );
});

export default TerminalOutput;
--- END OF FILE frontend/src/components/TerminalOutput.jsx ---

--- START OF FILE frontend/src/components/GameLayout.jsx ---
// frontend/src/components/GameLayout.jsx
import React from 'react';
import TabBar from './TabBar';
import TabContent from './TabbedWindow';
import CharacterInfoBar from './CharacterInfoBar';
import VitalsMonitor from './VitalsMonitor';
import BottomInfoBar from './BottomInfoBar';
import CommandInput from './CommandInput';
import Map from './Map';

// CSS IMPORTS - THE HOLY TEMPLE
import './TabBar.css';
import './TabbedWindow.css';
import './Terminal.css'; // This is the one we were missing.
import './CharacterInfoBar.css';
import './VitalsMonitor.css';
import './BottomInfoBar.css';
import './Map.css';

import './GroundItems.css'; // Importing GroundItems styles
import './LookResult.css'; // Importing LookResult styles

import './AbilityList.css'; 

function GameLayout() {
  return (
    <>
      <header className="header-text">
        {/* Header stuff */}
      </header>
      <div className="game-area-wrapper">
        <div className="mud-container">
          <CharacterInfoBar />
          <div className="terminal-window-container">
            <TabBar />
            <TabContent />
          </div>
          <div className="game-footer-bar">
            <BottomInfoBar />
            <VitalsMonitor />
            <CommandInput />
          </div>
        </div>
        <Map />
      </div>
    </>
  );
}

export default GameLayout;
--- END OF FILE frontend/src/components/GameLayout.jsx ---

--- START OF FILE frontend/src/components/TabbedWindow.jsx ---
import React, { useEffect, useRef } from 'react';
import useGameStore from '../state/gameStore';

// Import the content components
import TerminalOutput from './TerminalOutput';
import ScoreSheet from './ScoreSheet';
import Inventory from './Inventory';
import SkillsList from './SkillsList';
import TraitsList from './TraitsList';
// No CSS import here if GameLayout handles it.

const TabContent = () => {
  const activeTab = useGameStore((state) => state.activeTab);
  const logLines = useGameStore((state) => state.logLines);
  
  // This ref will be FORWARDED to the TerminalOutput component
  const terminalOutputRef = useRef(null);

  useEffect(() => {
    // We only scroll if the active tab is Terminal and the ref is attached
    if (activeTab === 'Terminal' && terminalOutputRef.current) {
      const element = terminalOutputRef.current;
      // Scroll the actual overflowing element to the bottom
      element.scrollTop = element.scrollHeight;
    }
  }, [logLines, activeTab]); // Re-run when new lines are added to the terminal

  const renderActiveTab = () => {
    switch (activeTab) {
      case 'Terminal':
        // Pass the ref down to the component that has the scrollbar
        return <TerminalOutput ref={terminalOutputRef} logLines={logLines} />;
      case 'Score':
        return <ScoreSheet />;
      case 'Backpack':
      case 'Equipment':
        return <Inventory />;
      case 'Skills/Spells':
        return <SkillsList />;
      case 'Traits':
        return <TraitsList />;
      default:
        return <div className="placeholder-content">The '{activeTab}' tab is under construction. Now fuck off.</div>;
    }
  };

  // The wrapper is now just a simple div. No refs, no special classes.
  return (
    <div className="tab-content-wrapper">
      {renderActiveTab()}
    </div>
  );
};

export default TabContent;
--- END OF FILE frontend/src/components/TabbedWindow.jsx ---

--- START OF FILE frontend/src/components/SkillsList.jsx ---
import React from 'react';
import useGameStore from '../state/gameStore';

const SkillsList = () => {
  const abilities = useGameStore((state) => state.abilities);

  if (!abilities) {
    return <div>Loading skills...</div>;
  }

  return (
    <div className="ability-list-container">
      <h3 className="ability-list-header">Skills & Spells</h3>
      {abilities.skills.map((skill) => (
        <div key={skill.name} className={`ability-entry ${skill.has_learned ? 'learned' : 'unlearned'}`}>
          <div className="ability-header">
            <span className="ability-level">[Lvl {skill.level_required}]</span>
            <span className="ability-name">{skill.name}</span>
          </div>
          <p className="ability-description">{skill.description}</p>
        </div>
      ))}
    </div>
  );
};

export default SkillsList;
--- END OF FILE frontend/src/components/SkillsList.jsx ---

--- START OF FILE frontend/src/components/TraitsList.jsx ---
import React from 'react';
import useGameStore from '../state/gameStore';


const TraitsList = () => {
  const abilities = useGameStore((state) => state.abilities);

  if (!abilities) {
    return <div>Loading traits...</div>;
  }

  return (
    <div className="ability-list-container">
      <h3 className="ability-list-header">Traits</h3>
      {abilities.traits.map((trait) => (
        <div key={trait.name} className={`ability-entry ${trait.has_learned ? 'learned' : 'unlearned'}`}>
          <div className="ability-header">
            <span className="ability-level">[Lvl {trait.level_required}]</span>
            <span className="ability-name">{trait.name}</span>
          </div>
          <p className="ability-description">{trait.description}</p>
        </div>
      ))}
    </div>
  );
};

export default TraitsList;
--- END OF FILE frontend/src/components/TraitsList.jsx ---

--- CORE FILE NOT FOUND: frontend/src/components/ChatWindow.jsx ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
