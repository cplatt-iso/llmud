--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Sun Jun  8 04:14:29 AM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_npc.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/npc_dialogue_ticker.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/npc_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/npc.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/character_classes.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/loot_tables.json
backend/app/seeds/mob_spawn_definitions.json
backend/app/seeds/mob_templates.json
backend/app/seeds/npcs.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
bundle_context.sh
frontend/src/api.js
frontend/src/config.js
frontend/src/index.html
frontend/src/main.js
frontend/src/map.js
frontend/src/script.js
frontend/src/state.js
frontend/src/style.css
frontend/src/ui.js
frontend/src/websocket.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed." >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh"
    "README.md"

    # --- Backend - Core application & Logging ---
    "$BACKEND_APP_DIR/main.py"
    "$BACKEND_APP_DIR/core/config.py"
    "$BACKEND_APP_DIR/websocket_router.py"    # For routing new commands

    # --- Backend - PRIMARY FOCUS FOR NEXT STEPS (Shops, NPCs, and Commerce) ---
    # "$BACKEND_APP_DIR/commands/shop_parser.py"       # CRITICAL: We will create this file for list/buy commands.
    "$BACKEND_APP_DIR/crud/crud_character.py"         # CRITICAL: For update_character_currency
    "$BACKEND_APP_DIR/crud/crud_character_inventory.py" # CRITICAL: For add_item_to_character_inventory
    "$BACKEND_APP_DIR/crud/crud_npc.py"               # CRITICAL: For getting NPC data
    "$BACKEND_APP_DIR/crud/crud_item.py"              # CRITICAL: For getting item price/value
    "$BACKEND_APP_DIR/commands/utils.py"              # IMPORTANT: For formatting shop lists
    "$BACKEND_APP_DIR/game_logic/npc_dialogue_ticker.py" # IMPORTANT: The AI part we just built
    "$BACKEND_APP_DIR/services/world_service.py"        # IMPORTANT: Where our broadcast logic lives

    # --- Backend - Essential Models for Shop Logic ---
    "$BACKEND_APP_DIR/models/item.py"               # Defines item value
    "$BACKEND_APP_DIR/models/character.py"          # Defines player currency
    "$BACKEND_APP_DIR/models/character_inventory_item.py" # The destination for purchased items
    "$BACKEND_APP_DIR/models/npc_template.py"       # Defines the NPC and their shop_inventory
    "$BACKEND_APP_DIR/models/room.py"               # Defines npc_placements

    # --- Backend - Essential Schemas for Shop Logic ---
    "$BACKEND_APP_DIR/schemas/item.py"
    "$BACKEND_APP_DIR/schemas/character.py"
    "$BACKEND_APP_DIR/schemas/npc.py"
    "$BACKEND_APP_DIR/schemas/room.py"

    # --- Seed Data (ABSOLUTELY CRITICAL) ---
    "$BACKEND_APP_DIR/seeds/npcs.json"                  # MAJOR FOCUS: Defines what merchants sell
    "$BACKEND_APP_DIR/seeds/items.json"                 # MAJOR FOCUS: Defines item properties and prices
    "$BACKEND_APP_DIR/seeds/rooms_z0.json"              # For placing the shops
    "$BACKEND_APP_DIR/seeds/loot_tables.json"           # For context on the game economy
    "$BACKEND_APP_DIR/seeds/mob_spawn_definitions.json" # For world context

    # --- Frontend (Relevant for displaying shop info) ---
    "$FRONTEND_SRC_DIR/main.js"      # To see if command submission or response handling breaks
    "$FRONTEND_SRC_DIR/ui.js"        # If shop list formatting needs CSS tweaks
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (✨💰💪🧩💀🚪) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Flesh out the damn world - Gear, Loot, and More Seeds!

The map is less of an abstract nightmare, and the core gameplay loop is... loopy. Now we need to make the interactions richer and the world feel less empty.

*   **Full Equipment System:** Define all equipment slots. Implement robust `equip` and `unequip` logic. Ensure stats update correctly.
*   **Mob Loot Tables:** Mobs need to drop more than just coins. Define loot tables (specific items, random items from categories, chances).
*   **Seed More Content (Externalize ALL THE THINGS):**
    *   `mob_templates.json`
    *   `character_classes.json`
    *   `skills.json`
    *   `traits.json`
    *   `mob_spawn_definitions.json`
    *   Update corresponding CRUD seeders to load from these JSONs.
*   **Seed Initial Equipment:** Place starting gear on character creation or in initial rooms.

This will involve a lot of backend work (models, CRUD, game logic) and careful JSON schema design for the seed files.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/main.py ---
# backend/app/main.py
import asyncio
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
import sys # For detailed print statements
from app.core.config import settings
import logging # Import logging

# --- Setup Logging First ---
# This needs to happen before other modules that might use logging are imported,
# or at least before they try to log.
try:
    from app.core.logging_config import setup_logging
    setup_logging()
    print("--- MAIN.PY: setup_logging() CALLED (no exception caught) ---", flush=True)
except ImportError as e_log_setup:
    print(f"--- CRITICAL: main.py - FAILED to import or run setup_logging: {e_log_setup} ---", flush=True)
    sys.exit(1) # Exit if logging can't be set up, as it's crucial for debugging

logger = logging.getLogger(__name__) # Get a logger for this module

# --- Add these lines for immediate feedback on logger level ---
print(f"--- MAIN.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_main = logger.getEffectiveLevel()
print(f"--- MAIN.PY: Effective log level for 'app.main' logger = {effective_level_main} ({logging.getLevelName(effective_level_main)}) ---", flush=True)
logger.debug(f"--- MAIN.PY DEBUG LOG TEST: Top of file, Python version: {sys.version} ---") # Changed from logger.debug to ensure it prints if DEBUG is working
logger.info(f"--- MAIN.PY INFO LOG TEST: Top of file, Python version: {sys.version} ---")
# --- End of added lines ---

from app.api.v1.api_router import api_router as v1_api_router
logger.debug("--- main.py - Imported v1_api_router ---")
from app.websocket_router import router as ws_router
logger.debug("--- main.py - Imported ws_router ---")
from app.db.session import engine, get_db
logger.debug("--- main.py - Imported engine, get_db from app.db.session ---")
from app.db import base_class
logger.debug("--- main.py - Imported base_class from app.db ---")
from app.core.config import settings
logger.debug(f"--- main.py - Imported settings. Project Name: {settings.PROJECT_NAME} ---")
from app.crud.crud_room import seed_initial_world
logger.debug("--- main.py - Imported seed_initial_world ---")
from app.crud.crud_item import seed_initial_items 
logger.debug("--- main.py - Imported seed_initial_items ---")
from app.crud.crud_mob import seed_initial_mob_templates
logger.debug("--- main.py - Imported seed_initial_mob_templates ---")
from app.game_logic.combat import start_combat_ticker_task, stop_combat_ticker_task
logger.debug("--- main.py - Imported combat_manager tasks ---")
from app.crud.crud_character_class import seed_initial_character_class_templates 
logger.debug("--- main.py - Imported seed_initial_character_class_templates ---")
from app.crud.crud_skill import seed_initial_skill_templates 
logger.debug("--- main.py - Imported seed_initial_skill_templates ---")
from app.crud.crud_trait import seed_initial_trait_templates 
logger.debug("--- main.py - Imported seed_initial_trait_templates ---")
from app.game_logic.world_ticker import start_world_ticker_task, stop_world_ticker_task
logger.debug("--- main.py - Imported world_ticker tasks ---")
from app.crud.crud_mob_spawn_definition import seed_initial_mob_spawn_definitions 
logger.debug("--- main.py - Imported seed_initial_mob_spawn_definitions ---")
from app.crud.crud_npc import seed_initial_npc_templates
logger.debug("--- main.py - Imported seed_initial_npc_templates ---")
from app.game_logic.npc_dialogue_ticker import start_dialogue_ticker_task, stop_dialogue_ticker_task
logger.debug("--- main.py - Imported npc_dialogue_ticker shit ---")
logger.debug("--- main.py - About to call Base.metadata.create_all(bind=engine) ---")
try:
    base_class.Base.metadata.create_all(bind=engine)
    logger.info("--- main.py - Base.metadata.create_all(bind=engine) COMPLETED ---")
except Exception as e:
    logger.error(f"--- main.py - ERROR during Base.metadata.create_all: {e} ---", exc_info=True)
    # Depending on the severity, you might want to sys.exit() here

logger.debug("--- main.py - Creating FastAPI app instance ---")
app = FastAPI(title=settings.PROJECT_NAME)
logger.info("--- main.py - FastAPI app instance CREATED ---")

@app.on_event("startup")
def on_startup_sync():
    logger.info("--- main.py - START of on_startup_sync event ---")
    db: Session = next(get_db())
    logger.debug("--- main.py - on_startup_sync: Acquired DB session ---")
    try:
        logger.info("--- main.py - on_startup_sync: Running startup event: Seeding initial data... ---")
        
        # CORRECT ORDER:
        # 1. Seed items FIRST
        seed_initial_items(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_items COMPLETED ---")

        # 2. THEN seed the world (rooms/exits), which might place items
        seed_initial_world(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_world COMPLETED ---")
        
        # 3. THEN other things
        seed_initial_mob_templates(db)        
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_templates COMPLETED ---")

        seed_initial_npc_templates(db) # <<< ADD THIS LINE
        logger.debug("--- main.py - on_startup_sync: seed_initial_npc_templates COMPLETED ---")
        
        seed_initial_character_class_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_character_class_templates COMPLETED ---")
        
        seed_initial_skill_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_skill_templates COMPLETED ---")
        
        seed_initial_trait_templates(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_trait_templates COMPLETED ---")
        
        seed_initial_mob_spawn_definitions(db)
        logger.debug("--- main.py - on_startup_sync: seed_initial_mob_spawn_definitions COMPLETED ---")
        
        logger.info("--- main.py - on_startup_sync: Starting combat ticker... ---")
        start_combat_ticker_task()
        logger.debug("--- main.py - on_startup_sync: Combat ticker STARTED ---")      

        logger.info("--- main.py - on_startup_sync: Starting NPC dialogue ticker... ---")
        start_dialogue_ticker_task()        
        logger.info("--- main.py - on_startup_sync: Startup event processing FINISHED ---")

        logger.info("--- main.py - on_startup_sync: Starting world ticker... ---") 
        start_world_ticker_task()    
        logger.debug("--- main.py - on_startup_sync: World ticker STARTED ---")     
        logger.info("--- main.py - on_startup_sync: Startup event processing FINISHED ---")
    except Exception as e_startup:
        logger.error(f"--- main.py - ERROR during on_startup_sync: {e_startup} ---", exc_info=True)
    finally:
        logger.debug("--- main.py - on_startup_sync: Closing DB session ---")
        db.close()
        logger.debug("--- main.py - on_startup_sync: DB session CLOSED ---")
    logger.info("--- main.py - END of on_startup_sync event ---")

logger.debug("--- main.py - About to include v1_api_router ---")
app.include_router(v1_api_router, prefix=settings.API_V1_STR)
logger.debug("--- main.py - v1_api_router INCLUDED ---")

logger.debug("--- main.py - About to include ws_router ---")
app.include_router(ws_router)
logger.debug("--- main.py - ws_router INCLUDED ---")

@app.get("/")
async def root():
    logger.debug("--- main.py - GET / request received ---")
    return {"message": f"Welcome to {settings.PROJECT_NAME}. Now with a World Ticker humming in the background!"}

logger.info("--- main.py - FastAPI app instance configured. End of file. ---")
--- END OF FILE backend/app/main.py ---

--- START OF FILE backend/app/core/config.py ---
# backend/app/core/config.py
import os
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict

# Check if we're likely running in an Alembic 'env.py' context BEFORE settings are needed for DB connection
# This is a heuristic. Alembic sets 'alembic.version' in its context.
# A simpler heuristic: if a specific env var for alembic is set.
IS_ALEMBIC_ENV_PY_CONTEXT = os.getenv("ALEMBIC_ENV_PY_RUNNING") == "true"

class Settings(BaseSettings):
    PROJECT_NAME: str = "MUD Project - Backend"
    API_V1_STR: str = "/api/v1"
    
    DATABASE_URL: Optional[str] = "postgresql://dummy_user:dummy_password@dummy_host:5432/dummy_db" if IS_ALEMBIC_ENV_PY_CONTEXT else os.getenv("DATABASE_URL", "postgresql://user:password@db/llmud_db") # Added os.getenv for normal case
    SECRET_KEY: str = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7" # CHANGE THIS IN PRODUCTION!
    GEMINI_API_KEY: Optional[str] = None
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7 # Token expires in 7 days

    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "DEBUG").upper() 
    SHOW_COMBAT_ROLLS_TO_PLAYER: bool = os.getenv("SHOW_COMBAT_ROLLS_TO_PLAYER", "True").lower() == "true"


    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8', extra='ignore')

settings = Settings() 

# After instantiation, if it was a dummy, ensure it's overridden if not in Alembic context
# and the real env var is available.
if IS_ALEMBIC_ENV_PY_CONTEXT and settings.DATABASE_URL is not None and "dummy_user" in settings.DATABASE_URL:
    # logger.info("Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.") # Can't use logger before setup
    print("INFO: Settings initialized with dummy DATABASE_URL for Alembic env.py import phase.")
elif not IS_ALEMBIC_ENV_PY_CONTEXT and os.getenv("DATABASE_URL"):
    settings.DATABASE_URL = os.getenv("DATABASE_URL") # Ensure it's set from env if not in alembic context
elif not IS_ALEMBIC_ENV_PY_CONTEXT and not os.getenv("DATABASE_URL"):
    # This will have already failed in Settings() if '...' was used and no env var
    # logger.warning("DATABASE_URL not found in environment for normal app run!") # Can't use logger before setup
    print("WARNING: DATABASE_URL not found in environment for normal app run!")
--- END OF FILE backend/app/core/config.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple, Union
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session # attributes removed as it's used in parsers now
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

from app.core.config import settings
from app.db.session import SessionLocal
from app import crud, models, schemas # Full app imports
from app.websocket_manager import connection_manager
from app.game_logic import combat # For access to combat.active_combats, combat.send_combat_log etc.

from app.commands.utils import ( # General utils
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message,
    format_room_npcs_for_player_message
    # resolve_mob_target is used within ws_combat_actions_parser
    # resolve_room_item_target is used within ws_interaction_parser
)
from app.game_state import is_character_resting, set_character_resting_status
# ExitDetail is used within ws_movement_parser.attempt_player_move

# Import the new WS command parsers
from app.ws_command_parsers import (
    handle_ws_movement, handle_ws_flee,
    handle_ws_attack, handle_ws_use_combat_skill,
    handle_ws_get_take, handle_ws_unlock, handle_ws_search_examine,
    handle_ws_contextual_interactable, handle_ws_use_ooc_skill,
    handle_ws_look, handle_ws_rest
)

logger = logging.getLogger(__name__)
# --- Logger setup print lines (can be removed once stable) ---
print(f"--- WEBSOCKET_ROUTER.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_ws = logger.getEffectiveLevel()
print(f"--- WEBSOCKET_ROUTER.PY: Effective log level for '{logger.name}' logger = {effective_level_ws} ({logging.getLevelName(effective_level_ws)}) ---", flush=True)
logger.info("--- WEBSOCKET_ROUTER.PY INFO LOG TEST: Module loaded (Post-Refactor) ---")
# --- End of logger setup print lines ---

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str) # Ensure player_id_str is a valid UUID string
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError): # Catch JWT errors and ValueError from UUID conversion
        return None

# _handle_websocket_move_if_not_in_combat has been moved to ws_movement_parser.attempt_player_move

@router.websocket("/ws") 
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character_orm: Optional[models.Character] = None # Renamed from 'character' to avoid confusion with character_id param

    with get_db_sync() as db_conn_init: 
        player = await get_player_from_token(token, db_conn_init)
        if not player:
            logger.warning(f"WS Connect: Invalid token for char_id: {character_id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return
        
        fetched_char = crud.crud_character.get_character(db_conn_init, character_id=character_id)
        if not fetched_char or fetched_char.player_id != player.id:
            logger.warning(f"WS Connect: Invalid char_id: {character_id} for player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character_orm = fetched_char # Assign to the correctly scoped variable
    
    await connection_manager.connect(websocket, player.id, character_orm.id)
    logger.info(f"Player {player.id} (Character {character_orm.name} - {character_orm.id}) connected via WebSocket.")
    
    # --- Welcome Package ---
    initial_messages = [f"Welcome {character_orm.name}! You are connected via WebSocket."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db_welcome: 
        initial_room_orm = crud.crud_room.get_room_by_id(db_welcome, room_id=character_orm.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.")
            items_on_ground = crud.crud_room_item.get_items_in_room(db_welcome, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: initial_messages.append(items_text)
            
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db_welcome, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: initial_messages.append(mobs_text)
            
            other_chars_in_room = crud.crud_character.get_characters_in_room(db_welcome, room_id=initial_room_orm.id, exclude_character_id=character_orm.id)
            chars_text_initial = format_room_characters_for_player_message(other_chars_in_room)
            if chars_text_initial: initial_messages.append(chars_text_initial)
    
            npcs_in_room_welcome = crud.crud_room.get_npcs_in_room(db_welcome, room=initial_room_orm)
            npcs_text_welcome = format_room_npcs_for_player_message(npcs_in_room_welcome)
            if npcs_text_welcome: initial_messages.append(npcs_text_welcome)

    xp_for_next_level = crud.crud_character.get_xp_for_level(character_orm.level + 1)
    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump(exclude_none=True) if initial_room_schema else None,
        "character_vitals": {
            "current_hp": character_orm.current_health, "max_hp": character_orm.max_health,
            "current_mp": character_orm.current_mana, "max_mp": character_orm.max_mana,
            "current_xp": character_orm.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character_orm.level,
            "platinum": character_orm.platinum_coins, "gold": character_orm.gold_coins,
            "silver": character_orm.silver_coins, "copper": character_orm.copper_coins
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)
    # --- End Welcome Package ---

    try:
        while True:
            received_data = await websocket.receive_json()
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            # It's crucial to get fresh state at the beginning of each command processing loop
            with get_db_sync() as db_loop: 
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character_orm.id)
                if not current_char_state: 
                    logger.error(f"WS Loop: Character state lost for char_id: {character_orm.id}.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost in loop")
                    break 
                
                current_room_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                if not current_room_orm:
                    logger.error(f"WS Loop: Character {current_char_state.name} in invalid room {current_char_state.current_room_id}.")
                    await combat.send_combat_log(player.id, ["Error: Your current location is unstable. Please relog or contact support."], combat_ended=True)
                    continue 

                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_orm)
                
                verb_for_rest_check = command_text.split(" ", 1)[0].lower() if command_text else ""
                
                non_breaking_verbs = [ # Commands that don't break resting
                    "rest", "look", "l", "score", "sc", "status", "st", 
                    "help", "?", "skills", "sk", "traits", "tr", 
                    "inventory", "i", "ooc", "say", "'", "emote", ":" 
                ]
                
                if verb_for_rest_check and verb_for_rest_check not in non_breaking_verbs and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat.send_combat_log(player.id, ["You stop resting."], room_data=current_room_schema_for_command)

                if message_type == "command" and command_text:
                    verb = verb_for_rest_check 
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""
                    args_list = args_str.split() # For handlers that need a list

                    logger.debug(f"WS Router: Processing verb='{verb}', args='{args_str}' for char {current_char_state.name}")

                    # --- Command Dispatching ---
                    if verb == "rest":
                        await handle_ws_rest(db_loop, player, current_char_state, current_room_orm)
                    elif verb in ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]:
                        await handle_ws_movement(db_loop, player, current_char_state, current_room_schema_for_command, verb, args_str)
                    elif verb == "flee":
                        await handle_ws_flee(db_loop, player, current_char_state, current_room_schema_for_command, args_str)
                    elif verb in ["attack", "atk", "kill", "k"]:
                        await handle_ws_attack(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "use":
                        if not args_str: 
                            await combat.send_combat_log(player.id, ["Use what skill?"], room_data=current_room_schema_for_command); continue
                        
                        temp_args_list_for_skill_parse = args_str.split()
                        learned_skill_tags = current_char_state.learned_skills or []
                        if not learned_skill_tags: 
                            await combat.send_combat_log(player.id, ["You have no skills."], room_data=current_room_schema_for_command); continue

                        # Simplified skill name parsing (copied from previous) - THIS SHOULD BE A UTILITY
                        parsed_skill_template: Optional[models.SkillTemplate] = None
                        parsed_remaining_args: str = ""
                        possible_matches_temp: List[Tuple[models.SkillTemplate, str]] = []
                        for i in range(len(temp_args_list_for_skill_parse), 0, -1):
                            current_skill_input = " ".join(temp_args_list_for_skill_parse[:i]).lower()
                            potential_target_str = " ".join(temp_args_list_for_skill_parse[i:]).strip()
                            for skill_tag_loop in learned_skill_tags:
                                st_db = crud.crud_skill.get_skill_template_by_tag(db_loop, skill_id_tag=skill_tag_loop)
                                if not st_db: continue
                                if st_db.skill_id_tag.lower().startswith(current_skill_input) or st_db.name.lower().startswith(current_skill_input):
                                    if not any(em.id == st_db.id for em, _ in possible_matches_temp):
                                        possible_matches_temp.append((st_db, potential_target_str))
                            if possible_matches_temp and len(current_skill_input.split()) > 0: break
                        
                        if not possible_matches_temp: await combat.send_combat_log(player.id, [f"No skill matching '{temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else args_str}'."], room_data=current_room_schema_for_command); continue
                        elif len(possible_matches_temp) == 1: parsed_skill_template, parsed_remaining_args = possible_matches_temp[0]
                        else:
                            exact_match_s = None; s_input_first = temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else ""
                            for sm_t, sm_a in possible_matches_temp:
                                if sm_t.name.lower() == s_input_first or sm_t.skill_id_tag.lower() == s_input_first:
                                    exact_match_s = sm_t; parsed_remaining_args = sm_a; break
                            if exact_match_s: parsed_skill_template = exact_match_s
                            else: await combat.send_combat_log(player.id, [f"Multiple skills match. Specify: {', '.join(list(set([st.name for st, _ in possible_matches_temp])))}"], room_data=current_room_schema_for_command); continue
                        
                        if not parsed_skill_template: await combat.send_combat_log(player.id, ["Error selecting skill for 'use' command."], room_data=current_room_schema_for_command); continue

                        # Dispatch based on skill type
                        if parsed_skill_template.skill_type == "COMBAT_ACTIVE":
                            await handle_ws_use_combat_skill(db_loop, player, current_char_state, current_room_schema_for_command, args_str) # Pass original args_str for its own parsing
                        elif parsed_skill_template.skill_type == "UTILITY_OOC":
                            # parsed_remaining_args is the target for the OOC skill (e.g., direction string)
                            await handle_ws_use_ooc_skill(db_loop, player, current_char_state, current_room_orm, parsed_skill_template, parsed_remaining_args)
                        else:
                            await combat.send_combat_log(player.id, [f"Skill '{parsed_skill_template.name}' type ({parsed_skill_template.skill_type}) cannot be 'used' this way."], room_data=current_room_schema_for_command)
                    
                    elif verb in ["get", "take"]:
                        await handle_ws_get_take(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "unlock":
                        await handle_ws_unlock(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "search" or verb == "examine":
                        await handle_ws_search_examine(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "look" or verb == "l":
                        await handle_ws_look(db_loop, player, current_char_state, current_room_orm, args_str)
                    else: # Fallback: Try contextual interactable actions
                        is_interactable_action_handled = False
                        if current_room_orm.interactables: # Check if list is not None and not empty
                            target_interactable_name_or_id = args_str.lower()
                            for interactable_dict_ws in current_room_orm.interactables:
                                try:
                                    interactable_obj_ws = schemas.InteractableDetail(**interactable_dict_ws) # Validate from DB data
                                    is_visible = not interactable_obj_ws.is_hidden or current_char_state.id in interactable_obj_ws.revealed_to_char_ids
                                    
                                    if is_visible and verb == interactable_obj_ws.action_verb.lower():
                                        matches_this_interactable = False
                                        if not target_interactable_name_or_id: # e.g. "pull"
                                            # Count how many pullable things are visible
                                            count_with_verb = 0
                                            for other_i_d in current_room_orm.interactables:
                                                other_i = schemas.InteractableDetail(**other_i_d)
                                                other_vis = not other_i.is_hidden or current_char_state.id in other_i.revealed_to_char_ids
                                                if other_vis and other_i.action_verb.lower() == verb:
                                                    count_with_verb +=1
                                            if count_with_verb == 1: matches_this_interactable = True
                                        elif interactable_obj_ws.id_tag.lower() == target_interactable_name_or_id or \
                                             target_interactable_name_or_id in interactable_obj_ws.name.lower():
                                            matches_this_interactable = True
                                        
                                        if matches_this_interactable:
                                            await handle_ws_contextual_interactable(db_loop, player, current_char_state, current_room_orm, verb, args_list, interactable_obj_ws)
                                            is_interactable_action_handled = True; break 
                                except Exception as e_parse_interactable_ws_ctx: 
                                    logger.error(f"WS: Error parsing interactable for contextual check: {e_parse_interactable_ws_ctx}. Data: {interactable_dict_ws}")
                        
                        if not is_interactable_action_handled:
                            # If not any of the above, it's an unknown command for WebSocket
                            await combat.send_combat_log(player.id, [f"Unrecognized command via WebSocket: '{command_text}'. Try 'help' (HTTP)."], room_data=current_room_schema_for_command)
                
                    try:
                        db_loop.commit() # Commit changes made by the handler
                        logger.debug(f"WS Router: DB commit successful for command '{command_text}' by {current_char_state.name}")
                    except Exception as e_commit:
                        db_loop.rollback()
                        logger.error(f"WS Router: DB commit failed for command '{command_text}' by {current_char_state.name}: {e_commit}", exc_info=True)
                        await combat.send_combat_log(player.id, ["A glitch in the matrix occurred. Your last action may not have saved."], room_data=current_room_schema_for_command) # Send error to player
                
                elif message_type != "command": 
                    await combat.send_combat_log(player.id, [f"Unrecognized message type: {message_type}."], room_data=current_room_schema_for_command)
                elif not command_text : # Empty command string for type "command"
                     await combat.send_combat_log(player.id, ["Empty command received."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'} (Character {character_orm.id if character_orm else 'N/A'})")
        if character_orm and character_orm.id: 
            combat.end_combat_for_character(character_orm.id, reason="websocket_disconnect_main_handler")
            if is_character_resting(character_orm.id):
                set_character_resting_status(character_orm.id, False)
    except Exception as e:
        err_player_id_str = str(player.id) if player else "Unknown Player"
        err_char_id_str = str(character_orm.id) if character_orm else "Unknown Character"
        logger.error(f"Critical Error in WebSocket handler for Player {err_player_id_str} (Character {err_char_id_str}): {e}", exc_info=True)
        try:
            # Attempt to send a generic error to the client before closing
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred. Please try reconnecting."})
        except Exception as send_err: 
            logger.error(f"Failed to send critical error to WebSocket for Player {err_player_id_str}: {send_err}")
    finally:
        if player and player.id: 
            connection_manager.disconnect(player.id) 
            if character_orm and character_orm.id and is_character_resting(character_orm.id): 
                set_character_resting_status(character_orm.id, False)
        char_id_log_final = str(character_orm.id) if character_orm else "N/A"
        player_id_log_final = str(player.id) if player else "N/A"
        logger.info(f"WebSocket connection for Player {player_id_log_final} (Character {char_id_log_final}) fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/crud/crud_character.py ---
# backend/app/crud/crud_character.py
from sqlalchemy.orm import Session, attributes
import uuid
import logging # Added logging
from typing import Any, Dict, Optional, List, Tuple, Union 

from .. import models, schemas, crud 

logger = logging.getLogger(__name__)

# Base stats for a character before any class modifiers are applied.
# Class templates will modify these.
DEFAULT_STATS = {
    "strength": 10, "dexterity": 10, "constitution": 10,
    "intelligence": 10, "wisdom": 10, "charisma": 10, "luck": 5,
    "current_health": 20, "max_health": 20, # These will be further adjusted by class bonuses
    "current_mana": 10, "max_mana": 10,   # These will be further adjusted by class bonuses
    "level": 1, "experience_points": 0,
    "base_ac": 10, 
    "base_attack_bonus": 0, # This is a flat bonus, attribute modifiers are added separately
    "base_damage_dice": "1d4", # Default unarmed/improvised weapon
    "base_damage_bonus": 0,    # Flat damage bonus, attribute modifiers added separately
    "learned_skills": [], 
    "learned_traits": []
}

XP_THRESHOLDS = {
    1: 0, 2: 100, 3: 300, 4: 600, 5: 1000, 6: 1500, 7: 2100, 8: 2800, 9: 3600, 
    10: 4500, 11: 5500, 12: 6600, 13: 7800, 14: 9100, 15: 10500, 16: 12000, 
    17: 13600, 18: 15300, 19: 17100, 20: 19000
    # 21: float('inf') # Example for a hard cap
}

COPPER_PER_SILVER = 100
SILVER_PER_GOLD = 100
GOLD_PER_PLATINUM = 100

# CLASS_LEVEL_BONUSES dictionary is REMOVED as this data now comes from CharacterClassTemplate.stat_gains_per_level

def update_character_currency(
    db: Session, 
    character_id: uuid.UUID, 
    platinum_change: int = 0,
    gold_change: int = 0, 
    silver_change: int = 0, 
    copper_change: int = 0
) -> Tuple[Optional[models.Character], str]:
    character = get_character(db, character_id=character_id)
    if not character:
        return None, "Character not found."

    current_total_copper = (character.platinum_coins * GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                           (character.gold_coins * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                           (character.silver_coins * COPPER_PER_SILVER) + \
                            character.copper_coins
    
    change_total_copper = (platinum_change * GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                          (gold_change * SILVER_PER_GOLD * COPPER_PER_SILVER) + \
                          (silver_change * COPPER_PER_SILVER) + \
                           copper_change

    if current_total_copper + change_total_copper < 0:
        return character, "Not enough funds for this transaction."

    new_total_copper = current_total_copper + change_total_copper

    new_platinum = new_total_copper // (GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER)
    remainder_after_platinum = new_total_copper % (GOLD_PER_PLATINUM * SILVER_PER_GOLD * COPPER_PER_SILVER)
    new_gold = remainder_after_platinum // (SILVER_PER_GOLD * COPPER_PER_SILVER) 
    remainder_after_gold = remainder_after_platinum % (SILVER_PER_GOLD * COPPER_PER_SILVER)    
    new_silver = remainder_after_gold // COPPER_PER_SILVER
    new_copper = remainder_after_gold % COPPER_PER_SILVER

    character.platinum_coins = new_platinum
    character.gold_coins = new_gold
    character.silver_coins = new_silver
    character.copper_coins = new_copper

    db.add(character) # Stage the change
    # db.commit() # <<< REMOVED
    # db.refresh(character) # <<< REMOVED
    
    change_parts = []
    if platinum_change != 0: change_parts.append(f"{abs(platinum_change)}p")
    if gold_change != 0: change_parts.append(f"{abs(gold_change)}g")
    if silver_change != 0: change_parts.append(f"{abs(silver_change)}s")
    if copper_change != 0: change_parts.append(f"{abs(copper_change)}c")
    action = "gained" if change_total_copper > 0 else "lost" if change_total_copper < 0 else "changed by"
    balance_parts = []
    if new_platinum > 0: balance_parts.append(f"{new_platinum}p")
    if new_gold > 0: balance_parts.append(f"{new_gold}g")
    if new_silver > 0: balance_parts.append(f"{new_silver}s")
    if new_copper > 0 or not balance_parts: balance_parts.append(f"{new_copper}c")
    current_balance_str = " ".join(balance_parts) if balance_parts else "0c"

    if not change_parts and change_total_copper == 0:
        message = "Currency unchanged."
    elif not change_parts and change_total_copper != 0: 
         message = f"Currency updated. New total: {current_balance_str}"
    else:
        message = f"You {action} {' '.join(change_parts)}. Current balance: {current_balance_str}"

    return character, message

def get_xp_for_level(level: int) -> Union[int, float]:
    return XP_THRESHOLDS.get(level, float('inf'))

def get_character(db: Session, character_id: uuid.UUID) -> Optional[models.Character]:
    # Ensure class_template_ref is loaded if needed frequently after fetching a character.
    # Consider adding options(joinedload(models.Character.class_template_ref)) if it's always used.
    return db.query(models.Character).filter(models.Character.id == character_id).first()

def get_character_by_name(db: Session, name: str) -> Optional[models.Character]:
    return db.query(models.Character).filter(models.Character.name == name).first()

def get_characters_by_player(db: Session, player_id: uuid.UUID, skip: int = 0, limit: int = 100) -> List[models.Character]:
    return db.query(models.Character).filter(models.Character.player_id == player_id).offset(skip).limit(limit).all()

def _fetch_class_template_for_character(db: Session, character: models.Character) -> Optional[models.CharacterClassTemplate]:
    """Ensures the character.class_template_ref is populated."""
    if character.class_template_ref and character.class_template_ref.id == character.character_class_template_id:
        return character.class_template_ref
    if character.character_class_template_id:
        class_template = crud.crud_character_class.get_character_class_template(db, class_template_id=character.character_class_template_id)
        if class_template:
            character.class_template_ref = class_template # Cache it on the character object for this session
            return class_template
    logger.warning(f"Character {character.name} (ID: {character.id}) has no class_template_id or template not found.")
    return None

def _grant_abilities_for_level(db: Session, character: models.Character, level_to_grant_for: int) -> List[str]:
    granted_messages = []
    level_str = str(level_to_grant_for)
    
    class_template = _fetch_class_template_for_character(db, character)
        
    if class_template and class_template.skill_tree_definition:
        skill_tree: Dict[str, Any] = class_template.skill_tree_definition
        core_skills_for_level: List[str] = skill_tree.get("core_skills_by_level", {}).get(level_str, [])
        if core_skills_for_level:
            if character.learned_skills is None: character.learned_skills = [] # Initialize if None
            learned_new_skill = False
            for skill_tag in core_skills_for_level:
                skill_def = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_tag)
                if skill_def and skill_tag not in character.learned_skills:
                    character.learned_skills.append(skill_tag)
                    granted_messages.append(f"You have learned skill: {skill_def.name}!")
                    learned_new_skill = True
            if learned_new_skill: attributes.flag_modified(character, "learned_skills")

        core_traits_for_level: List[str] = skill_tree.get("core_traits_by_level", {}).get(level_str, [])
        if core_traits_for_level:
            if character.learned_traits is None: character.learned_traits = [] # Initialize if None
            learned_new_trait = False
            for trait_tag in core_traits_for_level:
                trait_def = crud.crud_trait.get_trait_template_by_tag(db, trait_id_tag=trait_tag)
                if trait_def and trait_tag not in character.learned_traits:
                    character.learned_traits.append(trait_tag)
                    granted_messages.append(f"You have gained trait: {trait_def.name}!")
                    learned_new_trait = True
            if learned_new_trait: attributes.flag_modified(character, "learned_traits")
    elif not class_template:
        logger.warning(f"Cannot grant abilities for level {level_to_grant_for} to character {character.name}: No class template loaded.")
        
    return granted_messages

def create_character(
    db: Session, *,
    character_in: schemas.CharacterCreate,
    player_id: uuid.UUID,
    initial_room_id: uuid.UUID
) -> models.Character:
    db_character_data = character_in.model_dump(exclude_unset=True)
    
    # Start with base defaults
    final_char_args = DEFAULT_STATS.copy() 
    # Ensure JSONB fields from defaults are mutable lists/dicts if needed downstream directly
    final_char_args["learned_skills"] = list(final_char_args["learned_skills"]) 
    final_char_args["learned_traits"] = list(final_char_args["learned_traits"])

    class_template_id_to_set: Optional[uuid.UUID] = None
    class_name_from_input = db_character_data.get("class_name", "Adventurer") 
    
    # Fetch the class template; "Adventurer" is the default if none specified or found
    class_template: Optional[models.CharacterClassTemplate] = crud.crud_character_class.get_character_class_template_by_name(db, name=class_name_from_input)
    if not class_template and class_name_from_input != "Adventurer": # If a specific class was requested but not found, try Adventurer
        logger.warning(f"Character class template '{class_name_from_input}' not found. Attempting to default to 'Adventurer'.")
        class_template = crud.crud_character_class.get_character_class_template_by_name(db, name="Adventurer")

    effective_class_name = "Adventurer" # Fallback name

    if class_template:
        class_template_id_to_set = class_template.id
        effective_class_name = class_template.name # Use the name from the template
        
        # Apply base stat modifiers from class template
        if class_template.base_stat_modifiers:
            for stat, modifier in class_template.base_stat_modifiers.items():
                if stat in final_char_args: 
                    final_char_args[stat] = final_char_args.get(stat, 0) + modifier # Use .get for safety if stat wasn't in DEFAULT_STATS
        
        # Apply starting health/mana bonuses
        final_char_args["max_health"] = final_char_args.get("max_health", 0) + class_template.starting_health_bonus
        final_char_args["current_health"] = final_char_args["max_health"] # Full health at creation
        final_char_args["max_mana"] = final_char_args.get("max_mana", 0) + class_template.starting_mana_bonus
        final_char_args["current_mana"] = final_char_args["max_mana"] # Full mana at creation
    else:
        logger.warning(f"No class template found for '{class_name_from_input}' or 'Adventurer'. Character will use raw default stats.")
        # effective_class_name remains "Adventurer" or could be set to something generic

    db_character = models.Character(
        name=db_character_data["name"],
        class_name=effective_class_name,
        player_id=player_id,
        current_room_id=initial_room_id,
        character_class_template_id=class_template_id_to_set,
        **final_char_args 
    )
    db.add(db_character) # db_character is now pending

    if class_template: 
        db_character.class_template_ref = class_template

    initial_ability_messages = _grant_abilities_for_level(db, db_character, 1) 
    if initial_ability_messages:
        logger.info(f"Character '{db_character.name}' initial abilities granted: {', '.join(initial_ability_messages)}")

    # Grant starting equipment
    if class_template and class_template.starting_equipment_refs:
        logger.info(f"Attempting to grant starting equipment for {db_character.name} (ID pending: {db_character.id})")
        for item_ref_name_or_tag in class_template.starting_equipment_refs:
            item_template_to_add = crud.crud_item.get_item_by_name(db, name=item_ref_name_or_tag)
            if not item_template_to_add: 
                 item_template_to_add = crud.crud_item.get_item_by_item_tag(db, item_tag=item_ref_name_or_tag)

            if item_template_to_add:
                # Call the modified add_item_to_character_inventory, passing the character_obj
                # This function will now append to db_character.inventory_items
                _, msg = crud.crud_character_inventory.add_item_to_character_inventory(
                    db, character_obj=db_character, item_id=item_template_to_add.id, quantity=1
                )
                logger.info(f"Staging starting item '{item_template_to_add.name}' for '{db_character.name}'. Inv Msg: {msg}")
            else:
                logger.warning(f"Starting equipment item/tag '{item_ref_name_or_tag}' not found for class '{class_template.name}'.")
    
    # Before commit, let's see if items are in the pending list
    if hasattr(db_character, 'inventory_items') and db_character.inventory_items:
        logger.info(f"Character {db_character.name} has {len(db_character.inventory_items)} items in inventory_items relationship before commit.")
        for idx, item_entry in enumerate(db_character.inventory_items):
            logger.debug(f"  Item {idx}: Item ID {item_entry.item_id}, Qty {item_entry.quantity}, Char ID (on entry) {item_entry.character_id}")
    else:
        logger.warning(f"Character {db_character.name} has NO items in inventory_items relationship before commit.")

    db.commit() 
    db.refresh(db_character) 
    # After refresh, inventory_items should be populated from DB if commit was successful
    if hasattr(db_character, 'inventory_items') and db_character.inventory_items:
         logger.info(f"Character {db_character.name} has {len(db_character.inventory_items)} items in inventory_items AFTER commit & refresh.")
    else:
        logger.info(f"Character {db_character.name} has NO items in inventory_items AFTER commit & refresh.")

    logger.info(f"Character '{db_character.name}' created successfully with ID {db_character.id}.")
    return db_character

def update_character_room(db: Session, character_id: uuid.UUID, new_room_id: uuid.UUID) -> Optional[models.Character]:
    db_character = get_character(db, character_id=character_id)
    if db_character:
        db_character.current_room_id = new_room_id
        db.add(db_character) # Stage the change
        # db.commit() # <<< REMOVED
        # db.refresh(db_character) # <<< REMOVED
        return db_character
    return None

def update_character_health(db: Session, character_id: uuid.UUID, amount_change: int) -> Optional[models.Character]:
    character = get_character(db, character_id=character_id)
    if not character:
        return None
    
    character.current_health += amount_change
    character.current_health = max(0, min(character.current_health, character.max_health))
        
    db.add(character) # Stage the change
    # db.commit() # <<< REMOVED
    # db.refresh(character) # <<< REMOVED
    return character

def _apply_level_up(db: Session, character: models.Character) -> List[str]:
    level_up_messages = []
    
    current_max_defined_level = max(XP_THRESHOLDS.keys()) if XP_THRESHOLDS else 0
    if character.level >= current_max_defined_level and get_xp_for_level(character.level + 1) == float('inf'):
         level_up_messages.append(f"You are already at the maximum defined level ({character.level}). Cannot level up further.")
         return level_up_messages

    character.level += 1
    level_up_messages.append(f"Ding! You have reached Level {character.level}!")

    # Get stat gains from class template
    class_template = _fetch_class_template_for_character(db, character)
    hp_gain_from_class = 0
    mp_gain_from_class = 0
    # bab_gain_from_class = 0 # Not directly adding to character.base_attack_bonus, as that's flat.
                            # BAB is usually calculated dynamically or traits/feats grant it.
                            # If you have a character.base_attack_bonus_per_level field, update it here.

    if class_template and class_template.stat_gains_per_level:
        sgl = class_template.stat_gains_per_level
        hp_gain_from_class = int(sgl.get("hp", 3)) # Default to 3 if not specified
        mp_gain_from_class = int(sgl.get("mp", 1)) # Default to 1
        # bab_from_class_per_level = float(sgl.get("base_attack_bonus", 0.0))
        # character.base_attack_bonus += bab_from_class_per_level # Example if you store BAB progression this way
                                                                # Ensure base_attack_bonus is Float if so.
    else: # Fallback if no template or no stat_gains defined (e.g. very basic Adventurer)
        logger.warning(f"No stat_gains_per_level found for class '{character.class_name}' on level up for {character.name}. Using fallback.")
        hp_gain_from_class = 3 # Generic fallback
        mp_gain_from_class = 1 # Generic fallback

    con_mod = character.get_attribute_modifier("constitution")
    hp_gain_total = max(1, con_mod + hp_gain_from_class) 
    character.max_health += hp_gain_total
    level_up_messages.append(f"Your maximum health increases by {hp_gain_total}!")

    # Example: Mana gain could also be influenced by a primary casting stat like intelligence or wisdom
    int_mod = character.get_attribute_modifier("intelligence") # Or relevant mana attribute for the class
    mp_gain_total = max(0, int_mod + mp_gain_from_class) 
    character.max_mana += mp_gain_total
    if mp_gain_total > 0 or mp_gain_from_class > 0 : # Only message if there was potential for mana gain
        level_up_messages.append(f"Your maximum mana increases by {mp_gain_total}!")

    character.current_health = character.max_health # Full heal on level up
    character.current_mana = character.max_mana   # Full mana on level up
    level_up_messages.append("You feel invigorated!")
    
    ability_messages = _grant_abilities_for_level(db, character, character.level)
    level_up_messages.extend(ability_messages)
    
    db.add(character) # Stage changes from level up
    return level_up_messages


def _apply_level_down(db: Session, character: models.Character) -> List[str]:
    if character.level <= 1:
        return ["You cannot de-level below level 1, you pathetic worm."]
    
    level_down_messages = []
    xp_for_new_lower_level = get_xp_for_level(character.level - 1)
    if xp_for_new_lower_level == float('inf'): # Should not happen if level > 1
        xp_for_new_lower_level = XP_THRESHOLDS.get(character.level -1, 0)

    # Estimate loss based on what was gained. This is tricky without storing historical gains.
    # Simplification: remove gains as if they were from the class template for the *new lower level*.
    class_template = _fetch_class_template_for_character(db, character)
    hp_loss_from_class = 3 # Default
    mp_loss_from_class = 1 # Default

    if class_template and class_template.stat_gains_per_level:
        sgl = class_template.stat_gains_per_level
        hp_loss_from_class = int(sgl.get("hp", 3))
        mp_loss_from_class = int(sgl.get("mp", 1))
    else:
        logger.warning(f"No stat_gains_per_level for class '{character.class_name}' on level down for {character.name}. Using fallback loss.")

    con_mod = character.get_attribute_modifier("constitution")
    hp_loss_estimate = max(1, con_mod + hp_loss_from_class)
    character.max_health = max(1, character.max_health - hp_loss_estimate) 
    level_down_messages.append(f"Your maximum health decreases by {hp_loss_estimate}.")

    int_mod = character.get_attribute_modifier("intelligence")
    mp_loss_estimate = max(0, int_mod + mp_loss_from_class)
    character.max_mana = max(0, character.max_mana - mp_loss_estimate)
    if mp_loss_estimate > 0 or mp_loss_from_class > 0:
        level_down_messages.append(f"Your maximum mana decreases by {mp_loss_estimate}.")

    character.current_health = min(character.current_health, character.max_health)
    character.current_mana = min(character.current_mana, character.max_mana)

    character.level -= 1
    level_down_messages.append(f"You feel weaker... You have de-leveled to Level {character.level}.")
    character.experience_points = int(xp_for_new_lower_level) 

    # TODO: Logic to remove skills/traits learned at the level lost. This is complex.
    # For now, skills/traits are not removed on de-level.

    db.add(character) # Stage changes from level down
    return level_down_messages


def add_experience(db: Session, character_id: uuid.UUID, amount: int) -> Tuple[Optional[models.Character], List[str]]:
    character = get_character(db, character_id=character_id)
    if not character:
        return None, ["Character not found."]
    messages = []
    if amount == 0: # Check if still needed or handled by caller
        # return character, ["No experience gained or lost. How pointless."] 
        pass # Allow 0 for potential future effects, combat loop might filter this.

    initial_level = character.level
    character.experience_points += amount
    if amount !=0 : # Only message if XP actually changed
      messages.append(f"{'Gained' if amount > 0 else 'Lost'} {abs(amount)} experience points. Current XP: {character.experience_points}")

    # Level up loop
    xp_for_next_level = get_xp_for_level(character.level + 1)
    while character.experience_points >= xp_for_next_level and xp_for_next_level != float('inf'):
        overflow_xp = character.experience_points - int(xp_for_next_level) # XP beyond what's needed for next level
        level_up_messages = _apply_level_up(db, character) # _apply_level_up stages changes
        messages.extend(level_up_messages)
        
        # Set XP to the start of the new current level, plus overflow
        xp_at_start_of_new_level = get_xp_for_level(character.level)
        if xp_at_start_of_new_level == float('inf'): # Should not happen if level up occurred
            character.experience_points = 0
        else:
            character.experience_points = int(xp_at_start_of_new_level) + overflow_xp
        
        xp_for_next_level = get_xp_for_level(character.level + 1) # Recalculate for potential multi-level up

    # De-level loop (only if XP is negative or below current level's threshold)
    xp_required_for_current_level = get_xp_for_level(character.level)
    while character.level > 1 and character.experience_points < xp_required_for_current_level :
        # Note: If XP becomes negative, this loop will run.
        # _apply_level_down will set XP to the start of the new lower level.
        delevel_messages = _apply_level_down(db, character) # _apply_level_down stages changes
        messages.extend(delevel_messages)
        xp_required_for_current_level = get_xp_for_level(character.level) # For the new, lower level

    # Ensure XP doesn't go below 0 for level 1 characters
    if character.level == 1 and character.experience_points < 0:
        character.experience_points = 0

    db.add(character) # Ensure character is staged after all XP and level modifications
    # db.commit() # <<< REMOVED - Caller (e.g. skill_resolver or command handler) commits
    # db.refresh(character) # <<< REMOVED
    
    # Add a generic level change message if specific Ding/Delevel messages weren't generated
    # (e.g. if level changed via admin command without going through xp gain/loss)
    if character.level != initial_level and not any("Ding!" in m or "de-leveled" in m for m in messages):
        messages.append(f"Your level is now {character.level}.")
    return character, messages

def get_characters_in_room(db: Session, *, room_id: uuid.UUID, exclude_character_id: Optional[uuid.UUID] = None) -> List[models.Character]:
    query = db.query(models.Character).filter(models.Character.current_room_id == room_id)
    if exclude_character_id:
        query = query.filter(models.Character.id != exclude_character_id)
    return query.all()
--- END OF FILE backend/app/crud/crud_character.py ---

--- START OF FILE backend/app/crud/crud_character_inventory.py ---
# backend/app/crud/crud_character_inventory.py
from sqlalchemy.orm import Session, joinedload, attributes
import uuid
from typing import List, Optional, Tuple, Dict # Added Dict
import logging

from .. import models, schemas # models.Item, models.Character, models.CharacterInventoryItem
from ..models.item import EQUIPMENT_SLOTS # For validation

logger = logging.getLogger(__name__)

def get_inventory_item_entry_by_id(db: Session, inventory_item_id: uuid.UUID) -> Optional[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item)
    ).filter(models.CharacterInventoryItem.id == inventory_item_id).first()

def get_character_inventory(db: Session, character_id: uuid.UUID) -> List[models.CharacterInventoryItem]:
    return db.query(models.CharacterInventoryItem).options(
        joinedload(models.CharacterInventoryItem.item)
    ).filter(models.CharacterInventoryItem.character_id == character_id).all()

def character_has_item_with_tag(db: Session, character_id: uuid.UUID, item_tag: str) -> bool:
    count = db.query(models.CharacterInventoryItem.id).join(
        models.Item, models.CharacterInventoryItem.item_id == models.Item.id
    ).filter(
        models.CharacterInventoryItem.character_id == character_id,
        models.Item.properties["item_tag"].astext == item_tag
    ).count()
    return count > 0

def add_item_to_character_inventory(
    db: Session, *, character_obj: models.Character, item_id: uuid.UUID, quantity: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    item_template = db.query(models.Item).filter(models.Item.id == item_id).first()
    if not item_template:
        return None, "Item template not found."
    if quantity <= 0:
        return None, "Quantity must be positive."

    # Ensure character_obj has an ID, important if it's a new character in the same transaction
    if not character_obj.id:
        logger.warning("Character object does not have an ID yet. Flushing session to assign ID before adding inventory.")
        try:
            db.flush([character_obj]) # Flush only this object to get an ID if it's new
            if not character_obj.id: # Still no ID after flush
                logger.error("Failed to obtain character ID even after flush. Cannot add item to inventory.")
                return None, "Cannot add item: Character ID missing."
        except Exception as e_flush:
            logger.error(f"Error flushing character to get ID: {e_flush}")
            db.rollback() # Rollback potential partial flush
            return None, "Error obtaining character ID for inventory."

    first_created_or_updated_entry: Optional[models.CharacterInventoryItem] = None
    total_added_successfully = 0
    messages: List[str] = []

    if item_template.stackable:
        remaining_quantity_to_add = quantity
        
        # Get the max_stack_size from the item template.
        # If it's None, this item has no defined stack limit from the template.
        effective_max_stack_template: Optional[int] = item_template.max_stack_size

        # Attempt to add to an existing unequipped stack first
        existing_unequipped_stack = db.query(models.CharacterInventoryItem).filter(
            models.CharacterInventoryItem.character_id == character_obj.id,
            models.CharacterInventoryItem.item_id == item_id,
            models.CharacterInventoryItem.equipped == False
        ).first()

        if existing_unequipped_stack:
            space_in_existing_stack: int
            if effective_max_stack_template is None: # No defined limit on the item template
                # If no limit, it can take all remaining quantity.
                space_in_existing_stack = remaining_quantity_to_add
            else:
                # Calculate space based on the defined limit.
                space_in_existing_stack = effective_max_stack_template - existing_unequipped_stack.quantity
            
            # Ensure we don't try to add a negative amount if stack is somehow overfull (data integrity issue)
            space_in_existing_stack = max(0, space_in_existing_stack)
            
            can_add_to_this_stack = min(remaining_quantity_to_add, space_in_existing_stack)

            if can_add_to_this_stack > 0:
                existing_unequipped_stack.quantity += can_add_to_this_stack
                db.add(existing_unequipped_stack) # Mark as changed
                if not first_created_or_updated_entry:
                    first_created_or_updated_entry = existing_unequipped_stack
                total_added_successfully += can_add_to_this_stack
                remaining_quantity_to_add -= can_add_to_this_stack
                messages.append(f"Added {can_add_to_this_stack} to existing stack of {item_template.name}.")

        # Add any remaining quantity to new stacks
        while remaining_quantity_to_add > 0:
            current_add_amount: int
            if effective_max_stack_template is None: # No limit for new stacks either
                current_add_amount = remaining_quantity_to_add # Create one new stack with all remaining
            elif remaining_quantity_to_add > effective_max_stack_template:
                current_add_amount = effective_max_stack_template # Fill one new stack to max
            else:
                current_add_amount = remaining_quantity_to_add # New stack with the rest

            new_entry = models.CharacterInventoryItem(
                character_id=character_obj.id,
                item_id=item_id,
                quantity=current_add_amount
            )
            db.add(new_entry)
            if not first_created_or_updated_entry:
                first_created_or_updated_entry = new_entry
            total_added_successfully += current_add_amount
            remaining_quantity_to_add -= current_add_amount
            messages.append(f"Created new stack of {item_template.name} with {current_add_amount}.")
    
    else: # Not stackable, create individual entries
        for _ in range(quantity):
            new_entry = models.CharacterInventoryItem(
                character_id=character_obj.id,
                item_id=item_id,
                quantity=1 # Non-stackable items always have quantity 1 per entry
            )
            db.add(new_entry)
            if not first_created_or_updated_entry:
                first_created_or_updated_entry = new_entry
            total_added_successfully += 1
        if total_added_successfully > 0:
             messages.append(f"Added {total_added_successfully} individual {item_template.name}(s).")

    # Construct final message based on operations
    final_message = ""
    if total_added_successfully == quantity and quantity > 0:
        # Consolidate messages if only one operation occurred
        if len(messages) == 1:
            final_message = messages[0].replace("Staged ", "").capitalize() # Cleaner message
        elif len(messages) > 1:
            final_message = f"Successfully added {quantity}x {item_template.name}. Details: {' '.join(messages)}"
        else: # Should not happen if total_added_successfully > 0
            final_message = f"Staged addition of {quantity}x {item_template.name}."
    elif total_added_successfully > 0 and total_added_successfully < quantity:
        final_message = f"Partially added {item_template.name}: {total_added_successfully} of {quantity} due to limits. Details: {' '.join(messages)}"
    elif total_added_successfully == 0 and quantity > 0:
        final_message = f"Could not add any {item_template.name}; likely due to stack limits or other constraints. Details: {' '.join(messages)}"
    elif quantity == 0 : # Explicitly adding zero quantity
        final_message = f"No {item_template.name} added (quantity was zero)."


    return first_created_or_updated_entry, final_message


def remove_item_from_character_inventory(
    db: Session, *, inventory_item_id: uuid.UUID, quantity_to_remove: int = 1
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    entry = get_inventory_item_entry_by_id(db, inventory_item_id)
    if not entry:
        return None, "Inventory item entry not found."
    if entry.equipped:
        item_name = entry.item.name if entry.item else "item"
        return None, f"Cannot remove '{item_name}'; it is currently equipped. Unequip it first."
    if quantity_to_remove <= 0:
        return None, "Quantity to remove must be positive."

    original_item_name = entry.item.name if entry.item else "Unknown Item"

    if entry.quantity > quantity_to_remove:
        entry.quantity -= quantity_to_remove
        db.add(entry)
        return entry, f"Staged removal of {quantity_to_remove} x {original_item_name}. {entry.quantity} remaining."
    elif entry.quantity <= quantity_to_remove: # Remove the whole stack/item
        removed_qty = entry.quantity
        db.delete(entry)
        # If quantity_to_remove was > entry.quantity, we only removed what was there.
        # The message should reflect the actual amount removed.
        message = f"Staged deletion of all {removed_qty} x {original_item_name} from inventory."
        if quantity_to_remove > removed_qty:
            message += f" (Tried to remove {quantity_to_remove}, only {removed_qty} available)."
        return None, message # Return None because the entry is deleted
    return None, "Error in remove item logic." # Should not reach here


def equip_item_from_inventory(
    db: Session, *, character_obj: models.Character, inventory_item_id: uuid.UUID, target_slot: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    logger.debug(f"[CRUD_EQUIP] Attempting to equip item_id: {inventory_item_id} for char: {character_obj.name} to slot: {target_slot}")
    char_inv_entry = get_inventory_item_entry_by_id(db, inventory_item_id)

    if not char_inv_entry:
        logger.warning(f"[CRUD_EQUIP_FAIL] Item instance {inventory_item_id} not found.")
        return None, "Item instance not found in your inventory records."
    if char_inv_entry.character_id != character_obj.id:
        logger.warning(f"[CRUD_EQUIP_FAIL] Ownership mismatch: Item {inventory_item_id} (owner: {char_inv_entry.character_id}) vs Char {character_obj.id}")
        return None, "This item does not belong to you."

    item_name_for_log = char_inv_entry.item.name if char_inv_entry.item else "UnknownItem"
    if char_inv_entry.equipped:
        logger.info(f"[CRUD_EQUIP_FAIL] Item '{item_name_for_log}' ({inventory_item_id}) already equipped in {char_inv_entry.equipped_slot}.")
        return char_inv_entry, f"{item_name_for_log} is already equipped in {char_inv_entry.equipped_slot}."

    item_template = char_inv_entry.item
    if not item_template:
        logger.error(f"[CRUD_EQUIP_FAIL] Inventory item {char_inv_entry.id} is missing its item_template relationship.")
        return None, "Item template data missing for this inventory item."

    if not item_template.slot or item_template.slot in ["consumable", "inventory", "junk", "key", "tool", "crafting_material"]:
        logger.warning(f"[CRUD_EQUIP_FAIL] Item '{item_template.name}' (type: {item_template.item_type}, defined slot: {item_template.slot}) is not equippable.")
        return None, f"{item_template.name} is not equippable in a character slot."

    final_target_slot = target_slot
    item_defined_slot_type = item_template.slot

    if not final_target_slot:
        if item_defined_slot_type in EQUIPMENT_SLOTS:
            final_target_slot = item_defined_slot_type
            logger.debug(f"[CRUD_EQUIP] Auto-determined slot for '{item_template.name}' to be '{final_target_slot}' based on item.slot '{item_defined_slot_type}'.")
        elif item_defined_slot_type == "ring":
             logger.warning(f"[CRUD_EQUIP_FAIL] Specific finger slot not provided for ring '{item_template.name}'.")
             return None, f"Please specify which finger slot to equip {item_template.name} (e.g., equip {item_template.name} finger_1)."
        else:
            logger.warning(f"[CRUD_EQUIP_FAIL] Cannot auto-determine slot for '{item_template.name}' (type: {item_defined_slot_type}). User must specify.")
            return None, f"Cannot automatically determine slot for {item_template.name} (defined slot type: {item_defined_slot_type}). Please specify a target slot."

    if final_target_slot not in EQUIPMENT_SLOTS:
        logger.warning(f"[CRUD_EQUIP_FAIL] Invalid target_slot '{final_target_slot}' specified by user or logic.")
        return None, f"Invalid equipment slot: '{final_target_slot}'. Valid slots are: {', '.join(EQUIPMENT_SLOTS.keys())}."

    # Compatibility checks
    if item_defined_slot_type == "ring" and not final_target_slot.startswith("finger"):
        return None, f"{item_template.name} (a ring) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."
    if item_defined_slot_type == "main_hand" and final_target_slot not in ["main_hand", "off_hand"]:
        return None, f"{item_template.name} (main_hand weapon) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."
    if item_defined_slot_type == "off_hand" and final_target_slot != "off_hand": # Shields, etc.
        return None, f"{item_template.name} (off_hand item) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."
    # Ensure a general item (e.g. item.slot = "torso") is being equipped to the correct slot
    if item_defined_slot_type != "ring" and item_defined_slot_type not in ["main_hand", "off_hand"] and item_defined_slot_type != final_target_slot:
        return None, f"{item_template.name} (for {item_defined_slot_type}) cannot be equipped to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."


    # Fetch current inventory directly from DB within this transaction for most up-to-date view
    current_character_inventory_snapshot = get_character_inventory(db, character_obj.id)

    # 1. Unequip item(s) currently in the final_target_slot
    for item_to_unequip_orm in current_character_inventory_snapshot:
        if item_to_unequip_orm.id == char_inv_entry.id: continue # Don't try to unequip the item we are trying to equip
        if item_to_unequip_orm.equipped and item_to_unequip_orm.equipped_slot == final_target_slot:
            logger.info(f"[CRUD_EQUIP] Unequipping '{item_to_unequip_orm.item.name if item_to_unequip_orm.item else 'item'}' from slot '{final_target_slot}' to make space.")
            item_to_unequip_orm.equipped = False
            item_to_unequip_orm.equipped_slot = None
            db.add(item_to_unequip_orm)

    # 2. Handle two-handed items: if equipping a two-handed item, unequip from the other hand slot
    if item_template.properties and item_template.properties.get("two_handed", False):
        other_hand_slot = None
        if final_target_slot == "main_hand": other_hand_slot = "off_hand"
        elif final_target_slot == "off_hand": other_hand_slot = "main_hand" # Equipping two-hander in off_hand implies main is also used

        if other_hand_slot:
            for other_hand_item_orm in current_character_inventory_snapshot:
                if other_hand_item_orm.id == char_inv_entry.id: continue
                if other_hand_item_orm.equipped and other_hand_item_orm.equipped_slot == other_hand_slot:
                    logger.info(f"[CRUD_EQUIP] Unequipping '{other_hand_item_orm.item.name if other_hand_item_orm.item else 'item'}' from '{other_hand_slot}' for two-handed '{item_template.name}'.")
                    other_hand_item_orm.equipped = False
                    other_hand_item_orm.equipped_slot = None
                    db.add(other_hand_item_orm)

    # 3. Equip the new item
    # If the item being equipped is stackable and quantity > 1, we need to split it.
    # One item gets equipped, the rest (quantity - 1) remains/becomes an unequipped stack.
    if item_template.stackable and char_inv_entry.quantity > 1:
        # Create a new inventory entry for the remainder
        remainder_quantity = char_inv_entry.quantity - 1
        new_unequipped_stack = models.CharacterInventoryItem(
            character_id=character_obj.id,
            item_id=item_template.id,
            quantity=remainder_quantity
        )
        db.add(new_unequipped_stack)
        logger.debug(f"Split stack for equipping: {remainder_quantity} of {item_template.name} remains in backpack.")
        # Modify the current entry to be quantity 1 and equipped
        char_inv_entry.quantity = 1

    logger.info(f"[CRUD_EQUIP] Setting item '{item_template.name}' (ID: {char_inv_entry.id}): equipped=True, equipped_slot='{final_target_slot}'")
    char_inv_entry.equipped = True
    char_inv_entry.equipped_slot = final_target_slot
    db.add(char_inv_entry)

    return char_inv_entry, f"Staged equipping of {item_template.name} to {EQUIPMENT_SLOTS.get(final_target_slot, final_target_slot)}."

def unequip_item_to_inventory(
    db: Session, *, character_obj: models.Character, inventory_item_id: Optional[uuid.UUID] = None, slot_to_unequip: Optional[str] = None
) -> Tuple[Optional[models.CharacterInventoryItem], str]:
    char_inv_entry_to_unequip: Optional[models.CharacterInventoryItem] = None

    current_character_inventory_snapshot = get_character_inventory(db, character_obj.id)


    if inventory_item_id:
        # Find the specific item instance from the snapshot
        for item_instance in current_character_inventory_snapshot:
            if item_instance.id == inventory_item_id:
                if item_instance.character_id == character_obj.id:
                    char_inv_entry_to_unequip = item_instance
                else: # Ownership mismatch
                    logger.warning(f"Attempt to unequip item {inventory_item_id} by char {character_obj.name} but item belongs to char_id {item_instance.character_id}")
                    return None, "This item instance does not belong to you."
                break
    elif slot_to_unequip:
        if slot_to_unequip not in EQUIPMENT_SLOTS:
             return None, f"Invalid equipment slot: '{slot_to_unequip}'."
        for item_instance in current_character_inventory_snapshot:
            if item_instance.equipped and item_instance.equipped_slot == slot_to_unequip:
                char_inv_entry_to_unequip = item_instance
                break
    else:
        return None, "Must specify an item ID or a slot to unequip."

    if not char_inv_entry_to_unequip:
        return None, "No equipped item found for the given criteria."

    if not char_inv_entry_to_unequip.item:
        logger.error(f"Equipped item {char_inv_entry_to_unequip.id} is missing its item_template data.")
        return None, "Item template data missing for this equipped item."

    if not char_inv_entry_to_unequip.equipped or not char_inv_entry_to_unequip.equipped_slot:
        return char_inv_entry_to_unequip, f"{char_inv_entry_to_unequip.item.name} is not currently equipped."

    item_name_unequipped = char_inv_entry_to_unequip.item.name
    slot_display_name = EQUIPMENT_SLOTS.get(char_inv_entry_to_unequip.equipped_slot, char_inv_entry_to_unequip.equipped_slot)

    char_inv_entry_to_unequip.equipped = False
    char_inv_entry_to_unequip.equipped_slot = None
    db.add(char_inv_entry_to_unequip)

    # After unequipping, if the item is stackable, try to merge it with an existing unequipped stack
    if char_inv_entry_to_unequip.item.stackable:
        # Query again for an unequipped stack of the same item_id (excluding the one we just unequipped if it's still in session with old state)
        # This logic needs to be careful about the object identity of char_inv_entry_to_unequip
        # It might be simpler to let a subsequent "cleanup/compact inventory" function handle this,
        # or ensure the `add_item_to_character_inventory` logic is robust enough to merge when items are re-added.
        # For now, we'll just unequip it. The next time an item of this type is added, add_item logic should find this unequipped one.
        
        # Let's try to merge:
        potential_merge_stack = db.query(models.CharacterInventoryItem).filter(
            models.CharacterInventoryItem.character_id == character_obj.id,
            models.CharacterInventoryItem.item_id == char_inv_entry_to_unequip.item_id,
            models.CharacterInventoryItem.equipped == False,
            models.CharacterInventoryItem.id != char_inv_entry_to_unequip.id # Exclude the item we just unequipped itself
        ).first()

        if potential_merge_stack:
            max_stack = char_inv_entry_to_unequip.item.max_stack_size if char_inv_entry_to_unequip.item.max_stack_size is not None else float('inf')
            if potential_merge_stack.quantity + char_inv_entry_to_unequip.quantity <= max_stack:
                logger.debug(f"Merging unequipped {item_name_unequipped} (qty {char_inv_entry_to_unequip.quantity}) into existing stack (qty {potential_merge_stack.quantity})")
                potential_merge_stack.quantity += char_inv_entry_to_unequip.quantity
                db.add(potential_merge_stack)
                db.delete(char_inv_entry_to_unequip) # Delete the now-merged original entry
                char_inv_entry_to_unequip = potential_merge_stack # The ORM object to return is now the merged stack
            # else: cannot merge, leave as separate stack (already handled by unequipping)
    
    return char_inv_entry_to_unequip, f"Staged unequipping of {item_name_unequipped} from {slot_display_name}."
--- END OF FILE backend/app/crud/crud_character_inventory.py ---

--- START OF FILE backend/app/crud/crud_npc.py ---
# backend/app/crud/crud_npc.py
import json
import os
import uuid
import logging
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session

from .. import models, schemas

logger = logging.getLogger(__name__)

# Path to the seeds directory
CRUD_DIR = os.path.dirname(os.path.abspath(__file__))
SEEDS_DIR = os.path.join(CRUD_DIR, "..", "seeds")

def _load_seed_data_from_json(filename: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEEDS_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"Seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {filepath}: {e}")
        return []

def get_npc_template_by_tag(db: Session, unique_name_tag: str) -> Optional[models.NpcTemplate]:
    return db.query(models.NpcTemplate).filter(models.NpcTemplate.unique_name_tag == unique_name_tag).first()

def create_npc_template(db: Session, *, template_in: schemas.NpcTemplateCreate) -> models.NpcTemplate:
    db_template = models.NpcTemplate(**template_in.model_dump())
    db.add(db_template)
    return db_template

def seed_initial_npc_templates(db: Session):
    logger.info("--- Attempting to seed initial NPC templates from npcs.json ---")
    npc_definitions = _load_seed_data_from_json("npcs.json")

    if not npc_definitions:
        logger.warning("No NPC definitions found in npcs.json. Aborting NPC seeding.")
        return

    seeded_count = 0
    updated_count = 0
    skipped_count = 0

    for npc_data in npc_definitions:
        tag = npc_data.get("unique_name_tag")
        if not tag:
            logger.warning(f"Skipping NPC entry due to missing 'unique_name_tag': {npc_data}")
            skipped_count += 1
            continue

        existing_npc = get_npc_template_by_tag(db, unique_name_tag=tag)
        
        try:
            # We need a Pydantic model to validate the data from JSON
            # Let's create one on the fly here for simplicity or assume it exists in schemas
            # For now, we'll pass the dict directly and let the ORM handle it, but a schema is better.
            
            if existing_npc:
                logger.debug(f"NPC template '{tag}' already exists. Checking for updates...")
                changed = False
                for field, value in npc_data.items():
                    if getattr(existing_npc, field) != value:
                        setattr(existing_npc, field, value)
                        changed = True
                if changed:
                    db.add(existing_npc)
                    logger.info(f"Updated NPC template: {tag}")
                    updated_count += 1
                else:
                    skipped_count += 1
            else:
                # This assumes your JSON data keys match the model attributes exactly.
                # A proper implementation uses a Pydantic schema here.
                # create_npc_template(db, template_in=schemas.NpcTemplateCreate(**npc_data))
                db_npc = models.NpcTemplate(**npc_data)
                db.add(db_npc)
                seeded_count += 1
                logger.info(f"Creating NPC template: {tag}")

        except Exception as e:
            logger.error(f"Failed to process NPC template '{tag}': {e}", exc_info=True)
            skipped_count += 1
            db.rollback()
            continue

    if seeded_count > 0 or updated_count > 0:
        logger.info(f"Committing {seeded_count} new and {updated_count} updated NPC templates.")
        db.commit()
    else:
        logger.info("No new or updated NPC templates. No commit needed.")
        db.rollback() # Rollback if nothing changed

    logger.info(f"NPC template seeding complete. New: {seeded_count}, Updated: {updated_count}, Skipped: {skipped_count}")
--- END OF FILE backend/app/crud/crud_npc.py ---

--- START OF FILE backend/app/crud/crud_item.py ---
# backend/app/crud/crud_item.py
import json
import os
import uuid
import logging # Import logging
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session

from .. import models, schemas

logger = logging.getLogger(__name__) # Get a logger for this module

# Path to the seeds directory (relative to this file)
SEED_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "seeds")

def _load_seed_data_for_items(filename: str) -> List[Dict[str, Any]]:
    filepath = os.path.join(SEED_DIR, filename)
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"Seed file not found: {filepath}")
        return []
    except json.JSONDecodeError as e:
        logger.error(f"Could not decode JSON from {filepath}: {e}")
        return []

def get_item_by_id(db: Session, item_id: uuid.UUID) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.id == item_id).first()

def get_item_by_name(db: Session, name: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.name == name).first()

def get_item_by_item_tag(db: Session, item_tag: str) -> Optional[models.Item]:
    return db.query(models.Item).filter(models.Item.properties["item_tag"].astext == item_tag).first()

def get_all_items(db: Session, skip: int = 0, limit: int = 100) -> List[models.Item]:
    return db.query(models.Item).offset(skip).limit(limit).all()

def create_item(db: Session, *, item_in: schemas.ItemCreate) -> models.Item:
    db_item = models.Item(**item_in.model_dump())
    db.add(db_item)
    # Caller should handle commit/flush
    return db_item

def seed_initial_items(db: Session):
    logger.info("Attempting to seed initial items from JSON...")
    item_definitions = _load_seed_data_for_items("items.json")

    if not item_definitions:
        logger.warning("No item definitions found or error loading items.json. Aborting item seeding.")
        return

    seeded_count = 0
    skipped_count = 0
    updated_count = 0 # For clarity

    for item_data in item_definitions:
        item_name = item_data.get("name")
        if not item_name:
            logger.warning(f"Skipping item entry due to missing name: {item_data}")
            skipped_count += 1
            continue

        existing_item = get_item_by_name(db, name=item_name)
        
        try:
            if existing_item:
                logger.debug(f"Item '{item_name}' already exists. Attempting update...")
                item_update_schema = schemas.ItemUpdate(**item_data) 
                changed = False
                for field, value in item_update_schema.model_dump(exclude_unset=True).items():
                    if getattr(existing_item, field) != value:
                        setattr(existing_item, field, value)
                        changed = True
                if changed:
                    db.add(existing_item)
                    logger.info(f"Updated item: {item_name}")
                    updated_count += 1
                else:
                    # logger.debug(f"Item '{item_name}' exists and no changes detected. Skipping update.")
                    skipped_count +=1 # Not really skipped, but not "newly seeded" or "updated"
            else:
                item_create_schema = schemas.ItemCreate(**item_data)
                logger.info(f"Creating item: {item_create_schema.name}")
                create_item(db, item_in=item_create_schema)
                seeded_count += 1
        except Exception as e_pydantic:
            logger.error(f"Pydantic validation or DB operation failed for item '{item_name}': {e_pydantic}. Data: {item_data}")
            skipped_count += 1
            continue
    
    if seeded_count > 0 or updated_count > 0:
        try:
            logger.info(f"Committing {seeded_count} new items and {updated_count} updated items.")
            db.commit() 
            logger.info("Item seeding commit successful.")
        except Exception as e_commit:
            logger.error(f"Error committing item seeds: {e_commit}. Rolling back.")
            db.rollback()
    else:
        logger.info("No new items to seed or items to update. No commit needed for items.")

    logger.info(f"Item seeding complete. New: {seeded_count}, Updated: {updated_count}, Unchanged/Skipped: {skipped_count}")


def update_item(db: Session, *, db_item: models.Item, item_in: schemas.ItemUpdate) -> models.Item:
    update_data = item_in.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_item, key, value)
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    return db_item

def delete_item(db: Session, *, item_id: uuid.UUID) -> Optional[models.Item]:
    db_item = db.query(models.Item).filter(models.Item.id == item_id).first()
    if db_item:
        db.delete(db_item)
        db.commit()
    return db_item
--- END OF FILE backend/app/crud/crud_item.py ---

--- START OF FILE backend/app/commands/utils.py ---
# backend/app/commands/utils.py
import re
import logging
from typing import Any, List, Optional, Tuple, Dict
import uuid
import random

from app import models, schemas # Group app-level imports
from app.models.item import EQUIPMENT_SLOTS
from app.schemas.common_structures import ExitDetail


logger_utils = logging.getLogger(__name__)


def get_visible_length(s: str) -> int:
    """Removes HTML tags and returns the length of the visible string."""
    return len(re.sub(r'<[^>]+>', '', s))


def format_room_items_for_player_message(
    room_items: List[models.RoomItemInstance]
) -> Tuple[str, Dict[int, uuid.UUID]]:
    """Formats items on the ground into a readable string, numbered, and returns a map."""
    lines = []
    item_map: Dict[int, uuid.UUID] = {}

    if room_items:
        lines.append("\nYou also see on the ground:")
        # Sort room items by name before displaying and mapping
        # This ensures consistent numbering if the order from DB isn't guaranteed
        sorted_room_items = sorted(room_items, key=lambda ri: ri.item.name if ri.item else "")

        for idx, room_item_instance in enumerate(sorted_room_items):
            item_name = room_item_instance.item.name if room_item_instance.item else "Unknown Item"
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            item_name_html = f"<span class='inv-item-name'>{item_name}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {room_item_instance.quantity})</span>"
            prefix_html = f"  {item_number_html} "

            lines.append(f"{prefix_html}{item_name_html} {item_qty_html}")
            item_map[idx + 1] = room_item_instance.id # Map display number to original instance ID

    return "\n".join(lines), item_map


def _format_ambiguity_prompt(
    target_ref: str,
    matches: List[models.RoomItemInstance],
    match_type_desc: str
) -> str:
    """Helper to create a prompt when multiple items match a target reference."""
    prompt_lines = [f"Multiple items {match_type_desc} '{target_ref}'. Which did you mean?"]
    # Sort matches for consistent numbering in prompt.
    display_sorted_matches = sorted(matches, key=lambda inst: inst.item.name if inst.item else "")

    for i, item_match in enumerate(display_sorted_matches):
        item_name = item_match.item.name if item_match.item else "Unknown Item"
        prompt_lines.append(f"  - {item_name}") # Consider adding numbers if commands will use them

    return "\n".join(prompt_lines)


def resolve_room_item_target(
    target_ref: str,
    items_on_ground: List[models.RoomItemInstance]
) -> Tuple[Optional[models.RoomItemInstance], Optional[str]]:
    """
    Resolves a target reference (name, number, tag) to a specific RoomItemInstance.
    Handles ambiguity by returning a prompt message.
    """
    if not items_on_ground:
        return None, "There is nothing on the ground here."

    target_ref_lower = target_ref.lower().strip()
    if not target_ref_lower:
        return None, "Get what?"

    # To match format_room_items_for_player_message, resolve numbers based on the sorted order
    sorted_items_for_resolution = sorted(items_on_ground, key=lambda ri: ri.item.name if ri.item else "")

    try:
        num_ref = int(target_ref_lower)
        if 1 <= num_ref <= len(sorted_items_for_resolution):
            return sorted_items_for_resolution[num_ref - 1], None
    except ValueError:
        # Not a number, proceed to name/tag matching
        pass

    exact_name_matches: List[models.RoomItemInstance] = []
    exact_tag_matches: List[models.RoomItemInstance] = []
    keyword_matches: List[models.RoomItemInstance] = [] # e.g., for "key" type
    partial_name_matches: List[models.RoomItemInstance] = []

    # For name/tag matching, iterate through the original list.
    # Order doesn't matter for these match types until ambiguity resolution.
    for item_instance in items_on_ground:
        if not item_instance.item or not item_instance.item.name:
            continue

        item_name_lower = item_instance.item.name.lower()
        item_type_lower = item_instance.item.item_type.lower() if item_instance.item.item_type else ""
        item_properties = item_instance.item.properties or {}
        item_tag_from_prop = item_properties.get("item_tag", "").lower()

        if item_name_lower == target_ref_lower:
            exact_name_matches.append(item_instance)
        if item_tag_from_prop and item_tag_from_prop == target_ref_lower:
            if item_instance not in exact_tag_matches: # Avoid duplicates if name and tag are same
                exact_tag_matches.append(item_instance)
        if target_ref_lower == "key" and "key" in item_type_lower: # Special handling for "key"
            if item_instance not in keyword_matches:
                keyword_matches.append(item_instance)
        if item_name_lower.startswith(target_ref_lower):
            # Add to partial matches only if not already an exact match by name or tag
            if item_instance not in exact_name_matches and \
               item_instance not in exact_tag_matches and \
               item_instance not in partial_name_matches:
                partial_name_matches.append(item_instance)

    # Prioritize match types
    if len(exact_name_matches) == 1:
        return exact_name_matches[0], None
    if len(exact_name_matches) > 1:
        return None, _format_ambiguity_prompt(target_ref, exact_name_matches, "exactly named")

    if len(exact_tag_matches) == 1:
        return exact_tag_matches[0], None
    if len(exact_tag_matches) > 1:
        return None, _format_ambiguity_prompt(target_ref, exact_tag_matches, "tagged as")

    if target_ref_lower == "key" and keyword_matches: # Check keyword matches for "key"
        if len(keyword_matches) == 1:
            return keyword_matches[0], None
        if len(keyword_matches) > 1:
            return None, _format_ambiguity_prompt("key", keyword_matches, "of type 'key'")

    if len(partial_name_matches) == 1:
        return partial_name_matches[0], None
    if len(partial_name_matches) > 1:
        return None, _format_ambiguity_prompt(target_ref, partial_name_matches, "partially named")

    return None, f"You don't see anything like '{target_ref}' on the ground here."


def format_room_mobs_for_player_message(
    room_mobs: List[models.RoomMobInstance]
) -> Tuple[str, Dict[int, uuid.UUID]]:
    """Formats mobs in the room into a readable string, numbered, and returns a map."""
    lines = []
    mob_map: Dict[int, uuid.UUID] = {}

    if room_mobs:
        lines.append("\nAlso here:")
        # Sort mobs by name for consistent display numbering
        sorted_room_mobs = sorted(room_mobs, key=lambda m: m.mob_template.name if m.mob_template else "")

        for idx, mob_instance in enumerate(sorted_room_mobs):
            template = mob_instance.mob_template
            mob_name = template.name if template else "Unknown Creature"
            mob_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            mob_name_html = f"<span class='inv-item-name'>{mob_name}</span>"

            lines.append(f"  {mob_number_html} {mob_name_html}")
            mob_map[idx + 1] = mob_instance.id # Map display number to original instance ID

    return "\n".join(lines), mob_map


def format_inventory_for_player_message(
    inventory_display_schema: schemas.CharacterInventoryDisplay
) -> str:
    """Formats a character's complete inventory for display, aggregating all items by name."""
    lines = []

    # --- Equipped Items (Logic is fine, no changes needed here) ---
    equipped_item_parts = []
    max_visible_equipped_prefix_len = 0

    if inventory_display_schema.equipped_items:
        equipped_list_for_sorting = []
        for slot_key, inv_item_schema in inventory_display_schema.equipped_items.items():
            processed_slot_key = str(slot_key).strip()
            display_slot_name_raw = EQUIPMENT_SLOTS.get(processed_slot_key, processed_slot_key.capitalize())
            equipped_list_for_sorting.append((display_slot_name_raw, slot_key, inv_item_schema))
        
        equipped_list_for_sorting.sort(key=lambda x: x[0]) # Sort by display_slot_name_raw

        for display_slot_name_raw, _slot_key, inv_item_schema in equipped_list_for_sorting:
            slot_name_html = f"<span class='inv-slot-name'>{display_slot_name_raw}</span>"
            prefix_html = f"  [{slot_name_html}]"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_equipped_prefix_len = max(max_visible_equipped_prefix_len, visible_prefix_len)

            item_name_raw = inv_item_schema.item.name.strip() if inv_item_schema.item else "Unknown Item"
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {inv_item_schema.quantity})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"

            equipped_item_parts.append({
                'sort_key': display_slot_name_raw,
                'prefix_html': prefix_html,
                'visible_prefix_len': visible_prefix_len,
                'suffix_html': suffix_html
            })

    lines.append(f"<span class='inv-section-header'>--- Equipped ---</span>")
    if equipped_item_parts:
        for parts in equipped_item_parts: # Already sorted by sort_key (display_slot_name_raw)
            padding_needed = max(0, (max_visible_equipped_prefix_len + 2) - parts['visible_prefix_len'])
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else:
        lines.append("  Nothing equipped. You're practically naked, you degenerate.")

    # --- Backpack Items (THE NEW, BETTER LOGIC) ---
    lines.append(f"\n<span class='inv-section-header'>--- Backpack ---</span>")

    # ONE dictionary to rule them all. Key by item NAME for aggregation.
    aggregated_backpack_items: Dict[str, Dict[str, Any]] = {}

    if inventory_display_schema.backpack_items:
        for inv_item_schema in inventory_display_schema.backpack_items:
            if not inv_item_schema.item:
                logger_utils.warning(
                    f"Inventory item schema (ID: {inv_item_schema.id if hasattr(inv_item_schema, 'id') else 'N/A'}) "
                    "missing nested item details."
                )
                continue

            item_name = inv_item_schema.item.name
            if item_name not in aggregated_backpack_items:
                aggregated_backpack_items[item_name] = {
                    "name": item_name,
                    "quantity": 0,  # <-- THE FIX IS HERE
                }
            aggregated_backpack_items[item_name]["quantity"] += inv_item_schema.quantity

    # Convert the aggregated dictionary to a list for sorting and display
    final_backpack_display_entries = sorted(
        list(aggregated_backpack_items.values()), 
        key=lambda x: x["name"]
    )

    backpack_item_parts = []
    max_visible_backpack_prefix_len = 0
    if final_backpack_display_entries:
        for idx, entry_data in enumerate(final_backpack_display_entries):
            item_number_html = f"<span class='inv-backpack-number'>{idx + 1}.</span>"
            prefix_html = f"  {item_number_html}"
            visible_prefix_len = get_visible_length(prefix_html)
            max_visible_backpack_prefix_len = max(max_visible_backpack_prefix_len, visible_prefix_len)

            item_name_raw = entry_data["name"].strip()
            item_name_html = f"<span class='inv-item-name'>{item_name_raw}</span>"
            item_qty_html = f"<span class='inv-item-qty'>(Qty: {entry_data['quantity']})</span>"
            suffix_html = f"{item_name_html} {item_qty_html}"

            backpack_item_parts.append({
                'prefix_html': prefix_html,
                'visible_prefix_len': visible_prefix_len,
                'suffix_html': suffix_html
            })

        for parts in backpack_item_parts:
            padding_needed = max(0, (max_visible_backpack_prefix_len + 1) - parts['visible_prefix_len'])
            padding_spaces = " " * padding_needed
            lines.append(f"{parts['prefix_html']}{padding_spaces}{parts['suffix_html']}")
    else:
        lines.append("  Your backpack is as empty as your skull.")

    # --- Currency (No changes needed) ---
    lines.append(f"\n<span class='inv-section-header'>--- Currency ---</span>")
    currency_parts = []
    if inventory_display_schema.platinum > 0:
        currency_parts.append(f"<span class='currency platinum'>{inventory_display_schema.platinum}p</span>")
    if inventory_display_schema.gold > 0:
        currency_parts.append(f"<span class='currency gold'>{inventory_display_schema.gold}g</span>")
    if inventory_display_schema.silver > 0:
        currency_parts.append(f"<span class='currency silver'>{inventory_display_schema.silver}s</span>")
    if currency_parts or inventory_display_schema.copper > 0:
        currency_parts.append(f"<span class='currency copper'>{inventory_display_schema.copper}c</span>")

    if currency_parts:
        lines.append(f"  {' '.join(currency_parts)}")
    else:
        lines.append("  You are utterly destitute. Not a single coin to your pathetic name.")

    return "\n".join(lines)

def format_room_npcs_for_player_message(
    room_npcs: List[models.NpcTemplate]
) -> str:
    """Formats NPCs in the room into a readable string."""
    if not room_npcs:
        return ""

    lines = ["\nYou see here:"]
    # Sort NPCs by name for consistent display
    sorted_room_npcs = sorted(room_npcs, key=lambda c: c.name)

    for npc_template in sorted_room_npcs:
        npc_name_html = f"<span class='npc-name'>{npc_template.name}</span>"
        # Example: Bjorne Ironhand (Weaponsmith)
        npc_type_html = f"<span class='npc-type'>({npc_template.npc_type.replace('_', ' ').title()})</span>"
        lines.append(f"  {npc_name_html} {npc_type_html}")

    return "\n".join(lines)

def roll_dice(dice_str: str):
    """Rolls dice based on a string like '2d6+3'."""
    if not dice_str:
        return 0

    dice_str = dice_str.replace(" ", "").lower()
    parts = dice_str.split('d')
    num_dice = 1

    if not parts[0] and len(parts) > 1: # Handles "d6" case
        num_dice = 1
    elif parts[0]:
        try:
            num_dice = int(parts[0])
        except ValueError:
            # If the first part is not 'd' and not a number, it might be a flat number
            try:
                return int(parts[0])
            except ValueError:
                return 0 # Invalid format

    if len(parts) < 2: # Only a number was provided, e.g., "5"
        return num_dice

    dice_spec = parts[1]
    modifier = 0
    dice_sides_str = dice_spec

    if '+' in dice_spec:
        sides_mod = dice_spec.split('+', 1)
        dice_sides_str = sides_mod[0]
        try:
            modifier = int(sides_mod[1])
        except (ValueError, IndexError):
            return 0 # Invalid modifier
    elif '-' in dice_spec:
        sides_mod_neg = dice_spec.split('-', 1)
        dice_sides_str = sides_mod_neg[0]
        try:
            modifier = -int(sides_mod_neg[1])
        except (ValueError, IndexError):
            return 0 # Invalid modifier

    try:
        dice_sides = int(dice_sides_str)
    except ValueError:
        return 0 # Invalid dice sides

    if dice_sides <= 0:
        return 0 # Cannot roll zero or negative-sided dice

    total_roll = sum(random.randint(1, dice_sides) for _ in range(num_dice))
    return total_roll + modifier


def resolve_mob_target(
    target_ref: str,
    mobs_in_room: List[models.RoomMobInstance]
) -> Tuple[Optional[models.RoomMobInstance], Optional[str]]:
    """Resolves a target reference (name or number) to a specific RoomMobInstance."""
    if not mobs_in_room:
        return None, f"There is nothing called '{target_ref}' here to target." # More specific

    target_ref_lower = target_ref.lower().strip()
    if not target_ref_lower:
        return None, "Attack what?" # Or "Target what?"

    # Sort mobs for consistent numbering, matching format_room_mobs_for_player_message
    sorted_mobs_for_resolution = sorted(
        mobs_in_room,
        key=lambda m: m.mob_template.name if m.mob_template else ""
    )

    try:
        num_ref = int(target_ref_lower) # Use target_ref_lower for consistency
        if 1 <= num_ref <= len(sorted_mobs_for_resolution):
            return sorted_mobs_for_resolution[num_ref - 1], None
    except ValueError:
        pass # Not a number

    exact_matches: List[models.RoomMobInstance] = []
    for mob_instance in sorted_mobs_for_resolution:
        if mob_instance.mob_template and mob_instance.mob_template.name.lower() == target_ref_lower:
            exact_matches.append(mob_instance)

    if len(exact_matches) == 1:
        return exact_matches[0], None
    if len(exact_matches) > 1:
        prompt_lines = [f"Multiple exact matches for '{target_ref}'. Which did you mean?"]
        for i, mob_match in enumerate(exact_matches): # Already sorted
            mob_name = mob_match.mob_template.name if mob_match.mob_template else "Unknown Mob"
            prompt_lines.append(f"  {i + 1}. {mob_name} (Exact)")
        return None, "\n".join(prompt_lines)

    partial_matches: List[models.RoomMobInstance] = []
    # Use a set to avoid adding the same mob multiple times if it matches different criteria
    matched_mob_ids_for_partial = set()
    for mob_instance in sorted_mobs_for_resolution: # Iterate sorted list for consistent partial match order
        if not (mob_instance.mob_template and mob_instance.mob_template.name):
            continue

        mob_name_lower = mob_instance.mob_template.name.lower()
        mob_name_words = mob_name_lower.split()
        matched_this_instance = False

        if mob_name_lower.startswith(target_ref_lower):
            matched_this_instance = True
        if not matched_this_instance:
            for word in mob_name_words:
                if word.startswith(target_ref_lower):
                    matched_this_instance = True
                    break
        if not matched_this_instance: # Check if target is a word in the name
            if target_ref_lower in mob_name_words:
                matched_this_instance = True
        
        if matched_this_instance and mob_instance.id not in matched_mob_ids_for_partial:
            partial_matches.append(mob_instance)
            matched_mob_ids_for_partial.add(mob_instance.id)

    if len(partial_matches) == 1:
        return partial_matches[0], None
    if len(partial_matches) > 1:
        prompt_lines = [f"Which '{target_ref}' did you mean?"]
        for i, mob_match in enumerate(partial_matches): # Already sorted
            mob_name = mob_match.mob_template.name if mob_match.mob_template else "Unknown Mob"
            prompt_lines.append(f"  {i + 1}. {mob_name}")
        return None, "\n".join(prompt_lines)

    return None, f"Cannot find anything called '{target_ref}' here to target."


def format_room_characters_for_player_message(
    room_characters: List[models.Character]
) -> str:
    """Formats other characters in the room into a readable string."""
    if not room_characters:
        return ""

    lines = ["\nAlso present:"]
    # Sort characters by name for consistent display
    sorted_room_characters = sorted(room_characters, key=lambda c: c.name)

    for char_orm in sorted_room_characters:
        char_name_html = f"<span class='char-name'>{char_orm.name}</span>"
        char_class_html = f"<span class='char-class'>({char_orm.class_name or 'Unknown Class'})</span>"
        lines.append(f"  {char_name_html} {char_class_html}")

    return "\n".join(lines)


def get_dynamic_room_description(room_orm: models.Room) -> str:
    """
    Processes a room's base description, replacing dynamic exit placeholders
    with their current locked/unlocked status descriptions.
    """
    base_description = room_orm.description or "You see nothing remarkable."
    if not room_orm.exits:
        return base_description

    processed_description = base_description
    for direction, exit_data_dict in room_orm.exits.items():
        if not isinstance(exit_data_dict, dict):
            logger_utils.warning(f"Exit data for '{direction}' in room '{room_orm.name}' is not a dict. Skipping.")
            continue
        try:
            exit_detail = schemas.ExitDetail(**exit_data_dict) # Use Pydantic model for validation and defaults
            placeholder = f"[DYNAMIC_EXIT_{direction.upper()}]"

            status_description = ""
            if exit_detail.is_locked:
                status_description = exit_detail.description_when_locked or f"The way {direction} is locked."
            elif exit_detail.description_when_unlocked:
                status_description = exit_detail.description_when_unlocked
            else: # Not locked, and no specific unlocked description
                status_description = f"The way {direction} is open."

            if placeholder in processed_description:
                processed_description = processed_description.replace(placeholder, status_description)
            # else:
                # logger_utils.debug(f"Placeholder '{placeholder}' not found in description for room '{room_orm.name}'.")

        except Exception as e_parse: # Catch Pydantic validation errors or others
            logger_utils.error(
                f"Error parsing exit detail for dynamic desc in room '{room_orm.name}', exit '{direction}': {e_parse}",
                exc_info=True
            )
            continue

    return processed_description
--- END OF FILE backend/app/commands/utils.py ---

--- START OF FILE backend/app/game_logic/npc_dialogue_ticker.py ---
# backend/app/game_logic/npc_dialogue_ticker.py
import asyncio
import random
import logging
from typing import Optional, Dict, List
import uuid

from sqlalchemy.orm import Session
from app import crud, models
from app.core.config import settings
from app.db.session import SessionLocal
from app.websocket_manager import connection_manager
from app.services.world_service import broadcast_say_to_room

logger = logging.getLogger(__name__)

# --- Gemini API Configuration ---
client = None
try:
    from google import genai
    if settings.GEMINI_API_KEY:
        client = genai.Client(api_key=settings.GEMINI_API_KEY)
        logger.info("Gemini AI Client initialized successfully.")
    else:
        logger.warning("GEMINI_API_KEY not found in settings. NPC AI dialogue will be disabled.")
except ImportError:
    logger.warning("google-genai library not found. Please ensure it is in requirements.txt and the container is rebuilt.")
except Exception as e:
    logger.error(f"Failed to initialize Gemini AI Client: {e}", exc_info=True)


# --- Ticker State ---
_dialogue_ticker_task: Optional[asyncio.Task] = None
_last_spoken_times: dict[str, float] = {}
DIALOGUE_COOLDOWN_SECONDS = 60

def get_gemini_dialogue(npc: models.NpcTemplate, players_in_room: list) -> str:
    """Calls the Gemini API to generate dialogue for an NPC."""
    if not client:
        if npc.dialogue_lines_static:
            return random.choice(npc.dialogue_lines_static)
        return f"{npc.name} stands here silently."

    try:
        # We only need player names for the prompt
        player_names = ", ".join([p.name for p in players_in_room])
        prompt = f"""
        {npc.personality_prompt}

        You are in a room with the following people: {player_names}.
        Based on your personality, say something appropriate to them or the situation.
        Do not use asterisks or action descriptions. Just provide the line of dialogue.
        Keep your dialogue to one or two sentences.
        """

        response = client.models.generate_content(
            model='models/gemini-2.5-flash-preview-05-20',                          
            contents=prompt
        )

        if response and hasattr(response, 'text') and response.text:
            dialogue = response.text.strip().replace('"', '')
            logger.info(f"Generated dialogue for {npc.name}: '{dialogue}'")
            return dialogue
        else:
            logger.warning(f"Gemini API returned a response with no text for {npc.name}. Using fallback.")
            if npc.dialogue_lines_static:
                return random.choice(npc.dialogue_lines_static)
            return f"{npc.name} seems to be thinking, but says nothing."

    except Exception as e:
        logger.error(f"Error calling Gemini API for NPC {npc.name}: {e}", exc_info=True)
        if npc.dialogue_lines_static:
            return random.choice(npc.dialogue_lines_static)
        return f"{npc.name} clears their throat but says nothing."

async def dialogue_ticker_loop():
    """The main loop for the NPC dialogue ticker."""
    while True:
        try:
            await asyncio.sleep(15)
            if not client:
                continue
                
            logger.debug("Dialogue Ticker: Checking for NPCs to speak...")

            # --- NEW, CACHE-CENTRIC LOGIC ---
            # Step 1: Get all online character locations from the cache.
            online_character_locations = connection_manager.get_all_player_locations()
            if not online_character_locations:
                continue

            # Step 2: Invert the dictionary to group characters by room.
            # Result: { room_id: [char_id_1, char_id_2], ... }
            rooms_with_players: Dict[uuid.UUID, List[uuid.UUID]] = {}
            for char_id, room_id in online_character_locations.items():
                if room_id not in rooms_with_players:
                    rooms_with_players[room_id] = []
                rooms_with_players[room_id].append(char_id)
            
            # Now we have a list of rooms that are guaranteed to have online players.
            with SessionLocal() as db:
                for room_id, char_ids_in_room in rooms_with_players.items():
                    room = crud.crud_room.get_room_by_id(db, room_id=room_id)
                    if not room or not room.npc_placements:
                        continue # This room has no NPCs, move on.

                    # We need the character objects for their names for the prompt.
                    # This is the only database hit we need for characters now.
                    player_character_objects = [crud.crud_character.get_character(db, cid) for cid in char_ids_in_room]
                    # Filter out any that might not be found for some reason
                    valid_players_in_room = [p for p in player_character_objects if p]

                    if not valid_players_in_room:
                        continue

                    # Now, process NPCs for this confirmed active room
                    npcs_in_room = crud.crud_room.get_npcs_in_room(db, room=room)
                    for npc in npcs_in_room:
                        last_spoken = _last_spoken_times.get(npc.unique_name_tag, 0)
                        if asyncio.get_event_loop().time() - last_spoken < DIALOGUE_COOLDOWN_SECONDS:
                            continue

                        # Generate and broadcast dialogue
                        loop = asyncio.get_running_loop()
                        dialogue_line = await loop.run_in_executor(
                            None,
                            get_gemini_dialogue,
                            npc,
                            valid_players_in_room
                        )
                        
                        await broadcast_say_to_room(
                            db=db,
                            speaker_name=npc.name,
                            room_id=room.id,
                            message=dialogue_line
                        )
                        _last_spoken_times[npc.unique_name_tag] = asyncio.get_event_loop().time()

        except asyncio.CancelledError:
            logger.info("Dialogue Ticker: Task cancelled.")
            break
        except Exception as e:
            logger.error(f"Dialogue Ticker: Unhandled error in loop: {e}", exc_info=True)
            await asyncio.sleep(30)

def start_dialogue_ticker_task():
    global _dialogue_ticker_task
    if _dialogue_ticker_task is None or _dialogue_ticker_task.done():
        logger.info("Dialogue Ticker: Attempting to start task...")
        _dialogue_ticker_task = asyncio.create_task(dialogue_ticker_loop())
        logger.info("Dialogue Ticker: Task created and running.")

def stop_dialogue_ticker_task():
    global _dialogue_ticker_task
    if _dialogue_ticker_task and not _dialogue_ticker_task.done():
        _dialogue_ticker_task.cancel()
        logger.info("Dialogue Ticker: Task cancellation requested.")
    _dialogue_ticker_task = None
--- END OF FILE backend/app/game_logic/npc_dialogue_ticker.py ---

--- START OF FILE backend/app/services/world_service.py ---
# backend/app/services/world_service.py
import uuid
from typing import Optional

from sqlalchemy.orm import Session

from app import crud
from app.websocket_manager import connection_manager

async def broadcast_say_to_room(
    db: Session,
    speaker_name: str,
    room_id: uuid.UUID,
    message: str,
    exclude_player_id: Optional[uuid.UUID] = None
):
    """Broadcasts a 'say' message to all players in a room."""
    # We use a distinct CSS class for NPC speech to differentiate it from player speech.
    full_message = f"<span class='npc-name'>{speaker_name}</span> says, \"{message}\""

    # Find all characters (players) in the target room.
    characters_to_notify = crud.crud_character.get_characters_in_room(db, room_id=room_id)
    
    player_ids_to_send_to = []
    for char in characters_to_notify:
        # Check if the character's controlling player is actually connected via WebSocket.
        if connection_manager.is_player_connected(char.player_id):
            # Ensure we don't send the message to an excluded player (e.g., if a player triggered the event).
            if exclude_player_id is None or char.player_id != exclude_player_id:
                player_ids_to_send_to.append(char.player_id)
    
    if player_ids_to_send_to:
        # Using 'ooc_message' type is fine as it's a simple text broadcast.
        # The client will render the HTML spans we've included.
        payload = {"type": "ooc_message", "message": full_message}
        await connection_manager.broadcast_to_players(payload, player_ids_to_send_to)
--- END OF FILE backend/app/services/world_service.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    owner: Mapped["Player"] = relationship(back_populates="characters")

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)

    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/character_inventory_item.py ---
# backend/app/models/character_inventory_item.py
import uuid
from typing import TYPE_CHECKING, Optional

from sqlalchemy import ForeignKey, Integer, Boolean, String
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .character import Character  # noqa: F401
    from .item import Item  # noqa: F401


class CharacterInventoryItem(Base):
    __tablename__ = "character_inventory_items"

    # Composite Primary Key: (character_id, item_id)
    # However, SQLAlchemy prefers a single surrogate primary key for association objects
    # if they have additional attributes beyond just the foreign keys.
    # Let's add an explicit id for this table for easier reference, though character_id + item_id could form a unique constraint.
    # Or, if an item can appear multiple times (e.g. two identical non-stackable swords),
    # then an auto-incrementing ID for this table row is essential.
    # Let's assume for now a character can only have ONE "entry" for a given item_id, and quantity handles multiples if stackable.
    # If not stackable, and they have two of the same sword, they'd be two separate Item instances in the Item table (e.g. with serial numbers or unique IDs anyway).
    # For our MUD, usually an Item is a "template". If a player has two "Long Sword" (same item_id), this table handles it.
    # Okay, if Item.stackable is false, each instance is a separate row here with quantity 1.
    # If Item.stackable is true, one row with quantity > 1.
    # Let's give this table its own UUID PK for simplicity in referencing a specific *instance* in inventory.

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, comment="Unique ID for this specific instance of an item in a character's inventory")
    
    character_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("characters.id"), index=True, nullable=False)
    item_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("items.id"), index=True, nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    
    # Indicates if this specific inventory item instance is currently equipped
    equipped: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False, index=True)
    
    # If equipped, this specifies which of the character's equipment slots it occupies.
    # This must be one of the keys from models.item.EQUIPMENT_SLOTS.
    # Necessary for items that can fit into more than one type of slot (e.g. generic 'ring' item into 'finger_1' or 'finger_2')
    # or to distinguish main_hand vs off_hand for identical weapons.
    equipped_slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="Actual character slot occupied if equipped, e.g. 'finger_1'")

    # Relationships
    character: Mapped["Character"] = relationship(back_populates="inventory_items")
    item: Mapped["Item"] = relationship() # No back_populates needed if Item doesn't need to know all its inventory entries directly

    def __repr__(self) -> str:
        return f"<CharInvItem(id={self.id}, char_id='{self.character_id}', item_id='{self.item_id}', qty={self.quantity}, equipped={self.equipped}, slot='{self.equipped_slot}')>"
--- END OF FILE backend/app/models/character_inventory_item.py ---

--- START OF FILE backend/app/models/npc_template.py ---
# backend/app/models/npc_template.py
import uuid
from typing import Optional, Dict, Any, List

from sqlalchemy import String, Text
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column

from ..db.base_class import Base

class NpcTemplate(Base):
    __tablename__ = "npc_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    unique_name_tag: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text)
    
    npc_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., merchant, quest_giver, guard")
    
    # For LLM integration
    personality_prompt: Mapped[Optional[str]] = mapped_column(Text)
    
    # For simple, non-LLM dialogue
    dialogue_lines_static: Mapped[Optional[List[str]]] = mapped_column(JSONB)
    
    # For merchants
    shop_inventory: Mapped[Optional[List[str]]] = mapped_column(JSONB, comment="List of item names or tags the NPC sells")

    def __repr__(self) -> str:
        return f"<NpcTemplate(id={self.id}, name='{self.name}', type='{self.npc_type}')>"
--- END OF FILE backend/app/models/npc_template.py ---

--- START OF FILE backend/app/models/room.py ---
# backend/app/models/room.py

import uuid
from typing import Optional, Dict, List, TYPE_CHECKING, Any 
from enum import Enum as PyEnum # To avoid conflict with potential future 'Enum' table

from sqlalchemy import Column, Integer, String, Text, Enum as SQLEnum # Enum for DB
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

if TYPE_CHECKING:
    from .room_item_instance import RoomItemInstance 
    from .room_mob_instance import RoomMobInstance

# NEW RoomType Enum
class RoomTypeEnum(PyEnum):
    STANDARD = "standard"
    SANCTUARY = "sanctuary" # No combat, perhaps faster regen
    SHOP = "shop"
    TRAINER = "trainer"
    DUNGEON_ENTRANCE = "dungeon_entrance"
    PUZZLE = "puzzle"
    # Add more as needed

class Room(Base):
    __tablename__ = "rooms"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    x: Mapped[int] = mapped_column(Integer, nullable=False)
    y: Mapped[int] = mapped_column(Integer, nullable=False)
    z: Mapped[int] = mapped_column(Integer, nullable=False)
    
    room_type: Mapped[RoomTypeEnum] = mapped_column( # <<< NEW FIELD
        SQLEnum(RoomTypeEnum, name="roomtypeenum", create_type=True), # create_type=True for SQLAlchemy to manage Enum in DB
        default=RoomTypeEnum.STANDARD, 
        nullable=False,
        index=True
    )

    exits: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSONB, 
        nullable=True, 
        default=lambda: {}
    )
    interactables: Mapped[Optional[List[Dict[str, Any]]]] = mapped_column(
        JSONB, 
        nullable=True, 
        default=lambda: []
    )
    npc_placements: Mapped[Optional[List[str]]] = mapped_column(
        JSONB,
        nullable=True,
        comment="List of unique_name_tags for NPC templates to be placed in this room."
    )
    items_on_ground: Mapped[List["RoomItemInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin"
    )
    mobs_in_room: Mapped[List["RoomMobInstance"]] = relationship(
        back_populates="room",
        cascade="all, delete-orphan",
        lazy="selectin" 
    )

    def __repr__(self) -> str:
        return f"<Room(id={self.id}, name='{self.name}', type='{self.room_type.value}', x={self.x}, y={self.y}, z={self.z})>"
--- END OF FILE backend/app/models/room.py ---

--- START OF FILE backend/app/schemas/item.py ---
# backend/app/schemas/item.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List

# --- Item Schemas ---
class ItemBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None
    item_type: str = Field(..., description="e.g., weapon, armor, potion, junk")
    slot: Optional[str] = Field(None, description="Primary equippable slot type, e.g., head, main_hand, consumable")
    properties: Optional[Dict[str, Any]] = Field(None, description="e.g., {'damage': '1d6', 'armor_class': 5}")
    weight: float = Field(0.0, ge=0)
    value: int = Field(0, ge=0)
    stackable: bool = False
    max_stack_size: Optional[int] = Field(1, ge=1)

class RoomItemInstanceBase(BaseModel):
    quantity: int
    item: 'Item' # Use the existing Item schema for the template details

class RoomItemInstanceInDB(RoomItemInstanceBase):
    id: uuid.UUID
    room_id: uuid.UUID
    item_id: uuid.UUID
    
    class Config:
        from_attributes = True
class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel): # Allow partial updates
    name: Optional[str] = None
    description: Optional[str] = None
    item_type: Optional[str] = None
    slot: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None
    weight: Optional[float] = None
    value: Optional[int] = None
    stackable: Optional[bool] = None
    max_stack_size: Optional[int] = None

class ItemInDBBase(ItemBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

class Item(ItemInDBBase): # For returning item info
    pass

class ItemInDB(ItemInDBBase): # More complete internal representation if needed
    pass


# --- CharacterInventoryItem Schemas ---
# This represents an item *instance* in a character's inventory

class CharacterInventoryItemBase(BaseModel):
    item_id: uuid.UUID
    quantity: int = Field(1, ge=1)
    equipped: bool = False
    equipped_slot: Optional[str] = None # Actual character slot occupied if equipped

class CharacterInventoryItemCreate(CharacterInventoryItemBase):
    # character_id will be supplied by the service/path
    pass

class CharacterInventoryItemUpdate(BaseModel):
    quantity: Optional[int] = Field(None, ge=1)
    equipped: Optional[bool] = None
    equipped_slot: Optional[str] = None

class CharacterInventoryItemInDBBase(CharacterInventoryItemBase):
    id: uuid.UUID # The unique ID of this inventory entry
    character_id: uuid.UUID
    item: Item # Include full item details when displaying inventory

    class Config:
        from_attributes = True

class CharacterInventoryItem(CharacterInventoryItemInDBBase): # For returning to client
    pass


# --- Composite Schema for Displaying Full Inventory ---
class CharacterInventoryDisplay(BaseModel):
    equipped_items: Dict[str, CharacterInventoryItem] = Field(default_factory=dict, description="Items currently equipped, keyed by their equipped_slot")
    backpack_items: List[CharacterInventoryItem] = Field(default_factory=list, description="Items in inventory but not equipped")
    platinum: int = 0
    gold: int = 0
    silver: int = 0
    copper: int = 0
    # Add more fields like total_weight, currency later

class EquipRequest(BaseModel):
    target_slot: Optional[str] = Field(None, description="Optional: The specific character slot to equip the item to, e.g., 'finger_1'")
--- END OF FILE backend/app/schemas/item.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)

    # Currency: Optional at creation, with defaults
    platinum_coins: Optional[int] = Field(0, description="Platinum coins owned by the character")
    gold_coins: Optional[int] = Field(0, description="Gold coins owned by the character")
    silver_coins: Optional[int] = Field(0, description="Silver coins owned by the character")
    copper_coins: Optional[int] = Field(100, description="Copper coins owned by the character, default 100 for new chars")

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):  # Inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    platinum_coins: int # type: ignore
    gold_coins: int # type: ignore
    silver_coins: int # type: ignore
    copper_coins: int # type: ignore

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/schemas/npc.py ---
# backend/app/schemas/npc.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

# --- NpcTemplate Schemas ---

class NpcTemplateBase(BaseModel):
    unique_name_tag: str = Field(..., description="Unique identifier tag for this NPC template.")
    name: str
    description: Optional[str] = None
    npc_type: str
    personality_prompt: Optional[str] = None
    dialogue_lines_static: Optional[List[str]] = None
    shop_inventory: Optional[List[str]] = None

class NpcTemplateCreate(NpcTemplateBase):
    pass

class NpcTemplateUpdate(NpcTemplateBase):
    pass

class NpcTemplateInDB(NpcTemplateBase):
    id: uuid.UUID

    class Config:
        from_attributes = True

# --- RoomNpcInstance Schemas (We'll need this soon) ---

# This represents an NPC that is actually placed in a room.
# For now, it's very simple, but it could hold state later (e.g., last_spoken_at).
class RoomNpcInstance(BaseModel):
    room_id: uuid.UUID
    npc_template: NpcTemplateInDB # Embed the full template detail
--- END OF FILE backend/app/schemas/npc.py ---

--- START OF FILE backend/app/schemas/room.py ---
# backend/app/schemas/room.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

from ..models.room import RoomTypeEnum
from .common_structures import ExitDetail, InteractableDetail
from .npc import NpcTemplateInDB # Import this properly now
from .item import RoomItemInstanceInDB
from .mob import RoomMobInstance
from .character import Character


# --- Room Schemas ---

# This is the base for what constitutes a "Room" in its simplest form.
class RoomBase(BaseModel):
    name: str
    description: Optional[str] = None
    x: int
    y: int
    z: int
    room_type: RoomTypeEnum = Field(default=RoomTypeEnum.STANDARD)

# This schema is specifically for CREATING rooms from the seeder JSON.
# It must match the structure of the "data" block in rooms_z0.json exactly.
class RoomCreate(RoomBase):
    exits: Optional[Dict[str, Any]] = Field(default_factory=dict)
    interactables: Optional[List[Dict[str, Any]]] = Field(default_factory=list)
    npc_placements: Optional[List[str]] = Field(default_factory=list)
    # Note: We use Dict[str, Any] for exits/interactables here because the seeder
    # does its own detailed Pydantic validation later. This schema is just for capture.

# This is for PARTIAL updates, e.g., via an API endpoint.
class RoomUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    exits: Optional[Dict[str, ExitDetail]] = None
    interactables: Optional[List[InteractableDetail]] = None
    room_type: Optional[RoomTypeEnum] = None
    npc_placements: Optional[List[str]] = None # Allow updating placements via API too

# This is the full representation of a Room as it exists in the database,
# including all relationships, for sending to the client.
class RoomInDB(RoomBase):
    id: uuid.UUID
    exits: Optional[Dict[str, ExitDetail]] = Field(default_factory=dict)
    interactables: Optional[List[InteractableDetail]] = Field(default_factory=list)
    items_on_ground: List[RoomItemInstanceInDB] = []
    mobs_in_room: List[RoomMobInstance] = []
    other_characters: List[Character] = []
    npcs_in_room: List[NpcTemplateInDB] = [] # This is now correct because of the import
    dynamic_description_additions: List[str] = []

    class Config:
        from_attributes = True
--- END OF FILE backend/app/schemas/room.py ---

--- START OF FILE backend/app/seeds/npcs.json ---
[
  {
    "unique_name_tag": "weapon_smith_bjorne",
    "name": "Bjorne Ironhand",
    "description": "A stout dwarf with a beard that seems to have more soot and forge-scale than actual hair in it. He leans against a massive anvil, arms like tree trunks crossed over his chest, eyeing you with an expression that's perpetually unimpressed.",
    "npc_type": "merchant",
    "personality_prompt": "You are Bjorne Ironhand, a grumpy, pragmatic dwarf weaponsmith. You are a master of your craft and have no time for fools. Your dialogue should be short, gruff, and to the point. You often complain about the quality of modern work or the weakness of others. You might occasionally mention your wares, like your 'fine axes' or 'sturdy swords', but only as a statement of fact, not a sales pitch. Never be overly friendly or helpful. Keep your responses to 1-2 sentences. Address players in the room by their names sometimes.  It is fine to use profanity.  For some reason you dislike cats and make jokes about how horrible they are.",
    "dialogue_lines_static": [
      "Hmph. What do you want?",
      "You'll not find a finer axe this side of the mountain. Not that you'd know what to do with it.",
      "Another adventurer... All twigs and no stones.",
      "This hammer has seen better steel than you'll ever be.",
      "Buy something or get out. You're letting the heat out of the forge."
    ],
    "shop_inventory": [
      "Dagger",
      "Rusty Sword",
      "Sharpened Bone",
      "Greataxe"
    ]
  },
  {
    "unique_name_tag": "armor_smith_elara",
    "name": "Elara Silent-Stitch",
    "description": "A tall, focused woman with streaks of grey in her tightly bound hair. She works silently at a large leather-strewn table, her movements economical and precise. She acknowledges your presence with a brief, sharp nod before her eyes return to her work.",
    "npc_type": "merchant",
    "personality_prompt": "You are Elara, a meticulous and quiet master armorer. You speak only when necessary, and your words are practical and precise. You value function over all else. You might observe a player and comment on the poor state of their armor, or the way a particular piece of your own work would offer superior protection in a specific area. You never waste words. Keep your responses to 1-2 short, declarative sentences. You are observant, not rude.",
    "dialogue_lines_static": [
      "A good fit is as important as the steel.",
      "That buckle will not hold.",
      "Measure twice, cut once.",
      "What do you need protecting?",
      "Silence is a fine tool."
    ],
    "shop_inventory": [
      "Cloth Tunic",
      "Wooden Shield",
      "Patched Leather Jerkin",
      "Studded Leather Jerkin",
      "Sturdy Leather Boots"
    ]
  }
]
--- END OF FILE backend/app/seeds/npcs.json ---

--- START OF FILE backend/app/seeds/items.json ---

[
  {
    "name": "Rusty Sword",
    "description": "A short sword, pitted with rust. Better than nothing.",
    "item_type": "weapon",
    "slot": "main_hand",
    "properties": { "damage": "1d6", "damage_type": "slashing", "weapon_type": "sword" },
    "weight": 3.0, "value": 5, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Cloth Tunic",
    "description": "Simple, patched-up clothing.",
    "item_type": "armor", "slot": "torso",
    "properties": { "armor_class_bonus": 1 },
    "weight": 1.0, "value": 2, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Wooden Shield",
    "description": "A basic round wooden shield.",
    "item_type": "armor", "slot": "off_hand",
    "properties": { "armor_class_bonus": 2, "item_subtype": "shield" },
    "weight": 5.0, "value": 8, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Dagger",
    "description": "A small, easily concealable dagger.",
    "item_type": "weapon", "slot": "main_hand",
    "properties": { "damage": "1d4", "damage_type": "piercing", "weapon_type": "dagger", "finesse": true },
    "weight": 1.0, "value": 2, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Archive Key Alpha",
    "description": "A small, intricately carved metal key. Sector 42.",
    "item_type": "key", "slot": null,
    "properties": { "item_tag": "archive_key_alpha" },
    "weight": 0.1, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Basic Healing Draught",
    "description": "A common herbal brew that knits minor wounds.",
    "item_type": "potion", "slot": "consumable",
    "properties": { "effect_type": "heal_direct", "heal_amount_dice": "2d4", "heal_amount_bonus": 2, "cooldown_group": "potion", "cooldown_seconds": 30 },
    "weight": 0.5, "value": 25, "stackable": true, "max_stack_size": 5
  },
  {
    "name": "Lockpicks",
    "description": "A set of fine tools for bypassing simple locks.",
    "item_type": "tool", "slot": null,
    "properties": { "item_tag": "basic_lockpicks", "provides_skill_bonus": { "skill_id_tag": "pick_lock_basic", "bonus_amount": 2 } },
    "weight": 0.2, "value": 50, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Rat Tail",
    "description": "A long, scaly rat tail. Gross.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "rat_tail_junk" },
    "weight": 0.1, "value": 1, "stackable": true, "max_stack_size": 20
  },
  {
    "name": "Cracked Tooth",
    "description": "A small, cracked animal tooth.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "cracked_tooth_junk" },
    "weight": 0.05, "value": 1, "stackable": true, "max_stack_size": 50
  },
  {
    "name": "Beast Pelt (Small)",
    "description": "The pelt of a small, furry creature. Could be useful.",
    "item_type": "crafting_material", "slot": null,
    "properties": { "item_tag": "pelt_small_beast" },
    "weight": 0.5, "value": 3, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Animal Bone",
    "description": "A sturdy animal bone, perhaps from a leg or rib.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "animal_bone_generic" },
    "weight": 0.3, "value": 1, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Old Boot",
    "description": "A single, waterlogged leather boot. Seen better days.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "old_boot_junk" },
    "weight": 1.0, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Rusty Tin Can",
    "description": "An old, rusty tin can. Empty, of course.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "rusty_can_junk" },
    "weight": 0.2, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Goblin Ear",
    "description": "A severed goblin ear. A common, if gruesome, trophy.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "goblin_ear_trophy" },
    "weight": 0.1, "value": 2, "stackable": true, "max_stack_size": 10
  },
  {
    "name": "Crude Dagger Scrap",
    "description": "A piece of a crudely made goblin dagger, broken and useless.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "crude_dagger_scrap" },
    "weight": 0.3, "value": 1, "stackable": true, "max_stack_size": 5
  },
  {
    "name": "Torn Pouch",
    "description": "A small leather pouch, torn and empty.",
    "item_type": "junk", "slot": null,
    "properties": { "item_tag": "torn_pouch_junk" },
    "weight": 0.1, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Studded Leather Jerkin",
    "description": "A sturdy leather jerkin reinforced with metal studs. Offers decent protection without sacrificing too much mobility.",
    "item_type": "armor",
    "slot": "torso",
    "properties": { "armor_class_bonus": 3 },
    "weight": 8.0, "value": 45, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Greataxe",
    "description": "A massive, intimidating axe that requires two hands to wield. It sacrifices defense for pure, unadulterated chopping power.",
    "item_type": "weapon",
    "slot": "main_hand",
    "properties": { "damage": "1d12", "damage_type": "slashing", "weapon_type": "axe", "two_handed": true },
    "weight": 10.0, "value": 30, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Sturdy Leather Boots",
    "description": "Well-worn leather boots that have seen many miles. They protect your precious little feet from the harsh ground.",
    "item_type": "armor",
    "slot": "feet",
    "properties": { "armor_class_bonus": 1 },
    "weight": 2.0, "value": 10, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Patched Leather Jerkin",
    "description": "A jerkin made of mismatched leather patches. Better than nothing, barely.",
    "item_type": "armor",
    "slot": "torso",
    "properties": { "armor_class_bonus": 2 },
    "weight": 6.0, "value": 15, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Cheap Locket",
    "description": "A tarnished, brass-colored locket. It's empty inside.",
    "item_type": "junk",
    "slot": null,
    "properties": { "item_tag": "cheap_locket_junk" },
    "weight": 0.1, "value": 3, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Bent Silver Spoon",
    "description": "A spoon that might have once been silver. It's now bent entirely out of shape.",
    "item_type": "junk",
    "slot": null,
    "properties": { "item_tag": "bent_spoon_junk" },
    "weight": 0.2, "value": 5, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "Sharpened Bone",
    "description": "A long, sharpened piece of bone. It could serve as a crude shiv in a pinch.",
    "item_type": "weapon",
    "slot": "main_hand",
    "properties": { "damage": "1d4", "damage_type": "piercing", "weapon_type": "dagger", "finesse": true },
    "weight": 0.5, "value": 1, "stackable": false, "max_stack_size": 1
  },
  {
    "name": "The Destructor",
    "description": "Point and Kill",
    "item_type": "weapon",
    "slot": "main_hand",
    "properties": { "damage": "10d99", "damage_type": "slashing", "weapon_type": "sword" },
    "weight": 1.0, "value": 500000, "stackable": false, "max_stack_size": 1
  }
]
--- END OF FILE backend/app/seeds/items.json ---

--- START OF FILE backend/app/seeds/rooms_z0.json ---
[
  {
    "unique_tag": "central_hub_0_0_0",
    "data": {
      "name": "Central Processing Unit (CPU)",
      "description": "The air hums. Corridors branch off. [DYNAMIC_EXIT_EAST]. A faint inscription reads 'Sector 0,0,0'. This appears to be some kind of nexus or entry point.",
      "x": 0, "y": 0, "z": 0,
      "room_type": "standard",
      "interactables": [
        {
          "id_tag": "cpu_east_lever",
          "name": "a sturdy metal lever",
          "description": "A heavy metal lever is set into the wall, currently in the 'up' position.",
          "action_verb": "pull",
          "on_interact_effect": {
            "type": "toggle_exit_lock",
            "target_exit_direction": "east",
            "message_success_self": "You pull the lever down with a CLUNK. You hear a mechanism engage nearby.",
            "message_success_others": "{character_name} pulls the lever. A distant clunk is heard."
          }
        }
      ]
    }
  },
  {
    "unique_tag": "east_storage_1_0_0",
    "data": {
      "name": "Secure Storage Vault Epsilon",
      "description": "Dust motes dance in the dim light. Shelves line the walls, mostly empty. Panel E-1. [DYNAMIC_EXIT_WEST]",
      "x": 1, "y": 0, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "outskirts_gate_0_1_0",
    "data": {
      "name": "Dilapidated Northern Gate",
      "description": "A crumbling stone archway marks what might have once been a northern exit from the central complex. The path beyond is overgrown and disappears into a tangle of thorny bushes.",
      "x": 0, "y": 1, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "beginner_path_0_2_0",
    "data": {
      "name": "Overgrown Path",
      "description": "Thorny bushes and grasping weeds choke this narrow path. The air is damp and smells of decay. Small creatures skitter in the undergrowth.",
      "x": 0, "y": 2, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "ruined_shack_clearing_0_3_0",
    "data": {
      "name": "Ruined Shack Clearing",
      "description": "The path opens into a small clearing where the remains of a wooden shack slowly rot. A rusty water pump stands askew nearby.",
      "x": 0, "y": 3, "z": 0,
      "room_type": "standard",
      "interactables": [
        {
          "id_tag": "shack_pump_handle",
          "name": "a rusty pump handle",
          "description": "The handle of the old water pump is stiff but might still move.",
          "action_verb": "pump",
          "on_interact_effect": {
            "type": "custom_event",
            "message_success_self": "You work the pump handle. After a few groaning protests, a trickle of brackish water sputters out.",
            "message_success_others": "{character_name} works the pump handle, producing a trickle of murky water."
          }
        }
      ]
    }
  },
  {
    "unique_tag": "shack_interior_0_4_0",
    "data": {
      "name": "Inside Ruined Shack",
      "description": "The interior of the shack is damp and filled with cobwebs. Most of the roof has caved in, offering a view of the sky. A tattered mat lies in one corner.",
      "x": 0, "y": 4, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "thorn_thicket_west_m1_3_0",
    "data": {
      "name": "Thorny Thicket (West)",
      "description": "An almost impassable thicket of thorny vines blocks easy passage further west. You can hear buzzing insects.",
      "x": -1, "y": 3, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "thorn_thicket_east_1_3_0",
    "data": {
      "name": "Thorny Thicket (East)",
      "description": "The thorny vines are particularly dense here, scraping at your clothes as you push through.",
      "x": 1, "y": 3, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "rat_infested_cellar_1_4_0",
    "data": {
      "name": "Rat-Infested Cellar Entrance",
      "description": "A collapsed section of ground near the eastern thicket reveals a dark opening leading down into what might be a cellar. It stinks of vermin. [DYNAMIC_EXIT_EAST_CELLAR_DOOR]",
      "x": 1, "y": 4, "z": 0,
      "room_type": "dungeon_entrance"
    }
  },
  {
    "unique_tag": "deep_cellar_main_2_4_0",
    "data": {
      "name": "Deep Cellar - Main Chamber",
      "description": "This small, damp cellar chamber is filled with refuse and the gnawed bones of small animals. The air is heavy with the stench of rats.",
      "x": 2, "y": 4, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "deep_cellar_nest_2_5_0",
    "data": {
      "name": "Deep Cellar - Rat Nest",
      "description": "A particularly rank corner of the cellar, piled high with shredded cloth and filth. This is clearly a nest for something unpleasant.",
      "x": 2, "y": 5, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "goblin_lookout_0_5_0",
    "data": {
      "name": "Goblin Lookout Point",
      "description": "North of the ruined shack, the path climbs slightly to a rocky outcrop. Crude goblin symbols are daubed on the rocks.",
      "x": 0, "y": 5, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "goblin_trail_m1_5_0",
    "data": {
      "name": "Goblin Trail West",
      "description": "A crudely marked trail leads west from the lookout, littered with discarded bones and scraps of leather.",
      "x": -1, "y": 5, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "goblin_camp_m2_5_0",
    "data": {
      "name": "Small Goblin Camp",
      "description": "A small, messy encampment is hidden here, with a poorly tended fire pit and a few crude hide tents. [DYNAMIC_EXIT_WEST_CAVE]",
      "x": -2, "y": 5, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "goblin_cave_entrance_m3_5_0",
    "data": {
      "name": "Goblin Cave Entrance",
      "description": "A narrow opening in the rocks, reeking of goblin filth, leads into a dark cave.",
      "x": -3, "y": 5, "z": 0,
      "room_type": "dungeon_entrance"
    }
  },
  {
    "unique_tag": "goblin_cave_storage_m3_6_0",
    "data": {
      "name": "Goblin Cave - Storage Nook",
      "description": "This small nook in the cave is piled with stolen junk and rotting food.",
      "x": -3, "y": 6, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "path_to_woods_0_6_0",
    "data": {
      "name": "Path to the Whispering Woods",
      "description": "The overgrown path continues north from the goblin lookout, gradually becoming overshadowed by larger, darker trees. The air grows cooler.",
      "x": 0, "y": 6, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_edge_0_7_0",
    "data": {
      "name": "Edge of the Whispering Woods",
      "description": "You stand at the verge of a dark and ancient forest. Twisted trees loom, their branches like skeletal fingers. The sounds of the outskirts fade behind you.",
      "x": 0, "y": 7, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_gloomy_trail_0_8_0",
    "data": {
      "name": "Gloomy Trail",
      "description": "A barely discernible trail winds deeper into the woods. Sunlight struggles to penetrate the thick canopy above.",
      "x": 0, "y": 8, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_wolf_den_clearing_m1_8_0",
    "data": {
      "name": "Wolf Den Clearing",
      "description": "The trail opens into a small clearing. The ground is paw-printed, and a low growl emanates from a shadowed cleft in some rocks to the west.",
      "x": -1, "y": 8, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "wolf_den_cave_m2_8_0",
    "data": {
      "name": "Inside the Wolf Den",
      "description": "A shallow cave, littered with bones and smelling strongly of wet fur. This is undoubtedly a wolf den.",
      "x": -2, "y": 8, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_ancient_oak_0_9_0",
    "data": {
      "name": "Ancient Oak",
      "description": "A colossal, ancient oak tree dominates this part of the woods. Its gnarled branches are draped with moss, and its roots heave up the earth.",
      "x": 0, "y": 9, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_spider_lair_1_9_0",
    "data": {
      "name": "Spider-Infested Grove",
      "description": "Thick, sticky webs hang between the trees here, glistening with dew. The silence is broken only by the rustling of something large in the higher branches.",
      "x": 1, "y": 9, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_broodmother_web_1_10_0",
    "data": {
      "name": "Broodmother's Web",
      "description": "A massive, funnel-shaped web fills a hollow between several large trees. The air is thick with the smell of decay and the chitinous clicking of many legs.",
      "x": 1, "y": 10, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "woods_hidden_shrine_m1_9_0",
    "data": {
      "name": "Hidden Forest Shrine",
      "description": "Tucked away behind a curtain of ivy to the west of the ancient oak, you find a small, moss-covered stone shrine, seemingly forgotten by time. [DYNAMIC_EXIT_WEST_SHRINE_NICHE]",
      "x": -1, "y": 9, "z": 0,
      "room_type": "sanctuary"
    }
  },
  {
    "unique_tag": "woods_shrine_niche_m2_9_0",
    "data": {
      "name": "Shrine Niche",
      "description": "A small alcove within the hidden shrine. A faint, almost imperceptible humming emanates from the stone.",
      "x": -2, "y": 9, "z": 0,
      "room_type": "puzzle"
    }
  },
  {
    "unique_tag": "woods_path_to_mine_0_10_0",
    "data": {
      "name": "Path to the Old Mine",
      "description": "The trail grows rockier and begins to ascend slightly, heading towards a cliff face visible through the trees to the north.",
      "x": 0, "y": 10, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_entrance_0_11_0",
    "data": {
      "name": "Old Mine Entrance",
      "description": "A dark, foreboding mine entrance gapes in the cliffside. Rotting timbers support the opening, and the air smells of damp earth and something metallic. [DYNAMIC_EXIT_NORTH_MINE_GATE]",
      "x": 0, "y": 11, "z": 0,
      "room_type": "dungeon_entrance"
    }
  },
  {
    "unique_tag": "mine_entry_tunnel_0_12_0",
    "data": {
      "name": "Mine Entry Tunnel",
      "description": "The tunnel is dark and supported by creaking wooden beams. Water drips from the ceiling, and the sound of skittering echoes from deeper within.",
      "x": 0, "y": 12, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_foremans_office_m1_12_0",
    "data": {
      "name": "Foreman's Office (Ruined)",
      "description": "A small, caved-in chamber off the main tunnel. A rickety desk and a broken chair are all that remain of what might have been an office.",
      "x": -1, "y": 12, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_shaft_junction_0_13_0",
    "data": {
      "name": "Mine Shaft Junction",
      "description": "The tunnel opens into a larger area where several mine shafts converge. Most are collapsed, but one leads east, and another continues deeper north.",
      "x": 0, "y": 13, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_east_vein_1_13_0",
    "data": {
      "name": "East Vein Tunnel",
      "description": "This narrow tunnel follows a vein of some glittering, unfamiliar ore. The air is stale.",
      "x": 1, "y": 13, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_east_dead_end_2_13_0",
    "data": {
      "name": "East Vein - Dead End",
      "description": "The tunnel ends abruptly in a rockfall. It seems this vein was worked out or abandoned.",
      "x": 2, "y": 13, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_deep_shaft_0_14_0",
    "data": {
      "name": "Deep Mine Shaft",
      "description": "This shaft descends steeply into darkness. The air is noticeably colder, and an unnerving silence hangs in the air.",
      "x": 0, "y": 14, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "mine_undead_chamber_0_15_0",
    "data": {
      "name": "Undead Miners' Chamber",
      "description": "This large cavern is littered with broken mining tools and the skeletal remains of miners, still clad in tattered work clothes. A chilling aura pervades the room.",
      "x": 0, "y": 15, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "bridge_to_sanctum_0_16_0",
    "data": {
      "name": "Crumbling Stone Bridge",
      "description": "North of the deepest part of the mine, a natural chasm is spanned by a dangerously weathered stone bridge. Far below, you can hear the faint sound of rushing water. The air feels charged.",
      "x": 0, "y": 16, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_gatehouse_0_17_0",
    "data": {
      "name": "Sanctum Gatehouse",
      "description": "Beyond the bridge stands a formidable stone gatehouse, its portcullis rusted shut. Strange symbols are carved above the archway. [DYNAMIC_EXIT_NORTH_SANCTUM_PORTCULLIS]",
      "x": 0, "y": 17, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_courtyard_0_18_0",
    "data": {
      "name": "Corrupted Sanctum Courtyard",
      "description": "The flagstones of this courtyard are cracked and overgrown with sickly weeds. Defaced statues stand in alcoves, and an oppressive atmosphere hangs heavy.",
      "x": 0, "y": 18, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_west_wing_m1_18_0",
    "data": {
      "name": "Sanctum - West Wing Antechamber",
      "description": "A once-grand antechamber, now fallen into ruin. Tapestries hang in tatters, and dust coats every surface.",
      "x": -1, "y": 18, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_library_m2_18_0",
    "data": {
      "name": "Sanctum Library (Desecrated)",
      "description": "Bookshelves line the walls, their contents mostly burned or torn. Pages skitter across the floor in the draft. A large, rune-covered lectern stands in the center. [DYNAMIC_EXIT_WEST_SECRET_PASSAGE]",
      "x": -2, "y": 18, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_secret_study_m3_18_0",
    "data": {
      "name": "Sanctum Secret Study",
      "description": "A hidden study, remarkably preserved. Books on dark arts and forbidden lore line the shelves. A single, guttering candle illuminates a desk.",
      "x": -3, "y": 18, "z": 0,
      "room_type": "puzzle"
    }
  },
  {
    "unique_tag": "sanctum_east_wing_1_18_0",
    "data": {
      "name": "Sanctum - East Wing Hallway",
      "description": "This hallway echoes with an unsettling silence. Doors leading off it are mostly broken or hanging from single hinges.",
      "x": 1, "y": 18, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_barracks_1_19_0",
    "data": {
      "name": "Sanctum Barracks (Haunted)",
      "description": "Rotting bunks line the walls of this former barracks. The air is icy cold, and a palpable sense of dread fills the room.",
      "x": 1, "y": 19, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_main_hall_0_19_0",
    "data": {
      "name": "Sanctum Main Hall",
      "description": "A vast, domed hall that must have once been breathtaking. Now, rubble litters the floor, and ominous shadows dance in the dim light filtering from cracks in the dome.",
      "x": 0, "y": 19, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_altar_chamber_0_20_0",
    "data": {
      "name": "Sanctum Altar Chamber",
      "description": "At the northernmost end of the sanctum lies a raised dais upon which a massive, dark stone altar stands. The air crackles with a malevolent energy. [DYNAMIC_EXIT_NORTH_ALTAR_BARRIER]",
      "x": 0, "y": 20, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "sanctum_inner_sanctum_0_21_0",
    "data": {
      "name": "Inner Sanctum",
      "description": "Beyond the altar, this chamber hums with concentrated dark power. Disturbing runes cover every surface, glowing faintly.",
      "x": 0, "y": 21, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "south_corridor_0_m1_0",
    "data": {
      "name": "South Maintenance Tunnel",
      "description": "Dimly lit and smelling faintly of burnt coffee. A heavy iron door blocks the way further south. Panel S-1. [DYNAMIC_EXIT_SOUTH_ARCHIVE]",
      "x": 0, "y": -1, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "deep_archive_0_m2_0",
    "data": {
      "name": "Deep Archive Sector 42",
      "description": "Ancient, whirring machinery fills this chamber. It feels important. Panel S-2. [DYNAMIC_EXIT_NORTH_ARCHIVE]",
      "x": 0, "y": -2, "z": 0,
      "room_type": "puzzle"
    }
  },
  {
    "unique_tag": "west_corridor_m1_0_0",
    "data": {
      "name": "West Logic Gate Array",
      "description": "To the west, a series of humming conduits. Panel W-1.",
      "x": -1, "y": 0, "z": 0,
      "room_type": "standard"
    }
  },
  {
    "unique_tag": "weapon_shop_m2_0_0",
    "data": {
      "name": "Bjorne's Brutal Blades",
      "description": "The air in this chamber is thick with the smell of coal smoke and hot metal. Racks of swords, axes, and maces line the walls, each one gleaming with a dangerous edge. A massive anvil and a smoldering forge dominate the center of the room.",
      "x": -2, "y": 0, "z": 0,
      "room_type": "shop",
      "npc_placements": ["weapon_smith_bjorne"]
    }
  },
  {
    "unique_tag": "armor_shop_m2_m1_0",
    "data": {
      "name": "The Silent Stitch",
      "description": "Unlike the noisy forge next door, this room is quiet and orderly. Mannequins wearing various pieces of leather and studded armor stand in silent judgment. Rolls of tanned hide and spools of thick waxed thread are neatly arranged on a large workbench.",
      "x": -2, "y": -1, "z": 0,
      "room_type": "shop",
      "npc_placements": ["armor_smith_elara"]
    }
  }
]
--- END OF FILE backend/app/seeds/rooms_z0.json ---

--- START OF FILE backend/app/seeds/loot_tables.json ---
{
  "vermin_common": [
    { "item_ref": "Rat Tail", "chance": 50, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Cracked Tooth", "chance": 25, "min_qty": 1, "max_qty": 1 }
  ],
  "small_beast_parts": [
    { "item_ref": "Beast Pelt (Small)", "chance": 30, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Animal Bone", "chance": 60, "min_qty": 1, "max_qty": 2 }
  ],
  "tier1_trash": [
    { "item_ref": "Old Boot", "chance": 10, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Rusty Tin Can", "chance": 15, "min_qty": 1, "max_qty": 1 }
  ],
  "goblin_common": [
    { "item_ref": "Goblin Ear", "chance": 40, "min_qty": 1, "max_qty": 2 },
    { "item_ref": "Crude Dagger Scrap", "chance": 20, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Torn Pouch", "chance": 30, "min_qty": 1, "max_qty": 1 }
  ],
  "crude_gear": [
    { "item_ref": "Rusty Sword", "chance": 5, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Dagger", "chance": 8, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Wooden Shield", "chance": 3, "min_qty": 1, "max_qty": 1 }
  ],
  "construct_parts_common": [
    { "item_ref": "Bent Gear", "chance": 50, "min_qty": 1, "max_qty": 3 },
    { "item_ref": "Frayed Wire", "chance": 40, "min_qty": 1, "max_qty": 2 },
    { "item_ref": "Small Lens", "chance": 15, "min_qty": 1, "max_qty": 1 }
  ],
  "tech_scrap": [
    { "item_ref": "Scrap Metal", "chance": 60, "min_qty": 1, "max_qty": 5 }
  ],
  "spider_parts": [
    { "item_ref": "Spider Silk Gland", "chance": 35, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Spider Fang", "chance": 25, "min_qty": 1, "max_qty": 2 }
  ],
  "tier1_beast_loot": [
    { "item_ref": "Beast Meat", "chance": 40, "min_qty": 1, "max_qty": 1 }
  ],
  "ectoplasm": [
    { "item_ref": "Ectoplasmic Residue", "chance": 70, "min_qty": 1, "max_qty": 3 }
  ],
  "spirit_essence": [
    { "item_ref": "Faint Spirit Essence", "chance": 25, "min_qty": 1, "max_qty": 1 }
  ],
  "tier2_ethereal": [
    { "item_ref": "Ghostly Shroud Scrap", "chance": 10, "min_qty": 1, "max_qty": 1 }
  ],
  "elemental_mote_air": [
    { "item_ref": "Whirling Dust Mote", "chance": 60, "min_qty": 1, "max_qty": 2 }
  ],
  "tier1_elemental": [
    { "item_ref": "Charged Sand", "chance": 20, "min_qty": 1, "max_qty": 1 }
  ],
  "stolen_goods_common": [
    { "item_ref": "Cheap Locket", "chance": 15, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Bent Silver Spoon", "chance": 20, "min_qty": 1, "max_qty": 1 }
  ],
  "tier2_humanoid": [
    { "item_ref": "Sharpened Bone", "chance": 30, "min_qty": 1, "max_qty": 1 }
  ],
  "bat_parts": [
    { "item_ref": "Bat Wing", "chance": 70, "min_qty": 1, "max_qty": 2 }
  ],
  "tier1_swarm_remains": [
    { "item_ref": "Guano", "chance": 20, "min_qty": 1, "max_qty": 3 }
  ],
  "construct_parts_rare": [
    { "item_ref": "Intact Servomotor", "chance": 10, "min_qty": 1, "max_qty": 1 }
  ],
  "enchanted_metal_shards": [
    { "item_ref": "Faintly Glowing Shard", "chance": 20, "min_qty": 1, "max_qty": 2 }
  ],
  "tier2_construct": [
    { "item_ref": "Polished Steel Plate", "chance": 5, "min_qty": 1, "max_qty": 1 }
  ],
  "dire_wolf_pelt": [
    { "item_ref": "Dire Wolf Pelt", "chance": 60, "min_qty": 1, "max_qty": 1 }
  ],
  "large_beast_trophy": [
    { "item_ref": "Large Wolf Fang", "chance": 30, "min_qty": 1, "max_qty": 1 }
  ],
  "tier3_beast_loot": [
    { "item_ref": "Prime Beast Meat", "chance": 15, "min_qty": 1, "max_qty": 1 }
  ],
  "bandit_gear": [
    { "item_ref": "Tarnished Ring", "chance": 5, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Studded Leather Jerkin", "chance": 5, "min_qty": 1, "max_qty": 1 },
    { "item_ref": "Patched Leather Jerkin", "chance": 10, "min_qty": 1, "max_qty": 1 }
  ]
}
--- END OF FILE backend/app/seeds/loot_tables.json ---

--- START OF FILE backend/app/seeds/mob_spawn_definitions.json ---
[
  {
    "definition_name": "CPURatsMain",
    "room_coords": { "x": 0, "y": 0, "z": 0 },
    "mob_template_name": "Giant Rat",
    "quantity_min": 1,
    "quantity_max": 2,
    "respawn_delay_seconds": 60,
    "is_active": true,
    "roaming_behavior": {
      "type": "random_adjacent",
      "move_chance_percent": 30,
      "max_distance_from_spawn": 2
    }
  },
  {
    "definition_name": "GoblinCampThugs",
    "room_coords": { "x": -2, "y": 5, "z": 0 },
    "mob_template_name": "Bandit Thug",
    "quantity_min": 1,
    "quantity_max": 2,
    "respawn_delay_seconds": 240,
    "is_active": true,
    "roaming_behavior": null
  },
  {
    "definition_name": "GoblinLookoutScouts",
    "room_coords": { "x": 0, "y": 5, "z": 0 },
    "mob_template_name": "Goblin Scout",
    "quantity_min": 1,
    "quantity_max": 3,
    "respawn_delay_seconds": 120,
    "is_active": true,
    "roaming_behavior": {
      "type": "random_adjacent",
      "move_chance_percent": 25,
      "max_distance_from_spawn": 1
    }
  }
]
--- END OF FILE backend/app/seeds/mob_spawn_definitions.json ---

--- START OF FILE frontend/src/main.js ---
// frontend/src/main.js
import { UI } from './ui.js';
import { API } from './api.js';
import { WebSocketService } from './websocket.js';
import { MapDisplay } from './map.js';
import { gameState, saveSession, loadSession, clearSession, updateGameState } from './state.js';

export function handleWebSocketMessage(serverData) {
    let charVitals = null;

    if (serverData.type === "welcome_package" && serverData.character_vitals) charVitals = serverData.character_vitals;
    else if (serverData.type === "combat_update" && serverData.character_vitals) charVitals = serverData.character_vitals;
    else if (serverData.type === "vitals_update") charVitals = serverData;

    if (charVitals) {
        UI.updatePlayerVitals(
            charVitals.current_hp, charVitals.max_hp,
            charVitals.current_mp, charVitals.max_mp,
            charVitals.current_xp, charVitals.next_level_xp
        );
        UI.updateCharacterInfoBar(gameState.selectedCharacterName, gameState.selectedCharacterClass, charVitals.level);
        if (charVitals.platinum !== undefined) {
            UI.updateCurrencyDisplay(charVitals.platinum, charVitals.gold, charVitals.silver, charVitals.copper);
        }
    }

    switch (serverData.type) {
        case "welcome_package":
            if (serverData.log && serverData.log.length > 0) UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            if (serverData.room_data) {
                const currentRoom = serverData.room_data;
                UI.updateGameDisplay(currentRoom);
                UI.updateExitsDisplay(currentRoom);
                updateGameState({ displayedRoomId: currentRoom.id });
                // Pass currentRoom data for immediate title/highlight and to determine target Z
                MapDisplay.fetchAndDrawMap(currentRoom);
            }
            break;
        case "combat_update":
            // First, always process the log and combat state.
            if (serverData.log && serverData.log.length > 0) {
                UI.appendToOutput(serverData.log.join('\n'), { styleClass: "game-message" });
            }
            updateGameState({ isInCombat: !serverData.combat_over });

            // THEN, ONLY if new room data is provided, update the display.
            if (serverData.room_data) {
                const currentRoom = serverData.room_data;
                const movedRoom = gameState.displayedRoomId !== currentRoom.id;
                const zLevelChanged = MapDisplay.currentZLevel !== currentRoom.z;

                // Note: updateGameDisplay is for the big text block, which we don't need on every combat tick.
                // The important part is updating the exits and map.
                UI.updateExitsDisplay(currentRoom);
                updateGameState({ displayedRoomId: currentRoom.id });

                if (movedRoom || zLevelChanged || !MapDisplay.mapDataCache[currentRoom.z]) {
                    MapDisplay.fetchAndDrawMap(currentRoom);
                } else {
                    MapDisplay.redrawMapForCurrentRoom(currentRoom.id, currentRoom);
                }
            }
            break;
        case "vitals_update": break;
        case "ooc_message": UI.appendToOutput(serverData.message, { styleClass: "ooc-chat-message" }); break;
        case "game_event": if (serverData.message) UI.appendToOutput(serverData.message, { styleClass: "game-message" }); break;
        default:
            if (serverData.message) UI.appendToOutput(`GS (${serverData.type}): ${serverData.message}`, { styleClass: "game-message" });
            else UI.appendToOutput(`GS (unparsed type: ${serverData.type}): ${JSON.stringify(serverData)}`, { styleClass: "game-message" });
            break;
    }
}

// ... (startLoginProcess, promptForPassword, etc. remain largely unchanged from previous correct version) ...
// Make sure they call UI.showAppropriateView() AFTER updateGameState loginState changes.

async function startLoginProcess() {
    clearSession();
    updateGameState({ loginState: 'PROMPT_USER' });
    WebSocketService.close();
    MapDisplay.clearMap();
    MapDisplay.currentMapDisplayData = null; // Clear current display data
    MapDisplay.currentZLevel = 0; // Reset Z
    MapDisplay.drawMap();
    UI.showAppropriateView();
    UI.clearOutput();
    UI.appendToOutput("Welcome to The Unholy MUD of Tron & Allen1.");
    UI.appendToOutput("Version: Refactored & Ready to Rumble!");
    UI.appendToOutput("-------------------------------------------------");
    UI.appendToOutput("Username (or type 'new' to register): ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Enter username or 'new'");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function promptForPassword() {
    updateGameState({ loginState: 'PROMPT_PASSWORD' });
    UI.showAppropriateView();
    UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true });
    UI.setInputCommandPlaceholder("Enter password");
    UI.setInputCommandType('password');
    UI.focusCommandInput();
}

async function promptForRegistrationUsername() {
    updateGameState({ loginState: 'REGISTER_PROMPT_USER' });
    UI.showAppropriateView();
    UI.appendToOutput("Registering new user.");
    UI.appendToOutput("Desired username: ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Enter desired username");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function promptForRegistrationPassword() {
    updateGameState({ loginState: 'REGISTER_PROMPT_PASSWORD' });
    UI.showAppropriateView();
    UI.appendToOutput("Desired password (min 8 chars): ", { isPrompt: true, noNewLineBefore: true });
    UI.setInputCommandPlaceholder("Enter desired password");
    UI.setInputCommandType('password');
    UI.focusCommandInput();
}

async function displayCharacterSelection() {
    updateGameState({ loginState: 'CHAR_SELECT_PROMPT' });
    UI.showAppropriateView();
    if (!gameState.currentAuthToken) {
        UI.appendToOutput("! Authentication token missing. Please log in.", { styleClass: 'error-message-inline' });
        handleLogout(); return;
    }
    UI.appendToOutput("\nFetching character list...");
    try {
        const characters = await API.fetchCharacters();
        updateGameState({ availableCharacters: characters });
        UI.appendToOutput("\n--- Character Selection ---");
        if (characters.length === 0) UI.appendToOutput("No characters found for your account.");
        else {
            UI.appendToOutput("Your characters:");
            characters.forEach((char, index) => UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${char.name}</span> (<span class="char-class">${char.class_name}</span> - Lvl ${char.level})</span>`));
        }
        UI.appendToOutput("Enter character # to play, or type 'new' to create one: ", { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter # or 'new'");
    } catch (error) {
        UI.appendToOutput(`! Error fetching characters: ${error.message}`, { styleClass: 'error-message-inline' });
        if (error.response && error.response.status === 401) handleLogout();
        else startLoginProcess();
    }
    UI.focusCommandInput();
}

async function promptForNewCharacterName() {
    updateGameState({ loginState: 'CHAR_CREATE_PROMPT_NAME', tempCharName: '' });
    UI.showAppropriateView();
    UI.appendToOutput("\n--- New Character Creation ---");
    UI.appendToOutput("Enter character name: ", { isPrompt: true });
    UI.setInputCommandPlaceholder("Character Name (3-50 chars)");
    UI.setInputCommandType('text');
    UI.focusCommandInput();
}

async function displayClassSelection() {
    updateGameState({ loginState: 'CHAR_CREATE_PROMPT_CLASS' });
    UI.showAppropriateView();
    UI.appendToOutput(`\nFetching available classes for ${gameState.tempCharName}...`);
    try {
        const classes = await API.fetchAvailableClasses();
        updateGameState({ availableClasses: classes });
        if (classes.length === 0) {
            UI.appendToOutput("! No character classes available. Defaulting to 'Adventurer'.", { styleClass: 'error-message-inline' });
            updateGameState({ tempCharClassName: 'Adventurer' });
            await createCharacterWithSelectedClass(); return;
        }
        UI.appendToOutput("Available Classes:");
        classes.forEach((charClass, index) => UI.appendToOutput(`<span class="char-list-item"><span class="char-index">${index + 1}.</span> <span class="char-name">${charClass.name}</span> - <span class="char-class-desc">${charClass.description || 'A mysterious path.'}</span></span>`));
        UI.appendToOutput(`Select class for '${gameState.tempCharName}' by number: `, { isPrompt: true });
        UI.setInputCommandPlaceholder("Enter class #");
    } catch (error) {
        UI.appendToOutput(`! Error fetching classes: ${error.message}. Defaulting to 'Adventurer'.`, { styleClass: 'error-message-inline' });
        updateGameState({ tempCharClassName: 'Adventurer' });
        await createCharacterWithSelectedClass();
    }
    UI.focusCommandInput();
}

async function createCharacterWithSelectedClass() {
    const charName = gameState.tempCharName;
    const charClassName = gameState.tempCharClassName || "Adventurer";
    UI.appendToOutput(`\nCreating ${charName} the ${charClassName}...`);
    try {
        await API.createCharacter(charName, charClassName);
        UI.appendToOutput("Character created successfully!");
        await displayCharacterSelection();
    } catch (error) {
        UI.appendToOutput(`! Error creating character: ${error.data?.detail || error.message}`, { styleClass: 'error-message-inline' });
        await displayCharacterSelection();
    }
}

async function selectCharacterAndStartGame(character) {
    UI.appendToOutput(`\nSelecting character: ${character.name}...`);
    try {
        const initialRoomData = await API.selectCharacterOnBackend(character.id);
        saveSession(gameState.currentAuthToken, character.id, character.name, character.class_name || 'Adventurer');
        await enterGameModeWithCharacter(character, initialRoomData);
    } catch (error) {
        UI.appendToOutput(`! Error selecting character: ${error.message}`, { styleClass: 'error-message-inline' });
        await displayCharacterSelection();
    }
}

async function enterGameModeWithCharacter(character, initialRoomDataFromHttpSelect) {
    updateGameState({
        selectedCharacterId: character.id,
        selectedCharacterName: character.name,
        selectedCharacterClass: character.class_name || 'Adventurer',
        loginState: 'IN_GAME'
    });
    UI.showAppropriateView();

    UI.updateCharacterInfoBar(character.name, character.class_name, character.level);
    UI.updateCurrencyDisplay(character.platinum_coins || 0, character.gold_coins || 0, character.silver_coins || 0, character.copper_coins || 0);

    UI.clearOutput();
    UI.appendToOutput(`Playing as: <span class="char-name">${character.name}</span>, the <span class="char-class">${character.class_name || 'Adventurer'}</span> (Lvl ${character.level || 1})`);
    UI.setInputCommandPlaceholder("Type command...");
    UI.setInputCommandType('text');

    // Pass initialRoomData to fetchAndDrawMap. It will use its Z to fetch if not cached.
    MapDisplay.fetchAndDrawMap(initialRoomDataFromHttpSelect);

    WebSocketService.connect();
    UI.focusCommandInput();
}

function handleLogout() {
    WebSocketService.close();
    MapDisplay.clearMap();
    MapDisplay.currentMapDisplayData = null; // Also clear this on logout
    MapDisplay.currentZLevel = 0;
    clearSession();
    startLoginProcess();
}

async function handleHttpCommandResponse(responseData, originalCommand) {
    if (responseData.message_to_player) UI.appendToOutput(responseData.message_to_player, { styleClass: 'game-message' });
    if (responseData.room_data) {
        const currentRoom = responseData.room_data;
        const cmdClean = originalCommand.toLowerCase().trim();
        const isLook = cmdClean.startsWith("look") || cmdClean === "l";
        const movedRoom = gameState.displayedRoomId !== currentRoom.id;
        const zLevelChanged = MapDisplay.currentZLevel !== currentRoom.z;

        if (isLook || movedRoom) UI.updateGameDisplay(currentRoom);
        UI.updateExitsDisplay(currentRoom);
        updateGameState({ displayedRoomId: currentRoom.id });

        if (movedRoom || zLevelChanged || !MapDisplay.mapDataCache[currentRoom.z]) {
            MapDisplay.fetchAndDrawMap(currentRoom);
        } else {
            MapDisplay.redrawMapForCurrentRoom(currentRoom.id, currentRoom);
        }
    }
}

async function handleInputSubmission() {
    const commandInputEl = UI.getCommandInput();
    if (!commandInputEl) return;
    const inputText = commandInputEl.value.trim();
    let echoText = inputText;
    let echoOptions = { isPrompt: false };

    if (gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
        echoText = '*'.repeat(inputText.length || 8);
        echoOptions.noNewLineBefore = true;
    } else if (gameState.loginState === 'IN_GAME' && inputText) {
        echoText = `> ${inputText}`;
    } else if (inputText) {
        echoOptions.noNewLineBefore = true;
    }

    if (inputText || gameState.loginState === 'PROMPT_PASSWORD' || gameState.loginState === 'REGISTER_PROMPT_PASSWORD') {
        UI.appendToOutput(echoText, echoOptions);
    }
    commandInputEl.value = '';

    try {
        switch (gameState.loginState) {
            case 'PROMPT_USER':
                if (inputText.toLowerCase() === 'new') await promptForRegistrationUsername();
                else if (inputText) { updateGameState({ tempUsername: inputText }); await promptForPassword(); }
                else { UI.appendToOutput("Username (or 'new'): ", { isPrompt: true, noNewLineBefore: true }); UI.focusCommandInput(); }
                break;
            case 'PROMPT_PASSWORD':
                UI.appendToOutput("\nAttempting login...");
                const loginData = await API.loginUser(gameState.tempUsername, inputText);
                saveSession(loginData.access_token, null, null, null);
                UI.appendToOutput("Login successful!");
                UI.setInputCommandType('text');
                await displayCharacterSelection();
                break;
            case 'REGISTER_PROMPT_USER':
                if (inputText) { updateGameState({ tempUsername: inputText }); await promptForRegistrationPassword(); }
                else { UI.appendToOutput("Desired username: ", { isPrompt: true, noNewLineBefore: true }); UI.focusCommandInput(); }
                break;
            case 'REGISTER_PROMPT_PASSWORD':
                updateGameState({ tempPassword: inputText });
                UI.appendToOutput("\nAttempting registration...");
                await API.registerUser(gameState.tempUsername, gameState.tempPassword);
                UI.appendToOutput("Registration successful!");
                UI.appendToOutput(`Now, please log in as '${gameState.tempUsername}'.`);
                updateGameState({ loginState: 'PROMPT_PASSWORD' });
                UI.showAppropriateView();
                UI.appendToOutput("Password: ", { isPrompt: true, noNewLineBefore: true });
                UI.setInputCommandPlaceholder("Enter password");
                UI.setInputCommandType('password');
                UI.focusCommandInput();
                break;
            case 'CHAR_SELECT_PROMPT':
                if (inputText.toLowerCase() === 'new') await promptForNewCharacterName();
                else {
                    const charIndex = parseInt(inputText, 10) - 1;
                    if (gameState.availableCharacters && charIndex >= 0 && charIndex < gameState.availableCharacters.length) {
                        await selectCharacterAndStartGame(gameState.availableCharacters[charIndex]);
                    } else {
                        UI.appendToOutput("! Invalid selection.", { styleClass: 'error-message-inline' });
                        UI.appendToOutput("Enter character #, or 'new': ", { isPrompt: true, noNewLineBefore: true });
                        UI.focusCommandInput();
                    }
                }
                break;
            case 'CHAR_CREATE_PROMPT_NAME':
                if (!inputText || inputText.length < 3 || inputText.length > 50) {
                    UI.appendToOutput("! Invalid name (3-50 chars). Name: ", { isPrompt: true, styleClass: 'error-message-inline', noNewLineBefore: true });
                    UI.focusCommandInput(); break;
                }
                updateGameState({ tempCharName: inputText });
                await displayClassSelection();
                break;
            case 'CHAR_CREATE_PROMPT_CLASS':
                const classIndex = parseInt(inputText, 10) - 1;
                if (gameState.availableClasses && classIndex >= 0 && classIndex < gameState.availableClasses.length) {
                    const selectedClass = gameState.availableClasses[classIndex];
                    updateGameState({ tempCharClassName: selectedClass.name });
                    await createCharacterWithSelectedClass();
                } else {
                    UI.appendToOutput("! Invalid class selection. Please enter a valid number.", { styleClass: 'error-message-inline' });
                    UI.appendToOutput(`Select class for ${gameState.tempCharName} by number: `, { isPrompt: true, noNewLineBefore: true });
                    UI.focusCommandInput();
                }
                break;
            case 'IN_GAME':
                if (!inputText) { UI.focusCommandInput(); break; }
                const lowerInputText = inputText.toLowerCase();
                const commandVerb = lowerInputText.split(" ")[0];

                if (commandVerb === "logout") { handleLogout(); break; }

                const webSocketHandledVerbs = ["attack", "atk", "kill", "k", "flee", "look", "l", "rest", "use", "skill", "cast", "get", "take", "unlock", "search", "examine", "pull", "push", "turn", "pry", "activate", "n", "s", "e", "w", "north", "south", "east", "west", "up", "down", "u", "d", "go"];
                if (webSocketHandledVerbs.includes(commandVerb)) {
                    WebSocketService.sendMessage({ type: "command", command_text: inputText });
                } else {
                    const httpOkayVerbs = ["spawnmob", "mod_xp", "set_hp", "giveme", "help", "ooc", "say", "score", "inventory", "i", "skills", "traits", "status", "st", "sc", "sk", "tr", "?", "equip", "unequip", "wear", "remove", "eq"];
                    if (httpOkayVerbs.includes(commandVerb)) {
                        const httpResponse = await API.sendHttpCommand(inputText);
                        handleHttpCommandResponse(httpResponse, inputText);
                    } else {
                        UI.appendToOutput(`Unrecognized command: '${inputText}'. Try 'help'.`);
                    }
                }
                break;
            default:
                UI.appendToOutput("! System error: Unknown login state.", { styleClass: 'error-message-inline' });
                startLoginProcess();
        }
    } catch (error) {
        console.error("Error during input submission:", error);
        UI.appendToOutput(`\n! Error: ${error.data?.detail || error.message || 'An unknown error occurred.'}`, { styleClass: 'error-message-inline' });
        if (gameState.loginState === 'PROMPT_PASSWORD') await promptForPassword();
        else if (gameState.loginState.includes('CHAR_')) await displayCharacterSelection();
        else if (gameState.loginState.includes('REGISTER_')) await promptForRegistrationUsername();
    }
}

async function attemptSessionResume() {
    if (loadSession() && gameState.currentAuthToken && gameState.selectedCharacterId) {
        UI.clearOutput();
        UI.appendToOutput("Attempting to resume session...");
        try {
            // For resume, we don't call selectCharacterOnBackend as the session token implies selection.
            // We directly construct a partial character and enter game mode.
            // enterGameModeWithCharacter will then call MapDisplay.fetchAndDrawMap(null)
            // and the WebSocket welcome_package will provide the definitive current room.
            UI.appendToOutput(`Resumed session as ${gameState.selectedCharacterName}.`);
            const resumedCharacter = {
                id: gameState.selectedCharacterId,
                name: gameState.selectedCharacterName,
                class_name: gameState.selectedCharacterClass,
                level: 1,
                platinum_coins: 0, gold_coins: 0, silver_coins: 0, copper_coins: 0
            };
            await enterGameModeWithCharacter(resumedCharacter, null); // Pass null for initialRoomData
            return true;
        } catch (error) { // This catch might not be hit if error is in async enterGameMode calls
            UI.appendToOutput(`! Session resume failed: ${error.data?.detail || error.message}. Please log in.`, { styleClass: 'error-message-inline' });
            clearSession();
        }
    }
    return false;
}

document.addEventListener('DOMContentLoaded', async () => {
    if (!UI.initializeElements()) return;
    MapDisplay.initialize();

    const commandInputEl = UI.getCommandInput();
    if (commandInputEl) {
        commandInputEl.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleInputSubmission();
            }
        });
    } else {
        console.error("Command input not found during DOMContentLoaded setup. Input will not work.");
    }

    if (!(await attemptSessionResume())) {
        startLoginProcess();
    }
});
--- END OF FILE frontend/src/main.js ---

--- START OF FILE frontend/src/ui.js ---
// frontend/src/ui.js
import { gameState } from './state.js';

export const UI = {
    // Existing elements
    outputElement: null,
    commandInputElement: null,
    promptTextElement: null,
    characterNameElement: null,
    characterClassElement: null,
    characterLevelElement: null,
    exitsTextElement: null,
    playerHpBar: null,
    playerHpText: null,
    playerMpBar: null,
    playerMpText: null,
    playerXpBar: null,
    playerXpText: null,
    currencyPlatinumElement: null,
    currencyGoldElement: null,
    currencySilverElement: null,
    currencyCopperElement: null,
    copyOutputButton: null,

    // Map related UI elements
    mapTitleBarElement: null,
    mapTitleTextElement: null,
    mapCoordsTextElement: null,
    mapZLevelValueElement: null,    // NEW for Z-level display
    mapZoneNameTextElement: null,   // NEW for Zone Name
    mapZoneLevelsTextElement: null, // NEW for Zone Levels

    // View state control
    gameViewElements: [],
    inputPromptLineElement: null,

    initializeElements: function () {
        this.outputElement = document.getElementById('output');
        this.commandInputElement = document.getElementById('commandInput');
        this.promptTextElement = document.getElementById('prompt-text');
        this.inputPromptLineElement = document.getElementById('input-prompt-line');

        this.characterNameElement = document.getElementById('char-info-name');
        this.characterClassElement = document.getElementById('char-info-class');
        this.characterLevelElement = document.getElementById('char-info-level');

        this.exitsTextElement = document.getElementById('exits-text');

        this.playerHpBar = document.getElementById('player-hp-bar');
        this.playerHpText = document.getElementById('player-hp-text');
        this.playerMpBar = document.getElementById('player-mp-bar');
        this.playerMpText = document.getElementById('player-mp-text');
        this.playerXpBar = document.getElementById('player-xp-bar');
        this.playerXpText = document.getElementById('player-xp-text');

        this.currencyPlatinumElement = document.querySelector('#currency-display-container .currency.platinum');
        this.currencyGoldElement = document.querySelector('#currency-display-container .currency.gold');
        this.currencySilverElement = document.querySelector('#currency-display-container .currency.silver');
        this.currencyCopperElement = document.querySelector('#currency-display-container .currency.copper');

        this.copyOutputButton = document.getElementById('copy-output-button');
        if (this.copyOutputButton) {
            this.copyOutputButton.addEventListener('click', () => this.copyOutputToClipboard());
        }

        this.mapTitleBarElement = document.getElementById('map-title-bar');
        this.mapTitleTextElement = document.getElementById('map-title-text');
        this.mapCoordsTextElement = document.getElementById('map-coords-text');

        // NEW elements for Z-level and Zone
        this.mapZLevelValueElement = document.getElementById('map-z-level-value');
        this.mapZoneNameTextElement = document.getElementById('map-zone-name-text');
        this.mapZoneLevelsTextElement = document.getElementById('map-zone-levels-text');


        this.gameViewElements = [
            document.getElementById('character-info-bar'),
            document.getElementById('bottom-info-bar'),
            document.getElementById('vitals-monitor'),
            document.getElementById('map-column'),
        ];

        if (!this.outputElement || !this.commandInputElement || !this.characterNameElement ||
            !this.mapTitleBarElement || !this.inputPromptLineElement || !this.mapZLevelValueElement ||
            !this.mapZoneNameTextElement || !this.mapZoneLevelsTextElement) { // Added new elements to check
            console.error("Fatal Error: Essential UI elements not found. The application cannot start.");
            document.body.innerHTML = "Error: UI elements missing. Please check console.";
            return false;
        }
        return true;
    },

    showAppropriateView: function () {
        const isGameActive = gameState.loginState === 'IN_GAME';
        this.gameViewElements.forEach(el => {
            if (el) {
                let currentDisplay = 'block';
                if (el.id === 'vitals-monitor' || el.id === 'bottom-info-bar' || el.id === 'character-info-bar' || el.id === 'map-column') {
                    currentDisplay = 'flex';
                }
                el.style.display = isGameActive ? currentDisplay : 'none';
            }
        });

        if (this.inputPromptLineElement) {
            const showInputPromptLine = gameState.loginState === 'IN_GAME' ||
                gameState.loginState === 'CHAR_SELECT_PROMPT' ||
                gameState.loginState === 'CHAR_CREATE_PROMPT_NAME' ||
                gameState.loginState === 'CHAR_CREATE_PROMPT_CLASS' ||
                gameState.loginState === 'PROMPT_USER' ||
                gameState.loginState === 'PROMPT_PASSWORD' ||
                gameState.loginState === 'REGISTER_PROMPT_USER' ||
                gameState.loginState === 'REGISTER_PROMPT_PASSWORD';
            this.inputPromptLineElement.style.display = showInputPromptLine ? 'flex' : 'none';
        }
    },

    clearOutput: function () { /* Unchanged */ if (this.outputElement) this.outputElement.innerHTML = ''; },
    appendToOutput: function (message, options = {}) { /* Unchanged */
        if (!this.outputElement) return; const { styleClass = '' } = options;
        const lineElement = document.createElement('div');
        if (styleClass) lineElement.classList.add(styleClass);
        lineElement.innerHTML = message;
        this.outputElement.insertBefore(lineElement, this.outputElement.firstChild);
        this.outputElement.scrollTop = 0;
    },
    updateCharacterInfoBar: function (name, className, level) { /* Unchanged */
        if (this.characterNameElement) this.characterNameElement.textContent = name || 'Unknown';
        if (this.characterClassElement) this.characterClassElement.textContent = className || 'Adventurer';
        if (this.characterLevelElement) this.characterLevelElement.textContent = (level !== undefined && level !== null) ? String(level) : '1';
    },

    updateMapTitleBar: function (x, y, z) { // Removed zoneName from here, handled by updateMapZoneBar
        if (this.mapCoordsTextElement) {
            if (x !== undefined && y !== undefined && z !== undefined) {
                this.mapCoordsTextElement.textContent = `${x}, ${y}, ${z}`;
            } else if (z !== undefined) {
                this.mapCoordsTextElement.textContent = `?, ?, ${z}`;
            } else {
                this.mapCoordsTextElement.textContent = "?, ?, ?";
            }
        }
        // Update Z-Level display box separately
        if (this.mapZLevelValueElement) {
            this.mapZLevelValueElement.textContent = (z !== undefined && z !== null) ? String(z) : "-";
        }
    },

    // NEW function for Zone Bar
    updateMapZoneBar: function (zoneName, zoneLevels) {
        if (this.mapZoneNameTextElement) {
            this.mapZoneNameTextElement.textContent = zoneName || "[Unknown Zone]";
        }
        if (this.mapZoneLevelsTextElement) {
            this.mapZoneLevelsTextElement.textContent = zoneLevels || "[Lvl ?-?]";
        }
    },

    updatePlayerVitals: function (currentHp, maxHp, currentMp, maxMp, currentXp, nextLevelXp) { /* Unchanged */
        if (this.playerHpBar && this.playerHpText) {
            const hpPercent = maxHp > 0 ? (currentHp / maxHp) * 100 : 0;
            this.playerHpBar.style.width = `${Math.max(0, Math.min(100, hpPercent))}%`;
            this.playerHpText.textContent = `${currentHp} / ${maxHp}`;
        }
        if (this.playerMpBar && this.playerMpText) {
            const mpPercent = maxMp > 0 ? (currentMp / maxMp) * 100 : 0;
            this.playerMpBar.style.width = `${Math.max(0, Math.min(100, mpPercent))}%`;
            this.playerMpText.textContent = `${currentMp} / ${maxMp}`;
        }
        if (this.playerXpBar && this.playerXpText) {
            const xpPercent = nextLevelXp > 0 && nextLevelXp !== -1 ? (currentXp / nextLevelXp) * 100 : (nextLevelXp === -1 ? 100 : 0);
            const displayNextLevelXp = (nextLevelXp === -1) ? "MAX" : nextLevelXp;
            this.playerXpBar.style.width = `${Math.max(0, Math.min(100, xpPercent))}%`;
            this.playerXpText.textContent = `${currentXp} / ${displayNextLevelXp}`;
        }
    },
    updateExitsDisplay: function (roomData) { /* Unchanged */
        if (this.exitsTextElement && roomData && roomData.exits) {
            const exitNames = Object.keys(roomData.exits).map(dir => dir.toUpperCase());
            this.exitsTextElement.textContent = exitNames.length > 0 ? exitNames.join(' | ') : 'None';
        } else if (this.exitsTextElement) { this.exitsTextElement.textContent = 'Unknown'; }
    },
    updateCurrencyDisplay: function (platinum, gold, silver, copper) { /* Unchanged */
        if (this.currencyPlatinumElement) this.currencyPlatinumElement.textContent = `${platinum || 0}p`;
        if (this.currencyGoldElement) this.currencyGoldElement.textContent = `${gold || 0}g`;
        if (this.currencySilverElement) this.currencySilverElement.textContent = `${silver || 0}s`;
        if (this.currencyCopperElement) this.currencyCopperElement.textContent = `${copper || 0}c`;
    },
    updateGameDisplay: function (roomData) { /* Unchanged */
        if (!roomData) return; let lines = [];
        lines.push(`<span class="room-name-header">--- ${roomData.name || 'Unknown Room'} ---</span>`);
        lines.push(roomData.description || 'An empty space.');
        if (roomData.dynamic_description_additions?.length > 0) roomData.dynamic_description_additions.forEach(line => lines.push(line));
        if (roomData.items_on_ground?.length > 0) {
            lines.push("You see here:");
            roomData.items_on_ground.forEach(item => lines.push(`  <span class="inv-item-name">${item.item_template.name}</span>${item.quantity > 1 ? ' (x' + item.quantity + ')' : ''}`));
        }
        if (roomData.mobs_in_room?.length > 0) {
            lines.push("Also here:");
            roomData.mobs_in_room.forEach((mob, index) => lines.push(`  ${index + 1}. <span class="inv-item-name">${mob.mob_template.name}</span>`));
        }
        if (roomData.other_characters?.length > 0) {
            lines.push("Others here:");
            roomData.other_characters.forEach(char => lines.push(`  <span class="char-name">${char.name}</span>`));
        }
        this.appendToOutput(lines.join('\n'), { styleClass: "game-message" });
    },
    getCommandInput: function () { return this.commandInputElement; },
    setInputCommandPlaceholder: function (text) { if (this.commandInputElement) this.commandInputElement.placeholder = text; },
    setInputCommandType: function (type) { if (this.commandInputElement) this.commandInputElement.type = type; },
    focusCommandInput: function () { if (this.commandInputElement) this.commandInputElement.focus(); },
    copyOutputToClipboard: function () { /* Unchanged */
        if (!this.outputElement) return; const textToCopy = this.outputElement.innerText || this.outputElement.textContent;
        navigator.clipboard.writeText(textToCopy)
            .then(() => this.appendToOutput("Log copied to clipboard.", { styleClass: "system-message-inline" }))
            .catch(err => { console.error('Failed to copy output: ', err); this.appendToOutput("! Failed to copy log.", { styleClass: "error-message-inline" }); });
    }
};
--- END OF FILE frontend/src/ui.js ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
