--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Mon Jun  9 04:24:50 PM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_npc.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/npc_dialogue_ticker.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/npc_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/npc.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/seeds/character_classes.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/loot_tables.json
backend/app/seeds/mob_spawn_definitions.json
backend/app/seeds/mob_templates.json
backend/app/seeds/npcs.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
backend/app/ws_command_parsers/ws_shop_parser.py
bundle_context.sh
frontend/src/components/BottomInfoBar.css
frontend/src/components/CharacterCreationScreen.css
frontend/src/components/CharacterInfoBar.css
frontend/src/components/CharacterSelectionScreen.css
frontend/src/components/Inventory.css
frontend/src/components/ItemName.css
frontend/src/components/LoginScreen.css
frontend/src/components/Map.css
frontend/src/components/Modal.css
frontend/src/components/ScoreSheet.css
frontend/src/components/Terminal.css
frontend/src/components/VitalsMonitor.css
frontend/src/index.css
frontend/src/index.html
frontend/src/services/apiService.js
frontend/src/services/webSocketService.js
frontend/src/state/gameStore.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed." >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh"
    "README.md"

    # --- Backend - Models & Schemas (The Blueprint of Power) ---
    "backend/app/models/player.py"          # CRITICAL: For adding the 'is_sysop' flag.
    "backend/app/models/character.py"       # CRITICAL: For adding 'god_level' and 'titles'.
    "backend/app/models/item.py"            # For referencing items in 'giveme'.
    "backend/app/schemas/player.py"         # To match the model changes.
    "backend/app/schemas/character.py"      # To match the model changes.

    # --- Backend - The Command & Control Logic ---
    "backend/app/websocket_router.py"       # CRITICAL: The main dispatcher where we'll check for Sysop roles.
    "backend/app/ws_command_parsers/ws_interaction_parser.py" # For the new 'equip'/'unequip' logic.
    # We will likely create a new file like 'ws_debug_parser.py' for 'giveme' and other sysop commands.

    # --- Backend - Dependencies & Game State ---
    "backend/app/api/dependencies.py"       # Always good to have for context on getting users/characters.
    "backend/app/game_state.py"             # To see how active sessions are managed.

    # --- Frontend - The User's Point of Interaction ---
    "frontend/src/state/gameStore.js"         # CRITICAL: The state will need to handle new data.
    "frontend/src/services/webSocketService.js" # CRITICAL: To see how messages are sent/received.
    "frontend/src/components/CommandInput.jsx"  # CRITICAL: Where the user types the commands.
    "frontend/src/components/Inventory.jsx"     # To verify equip/unequip/giveme works.
    "frontend/src/components/ItemName.jsx"      # The component that makes our items look sexy.

    # --- Frontend - Core App Structure ---
    "frontend/src/App.jsx"
    "frontend/src/main.jsx"
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (âœ¨ðŸ’°ðŸ’ªðŸ§©ðŸ’€ðŸšª) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Flesh out the damn world - Gear, Loot, and More Seeds!

The map is less of an abstract nightmare, and the core gameplay loop is... loopy. Now we need to make the interactions richer and the world feel less empty.

*   **Full Equipment System:** Define all equipment slots. Implement robust `equip` and `unequip` logic. Ensure stats update correctly.
*   **Mob Loot Tables:** Mobs need to drop more than just coins. Define loot tables (specific items, random items from categories, chances).
*   **Seed More Content (Externalize ALL THE THINGS):**
    *   `mob_templates.json`
    *   `character_classes.json`
    *   `skills.json`
    *   `traits.json`
    *   `mob_spawn_definitions.json`
    *   Update corresponding CRUD seeders to load from these JSONs.
*   **Seed Initial Equipment:** Place starting gear on character creation or in initial rooms.

This will involve a lot of backend work (models, CRUD, game logic) and careful JSON schema design for the seed files.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/models/player.py ---
# backend/app/models/player.py
import uuid
from typing import Optional, List, TYPE_CHECKING # List for future relationship typing

from sqlalchemy import Column, String # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship # Import Mapped, mapped_column

from ..db.base_class import Base

if TYPE_CHECKING: 
    from .character import Character 

class Player(Base):
    __tablename__ = "players"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
    characters: Mapped[List["Character"]] = relationship(back_populates="owner")

    # --- Relationships (Example for future) ---
    # If a Player can have multiple Characters:
    # characters: Mapped[List["Character"]] = relationship(back_populates="owner")
    # Note: Use "Character" as a string if Character class is defined later or in another file to avoid circular imports.

    def __repr__(self) -> str:
        return f"<Player(id={self.id}, username='{self.username}')>"
--- END OF FILE backend/app/models/player.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import Column, String, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    owner: Mapped["Player"] = relationship(back_populates="characters")

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)

    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/item.py ---
# backend/app/models/item.py
import uuid
from typing import Optional, Dict, Any

from sqlalchemy import Column, String, Text, Float, Integer, Boolean # Keep Column for __tablename__ etc.
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class Item(Base):
    __tablename__ = "items"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    item_type: Mapped[str] = mapped_column(String(50), index=True, nullable=False, comment="e.g., weapon, armor, potion, junk")
    # Slot where the item can be equipped. Nullable if not equippable (e.g. potion, junk).
    # Could be a list if an item can fit multiple slots (e.g. 'ring_finger_1', 'ring_finger_2'), or a generic 'ring'
    # For simplicity now, let's assume a single primary slot string, or comma-separated if multiple.
    # Or, better, just 'equippable_slot_type' (e.g. 'weapon', 'head', 'ring') and then CharacterInventoryItem handles specifics.
    # Let's go with a simple slot string for now that defines its primary use.
    rarity: Mapped[str] = mapped_column(String(50), nullable=False, default="common", index=True)
    slot: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., head, torso, main_hand, off_hand, ring, consumable, utility")
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True, comment="e.g., {'damage': '1d6', 'armor_class': 5, 'modifier': {'strength': 1}}")
    
    weight: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    value: Mapped[int] = mapped_column(Integer, nullable=False, default=0, comment="Monetary value for shops")
    stackable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    max_stack_size: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1, comment="Max items in a stack if stackable, 1 if not.")

    # Relationship to CharacterInventoryItem (one-to-many: one Item type can be in many inventories)
    # character_inventory_entries: Mapped[List["CharacterInventoryItem"]] = relationship(back_populates="item")


    def __repr__(self) -> str:
        return f"<Item(id={self.id}, name='{self.name}', type='{self.item_type}')>"

# Define standard equipment slots (could be in config or a helper)
# These are the "logical" slots on a character. An item might be usable in one or more of these.
# This helps in validating equip/unequip operations.
EQUIPMENT_SLOTS = {
    "head": "Head",
    "neck": "Neck",
    "torso": "Torso",
    "back": "Back", # Cloak
    "main_hand": "Main Hand",
    "off_hand": "Off Hand", # Shield or second weapon
    "legs": "Legs",
    "feet": "Feet",
    "wrists": "Wrists",
    "hands": "Hands", # Gloves
    "finger_1": "Finger 1",
    "finger_2": "Finger 2",
    "belt": "Belt", 
    "pipe": "Pipe", # For smoking items, if applicable
    "drugs": "Drugs", # Consumables like potions, elixirs, etc.
    "trinket": "Trinket" # Small items that don't fit other categories
    # "ranged_weapon": "Ranged Weapon",
    # "ammunition": "Ammunition"
}
--- END OF FILE backend/app/models/item.py ---

--- START OF FILE backend/app/schemas/player.py ---
# backend/app/schemas/player.py
from typing import Optional
import uuid
from pydantic import BaseModel, Field, EmailStr # EmailStr if you add email later

class PlayerBase(BaseModel):
    username: Optional[str] = Field(None, min_length=3, max_length=100)
    # email: Optional[EmailStr] = None # Example for later

class PlayerCreate(PlayerBase):
    username: str = Field(..., min_length=3, max_length=100) # type: ignore[override] # Make username required
    password: str = Field(..., min_length=8) # Plain password for creation

class PlayerUpdate(PlayerBase): # Not used yet, but for completeness
    username: Optional[str] = None
    password: Optional[str] = None # For password change functionality

class PlayerInDBBase(PlayerBase):
    id: uuid.UUID
    # hashed_password should not be in schemas returned to client

    class Config:
        from_attributes = True

class Player(PlayerInDBBase): # Schema for returning player info (without password)
    pass

class PlayerInDB(PlayerInDBBase): # More complete internal representation if needed
    hashed_password: str
--- END OF FILE backend/app/schemas/player.py ---

--- START OF FILE backend/app/schemas/character.py ---
# backend/app/schemas/character.py
import uuid
from pydantic import BaseModel, Field
from typing import Optional, List # Added List

# Shared properties
class CharacterBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    class_name: Optional[str] = Field("Adventurer", max_length=50)

    # Core Attributes (Defaults provided, so they are effectively non-optional after Pydantic processing)
    strength: int = Field(10, ge=1, le=100) 
    dexterity: int = Field(10, ge=1, le=100)
    constitution: int = Field(10, ge=1, le=100)
    intelligence: int = Field(10, ge=1, le=100)
    wisdom: int = Field(10, ge=1, le=100)
    charisma: int = Field(10, ge=1, le=100)
    luck: int = Field(5, ge=1, le=100)

    # Currency: Optional at creation, with defaults
    platinum_coins: Optional[int] = Field(0, description="Platinum coins owned by the character")
    gold_coins: Optional[int] = Field(0, description="Gold coins owned by the character")
    silver_coins: Optional[int] = Field(0, description="Silver coins owned by the character")
    copper_coins: Optional[int] = Field(100, description="Copper coins owned by the character, default 100 for new chars")

# Properties to receive on character creation
class CharacterCreate(CharacterBase):
    # name and class_name are inherited.
    # Stats are inherited and will use defaults from CharacterBase if not provided.
    pass

# Properties to receive on character update
class CharacterUpdate(BaseModel):
    name: Optional[str] = None
    class_name: Optional[str] = None
    current_room_id: Optional[uuid.UUID] = None


# Properties shared by models stored in DB
class CharacterInDBBase(CharacterBase):  # Inherits cleanly from CharacterBase
    id: uuid.UUID
    player_id: uuid.UUID
    current_room_id: uuid.UUID
    character_class_template_id: Optional[uuid.UUID] = None 

    # Attributes and Vitals will be present from DB
    # strength, dexterity, etc., are already defined in CharacterBase as int

    current_health: int
    max_health: int
    current_mana: int
    max_mana: int

    level: int
    experience_points: int
    
    base_ac: int
    base_attack_bonus: int
    base_damage_dice: str
    base_damage_bonus: int

    platinum_coins: int # type: ignore
    gold_coins: int # type: ignore
    silver_coins: int # type: ignore
    copper_coins: int # type: ignore

    # --- Skills & Traits ---
    learned_skills: Optional[List[str]] = None 
    learned_traits: Optional[List[str]] = None 

    class Config:
        from_attributes = True

# Properties to return to client
class Character(CharacterInDBBase):
    pass 

# Properties stored in DB
class CharacterInDB(CharacterInDBBase):
    pass
--- END OF FILE backend/app/schemas/character.py ---

--- START OF FILE backend/app/websocket_router.py ---
# backend/app/websocket_router.py
import uuid
from typing import Optional, Any, Generator, List, Tuple, Union
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, Query, status
from sqlalchemy.orm import Session # attributes removed as it's used in parsers now
from jose import JWTError, jwt
from contextlib import contextmanager
import logging

from app.core.config import settings
from app.db.session import SessionLocal
from app import crud, models, schemas # Full app imports
from app.websocket_manager import connection_manager
from app.game_logic import combat # For access to combat.active_combats, combat.send_combat_log etc.

from app.commands.utils import ( # General utils
    format_room_items_for_player_message,
    format_room_mobs_for_player_message,
    format_room_characters_for_player_message,
    format_room_npcs_for_player_message
    # resolve_mob_target is used within ws_combat_actions_parser
    # resolve_room_item_target is used within ws_interaction_parser
)
from app.game_state import is_character_resting, set_character_resting_status
# ExitDetail is used within ws_movement_parser.attempt_player_move

# Import the new WS command parsers
from app.ws_command_parsers import (
    handle_ws_movement, handle_ws_flee,
    handle_ws_attack, handle_ws_use_combat_skill,
    handle_ws_get_take, handle_ws_unlock, handle_ws_search_examine,
    handle_ws_contextual_interactable, handle_ws_use_ooc_skill,
    handle_ws_look, handle_ws_rest,
    handle_ws_list, handle_ws_buy, handle_ws_sell, handle_ws_sell_all_junk
)

logger = logging.getLogger(__name__)
# --- Logger setup print lines (can be removed once stable) ---
print(f"--- WEBSOCKET_ROUTER.PY: settings.LOG_LEVEL = '{settings.LOG_LEVEL}' ---", flush=True)
effective_level_ws = logger.getEffectiveLevel()
print(f"--- WEBSOCKET_ROUTER.PY: Effective log level for '{logger.name}' logger = {effective_level_ws} ({logging.getLevelName(effective_level_ws)}) ---", flush=True)
logger.info("--- WEBSOCKET_ROUTER.PY INFO LOG TEST: Module loaded (Post-Refactor) ---")
# --- End of logger setup print lines ---

router = APIRouter()

@contextmanager
def get_db_sync() -> Generator[Session, None, None]:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_player_from_token(token: Optional[str], db: Session) -> Optional[models.Player]:
    if not token: 
        return None
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        player_id_str: Optional[str] = payload.get("sub")
        if not player_id_str: 
            return None
        player_uuid = uuid.UUID(player_id_str) # Ensure player_id_str is a valid UUID string
        return crud.crud_player.get_player(db, player_id=player_uuid)
    except (JWTError, ValueError): # Catch JWT errors and ValueError from UUID conversion
        return None

# _handle_websocket_move_if_not_in_combat has been moved to ws_movement_parser.attempt_player_move

@router.websocket("/ws") 
async def websocket_game_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="Player's JWT authentication token"),
    character_id: uuid.UUID = Query(..., description="UUID of the character connecting")
):
    player: Optional[models.Player] = None
    character_orm: Optional[models.Character] = None # Renamed from 'character' to avoid confusion with character_id param

    with get_db_sync() as db_conn_init: 
        player = await get_player_from_token(token, db_conn_init)
        if not player:
            logger.warning(f"WS Connect: Invalid token for char_id: {character_id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid authentication token")
            return
        
        fetched_char = crud.crud_character.get_character(db_conn_init, character_id=character_id)
        if not fetched_char or fetched_char.player_id != player.id:
            logger.warning(f"WS Connect: Invalid char_id: {character_id} for player: {player.id}")
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION, reason="Invalid character ID or not owned by player")
            return
        character_orm = fetched_char # Assign to the correctly scoped variable
    
    await connection_manager.connect(websocket, player.id, character_orm.id)
    logger.info(f"Player {player.id} (Character {character_orm.name} - {character_orm.id}) connected via WebSocket.")
    
    # --- Welcome Package ---
    initial_messages = [f"Welcome {character_orm.name}! You are connected via WebSocket."]
    initial_room_schema: Optional[schemas.RoomInDB] = None
    with get_db_sync() as db_welcome: 
        initial_room_orm = crud.crud_room.get_room_by_id(db_welcome, room_id=character_orm.current_room_id)
        if initial_room_orm:
            initial_room_schema = schemas.RoomInDB.from_orm(initial_room_orm)
            initial_messages.insert(1, f"You are in {initial_room_orm.name}.")
            items_on_ground = crud.crud_room_item.get_items_in_room(db_welcome, room_id=initial_room_orm.id)
            items_text, _ = format_room_items_for_player_message(items_on_ground)
            if items_text: initial_messages.append(items_text)
            
            mobs_in_room = crud.crud_mob.get_mobs_in_room(db_welcome, room_id=initial_room_orm.id)
            mobs_text, _ = format_room_mobs_for_player_message(mobs_in_room)
            if mobs_text: initial_messages.append(mobs_text)
            
            other_chars_in_room = crud.crud_character.get_characters_in_room(db_welcome, room_id=initial_room_orm.id, exclude_character_id=character_orm.id)
            chars_text_initial = format_room_characters_for_player_message(other_chars_in_room)
            if chars_text_initial: initial_messages.append(chars_text_initial)
    
            npcs_in_room_welcome = crud.crud_room.get_npcs_in_room(db_welcome, room=initial_room_orm)
            npcs_text_welcome = format_room_npcs_for_player_message(npcs_in_room_welcome)
            if npcs_text_welcome: initial_messages.append(npcs_text_welcome)

    xp_for_next_level = crud.crud_character.get_xp_for_level(character_orm.level + 1)
    welcome_payload = {
        "type": "welcome_package",
        "log": initial_messages,
        "room_data": initial_room_schema.model_dump(exclude_none=True) if initial_room_schema else None,
        "character_vitals": {
            "current_hp": character_orm.current_health, "max_hp": character_orm.max_health,
            "current_mp": character_orm.current_mana, "max_mp": character_orm.max_mana,
            "current_xp": character_orm.experience_points,
            "next_level_xp": int(xp_for_next_level) if xp_for_next_level != float('inf') else -1,
            "level": character_orm.level,
            "platinum": character_orm.platinum_coins, "gold": character_orm.gold_coins,
            "silver": character_orm.silver_coins, "copper": character_orm.copper_coins
        }
    }
    await connection_manager.send_personal_message(welcome_payload, player.id)
    # --- End Welcome Package ---

    try:
        while True:
            received_data = await websocket.receive_json()
            message_type = received_data.get("type")
            command_text = received_data.get("command_text", "").strip()

            # It's crucial to get fresh state at the beginning of each command processing loop
            with get_db_sync() as db_loop: 
                current_char_state = crud.crud_character.get_character(db_loop, character_id=character_orm.id)
                if not current_char_state: 
                    logger.error(f"WS Loop: Character state lost for char_id: {character_orm.id}.")
                    await websocket.close(code=status.WS_1011_INTERNAL_ERROR, reason="Character state lost in loop")
                    break 
                
                current_room_orm = crud.crud_room.get_room_by_id(db_loop, current_char_state.current_room_id)
                if not current_room_orm:
                    logger.error(f"WS Loop: Character {current_char_state.name} in invalid room {current_char_state.current_room_id}.")
                    await combat.send_combat_log(player.id, ["Error: Your current location is unstable. Please relog or contact support."], combat_ended=True)
                    continue 

                current_room_schema_for_command = schemas.RoomInDB.from_orm(current_room_orm)
                
                verb_for_rest_check = command_text.split(" ", 1)[0].lower() if command_text else ""
                
                non_breaking_verbs = [ # Commands that don't break resting
                    "rest", "look", "l", "score", "sc", "status", "st", 
                    "help", "?", "skills", "sk", "traits", "tr", 
                    "inventory", "i", "ooc", "say", "'", "emote", ":",
                    "list", "buy", "sell"
                ]
                
                if verb_for_rest_check and verb_for_rest_check not in non_breaking_verbs and is_character_resting(current_char_state.id):
                    set_character_resting_status(current_char_state.id, False)
                    await combat.send_combat_log(player.id, ["You stop resting."], room_data=current_room_schema_for_command)

                if message_type == "command" and command_text:
                    verb = verb_for_rest_check 
                    args_str = command_text.split(" ", 1)[1].strip() if " " in command_text else ""
                    args_list = args_str.split() # For handlers that need a list

                    logger.debug(f"WS Router: Processing verb='{verb}', args='{args_str}' for char {current_char_state.name}")

                    # --- Command Dispatching ---
                    if verb == "rest":
                        await handle_ws_rest(db_loop, player, current_char_state, current_room_orm)
                    elif verb in ["north", "south", "east", "west", "up", "down", "n", "s", "e", "w", "u", "d", "go"]:
                        await handle_ws_movement(db_loop, player, current_char_state, current_room_schema_for_command, verb, args_str)
                    elif verb == "flee":
                        await handle_ws_flee(db_loop, player, current_char_state, current_room_schema_for_command, args_str)
                    elif verb in ["attack", "atk", "kill", "k"]:
                        await handle_ws_attack(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "use":
                        if not args_str: 
                            await combat.send_combat_log(player.id, ["Use what skill?"], room_data=current_room_schema_for_command); continue
                        
                        temp_args_list_for_skill_parse = args_str.split()
                        learned_skill_tags = current_char_state.learned_skills or []
                        if not learned_skill_tags: 
                            await combat.send_combat_log(player.id, ["You have no skills."], room_data=current_room_schema_for_command); continue

                        # Simplified skill name parsing (copied from previous) - THIS SHOULD BE A UTILITY
                        parsed_skill_template: Optional[models.SkillTemplate] = None
                        parsed_remaining_args: str = ""
                        possible_matches_temp: List[Tuple[models.SkillTemplate, str]] = []
                        for i in range(len(temp_args_list_for_skill_parse), 0, -1):
                            current_skill_input = " ".join(temp_args_list_for_skill_parse[:i]).lower()
                            potential_target_str = " ".join(temp_args_list_for_skill_parse[i:]).strip()
                            for skill_tag_loop in learned_skill_tags:
                                st_db = crud.crud_skill.get_skill_template_by_tag(db_loop, skill_id_tag=skill_tag_loop)
                                if not st_db: continue
                                if st_db.skill_id_tag.lower().startswith(current_skill_input) or st_db.name.lower().startswith(current_skill_input):
                                    if not any(em.id == st_db.id for em, _ in possible_matches_temp):
                                        possible_matches_temp.append((st_db, potential_target_str))
                            if possible_matches_temp and len(current_skill_input.split()) > 0: break
                        
                        if not possible_matches_temp: await combat.send_combat_log(player.id, [f"No skill matching '{temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else args_str}'."], room_data=current_room_schema_for_command); continue
                        elif len(possible_matches_temp) == 1: parsed_skill_template, parsed_remaining_args = possible_matches_temp[0]
                        else:
                            exact_match_s = None; s_input_first = temp_args_list_for_skill_parse[0].lower() if temp_args_list_for_skill_parse else ""
                            for sm_t, sm_a in possible_matches_temp:
                                if sm_t.name.lower() == s_input_first or sm_t.skill_id_tag.lower() == s_input_first:
                                    exact_match_s = sm_t; parsed_remaining_args = sm_a; break
                            if exact_match_s: parsed_skill_template = exact_match_s
                            else: await combat.send_combat_log(player.id, [f"Multiple skills match. Specify: {', '.join(list(set([st.name for st, _ in possible_matches_temp])))}"], room_data=current_room_schema_for_command); continue
                        
                        if not parsed_skill_template: await combat.send_combat_log(player.id, ["Error selecting skill for 'use' command."], room_data=current_room_schema_for_command); continue

                        # Dispatch based on skill type
                        if parsed_skill_template.skill_type == "COMBAT_ACTIVE":
                            await handle_ws_use_combat_skill(db_loop, player, current_char_state, current_room_schema_for_command, args_str) # Pass original args_str for its own parsing
                        elif parsed_skill_template.skill_type == "UTILITY_OOC":
                            # parsed_remaining_args is the target for the OOC skill (e.g., direction string)
                            await handle_ws_use_ooc_skill(db_loop, player, current_char_state, current_room_orm, parsed_skill_template, parsed_remaining_args)
                        else:
                            await combat.send_combat_log(player.id, [f"Skill '{parsed_skill_template.name}' type ({parsed_skill_template.skill_type}) cannot be 'used' this way."], room_data=current_room_schema_for_command)
                    
                    elif verb in ["get", "take"]:
                        await handle_ws_get_take(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "unlock":
                        await handle_ws_unlock(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "search" or verb == "examine":
                        await handle_ws_search_examine(db_loop, player, current_char_state, current_room_orm, args_list)
                    elif verb == "look" or verb == "l":
                        await handle_ws_look(db_loop, player, current_char_state, current_room_orm, args_str)
                    
                    # --- SHOP COMMANDS ---
                    elif verb == "list":
                        await handle_ws_list(db_loop, player, current_char_state, current_room_orm)
                    elif verb == "buy":
                        await handle_ws_buy(db_loop, player, current_char_state, current_room_orm, args_str)
                    elif verb == "sell":
                        if args_str.lower() in ["all junk", "all trash"]:
                            await handle_ws_sell_all_junk(db_loop, player, current_char_state, current_room_orm)
                        else:
                            await handle_ws_sell(db_loop, player, current_char_state, current_room_orm, args_str)

                    else: # Fallback: Try contextual interactable actions
                        is_interactable_action_handled = False
                        if current_room_orm.interactables: # Check if list is not None and not empty
                            target_interactable_name_or_id = args_str.lower()
                            for interactable_dict_ws in current_room_orm.interactables:
                                try:
                                    interactable_obj_ws = schemas.InteractableDetail(**interactable_dict_ws) # Validate from DB data
                                    is_visible = not interactable_obj_ws.is_hidden or current_char_state.id in interactable_obj_ws.revealed_to_char_ids
                                    
                                    if is_visible and verb == interactable_obj_ws.action_verb.lower():
                                        matches_this_interactable = False
                                        if not target_interactable_name_or_id: # e.g. "pull"
                                            # Count how many pullable things are visible
                                            count_with_verb = 0
                                            for other_i_d in current_room_orm.interactables:
                                                other_i = schemas.InteractableDetail(**other_i_d)
                                                other_vis = not other_i.is_hidden or current_char_state.id in other_i.revealed_to_char_ids
                                                if other_vis and other_i.action_verb.lower() == verb:
                                                    count_with_verb +=1
                                            if count_with_verb == 1: matches_this_interactable = True
                                        elif interactable_obj_ws.id_tag.lower() == target_interactable_name_or_id or \
                                             target_interactable_name_or_id in interactable_obj_ws.name.lower():
                                            matches_this_interactable = True
                                        
                                        if matches_this_interactable:
                                            await handle_ws_contextual_interactable(db_loop, player, current_char_state, current_room_orm, verb, args_list, interactable_obj_ws)
                                            is_interactable_action_handled = True; break 
                                except Exception as e_parse_interactable_ws_ctx: 
                                    logger.error(f"WS: Error parsing interactable for contextual check: {e_parse_interactable_ws_ctx}. Data: {interactable_dict_ws}")
                        
                        if not is_interactable_action_handled:
                            # If not any of the above, it's an unknown command for WebSocket
                            await combat.send_combat_log(player.id, [f"Unrecognized command via WebSocket: '{command_text}'. Try 'help' (HTTP)."], room_data=current_room_schema_for_command)
                
                    try:
                        db_loop.commit() # Commit changes made by the handler
                        logger.debug(f"WS Router: DB commit successful for command '{command_text}' by {current_char_state.name}")
                    except Exception as e_commit:
                        db_loop.rollback()
                        logger.error(f"WS Router: DB commit failed for command '{command_text}' by {current_char_state.name}: {e_commit}", exc_info=True)
                        await combat.send_combat_log(player.id, ["A glitch in the matrix occurred. Your last action may not have saved."], room_data=current_room_schema_for_command) # Send error to player
                
                elif message_type != "command": 
                    await combat.send_combat_log(player.id, [f"Unrecognized message type: {message_type}."], room_data=current_room_schema_for_command)
                elif not command_text : # Empty command string for type "command"
                     await combat.send_combat_log(player.id, ["Empty command received."], room_data=current_room_schema_for_command)

    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for Player {player.id if player else 'N/A'} (Character {character_orm.id if character_orm else 'N/A'})")
        if character_orm and character_orm.id: 
            combat.end_combat_for_character(character_orm.id, reason="websocket_disconnect_main_handler")
            if is_character_resting(character_orm.id):
                set_character_resting_status(character_orm.id, False)
    except Exception as e:
        err_player_id_str = str(player.id) if player else "Unknown Player"
        err_char_id_str = str(character_orm.id) if character_orm else "Unknown Character"
        logger.error(f"Critical Error in WebSocket handler for Player {err_player_id_str} (Character {err_char_id_str}): {e}", exc_info=True)
        try:
            # Attempt to send a generic error to the client before closing
            await websocket.send_json({"type": "error", "detail": "An unexpected server error occurred. Please try reconnecting."})
        except Exception as send_err: 
            logger.error(f"Failed to send critical error to WebSocket for Player {err_player_id_str}: {send_err}")
    finally:
        if player and player.id: 
            connection_manager.disconnect(player.id) 
            if character_orm and character_orm.id and is_character_resting(character_orm.id): 
                set_character_resting_status(character_orm.id, False)
        char_id_log_final = str(character_orm.id) if character_orm else "N/A"
        player_id_log_final = str(player.id) if player else "N/A"
        logger.info(f"WebSocket connection for Player {player_id_log_final} (Character {char_id_log_final}) fully closed.")
--- END OF FILE backend/app/websocket_router.py ---

--- START OF FILE backend/app/ws_command_parsers/ws_interaction_parser.py ---
# backend/app/ws_command_parsers/ws_interaction_parser.py

import uuid
import random
import logging # Added logging
from typing import Optional, List, Tuple, Union, Sequence 
from sqlalchemy.orm import Session, attributes

from app import crud, models, schemas
from app.game_logic import combat 
from app.commands.utils import resolve_room_item_target, get_dynamic_room_description # IMPORTED get_dynamic_room_description
from app.commands.command_args import CommandContext 
from app.commands import interaction_parser as http_interaction_parser 
from app.websocket_manager import connection_manager 
from app.schemas.common_structures import ExitDetail, InteractableDetail 

logger = logging.getLogger(__name__) # Added logger

async def _send_inventory_update_to_player(db: Session, character: models.Character):
    """
    Helper function to construct and send a full inventory update to a player.
    """
    if not character or not character.id:
        logger.error("Cannot send inventory update: Invalid character object provided.")
        return

    logger.debug(f"Constructing and sending real-time inventory update to character {character.name} ({character.id})")

    inventory_items_orm = crud.crud_character_inventory.get_character_inventory(db, character_id=character.id)
    
    equipped_items = {}
    backpack_items = []
    
    for item_orm in inventory_items_orm:
        item_schema = schemas.CharacterInventoryItem.from_orm(item_orm)
        if item_schema.equipped and item_schema.equipped_slot:
            equipped_items[item_schema.equipped_slot] = item_schema
        else:
            backpack_items.append(item_schema)
            
    inventory_display_data = schemas.CharacterInventoryDisplay(
        equipped_items=equipped_items,
        backpack_items=backpack_items,
        platinum=character.platinum_coins,
        gold=character.gold_coins,
        silver=character.silver_coins,
        copper=character.copper_coins
    )

    payload = {
        "type": "inventory_update",
        "inventory_data": inventory_display_data.model_dump(exclude_none=True)
    }

    await connection_manager.send_personal_message(payload, character.player_id)
    logger.debug(f"Inventory update payload sent to player_id {character.player_id}")
    
async def handle_ws_get_take(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room, 
    args_str: str 
):
    # ... (code to prepare room schema is unchanged) ...
    dynamic_desc = get_dynamic_room_description(current_room_orm)
    current_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    current_room_data_dict["description"] = dynamic_desc
    current_room_schema_with_dynamic_desc = schemas.RoomInDB(**current_room_data_dict)


    if args_str.lower() == "all":
        # ... (code for 'get all' logic is unchanged up until the commit) ...
        items_on_ground_orm = crud.crud_room_item.get_items_in_room(db, room_id=current_room_orm.id)
        if not items_on_ground_orm:
            await combat.send_combat_log(player.id, ["There is nothing on the ground here to get."], room_data=current_room_schema_with_dynamic_desc)
            return

        picked_up_item_messages = []
        failed_to_pick_up_messages = []
        picked_up_item_names_for_broadcast = []
        anything_actually_picked_up = False

        for room_item_instance in items_on_ground_orm:
            if not room_item_instance.item:
                logger.warning(f"RoomItemInstance {room_item_instance.id} in room {current_room_orm.id} has no associated ItemTemplate. Skipping for 'get all'.")
                continue

            if not getattr(room_item_instance.item, 'is_gettable', True):
                continue
            
            _inv_add_entry, add_message = crud.crud_character_inventory.add_item_to_character_inventory(
                db, character_obj=current_char_state,
                item_id=room_item_instance.item_id,
                quantity=room_item_instance.quantity
            )

            if _inv_add_entry:
                crud.crud_room_item.remove_item_from_room(
                    db, room_item_instance_id=room_item_instance.id,
                    quantity_to_remove=room_item_instance.quantity
                )
                item_name_with_qty = room_item_instance.item.name
                if room_item_instance.quantity > 1:
                    item_name_with_qty += f" (x{room_item_instance.quantity})"
                
                picked_up_item_messages.append(f"You take the {item_name_with_qty}.")
                picked_up_item_names_for_broadcast.append(item_name_with_qty)
                anything_actually_picked_up = True
            else:
                failed_to_pick_up_messages.append(f"Could not take {room_item_instance.item.name}: {add_message.replace('You pick up the ', '').replace('You add ', '').replace(' to your inventory.', '')}")
        
        if not anything_actually_picked_up and not failed_to_pick_up_messages:
            await combat.send_combat_log(player.id, ["There was nothing gettable on the ground."], room_data=current_room_schema_with_dynamic_desc)
            return

        if anything_actually_picked_up:
            db.commit()
            await _send_inventory_update_to_player(db, current_char_state) # ### UPDATE PUSH ###
        else:
            db.rollback() # If nothing was picked up, rollback any potential changes
        
        db.refresh(current_char_state)
        refreshed_room_orm = crud.crud_room.get_room_by_id(db, current_room_orm.id)

        # ... (rest of the 'get all' response logic is unchanged) ...
        updated_room_schema_for_response = current_room_schema_with_dynamic_desc # Default
        if refreshed_room_orm:
            updated_dynamic_desc = get_dynamic_room_description(refreshed_room_orm)
            updated_room_data_dict = schemas.RoomInDB.from_orm(refreshed_room_orm).model_dump()
            updated_room_data_dict["description"] = updated_dynamic_desc
            updated_room_schema_for_response = schemas.RoomInDB(**updated_room_data_dict)
        
        final_log_to_player = []
        if picked_up_item_messages:
            final_log_to_player.extend(picked_up_item_messages)
        if failed_to_pick_up_messages:
            final_log_to_player.extend(failed_to_pick_up_messages)
        
        if not final_log_to_player:
            final_log_to_player.append("No items were picked up.")

        xp_for_next = crud.crud_character.get_xp_for_level(current_char_state.level + 1)
        vitals_payload = {
            "current_hp": current_char_state.current_health, "max_hp": current_char_state.max_health,
            "current_mp": current_char_state.current_mana, "max_mp": current_char_state.max_mana,
            "current_xp": current_char_state.experience_points,
            "next_level_xp": int(xp_for_next) if xp_for_next != float('inf') else -1,
            "level": current_char_state.level, "platinum": current_char_state.platinum_coins,
            "gold": current_char_state.gold_coins, "silver": current_char_state.silver_coins,
            "copper": current_char_state.copper_coins
        }
        await combat.send_combat_log(player.id, final_log_to_player, room_data=updated_room_schema_for_response, character_vitals=vitals_payload)

        if picked_up_item_names_for_broadcast:
            broadcast_get_msg = f"<span class='char-name'>{current_char_state.name}</span> picks up: {', '.join(picked_up_item_names_for_broadcast)}."
            await combat.broadcast_to_room_participants(db, current_room_orm.id, broadcast_get_msg, exclude_player_id=player.id)
        return

    # --- Existing logic for single item "get" ---
    # ... (code for resolving single item is unchanged) ...
    if not args_str:
        await combat.send_combat_log(player.id, ["Get what?"], room_data=current_room_schema_with_dynamic_desc)
        return
    
    items_on_ground_orm = crud.crud_room_item.get_items_in_room(db, room_id=current_room_orm.id)
    if not items_on_ground_orm:
        await combat.send_combat_log(player.id, ["There is nothing on the ground here to get."], room_data=current_room_schema_with_dynamic_desc)
        return

    target_room_item_instance, error_or_prompt = resolve_room_item_target(args_str, items_on_ground_orm)
    if error_or_prompt:
        await combat.send_combat_log(player.id, [error_or_prompt], room_data=current_room_schema_with_dynamic_desc)
        return
    if not target_room_item_instance or not target_room_item_instance.item:
        await combat.send_combat_log(player.id, [f"Cannot find '{args_str}' on the ground here."], room_data=current_room_schema_with_dynamic_desc)
        return
    
    if not getattr(target_room_item_instance.item, 'is_gettable', True):
        await combat.send_combat_log(player.id, [f"You cannot pick up the {target_room_item_instance.item.name}."], room_data=current_room_schema_with_dynamic_desc)
        return
        
    _inv_add_entry, add_message = crud.crud_character_inventory.add_item_to_character_inventory(
        db, character_obj=current_char_state,
        item_id=target_room_item_instance.item_id,
        quantity=target_room_item_instance.quantity
    )
    if not _inv_add_entry: 
        await combat.send_combat_log(player.id, [f"You try to pick up {target_room_item_instance.item.name}, but cannot. ({add_message})"], room_data=current_room_schema_with_dynamic_desc)
        return
    
    crud.crud_room_item.remove_item_from_room(
        db, room_item_instance_id=target_room_item_instance.id,
        quantity_to_remove=target_room_item_instance.quantity
    )
    final_pickup_message = add_message
    
    db.commit()
    await _send_inventory_update_to_player(db, current_char_state) # ### UPDATE PUSH ###
    
    db.refresh(current_char_state) 
    refreshed_room_orm = crud.crud_room.get_room_by_id(db, current_room_orm.id)
    
    # ... (rest of the single 'get' response logic is unchanged) ...
    updated_room_schema_for_response = current_room_schema_with_dynamic_desc
    if refreshed_room_orm:
        updated_dynamic_desc = get_dynamic_room_description(refreshed_room_orm)
        updated_room_data_dict = schemas.RoomInDB.from_orm(refreshed_room_orm).model_dump()
        updated_room_data_dict["description"] = updated_dynamic_desc
        updated_room_schema_for_response = schemas.RoomInDB(**updated_room_data_dict)

    xp_for_next = crud.crud_character.get_xp_for_level(current_char_state.level + 1)
    vitals_payload = {
        "current_hp": current_char_state.current_health, "max_hp": current_char_state.max_health,
        "current_mp": current_char_state.current_mana, "max_mp": current_char_state.max_mana,
        "current_xp": current_char_state.experience_points,
        "next_level_xp": int(xp_for_next) if xp_for_next != float('inf') else -1,
        "level": current_char_state.level, "platinum": current_char_state.platinum_coins,
        "gold": current_char_state.gold_coins, "silver": current_char_state.silver_coins,
        "copper": current_char_state.copper_coins
    }
    await combat.send_combat_log(player.id, [final_pickup_message], room_data=updated_room_schema_for_response, character_vitals=vitals_payload)
    
    broadcast_get_msg = f"<span class='char-name'>{current_char_state.name}</span> picks up {target_room_item_instance.item.name}."
    await combat.broadcast_to_room_participants(db, current_room_orm.id, broadcast_get_msg, exclude_player_id=player.id)


async def handle_ws_unlock(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room,
    args_list: Sequence[str] 
):
    # Dynamic description for initial room schema if needed by HTTP parser (though it shouldn't modify it)
    initial_dynamic_desc = get_dynamic_room_description(current_room_orm)
    initial_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    initial_room_data_dict["description"] = initial_dynamic_desc
    initial_room_schema_with_dynamic_desc = schemas.RoomInDB(**initial_room_data_dict)

    cmd_context = CommandContext(
        db=db, active_character=current_char_state,
        current_room_orm=current_room_orm,
        current_room_schema=initial_room_schema_with_dynamic_desc, # Pass schema with dynamic desc
        original_command=f"unlock {' '.join(args_list)}", 
        command_verb="unlock", args=list(args_list) 
    )
    response_schema_from_http = await http_interaction_parser.handle_unlock(cmd_context)
    
    # Prepare final room data for WS response, ensuring it has dynamic description
    final_room_orm_for_response = crud.crud_room.get_room_by_id(db, current_room_orm.id) # Re-fetch
    if final_room_orm_for_response:
        final_dynamic_desc = get_dynamic_room_description(final_room_orm_for_response)
        final_room_data_dict = schemas.RoomInDB.from_orm(final_room_orm_for_response).model_dump()
        final_room_data_dict["description"] = final_dynamic_desc
        final_room_schema_for_ws_response = schemas.RoomInDB(**final_room_data_dict)
    else: # Fallback
        final_room_schema_for_ws_response = initial_room_schema_with_dynamic_desc


    if response_schema_from_http.message_to_player:
        await combat.send_combat_log(
            player.id, 
            [response_schema_from_http.message_to_player], 
            room_data=final_room_schema_for_ws_response # Use schema with dynamic desc
        )


async def handle_ws_search_examine(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room,
    args_list: Sequence[str] 
):
    initial_dynamic_desc = get_dynamic_room_description(current_room_orm)
    initial_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    initial_room_data_dict["description"] = initial_dynamic_desc
    initial_room_schema_with_dynamic_desc = schemas.RoomInDB(**initial_room_data_dict)

    cmd_context = CommandContext(
        db=db, active_character=current_char_state,
        current_room_orm=current_room_orm,
        current_room_schema=initial_room_schema_with_dynamic_desc,
        original_command=f"search {' '.join(args_list)}", 
        command_verb="search",  
        args=list(args_list) 
    )
    response_schema_from_http = await http_interaction_parser.handle_search(cmd_context)
    
    final_room_orm_for_response = crud.crud_room.get_room_by_id(db, current_room_orm.id) 
    if final_room_orm_for_response:
        final_dynamic_desc = get_dynamic_room_description(final_room_orm_for_response)
        final_room_data_dict = schemas.RoomInDB.from_orm(final_room_orm_for_response).model_dump()
        final_room_data_dict["description"] = final_dynamic_desc
        final_room_schema_for_ws_response = schemas.RoomInDB(**final_room_data_dict)
    else:
        final_room_schema_for_ws_response = initial_room_schema_with_dynamic_desc
        
    if response_schema_from_http.message_to_player:
        await combat.send_combat_log(
            player.id, 
            [response_schema_from_http.message_to_player], 
            room_data=final_room_schema_for_ws_response
        )

async def handle_ws_contextual_interactable(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room,
    verb: str, 
    args_list: Sequence[str], 
    interactable_schema: schemas.InteractableDetail 
):
    initial_dynamic_desc = get_dynamic_room_description(current_room_orm)
    initial_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    initial_room_data_dict["description"] = initial_dynamic_desc
    initial_room_schema_with_dynamic_desc = schemas.RoomInDB(**initial_room_data_dict)

    cmd_context = CommandContext(
        db=db, active_character=current_char_state,
        current_room_orm=current_room_orm,
        current_room_schema=initial_room_schema_with_dynamic_desc, 
        original_command=f"{verb} {' '.join(args_list)}",
        command_verb=verb, args=list(args_list) 
    )
    
    response_schema_from_http = await http_interaction_parser.handle_contextual_interactable_action(cmd_context, interactable_schema)
    
    # Re-fetch the current room ORM to ensure its 'exits' are up-to-date after any commits in HTTP parser
    final_response_room_orm = crud.crud_room.get_room_by_id(db, current_room_orm.id) 
    
    if final_response_room_orm:
        dynamic_desc_for_response = get_dynamic_room_description(final_response_room_orm)
        response_room_data_dict = schemas.RoomInDB.from_orm(final_response_room_orm).model_dump()
        response_room_data_dict["description"] = dynamic_desc_for_response
        response_room_schema_with_dynamic_desc = schemas.RoomInDB(**response_room_data_dict)
    else: 
        # Fallback if room somehow vanished
        logger.warning(f"Room {current_room_orm.id} not found after contextual interactable. Using initial schema for dynamic desc.")
        dynamic_desc_for_response = get_dynamic_room_description(current_room_orm) # Use potentially stale ORM
        fallback_dict = initial_room_schema_with_dynamic_desc.model_dump() # Should already have a dynamic desc
        # Ensure it's using the most recent dynamic description based on potentially stale ORM
        fallback_dict["description"] = dynamic_desc_for_response 
        response_room_schema_with_dynamic_desc = schemas.RoomInDB(**fallback_dict)

    if response_schema_from_http.message_to_player:
        await combat.send_combat_log(
            player.id, 
            [response_schema_from_http.message_to_player], 
            room_data=response_room_schema_with_dynamic_desc 
        )

async def handle_ws_use_ooc_skill(
    db: Session,
    player: models.Player,
    current_char_state: models.Character,
    current_room_orm: models.Room, 
    selected_skill_template: models.SkillTemplate, 
    target_identifier: Optional[str] 
):
    current_room_id_for_broadcast = current_room_orm.id
    
    # Initial room schema for log, with dynamic description
    initial_dynamic_desc = get_dynamic_room_description(current_room_orm)
    initial_room_data_dict = schemas.RoomInDB.from_orm(current_room_orm).model_dump()
    initial_room_data_dict["description"] = initial_dynamic_desc
    current_room_schema_for_log = schemas.RoomInDB(**initial_room_data_dict)

    resolved_target_for_effect: Optional[Union[models.RoomMobInstance, str]] = None

    if selected_skill_template.target_type == "DOOR":
        if target_identifier and target_identifier.lower() not in ["none", "self"]:
            resolved_target_for_effect = target_identifier
        else:
            await combat.send_combat_log(player.id, [f"Which direction do you want to use '{selected_skill_template.name}' on?"], room_data=current_room_schema_for_log)
            return
    elif selected_skill_template.target_type in ["SELF", "NONE"]:
        resolved_target_for_effect = None 
    else:
        await combat.send_combat_log(player.id, [f"Skill '{selected_skill_template.name}' has an OOC target type ('{selected_skill_template.target_type}') not yet handled for direct use."], room_data=current_room_schema_for_log)
        return

    skill_log_messages, action_taken_by_skill, char_after_ooc_skill_attempt = await combat.resolve_skill_effect(
        db, current_char_state, selected_skill_template, resolved_target_for_effect, 
        player.id, current_room_id_for_broadcast
    )
    
    final_room_schema_for_response = current_room_schema_for_log # Start with initial
    if action_taken_by_skill:
        if char_after_ooc_skill_attempt: db.add(char_after_ooc_skill_attempt)
        db.commit()
        
        if char_after_ooc_skill_attempt: 
            db.refresh(char_after_ooc_skill_attempt)
            current_char_state = char_after_ooc_skill_attempt 

        refreshed_room_orm = crud.crud_room.get_room_by_id(db, current_room_id_for_broadcast)
        if refreshed_room_orm:
            # Generate dynamic description for the updated room state
            final_dynamic_desc = get_dynamic_room_description(refreshed_room_orm)
            final_room_dict = schemas.RoomInDB.from_orm(refreshed_room_orm).model_dump()
            final_room_dict["description"] = final_dynamic_desc
            final_room_schema_for_response = schemas.RoomInDB(**final_room_dict)
        else:
            logger.warning(f"Room {current_room_id_for_broadcast} not found after OOC skill. Using initial schema for log.")
            # final_room_schema_for_response remains the initial one
    
    xp_for_next = crud.crud_character.get_xp_for_level(current_char_state.level + 1)
    vitals_payload = {
        "current_hp": current_char_state.current_health, "max_hp": current_char_state.max_health,
        "current_mp": current_char_state.current_mana, "max_mp": current_char_state.max_mana,
        "current_xp": current_char_state.experience_points,
        "next_level_xp": int(xp_for_next) if xp_for_next != float('inf') else -1,
        "level": current_char_state.level,
        "platinum": current_char_state.platinum_coins, "gold": current_char_state.gold_coins,
        "silver": current_char_state.silver_coins, "copper": current_char_state.copper_coins
    }
    await combat.send_combat_log(player.id, skill_log_messages, room_data=final_room_schema_for_response, character_vitals=vitals_payload)
--- END OF FILE backend/app/ws_command_parsers/ws_interaction_parser.py ---

--- START OF FILE backend/app/api/dependencies.py ---
# backend/app/api/dependencies.py
from typing import Optional
from fastapi import Depends, HTTPException, status, Header
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.orm import Session
import uuid

from app.core.config import settings
from app import models, schemas, crud
from app.db.session import get_db
from app.game_state import active_game_sessions # <<< ADDED THIS IMPORT

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY

async def get_current_player(
    db: Session = Depends(get_db),
    authorization: Optional[str] = Header(None) # <<< THIS IS THE MAGIC
) -> models.Player:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    if authorization is None:
        raise credentials_exception
    
    # Manually split the "Bearer <token>" string
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise credentials_exception
    except ValueError:
        raise credentials_exception

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username_or_player_id: Optional[str] = payload.get("sub")
        if username_or_player_id is None:
            raise credentials_exception
        
        try:
            player_uuid = uuid.UUID(username_or_player_id)
        except ValueError:
            raise credentials_exception
            
    except JWTError:
        raise credentials_exception
    
    player = crud.crud_player.get_player(db, player_id=player_uuid)
    if player is None:
        raise credentials_exception
    return player

async def get_current_active_character( 
    db: Session = Depends(get_db),
    current_player: models.Player = Depends(get_current_player)
) -> models.Character:
    character_id = active_game_sessions.get(current_player.id)
    
    if not character_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, 
            detail="No active character selected for this session. Please select a character.",
        )
    
    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character:
        active_game_sessions.pop(current_player.id, None)
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Active character with ID {character_id} not found. Session reset.",
        )

    if character.player_id != current_player.id:
        active_game_sessions.pop(current_player.id, None) 
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="CRITICAL: Active character's player ID does not match authenticated player. Session reset.",
        )
    return character
--- END OF FILE backend/app/api/dependencies.py ---

--- START OF FILE backend/app/game_state.py ---
# backend/app/game_state.py
import uuid
from typing import Dict, Optional

# Player ID -> Active Character ID mapping (for HTTP sessions)
active_game_sessions: Dict[uuid.UUID, uuid.UUID] = {}

# Character ID -> Resting Status (True if resting)
character_resting_status: Dict[uuid.UUID, bool] = {}

def is_character_resting(character_id: uuid.UUID) -> bool:
    return character_resting_status.get(character_id, False)

def set_character_resting_status(character_id: uuid.UUID, is_resting: bool):
    if is_resting:
        character_resting_status[character_id] = True
        print(f"GAME_STATE: Character {character_id} is now resting.")
    else:
        if character_id in character_resting_status:
            del character_resting_status[character_id]
            print(f"GAME_STATE: Character {character_id} stopped resting.")
--- END OF FILE backend/app/game_state.py ---

--- START OF FILE frontend/src/state/gameStore.js ---
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { apiService } from '../services/apiService';

const initialState = {
  sessionState: 'LOGGED_OUT', // 'LOGGED_OUT', 'LOGGING_IN', 'CHAR_SELECT', 'IN_GAME'
  token: null,
  characterId: null,
  characterName: '',
  characterClass: '',
  characterLevel: 1,
  characterList: [],
  classTemplates: [],
  logLines: [
    '<span class="system-message-inline">Zustand brain is online. Please log in.</span>',
  ].reverse(),
  vitals: {
    hp: { current: 100, max: 100 },
    mp: { current: 50, max: 50 },
    xp: { current: 0, max: 100 },
  },
  mapData: null,
  currentRoomId: null,
  activeModal: null, // null, 'inventory', 'score', 'skills', 'traits'
  characterStats: null, // Will hold the full character data for the score sheet
  inventory: null, // Will hold the full inventory data
};


const useGameStore = create(
  immer((set, get) => ({
    ...initialState,

    // === ACTIONS ===

    setSessionState: (newState) => set({ sessionState: newState }),

    login: (token) => {
      // console.log('[gameStore] login action called with token:', token);
      set({
        token: token,
        sessionState: 'CHAR_SELECT', // Set both at the same time!
      });
    },
    startCharacterCreation: () => {
        set({ sessionState: 'CHAR_CREATE' });
    },

    setClassTemplates: (templates) => {
        set({ classTemplates: templates });
    },

    finishCharacterCreation: () => {
        // After creating a character, we go back to the selection screen
        // to see our new masterpiece in the list.
        set({ sessionState: 'CHAR_SELECT' });
    },
    fetchScoreAndOpenModal: async () => {
      const token = get().token;
      if (!token) return;
      // If the data is already there, just open the modal. No need to fetch again.
      if (get().characterStats) {
        set({ activeModal: 'score' });
        return;
      }
      try {
        const charDetails = await apiService.fetchCharacterDetails(token);
        set({ characterStats: charDetails, activeModal: 'score' });
      } catch (error) {
        console.error("Failed to fetch character details:", error);
        get().addLogLine("! Could not retrieve character score sheet.");
      }
    },

    setCharacterList: (characters) => set({ characterList: characters }),

    selectCharacter: (character) => {
      set({
        characterId: character.id,
        characterName: character.name,
        characterClass: character.class_name,
        characterLevel: character.level,
        currentRoomId: character.current_room_id,
        sessionState: 'IN_GAME',
        logLines: [`<span class="system-message-inline">Welcome, ${character.name}!</span>`].reverse()
      });
      get().fetchMapData();
    },

    addLogLine: (line) => {
      set((state) => {
        state.logLines.unshift(line);
      });
    },

    fetchMapData: async () => {
      const token = get().token;
      if (!token) return;

      try {
        const mapData = await apiService.fetchMapData(token);
        set({ mapData: mapData });
      } catch (error) {
        console.error("Failed to fetch map data:", error);
        get().addLogLine("! Failed to load map data.");
      }
    },

    setVitals: (vitalsUpdate) => {
      set((state) => {
        state.vitals = { ...state.vitals, ...vitalsUpdate };
      });
    },

    setInventory: (inventoryData) => {
      set({ inventory: inventoryData });
    },

    fetchInventoryAndOpenModal: async () => {
      const token = get().token;
      if (!token) return;
      // Same logic as score: if inventory data exists, just show it.
      if (get().inventory) {
        set({ activeModal: 'inventory' });
        return;
      }
      try {
        const inventoryData = await apiService.fetchInventory(token);
        // We now use our dedicated setter
        get().setInventory(inventoryData);
        set({ activeModal: 'inventory' });
      } catch (error) {
        console.error("Failed to fetch inventory:", error);
        get().addLogLine("! Could not retrieve inventory.");
      }
    },

    // --- NEW MODAL ACTIONS ---
    openModal: (modalName) => set({ activeModal: modalName }),

    closeModal: () => {
      const currentModal = get().activeModal;
      // If we're closing the inventory, nullify its data to ensure a fresh fetch next time.
      if (currentModal === 'inventory') {
        set({ activeModal: null, inventory: null });
      } else if (currentModal === 'score') {
        set({ activeModal: null, characterStats: null });
      } else {
        set({ activeModal: null });
      }
    },

    // --- FULLY IMPLEMENTED LOGOUT ---
    logout: () => {
      console.log("[gameStore] Logging out.");
      set((state) => {
        // We can't just reset to initialState because we want to keep the log message.
        // So we reset each property manually.
        state.sessionState = 'LOGGED_OUT';
        state.token = null;
        state.characterId = null;
        state.characterName = '';
        state.characterClass = '';
        state.characterLevel = 1;
        state.characterList = [];
        state.vitals = { hp: { current: 100, max: 100 }, mp: { current: 50, max: 50 }, xp: { current: 0, max: 100 } };
        state.mapData = null;
        state.currentRoomId = null;
        state.activeModal = null;
        state.characterStats = null;
        // Add a nice logout message to the top of the new log
        state.logLines = ['<span class="system-message-inline">You have been logged out. Please log in again.</span>'].reverse();
      });
    }

  }))
);

export default useGameStore;
--- END OF FILE frontend/src/state/gameStore.js ---

--- START OF FILE frontend/src/services/webSocketService.js ---
import useGameStore from '../state/gameStore';

// The same way we updated the API service
const WS_PROTOCOL = 'wss:';
const WS_HOST = 'llmud.trazen.org';

// Again, direct access to the store for non-React files
const { getState, setState } = useGameStore;

let socket = null;

const handleMessage = (event) => {
    try {
        const serverData = JSON.parse(event.data);
        console.log("WS RCV:", serverData); // Good for debugging

        // HERE IS THE MAGIC:
        // We'll call setState directly based on the message type.
        // This is like a mini-reducer.
        switch (serverData.type) {
            case "welcome_package":
            case "combat_update": // COMBINED and CORRECTED
                setState((state) => {
                    if (serverData.log && serverData.log.length > 0) {
                        state.logLines.unshift(...serverData.log.reverse());
                    }
                    if (serverData.character_vitals) {
                        // The correct, nested mapping logic
                        state.vitals.hp.current = serverData.character_vitals.current_hp;
                        state.vitals.hp.max = serverData.character_vitals.max_hp;
                        state.vitals.mp.current = serverData.character_vitals.current_mp;
                        state.vitals.mp.max = serverData.character_vitals.max_mp;
                        state.vitals.xp.current = serverData.character_vitals.current_xp;
                        // The welcome package uses next_level_xp, but other vitals updates might not.
                        // Let's be safe.
                        if (serverData.character_vitals.next_level_xp !== undefined) {
                            state.vitals.xp.max = serverData.character_vitals.next_level_xp;
                        }
                        state.characterLevel = serverData.character_vitals.level;
                    }
                    // Also update the current room if new data is provided
                    if (serverData.room_data) {
                        state.currentRoomId = serverData.room_data.id;
                        // If the z-level changed, we should probably fetch a new map
                        if (state.mapData && state.mapData.z_level !== serverData.room_data.z) {
                            // We'll call fetchMapData outside the 'set' call
                            state.needsNewMap = true; // Let's use a flag
                        }
                    }
                    if (serverData.type === "combat_update") {
                        state.isInCombat = !serverData.combat_over;
                    }
                });
                // Handle the side-effect of fetching a new map
                if (getState().needsNewMap) {
                    setState({ needsNewMap: false }); // Reset the flag
                    getState().fetchMapData();
                }
                break;

            case "vitals_update": // This one ALSO needs to be fixed!
                setState((state) => {
                    // Apply the same mapping logic here
                    state.vitals.hp.current = serverData.current_hp;
                    state.vitals.hp.max = serverData.max_hp;
                    state.vitals.mp.current = serverData.current_mp;
                    state.vitals.mp.max = serverData.max_mp;
                    if (serverData.next_level_xp !== undefined) {
                        state.vitals.xp.max = serverData.next_level_xp;
                    }
                    state.vitals.xp.current = serverData.current_xp;
                    state.characterLevel = serverData.level;
                });
                break;
            
            // ### THE NEW CASE FOR REAL-TIME INVENTORY ###
            case "inventory_update":
                console.log("[WS] Received real-time inventory_update.");
                setState(state => {
                    // This directly overwrites the inventory slice of the state.
                    // If the modal is open, React will re-render it automagically.
                    state.inventory = serverData.inventory_data;
                });
                break;

            // Add more cases here as needed...
            case "game_event":
            case "ooc_message":
                setState((state) => {
                    state.logLines.unshift(serverData.message);
                });
                break;

            default:
                console.warn("Unhandled WS message type:", serverData.type);
                break;
        }

    } catch (e) {
        console.error("Error parsing or handling WebSocket message:", e);
    }
};

const handleClose = (event) => {
    console.log("WebSocket connection closed:", event.code, event.reason);
    setState({ isInCombat: false }); // Always reset combat status on disconnect
    socket = null;
    // Optionally, add a log line to inform the user
    setState(state => {
        state.logLines.unshift(`! Game server connection closed. (Code: ${event.code} ${event.reason || ''})`.trim());
    })
};

const handleError = (event) => {
    console.error("WebSocket error observed:", event);
    setState(state => {
        state.logLines.unshift("! WebSocket connection error.");
    });
};

export const webSocketService = {
    connect: () => {
        const token = getState().token;
        const characterId = getState().characterId;

        if (!token || !characterId) {
            console.error("WS Connect: Missing token or character ID.");
            return;
        }

        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log("WebSocket already open.");
            return;
        }

        const wsUrl = `${WS_PROTOCOL}//${WS_HOST}/ws?token=${token}&character_id=${characterId}`;
        console.log("Attempting WS connection to:", wsUrl);

        socket = new WebSocket(wsUrl);

        socket.onopen = () => console.log("WebSocket connection established.");
        socket.onmessage = handleMessage;
        socket.onclose = handleClose;
        socket.onerror = handleError;
    },

    disconnect: () => {
        if (socket) {
            socket.close();
        }
    },

    sendMessage: (payload) => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(payload));
        } else {
            console.error("Cannot send WS message: Not connected.");
            // Optionally add a log line for the user
            setState(state => {
                state.logLines.unshift("! Cannot send command: Not connected to game server.");
            });
        }
    }
};
--- END OF FILE frontend/src/services/webSocketService.js ---

--- START OF FILE frontend/src/components/CommandInput.jsx ---
import React, { useState } from 'react';
import { webSocketService } from '../services/webSocketService';
import useGameStore from '../state/gameStore';

function CommandInput() {
  const [inputValue, setInputValue] = useState('');
  const addLogLine = useGameStore((state) => state.addLogLine);

  const handleInputChange = (event) => {
    setInputValue(event.target.value);
  };

  const handleKeyPress = async (event) => {
    if (event.key === 'Enter') {
      const command = inputValue.trim();
      setInputValue('');

      if (!command) return;

      // Echo the command to the log
      addLogLine(`> ${command}`);

      const [verb] = command.toLowerCase().split(' ');

      // --- CLIENT-SIDE COMMAND INTERCEPTION ---
      switch (verb) {
        case 'logout':
          useGameStore.getState().logout();
          return;
        case 'score':
        case 'sc':
          useGameStore.getState().fetchScoreAndOpenModal();
          return;
        case 'inventory':
        case 'i':
        case 'inv':
          useGameStore.getState().fetchInventoryAndOpenModal();
          return;
        default:
          // If it's not a client-side command, send it to the server.
          webSocketService.sendMessage({ type: "command", command_text: command });
          break;
      }
    }
  };

  return (
    <div id="input-prompt-line" className="terminal-input-line">
      <span id="prompt-text"> </span>
      <input
        type="text"
        id="commandInput"
        className="terminal-input"
        name="mud_command_line"
        autoFocus
        autoComplete="off"
        placeholder="Type command..."
        value={inputValue}
        onChange={handleInputChange}
        onKeyPress={handleKeyPress}
      />
    </div>
  );
}

export default CommandInput;
--- END OF FILE frontend/src/components/CommandInput.jsx ---

--- START OF FILE frontend/src/components/Inventory.jsx ---
import React from 'react';
import useGameStore from '../state/gameStore';
import ItemName from './ItemName'; // <-- IMPORT OUR NEW COMPONENT
import './Inventory.css'; // <-- Import its own CSS

function Inventory() {
  const inventory = useGameStore((state) => state.inventory);

  if (!inventory) {
    return <div>Loading inventory...</div>;
  }

  const { equipped_items, backpack_items, platinum, gold, silver, copper } = inventory;

  const formatSlotName = (slot) => {
    return slot.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  };

  return (
    <div className="inventory-container">
      <div className="inventory-section">
        <h4 className="inventory-header">Equipped</h4>
        <div className="equipped-items-grid">
          {Object.keys(equipped_items).length > 0 ? (
            Object.entries(equipped_items).map(([slot, item]) => (
              <div key={slot} className="inventory-item equipped">
                <span className="slot-name">{`[${formatSlotName(slot)}]`}</span>
                {/* ### THE CHANGE IS HERE ### */}
                <ItemName item={item.item} />
              </div>
            ))
          ) : (
            <p className="inventory-empty-message">Nothing equipped.</p>
          )}
        </div>
      </div>

      <div className="inventory-section">
        <h4 className="inventory-header">Backpack</h4>
        <div className="backpack-items-list">
          {backpack_items.length > 0 ? (
            backpack_items.map((item) => (
              <div key={item.id} className="inventory-item backpack">
                {/* ### AND HERE ### */}
                <ItemName item={item.item} />
                {item.quantity > 1 && (
                  <span className="item-quantity"> (x{item.quantity})</span>
                )}
              </div>
            ))
          ) : (
            <p className="inventory-empty-message">Your backpack is empty.</p>
          )}
        </div>
      </div>
      
      <div className="inventory-section currency-footer">
         <h4 className="inventory-header">Wealth</h4>
         <div className="currency-display">
            <span className="currency platinum">{platinum}p</span>
            <span className="currency gold">{gold}g</span>
            <span className="currency silver">{silver}s</span>
            <span className="currency copper">{copper}c</span>
         </div>
      </div>
    </div>
  );
}

export default Inventory;
--- END OF FILE frontend/src/components/Inventory.jsx ---

--- START OF FILE frontend/src/components/ItemName.jsx ---
import React from 'react';
import { Tooltip } from 'react-tooltip';

// Helper to format property names nicely (e.g., 'armor_class' -> 'Armor Class')
const formatPropertyName = (propName) => {
  return propName
    .replace(/_/g, ' ')
    .replace(/\b\w/g, (char) => char.toUpperCase());
};

// ### NEW HELPER FUNCTION ###
// This maps the item_type string from the backend to a specific emoji.
const getIconForItemType = (item) => {
    // Check the slot first for specific equipment types
    switch (item.slot) {
        case 'main_hand':
        case 'off_hand':
            if (item.item_type === 'weapon') return 'âš”ï¸';
            if (item.item_type === 'shield') return 'ðŸ›¡ï¸';
            return 'âœ‹'; // Generic hand for other stuff
        case 'head':
            return 'ðŸ‘‘';
        case 'torso':
            return 'ðŸ‘•';
        case 'legs':
            return 'ðŸ‘–';
        case 'feet':
            return 'ðŸ‘¢';
        case 'ring':
            return 'ðŸ’';
        case 'neck':
            return 'ðŸ’Ž';
    }

    // Fallback to more generic item_type
    switch (item.item_type) {
        case 'weapon':
            return 'âš”ï¸';
        case 'shield':
             return 'ðŸ›¡ï¸';
        case 'armor':
            return 'ðŸ‘•';
        case 'potion':
            return 'ðŸ§ª';
        case 'scroll':
            return 'ðŸ“œ';
        case 'food':
            return 'ðŸ–';
        case 'key':
            return 'ðŸ”‘';
        case 'junk':
            return 'ðŸ—‘ï¸';
        default:
            return 'â”'; // A question mark for anything we haven't mapped yet
    }
};

function ItemName({ item }) {
  if (!item) return null;

  const renderTooltipContent = () => {
    // ... renderTooltipContent function is unchanged ...
    return (
      <div className="item-tooltip-content">
        {item.description && <p className="desc">{item.description}</p>}
        {item.properties && Object.keys(item.properties).length > 0 && (
          <div className="props">
            {Object.entries(item.properties).map(([key, value]) => (
              <p key={key} className="prop-line">
                <span className="prop-key">{formatPropertyName(key)}:</span>
                <span className="prop-value">{String(value)}</span>
              </p>
            ))}
          </div>
        )}
      </div>
    );
  };

  const tooltipId = `item-tooltip-${item.id}`;
  const itemIcon = getIconForItemType(item); // Get the icon for the current item

  return (
    <>
      <span
        className={`item-name-container rarity-${item.rarity || 'common'}`}
        data-tooltip-id={tooltipId}
      >
        {/* ### THE CHANGE IS HERE ### */}
        {/* We add the icon with a bit of spacing right before the name */}
        <span className="item-icon">{itemIcon}</span>
        <span className="item-text">{item.name}</span>
      </span>
      <Tooltip
        id={tooltipId}
        render={renderTooltipContent}
        className="item-tooltip-main"
        opacity={1}
      />
    </>
  );
}

export default ItemName;
--- END OF FILE frontend/src/components/ItemName.jsx ---

--- START OF FILE frontend/src/App.jsx ---
import React, { useEffect } from 'react';
// import { Tooltip } from 'react-tooltip'; // <-- NO LONGER NEEDED HERE
import useGameStore from './state/gameStore';
import GameLayout from './components/GameLayout';
import LoginScreen from './components/LoginScreen';
import CharacterSelectionScreen from './components/CharacterSelectionScreen';
import { webSocketService } from './services/webSocketService';
import CharacterCreationScreen from './components/CharacterCreationScreen';

function App() {
  const sessionState = useGameStore((state) => state.sessionState);

  // ... useEffect is unchanged ...
  useEffect(() => {
    if (sessionState === 'IN_GAME') {
      console.log('[App.jsx] Session is IN_GAME, connecting WebSocket...');
      webSocketService.connect();
    } else {
      console.log('[App.jsx] Session is NOT IN_GAME, disconnecting WebSocket...');
      webSocketService.disconnect();
    }
    return () => {
      console.log('[App.jsx] App unmounting, ensuring WebSocket is disconnected.');
      webSocketService.disconnect();
    };
  }, [sessionState]);


  const renderSessionState = () => {
    switch (sessionState) {
      case 'LOGGED_OUT':
        return <LoginScreen />;
      case 'CHAR_SELECT':
        return <CharacterSelectionScreen />;
      case 'CHAR_CREATE':
        return <CharacterCreationScreen />;
      case 'IN_GAME':      
        return <GameLayout />;
      default:
        return <div>[Loading...]</div>;
    }
  }

  // We no longer need to render the global tooltip here.
  return (
    <>
      {renderSessionState()}
    </>
  )
}

export default App;
--- END OF FILE frontend/src/App.jsx ---

--- START OF FILE frontend/src/main.jsx ---
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'
import useGameStore from './state/gameStore';

window.useGameStore = useGameStore;

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
--- END OF FILE frontend/src/main.jsx ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
