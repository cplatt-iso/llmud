--- SCRIPT START --- Creating bundle: project_context_bundle.txt ---
Timestamp: Sun Jun 15 06:38:46 PM UTC 2025

# --- LLM INSTRUCTION ---
# The following is a list of all potentially relevant files in the project.
# Below this list, a small core set of files has been bundled for initial context.
# If you need to see the content of any other file from the list to answer a question accurately,
# please ask for it specifically by its full path as listed.  DO NOT ASSUME CONTENT EXISTS.  VERIFY FIRST
# --- END LLM INSTRUCTION ---

--- LIST OF ALL PROJECT FILES ---
backend/app/api/dependencies.py
backend/app/api/__init__.py
backend/app/api/v1/api_router.py
backend/app/api/v1/endpoints/character_class.py
backend/app/api/v1/endpoints/character.py
backend/app/api/v1/endpoints/command.py
backend/app/api/v1/endpoints/hotbar.py
backend/app/api/v1/endpoints/__init__.py
backend/app/api/v1/endpoints/inventory.py
backend/app/api/v1/endpoints/map.py
backend/app/api/v1/endpoints/player.py
backend/app/api/v1/endpoints/room.py
backend/app/api/v1/endpoints/user.py
backend/app/api/v1/endpoints/world.py
backend/app/api/v1/__init__.py
backend/app/commands/chat_parser.py
backend/app/commands/combat_parser.py
backend/app/commands/command_args.py
backend/app/commands/debug_parser.py
backend/app/commands/__init__.py
backend/app/commands/interaction_parser.py
backend/app/commands/inventory_parser.py
backend/app/commands/meta_parser.py
backend/app/commands/movement_parser.py
backend/app/commands/shop_parser.py
backend/app/commands/social_parser.py
backend/app/commands/utils.py
backend/app/core/config.py
backend/app/core/__init__.py
backend/app/core/logging_config.py
backend/app/core/security.py
backend/app/crud/base.py
backend/app/crud/crud_character_class.py
backend/app/crud/crud_character_inventory.py
backend/app/crud/crud_character.py
backend/app/crud/crud_item.py
backend/app/crud/crud_mob.py
backend/app/crud/crud_mob_spawn_definition.py
backend/app/crud/crud_npc.py
backend/app/crud/crud_player.py
backend/app/crud/crud_room_item.py
backend/app/crud/crud_room.py
backend/app/crud/crud_skill.py
backend/app/crud/crud_trait.py
backend/app/crud/__init__.py
backend/app/db/base_class.py
backend/app/db/__init__.py
backend/app/db/session.py
backend/app/game_logic/combat/combat_round_processor.py
backend/app/game_logic/combat/combat_state_manager.py
backend/app/game_logic/combat/combat_ticker.py
backend/app/game_logic/combat/combat_utils.py
backend/app/game_logic/combat/__init__.py
backend/app/game_logic/combat/skill_resolver.py
backend/app/game_logic/__init__.py
backend/app/game_logic/mob_ai_ticker.py
backend/app/game_logic/mob_respawner.py
backend/app/game_logic/npc_dialogue_ticker.py
backend/app/game_logic/player_vital_regenerator.py
backend/app/game_logic/world_ticker.py
backend/app/game_state.py
backend/app/__init__.py
backend/app/main.py
backend/app/models/character_class_template.py
backend/app/models/character_inventory_item.py
backend/app/models/character.py
backend/app/models/__init__.py
backend/app/models/item.py
backend/app/models/mob_spawn_definition.py
backend/app/models/mob_template.py
backend/app/models/npc_template.py
backend/app/models/player.py
backend/app/models.py
backend/app/models/room_item_instance.py
backend/app/models/room_mob_instance.py
backend/app/models/room.py
backend/app/models/skill_template.py
backend/app/models/trait_template.py
backend/app/schemas/abilities.py
backend/app/schemas/character_class_template.py
backend/app/schemas/character.py
backend/app/schemas/chat.py
backend/app/schemas/command.py
backend/app/schemas/common_structures.py
backend/app/schemas/__init__.py
backend/app/schemas/item.py
backend/app/schemas/map.py
backend/app/schemas/mob.py
backend/app/schemas/mob_spawn_definition.py
backend/app/schemas/npc.py
backend/app/schemas/player.py
backend/app/schemas/room_item.py
backend/app/schemas/room.py
backend/app/schemas/shop.py
backend/app/schemas/skill.py
backend/app/schemas/trait.py
backend/app/schemas/who.py
backend/app/seeds/character_classes.json
backend/app/seeds/chat_channels.json
backend/app/seeds/exits_z0.json
backend/app/seeds/items.json
backend/app/seeds/loot_tables.json
backend/app/seeds/mob_spawn_definitions.json
backend/app/seeds/mob_templates.json
backend/app/seeds/npcs.json
backend/app/seeds/rooms_z0.json
backend/app/seeds/skills.json
backend/app/seeds/traits.json
backend/app/services/chat_manager.py
backend/app/services/__init__.py
backend/app/services/room_service.py
backend/app/services/world_service.py
backend/app/websocket_manager.py
backend/app/websocket_router.py
backend/app/ws_command_parsers/__init__.py
backend/app/ws_command_parsers/ws_admin_parser.py
backend/app/ws_command_parsers/ws_combat_actions_parser.py
backend/app/ws_command_parsers/ws_info_parser.py
backend/app/ws_command_parsers/ws_interaction_parser.py
backend/app/ws_command_parsers/ws_movement_parser.py
backend/app/ws_command_parsers/ws_shop_parser.py
bundle_context.sh
frontend/src/components/AbilityList.css
frontend/src/components/BottomInfoBar.css
frontend/src/components/CharacterCreationScreen.css
frontend/src/components/CharacterInfoBar.css
frontend/src/components/CharacterSelectionScreen.css
frontend/src/components/ChatWindow.css
frontend/src/components/EquipmentScreen.css
frontend/src/components/GroundItems.css
frontend/src/components/Hotbar.css
frontend/src/components/Inventory.css
frontend/src/components/ItemName.css
frontend/src/components/LoginScreen.css
frontend/src/components/LookResult.css
frontend/src/components/Map.css
frontend/src/components/Modal.css
frontend/src/components/ScoreSheet.css
frontend/src/components/ShopListing.css
frontend/src/components/TabBar.css
frontend/src/components/TabbedWindow.css
frontend/src/components/Terminal.css
frontend/src/components/VitalsMonitor.css
frontend/src/components/WhoList.css
frontend/src/index.css
frontend/src/index.html
frontend/src/services/apiService.js
frontend/src/services/webSocketService.js
frontend/src/state/gameStore.js
--- END OF FILE LIST ---

--- START OF CORE BUNDLED FILES ---

--- START OF FILE bundle_context.sh ---
#!/bin/bash

# Script to bundle specified project files into a single output file for context.
# It first lists all relevant project files, then bundles a core subset.
# Run this script from the root of your 'mud_project' directory.

OUTPUT_FILE="project_context_bundle.txt"
BACKEND_APP_DIR="backend/app"
FRONTEND_SRC_DIR="frontend/src"

# Clear the output file if it already exists
> "$OUTPUT_FILE"

echo "--- SCRIPT START --- Creating bundle: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- LLM Instruction ---
echo "# --- LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "# The following is a list of all potentially relevant files in the project." >> "$OUTPUT_FILE"
echo "# Below this list, a small core set of files has been bundled for initial context." >> "$OUTPUT_FILE"
echo "# If you need to see the content of any other file from the list to answer a question accurately," >> "$OUTPUT_FILE"
echo "# please ask for it specifically by its full path as listed.  DO NOT ASSUME CONTENT EXISTS.  VERIFY FIRST" >> "$OUTPUT_FILE"
echo "# --- END LLM INSTRUCTION ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# --- List of All Project Files ---
echo "--- LIST OF ALL PROJECT FILES ---" >> "$OUTPUT_FILE"
(
    # List the script itself
    echo "bundle_context.sh";

    # List backend files (Python and JSON, excluding pycache)
    if [ -d "$BACKEND_APP_DIR" ]; then
        find "$BACKEND_APP_DIR" -type f \( -name "*.py" -o -name "*.json" \) -not -path "*/__pycache__/*" -not -name "*.pyc";
    fi;

    # List frontend files (JS, HTML, CSS, JSON)
    if [ -d "$FRONTEND_SRC_DIR" ]; then
        find "$FRONTEND_SRC_DIR" -type f \( -name "*.js" -o -name "*.html" -o -name "*.css" -o -name "*.json" \);
    fi
) | sort >> "$OUTPUT_FILE"
echo "--- END OF FILE LIST ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"


# --- Core Files to Bundle ---
# Define a smaller set of core files to include in the bundle.
# Adjust this list as needed to provide essential starting context.
CORE_FILES_TO_BUNDLE=(
    "bundle_context.sh"
    "README.md"

    # --- OPERATION: SITUATIONAL AWARENESS & STATUS AFFLICTION ---
    
    # --- BACKEND: THE COMBAT BRAIN ---
    # The heart of the combat loop. This is where we'll gather the data for our new payload.
    "backend/app/game_logic/combat/combat_round_processor.py"
    
    # Manages the active_combats dictionary. We need this to know who's fighting.
    "backend/app/game_logic/combat/combat_state_manager.py"

    # The models for the combatants. We may need to add a status_effects column here later.
    "backend/app/models/character.py"
    "backend/app/models/room_mob_instance.py"
    "backend/app/models/mob_template.py" # Need this to get max HP.

    # --- FRONTEND: THE EYES ---
    # The main layout. We need to add our new CombatMonitor component here.
    "frontend/src/components/GameLayout.jsx"

    # The main state manager. We'll add a new 'combatState' object here.
    "frontend/src/state/gameStore.js"
    
    # The WebSocket handler. It needs to learn how to process our new 'combat_state_update' payload.
    "frontend/src/services/webSocketService.js"

    # The Map component. Our new component will live next to it, so we need to see how it's styled and placed.
    "frontend/src/components/Map.jsx"

    # --- PROPOSED NEW FILES (Ask me to create them) ---
    # "frontend/src/components/CombatMonitor.jsx"
    # "frontend/src/components/CombatMonitor.css"
)

echo "--- START OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
for FILE_PATH in "${CORE_FILES_TO_BUNDLE[@]}"; do
    if [ -f "$FILE_PATH" ]; then
        echo "" >> "$OUTPUT_FILE"
        echo "--- START OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        cat "$FILE_PATH" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE" # Add a newline for readability
        echo "--- END OF FILE $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Bundled core file: $FILE_PATH"
    else
        echo "" >> "$OUTPUT_FILE"
        echo "--- CORE FILE NOT FOUND: $FILE_PATH ---" >> "$OUTPUT_FILE"
        echo "Warning: Core file not found - $FILE_PATH"
    fi
done
echo "--- END OF CORE BUNDLED FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "--- SCRIPT END --- Bundle complete: $OUTPUT_FILE ---" >> "$OUTPUT_FILE"
echo "Bundle created: $OUTPUT_FILE"

exit 0
--- END OF FILE bundle_context.sh ---

--- START OF FILE README.md ---
# The Unholy MUD of Tron & Allen1 (UMGTWOTRDBSREUPPDX_TPSC) - Alpha

A text-based Multi-User Dungeon (MUD) with a Python/FastAPI backend and a Vanilla JavaScript frontend. Now with more ASCII art than strictly necessary and a map that occasionally works!

## Current State of Affairs (The "Holy Shit, Some of This Works" List)

We've dragged this beast kicking and screaming through several layers of digital hell, and look what we've got:

*   **Solid Foundations (Mostly):**
    *   Python/FastAPI backend, PostgreSQL/SQLAlchemy ORM, JWT Authentication.
    *   Vanilla JS frontend with distinct modules for UI, API, WebSocket, Game State, and Map.
    *   Persistent player sessions via localStorage (token, character ID, name, class).
*   **Improved UI:**
    *   Character info bar (Name, Class, Level).
    *   Vitals bars (HP, MP, XP) that update from WebSocket.
    *   Exits and Currency display.
    *   Scrollable terminal output with `flex-direction: column-reverse`.
    *   Copy Log button.
    *   **Interactive SVG Map:**
        *   Displays rooms and connections for the current Z-level.
        *   Highlights the player's current room.
        *   **Zoomable** via mousewheel and +/- buttons.
        *   **Pannable** via mouse click-and-drag.
        *   **Y-axis flipped** for intuitive "North is up" display.
        *   **Map Title Bar:** Shows "Map | Coords: X, Y, Z" for the current room.
        *   **Z-Level Display Box:** Shows "Level" and the current Z-level integer in the top-left of the map viewport.
        *   **Zone Display Bar (Placeholder):** Below the map, ready for zone name and level range.
        *   **Room Type Icons (Emojis):** Draws icons (✨💰💪🧩💀🚪) on rooms based on their `room_type` from backend data.
*   **Player & Character Lifecycle:**
    *   User registration and login.
    *   Multiple characters per account, character selection.
    *   Character creation with name and class (from backend-defined templates).
    *   Core attributes (Str, Dex, etc.), HP/MP, Level, XP.
    *   Leveling up (basic stat/ability gains driven by `CharacterClassTemplate`).
    *   Currency system (platinum, gold, silver, copper) with debug commands.
*   **Dynamic World & Inhabitants:**
    *   Coordinate-based rooms (`x, y, z`) with configurable exits (`Room.exits` JSONB field using `ExitDetail` schema).
    *   `Room.interactables` JSONB field for levers, hidden panels, etc., with effects like toggling exit locks or custom events.
    *   `MobTemplate` and `RoomMobInstance` system for creatures.
    *   `MobSpawnDefinition` for populating rooms (type, quantity, room, respawn timers, basic roaming AI).
    *   **World Ticker:** Handles mob respawning, basic mob AI (roaming, aggressive mob combat initiation), and player HP/MP regeneration (natural & resting state, interruptible by actions/combat).
*   **Interactive Gameplay:**
    *   Movement (N, S, E, W, U, D) via WebSocket, respects locked doors.
    *   `look` command (room details, items, mobs, other players) via WebSocket.
    *   Item system: `ItemTemplate` (from `items.json` seed), `RoomItemInstance` (items on ground), `CharacterInventoryItem` (player inventory).
    *   **Basic Equipment & Combat Stats:** Equipping/unequipping items (e.g., weapons, armor via HTTP commands for now). Combat stats (AC, attack bonus, damage) 
*   **Modern UI Conveniences:**
    *   **Draggable Hotbar:** A 10-slot hotbar allows players to drag-and-drop skills and consumable items for quick access via mouse click or number keys (1-0).
    dynamically calculated based on attributes and equipped weapon/armor. Unarmed combat defaults.
    *   **Combat System (WebSocket):** Real-time, server-side. Player attacks, mob attacks, skill usage. Target resolution (mobs by name/number, exits by direction). Death & respawn (player to 0,0,0). XP awards and currency drops from mobs (for basic attacks and skill kills). Combat logs/echoes to player and room.
    *   **Skills System:** Characters learn skills from `CharacterClassTemplate`. `use <skill> [target]` command (WebSocket).
        *   `basic_punch`, `power_attack_melee` implemented.
        *   Utility skill: `pick_lock_basic` (targets exit direction, rolls against DC, updates lock state).
    *   Social commands (`say`, `emote`, `fart`, `ooc`) via HTTP.
    *   Meta commands (`help`, `score`, `inventory`, `skills`, `traits`) via HTTP.
    *   Comprehensive debug commands (spawn items/mobs, modify stats/XP/level/currency) via HTTP.
*   **Seed Data Externalization:**
    *   `rooms_z0.json` and `exits_z0.json` define the initial world layout.
    *   `items.json` defines all base item templates.
    *   CRUD seeder functions (`seed_initial_world`, `seed_initial_items`) load from these JSON files, creating/updating DB entries.
*   **Map Data Caching (Client-Side):**
    *   The frontend now caches map data per Z-level (`MapDisplay.mapDataCache`).
    *   `fetchAndDrawMap` only makes an API call if the map for the target Z-level isn't already cached.
    *   Movement within a cached Z-level primarily uses `redrawMapForCurrentRoom` with fresh room data from WebSocket for title/highlight, avoiding full map re-fetches.

## Next Phase: Operation Situational Awareness & Status Affliction

The core loop is solid, but combat still feels like flying blind. The next evolution is to provide the player with critical real-time information and introduce deeper, more tactical gameplay systems.

*   **The Threat Assessment Display (Combat Target Window):** A new UI panel will be added under the map. During combat, this panel will display a dynamic list of all engaged enemies, complete with their health bars. This will provide at-a-glance information and allow players to switch targets by clicking on the desired mob.

*   **The Status Effect Engine (Buffs & Debuffs):** We will build the foundational backend and frontend systems for status effects. This includes:
    *   Modifying database models to store active effects (e.g., poisons, stat buffs, damage shields) and their durations on both players and mobs.
    *   Creating a new server-side ticker to process these effects each round.
    *   Designing UI elements to display active effects on the player and their target.

---
Remember to run `bundle_context.sh` from the project root to generate `project_context_bundle.txt` if you're handing this off or taking a break.
--- END OF FILE README.md ---

--- START OF FILE backend/app/game_logic/combat/combat_round_processor.py ---
# backend/app/game_logic/combat/combat_round_processor.py
import uuid
import random
import logging
from typing import List, Optional, Tuple, Union, Dict, Any

from sqlalchemy.orm import Session, attributes

from app import crud, models, schemas
from app.commands.utils import roll_dice, get_formatted_mob_name, get_dynamic_room_description
from .combat_utils import handle_mob_death_loot_and_cleanup # Existing import
from app import websocket_manager # MODIFIED IMPORT: Import the module

# combat sub-package imports
from .combat_state_manager import (
    active_combats, mob_targets, character_queued_actions,
    end_combat_for_character
)
from .skill_resolver import resolve_skill_effect

from .combat_utils import (
    send_combat_log, 
    perform_server_side_move, direction_map,
    broadcast_to_room_participants    
)
from app.ws_command_parsers.ws_interaction_parser import _send_inventory_update_to_player


logger = logging.getLogger(__name__)

async def process_combat_round(db: Session, character_id: uuid.UUID, player_id: uuid.UUID):
    # --- 1. Initial Character & Combat State Checks ---
    if character_id not in active_combats or not active_combats[character_id]:
        if character_id in active_combats: # Check if key exists before trying to use it
            end_combat_for_character(character_id, reason="no_targets_in_active_combats_dict_proc_round")
        return

    character = crud.crud_character.get_character(db, character_id=character_id)
    if not character: 
        logger.critical(f"PROC_ROUND: Character {character_id} not found. Cleaning combat states.")
        end_combat_for_character(character_id, reason="character_not_found_in_db_proc_round")
        return

    if character.current_health <= 0:
        round_log_dead_char = ["You are dead and cannot act."]
        end_combat_for_character(character_id, reason="character_is_dead_proc_round")
        current_room_for_update = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
        current_room_schema_for_update = schemas.RoomInDB.from_orm(current_room_for_update) if current_room_for_update else None
        xp_for_next_lvl = crud.crud_character.get_xp_for_level(character.level + 1)
        vitals_for_payload = {
            "current_hp": character.current_health, "max_hp": character.max_health,
            "current_mp": character.current_mana, "max_mp": character.max_mana,
            "current_xp": character.experience_points,
            "next_level_xp": int(xp_for_next_lvl) if xp_for_next_lvl != float('inf') else -1, # Handle infinity
            "level": character.level,
            "platinum": character.platinum_coins, "gold": character.gold_coins,
            "silver": character.silver_coins, "copper": character.copper_coins
        }
        await send_combat_log(player_id, round_log_dead_char, combat_over=True, room_data=current_room_schema_for_update, character_vitals=vitals_for_payload)
        return

    # --- 2. Round Setup ---
    char_combat_stats = character.calculate_combat_stats()
    player_ac = char_combat_stats["effective_ac"]
    round_log: List[str] = [] 
    combat_resolved_this_round = False
    action_str = character_queued_actions.get(character_id)
    character_queued_actions[character_id] = None # Clear action once retrieved
    
    room_of_action_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    if not room_of_action_orm:
        logger.error(f"PROC_ROUND: Character {character.name} ({character.id}) in invalid room_id {character.current_room_id}. Ending combat.")
        end_combat_for_character(character_id, reason="character_in_invalid_room_proc_round")
        await send_combat_log(player_id, ["Error: Your location is unstable. Combat disengaged."], combat_over=True)
        # db.add(character) # Character not modified here in a way that needs adding
        # db.commit() # Commit should happen at the end of the round
        return
    current_room_id_for_action_broadcasts = room_of_action_orm.id


    # --- 3. Player's Action Processing ---
    if action_str:
        if action_str.startswith("flee"):
            action_parts = action_str.split(" ", 1)
            flee_direction_canonical = action_parts[1] if len(action_parts) > 1 and action_parts[1] else "random"
            
            if random.random() < 0.60: 
                new_room_id, flee_departure_msg, flee_arrival_msg, _ = await perform_server_side_move(
                    db, character, flee_direction_canonical, player_id 
                )
                if new_room_id:
                    round_log.append(f"<span class='combat-success'>{flee_departure_msg}</span>")
                    if flee_arrival_msg: round_log.append(flee_arrival_msg) 
                    combat_resolved_this_round = True 
                else: 
                    round_log.append(f"<span class='combat-miss'>You try to flee {flee_direction_canonical if flee_direction_canonical != 'random' else ''}, but there's nowhere to go! ({flee_departure_msg})</span>")
            else: 
                round_log.append("<span class='combat-miss'>Your attempt to flee fails! You stumble.</span>")
                await broadcast_to_room_participants(db, current_room_id_for_action_broadcasts, 
                                              f"<span class='char-name'>{character.name}</span> tries to flee, but stumbles!",
                                              exclude_player_id=player_id)
        
        elif action_str.startswith("attack"):
            target_mob_id: Optional[uuid.UUID] = None
            try:
                target_mob_id_str = action_str.split(" ", 1)[1]
                target_mob_id = uuid.UUID(target_mob_id_str)
            except (IndexError, ValueError): 
                round_log.append("Invalid attack target format in queue.")
            
            if target_mob_id and target_mob_id in active_combats.get(character_id, set()):
                mob_instance = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_id)
                if mob_instance and mob_instance.mob_template:
                    if mob_instance.current_health > 0:
                        mob_template = mob_instance.mob_template
                        mob_ac = mob_template.base_defense if mob_template.base_defense is not None else 10 
                        
                        player_attack_bonus = char_combat_stats["attack_bonus"]
                        player_damage_dice = char_combat_stats["damage_dice"]
                        player_damage_bonus = char_combat_stats["damage_bonus"]
                        to_hit_roll = roll_dice("1d20")

                        updated_mob = None 
                        mob_name_formatted = get_formatted_mob_name(mob_instance, character) 

                        if (to_hit_roll + player_attack_bonus) >= mob_ac:
                            damage = max(1, roll_dice(player_damage_dice) + player_damage_bonus) 
                            round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-success'>HITS</span> {mob_name_formatted} for <span class='combat-hit'>{damage}</span> damage.")
                            await broadcast_to_room_participants(db, current_room_id_for_action_broadcasts, 
                                                          f"<span class='char-name'>{character.name}</span> HITS {mob_name_formatted} for {damage} damage!",
                                                          exclude_player_id=player_id)
                            updated_mob = crud.crud_mob.update_mob_instance_health(db, mob_instance.id, -damage)
                        
                        if updated_mob and updated_mob.current_health <= 0:
                            round_log.append(f"<span class='combat-death'>The {mob_name_formatted} DIES! Fucking finally.</span>")
                            character_after_attack_loot, autoloot_occurred, _ = await handle_mob_death_loot_and_cleanup(
                                db, character, updated_mob, round_log, player_id, current_room_id_for_action_broadcasts
                            )
                            if character_after_attack_loot:
                                character = character_after_attack_loot # Update character with XP/currency changes
                            
                            # Send inventory update if autoloot occurred
                            if autoloot_occurred and character.player_id:
                                await _send_inventory_update_to_player(db, character) # CORRECTED CALL
                                logger.debug(f"Sent inventory update to char {character.name} after autoloot from attack.")

                            active_combats.get(character_id, set()).discard(updated_mob.id) 
                            if updated_mob.id in mob_targets: mob_targets.pop(updated_mob.id, None) 
                        elif updated_mob: # Mob was hit but not killed
                                round_log.append(f"  {mob_name_formatted} HP: <span class='combat-hp'>{updated_mob.current_health}/{mob_template.base_health}</span>.")
                        else: # Player missed
                            round_log.append(f"<span class='char-name'>{character.name}</span> <span class='combat-miss'>MISSES</span> the {mob_name_formatted}.")
                            await broadcast_to_room_participants(db, current_room_id_for_action_broadcasts, 
                                                          f"<span class='char-name'>{character.name}</span> MISSES the {mob_name_formatted}.",
                                                          exclude_player_id=player_id)
                    else: # Target mob already dead
                        round_log.append(f"Your target, {mob_instance.mob_template.name if mob_instance.mob_template else 'the creature'}, is already defeated.")
                        if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
                elif mob_instance: # Mob instance exists but no template (data integrity issue)
                    logger.error(f"PROC_ROUND: Mob instance {mob_instance.id} missing mob_template. Cannot process attack.")
                    round_log.append(f"Your target is an unrecognizable entity. Attack fails.")
                    if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
                else: # Target mob ID not found in DB
                    round_log.append(f"Your target (ID: {target_mob_id}) seems to have vanished utterly.")
                    if target_mob_id: active_combats.get(character_id, set()).discard(target_mob_id)
            elif target_mob_id: # Target mob ID was provided but not in player's active combat list
                round_log.append("You try to attack, but your target isn't part of this fight.")
            else: # No valid target_mob_id was parsed from the action string
                 round_log.append("You flail at the air, unsure who to attack. What a loser.")
        
        elif action_str.startswith("use_skill"):
            parts = action_str.split(" ", 2) 
            skill_id_tag_from_queue = parts[1] if len(parts) > 1 else None
            target_identifier_from_queue = parts[2] if len(parts) > 2 else "NONE" 
            
            target_entity_for_skill_resolution: Optional[Union[models.RoomMobInstance, str]] = None 
            skill_template_to_use = crud.crud_skill.get_skill_template_by_tag(db, skill_id_tag=skill_id_tag_from_queue) if skill_id_tag_from_queue else None
            valid_target_context_for_skill = False

            if skill_template_to_use:
                if skill_template_to_use.target_type == "ENEMY_MOB":
                    if target_identifier_from_queue.lower() not in ["none", "self"]: 
                        try:
                            target_mob_uuid = uuid.UUID(target_identifier_from_queue)
                            if target_mob_uuid in active_combats.get(character_id, set()):
                                mob_for_skill = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_uuid)
                                if mob_for_skill and mob_for_skill.mob_template and mob_for_skill.current_health > 0:
                                    target_entity_for_skill_resolution = mob_for_skill
                                    valid_target_context_for_skill = True
                                else: round_log.append(f"Skill target '{mob_for_skill.mob_template.name if mob_for_skill and mob_for_skill.mob_template else 'creature'}' is invalid or dead.")
                            else: round_log.append(f"You can't use '{skill_template_to_use.name}' on something you're not actively fighting ({target_identifier_from_queue}).")
                        except ValueError: round_log.append(f"Invalid target ID '{target_identifier_from_queue}' for skill.")
                    else: round_log.append(f"'{skill_template_to_use.name}' requires an enemy target.")
                
                elif skill_template_to_use.target_type == "DOOR": 
                    if target_identifier_from_queue.lower() not in ["none", "self"]:
                        target_entity_for_skill_resolution = target_identifier_from_queue 
                        valid_target_context_for_skill = True
                    else: round_log.append(f"You need to specify a direction for '{skill_template_to_use.name}'.")

                elif skill_template_to_use.target_type in ["SELF", "NONE"]: 
                    target_entity_for_skill_resolution = None 
                    valid_target_context_for_skill = True
                
                if valid_target_context_for_skill:
                    skill_messages, action_was_taken_by_skill, char_after_skill = await resolve_skill_effect(
                        db, character, skill_template_to_use, target_entity_for_skill_resolution, 
                        player_id, current_room_id_for_action_broadcasts
                    )
                    round_log.extend(skill_messages)
                    if char_after_skill: character = char_after_skill 
                    
                    if isinstance(target_entity_for_skill_resolution, models.RoomMobInstance) and \
                       target_entity_for_skill_resolution.current_health <= 0:
                        db.refresh(target_entity_for_skill_resolution) # Ensure DB state is current
                        if target_entity_for_skill_resolution.current_health <= 0: # Double check after refresh
                            round_log.append(f"<span class='combat-death'>The {get_formatted_mob_name(target_entity_for_skill_resolution, character)} DIES from your skill!</span>")
                            character_after_skill_loot, autoloot_occurred_skill, _ = await handle_mob_death_loot_and_cleanup(
                                db, character, target_entity_for_skill_resolution, round_log, player_id, current_room_id_for_action_broadcasts
                            )
                            if character_after_skill_loot:
                                character = character_after_skill_loot
                            
                            if autoloot_occurred_skill and character.player_id:
                                await _send_inventory_update_to_player(db, character) # CORRECTED CALL
                                logger.debug(f"Sent inventory update to char {character.name} after skill autoloot.")

                            active_combats.get(character_id, set()).discard(target_entity_for_skill_resolution.id)
                            if target_entity_for_skill_resolution.id in mob_targets:
                                mob_targets.pop(target_entity_for_skill_resolution.id, None)
                    
                    if not action_was_taken_by_skill and not any("enough mana" in m.lower() for m in skill_messages) and \
                       not any("already unlocked" in m.lower() for m in skill_messages) and \
                       not any("no lock" in m.lower() for m in skill_messages): 
                        round_log.append(f"Your attempt to use {skill_template_to_use.name} fizzles.")
                elif not round_log: 
                    round_log.append(f"Could not determine a valid target or context for '{skill_template_to_use.name}'.")
            else:
                round_log.append(f"You try to use a skill '{skill_id_tag_from_queue}', but it's invalid or unknown.")
    else: 
        round_log.append("You pause, bewildered by the chaos.")

    # --- 4. Check if Player's Targets Are Defeated (Post-Player Action) ---
    current_targets_for_player = list(active_combats.get(character_id, set())) 
    all_targets_down_after_player_action = True 
    if not current_targets_for_player: 
        all_targets_down_after_player_action = True
    else:
        for mob_target_id in current_targets_for_player:
            mob_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_target_id)
            if mob_check and mob_check.current_health > 0:
                all_targets_down_after_player_action = False; break 
    
    if all_targets_down_after_player_action and not combat_resolved_this_round: 
        round_log.append("All your targets are defeated or gone. Combat ends.")
        combat_resolved_this_round = True


    # --- 5. Mobs' Actions (Retaliation) ---
    if not combat_resolved_this_round and character.current_health > 0:
        mobs_attacking_character_this_round: List[models.RoomMobInstance] = []
        for mob_id, targeted_char_id in list(mob_targets.items()):
            if targeted_char_id == character_id: 
                mob_instance_to_act = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id)
                if mob_instance_to_act and mob_instance_to_act.mob_template and \
                   mob_instance_to_act.current_health > 0 and \
                   mob_instance_to_act.room_id == character.current_room_id: 
                    mobs_attacking_character_this_round.append(mob_instance_to_act)
        
        for mob_instance in mobs_attacking_character_this_round:            
            if character.current_health <= 0: break 
            
            mob_template = mob_instance.mob_template 
            mob_name_formatted = get_formatted_mob_name(mob_instance, character)
            mob_attack_bonus = mob_template.level or 1 
            mob_damage_dice = mob_template.base_attack or "1d4" 
            mob_to_hit_roll = roll_dice("1d20")

            if (mob_to_hit_roll + mob_attack_bonus) >= player_ac:
                damage_to_player = max(1, roll_dice(mob_damage_dice)) 
                round_log.append(f"<span class='inv-item-name'>{mob_name_formatted}</span> <span class='combat-success'>HITS</span> <span class='char-name'>{character.name}</span> for <span class='combat-hit-player'>{damage_to_player}</span> damage.")
                await broadcast_to_room_participants(db, current_room_id_for_action_broadcasts, 
                                              f"<span class='inv-item-name'>{mob_name_formatted}</span> HITS <span class='char-name'>{character.name}</span> for {damage_to_player} damage!",
                                              exclude_player_id=player_id)
                character.current_health -= damage_to_player 
                round_log.append(f"  Your HP: <span class='combat-hp'>{character.current_health}/{character.max_health}</span>.")
                
                if character.current_health <= 0:
                    character.current_health = 0 
                    round_log.append("<span class='combat-death'>YOU HAVE DIED! How utterly predictable.</span>")
                    await broadcast_to_room_participants(db, current_room_id_for_action_broadcasts, 
                                                  f"<span class='char-name'>{character.name}</span> <span class='combat-death'>HAS DIED!</span>",
                                                  exclude_player_id=player_id) 
                    combat_resolved_this_round = True 
                    
                    max_health_at_death = character.max_health 
                    respawn_room_orm = crud.crud_room.get_room_by_coords(db, x=0, y=0, z=0) 
                    if respawn_room_orm:
                        char_after_respawn = crud.crud_character.update_character_room(db, character_id=character.id, new_room_id=respawn_room_orm.id)
                        if char_after_respawn: 
                            character = char_after_respawn 
                            round_log.append(f"A mystical force whisks your fading spirit away. You awaken, gasping, in <span class='room-name'>{respawn_room_orm.name}</span>.")
                        else: round_log.append("Error: Failed to update character room during respawn."); break 
                    else: round_log.append("Error: Respawn room (0,0,0) not found."); break 
                    
                    character.current_health = max_health_at_death 
                    round_log.append("You feel a surge of life, your wounds miraculously healed.")
                    break 
            else: 
                round_log.append(f"<span class='inv-item-name'>{mob_name_formatted}</span> <span class='combat-miss'>MISSES</span> <span class='char-name'>{character.name}</span>.")
                await broadcast_to_room_participants(db, current_room_id_for_action_broadcasts, 
                                              f"<span class='inv-item-name'>{mob_name_formatted}</span> MISSES <span class='char-name'>{character.name}</span>.",
                                              exclude_player_id=player_id)

    # --- 6. End of Round Cleanup & Next Action Queuing ---
    if combat_resolved_this_round:
        end_combat_for_character(character_id, reason="combat_resolved_this_round_proc_round")
    elif character.current_health > 0 and character_id in active_combats: 
        if not action_str or action_str.startswith("attack") or (action_str.startswith("flee") and not combat_resolved_this_round):
            remaining_targets_for_next_round = list(active_combats.get(character_id, set()))
            first_valid_target_id_for_next_round = None
            if remaining_targets_for_next_round:
                for mob_id_check in remaining_targets_for_next_round: 
                    mob_next_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=mob_id_check)
                    if mob_next_check and mob_next_check.current_health > 0:
                        first_valid_target_id_for_next_round = mob_id_check; break 
            
            if first_valid_target_id_for_next_round:
                character_queued_actions[character_id] = f"attack {first_valid_target_id_for_next_round}"
            else: 
                if not combat_resolved_this_round : 
                    round_log.append("No valid targets remain for next round. Combat ends.")
                end_combat_for_character(character_id, reason="no_valid_targets_remain_proc_round_queue_next")
                combat_resolved_this_round = True 

    # --- 7. Final DB Commit & Send Log ---
    db.add(character) 
    db.commit()
    db.refresh(character) 
    
    final_room_for_payload_orm = crud.crud_room.get_room_by_id(db, room_id=character.current_room_id)
    
    xp_for_next_level_final = crud.crud_character.get_xp_for_level(character.level + 1)
    final_vitals_payload = {
        "current_hp": character.current_health, "max_hp": character.max_health,
        "current_mp": character.current_mana, "max_mp": character.max_mana,
        "current_xp": character.experience_points,
        "next_level_xp": int(xp_for_next_level_final) if xp_for_next_level_final != float('inf') else -1, 
        "level": character.level,
        "platinum": character.platinum_coins, "gold": character.gold_coins,
        "silver": character.silver_coins, "copper": character.copper_coins
    }
    
    final_room_schema_for_response = None
    if final_room_for_payload_orm:
        final_dynamic_desc = get_dynamic_room_description(final_room_for_payload_orm)
        final_room_dict = schemas.RoomInDB.from_orm(final_room_for_payload_orm).model_dump()
        final_room_dict["description"] = final_dynamic_desc
        final_room_schema_for_response = schemas.RoomInDB(**final_room_dict)

    await send_combat_log(
        player_id, 
        round_log, 
        room_data=final_room_schema_for_response, 
        character_vitals=final_vitals_payload
    )
    
    # If XP or level could have changed, notify clients to update their Who list
    if any("XP gained" in log_entry for log_entry in round_log) or \
       any("You have reached Level" in log_entry for log_entry in round_log):
        await websocket_manager.connection_manager.broadcast({"type": "who_list_updated"}) # MODIFIED USAGE
        logger.info(f"Combat round for char {character_id} resulted in XP/level change. Broadcasted who_list_updated.")

    logger.info(f"Combat round processed for character {character_id}. Total log entries: {len(round_log)}")
--- END OF FILE backend/app/game_logic/combat/combat_round_processor.py ---

--- START OF FILE backend/app/game_logic/combat/combat_state_manager.py ---
# backend/app/game_logic/combat/combat_state_manager.py
import uuid
from typing import Dict, Set, Optional, List # Added List
import logging

from sqlalchemy.orm import Session

from app import crud, models, schemas # For type hints and DB access
from app.game_state import is_character_resting, set_character_resting_status
from .combat_utils import send_combat_log, broadcast_combat_event # Use from local package
from app.commands.utils import get_formatted_mob_name

logger = logging.getLogger(__name__)

# Global combat state dictionaries (consider if these should be encapsulated in a class later)
active_combats: Dict[uuid.UUID, Set[uuid.UUID]] = {}  # character_id -> set of mob_instance_ids
mob_targets: Dict[uuid.UUID, uuid.UUID] = {}  # mob_instance_id -> character_id
character_queued_actions: Dict[uuid.UUID, Optional[str]] = {} # character_id -> "action_verb target_id"

def is_mob_in_any_player_combat(mob_id: uuid.UUID) -> bool:
    """Checks if a mob is currently being targeted by any character in active_combats."""
    for _character_id, targeted_mob_ids in active_combats.items():
        if mob_id in targeted_mob_ids:
            return True
    # Also check if mob_targets has this mob_id (mob is targeting a player)
    if mob_id in mob_targets:
        return True
    return False

async def initiate_combat_session(
    db: Session, player_id: uuid.UUID, character_id: uuid.UUID, character_name: str, target_mob_instance_id: uuid.UUID
) -> bool: # Return bool for success/failure
    mob_instance_check = crud.crud_mob.get_room_mob_instance(db, room_mob_instance_id=target_mob_instance_id)
    if not mob_instance_check or mob_instance_check.current_health <= 0:
        await send_combat_log(player_id, ["Target is invalid or already dead."])
        return False
        
    character_check = crud.crud_character.get_character(db, character_id=character_id)
    if not character_check or character_check.current_health <= 0:
        # This check might be redundant if called from process_combat_round where char health is already checked
        await send_combat_log(player_id, ["You are too dead or incapacitated to start combat."])
        return False

    personal_log_messages = []
    if is_character_resting(character_check.id): 
        set_character_resting_status(character_check.id, False)
        personal_log_messages.append("You leap into action, abandoning your rest!")
    
    active_combats.setdefault(character_id, set()).add(target_mob_instance_id)
    mob_targets[target_mob_instance_id] = character_id 
    character_queued_actions[character_id] = f"attack {target_mob_instance_id}" # Default to attack
    
    engagement_message = f"<span class='char-name'>{character_name}</span> engages the <span class='inv-item-name'>{mob_instance_check.mob_template.name}</span>!"
    personal_log_messages.append(engagement_message)
    
    current_room_orm = crud.crud_room.get_room_by_id(db, character_check.current_room_id)
    current_room_schema = schemas.RoomInDB.from_orm(current_room_orm) if current_room_orm else None
    await send_combat_log(player_id, personal_log_messages, room_data=current_room_schema)
    # Broadcast engagement to room handled by caller or process_combat_round's hit messages
    return True


def end_combat_for_character(character_id: uuid.UUID, reason: str = "unknown"):
    """Clears a character from active_combats and mob_targets (if they were targeted)."""
    logger.debug(f"Ending combat for character {character_id}. Reason: {reason}.")
    if character_id in active_combats:
        mobs_character_was_fighting = list(active_combats.pop(character_id, set()))
        logger.debug(f"Character {character_id} was fighting mobs: {mobs_character_was_fighting}")
        for mob_id in mobs_character_was_fighting:
            if mob_id in mob_targets and mob_targets[mob_id] == character_id:
                logger.debug(f"Mob {mob_id} was targeting character {character_id}. Clearing target.")
                mob_targets.pop(mob_id, None)
    else: # Ensure mobs aren't stuck targeting a player who isn't in active_combats anymore
        mobs_to_clear_target_for = [mid for mid, cid_target in mob_targets.items() if cid_target == character_id]
        if mobs_to_clear_target_for:
            logger.debug(f"Character {character_id} not in active_combats, but mobs {mobs_to_clear_target_for} were targeting them. Clearing.")
            for mid_clear in mobs_to_clear_target_for:
                mob_targets.pop(mid_clear, None)
                
    character_queued_actions.pop(character_id, None)
    logger.debug(f"Combat states for character {character_id} cleared.")


async def mob_initiates_combat(db: Session, mob_instance: models.RoomMobInstance, target_character: models.Character):
    """
    Handles a mob initiating combat with a character, using formatted names
    and broadcasting the correct messages to the right people.
    """
    if not mob_instance or mob_instance.current_health <= 0 or not mob_instance.mob_template:
        return
    if not target_character or target_character.current_health <= 0:
        return
    
    # Check if this specific engagement already exists to prevent spam
    if target_character.id in active_combats and mob_instance.id in active_combats[target_character.id]:
        return 

    logger.info(f"COMBAT: {mob_instance.mob_template.name} ({mob_instance.id}) initiates combat with {target_character.name} ({target_character.id})!")
    
    # Set the combat state
    active_combats.setdefault(target_character.id, set()).add(mob_instance.id)
    mob_targets[mob_instance.id] = target_character.id  

    # --- THE TECHNICOLOR FIX ---
    # Get the correctly formatted, color-coded name for the mob from the player's perspective.
    mob_name_formatted = get_formatted_mob_name(mob_instance, target_character)
    char_name_html = f"<span class='char-name'>{target_character.name}</span>"
    
    # --- MESSAGE TO THE POOR BASTARD GETTING ATTACKED ---
    initiation_log_to_player: List[str] = []
    
    # Check if the player was resting and interrupt them.
    if is_character_resting(target_character.id): 
        set_character_resting_status(target_character.id, False)
        initiation_log_to_player.append("<span class='combat-warning'>You are startled from your rest!</span>")
    
    initiation_log_to_player.append(f"{mob_name_formatted} turns its baleful gaze upon you and <span class='combat-hit-player'>attacks!</span>")
    
    # Send the log to the player who got attacked.
    player_room_orm = crud.crud_room.get_room_by_id(db, room_id=target_character.current_room_id)
    player_room_schema = schemas.RoomInDB.from_orm(player_room_orm) if player_room_orm else None
    await send_combat_log(player_id=target_character.player_id, messages=initiation_log_to_player, room_data=player_room_schema)
    
    # --- MESSAGE TO EVERYONE ELSE IN THE ROOM ---
    # Note: We can't use the player-specific colored name for the broadcast,
    # as the color depends on each observer's level. The broadcast function
    # would need to be much smarter. For now, we'll use a generic span for others.
    mob_name_generic_html = f"<span class='mob-name'>{mob_instance.mob_template.name}</span>"
    
    broadcast_message = f"{mob_name_generic_html} shrieks and <span class='combat-hit-player'>attacks</span> {char_name_html}!"
    if "<span class='combat-warning'>You are startled from your rest!</span>" in " ".join(initiation_log_to_player):
         broadcast_message = f"{char_name_html} is startled from their rest as {mob_name_generic_html} <span class='combat-hit-player'>attacks</span>!"
    
    # The broadcast_combat_event function already correctly excludes the target player.
    await broadcast_combat_event(db, mob_instance.room_id, target_character.player_id, broadcast_message)
--- END OF FILE backend/app/game_logic/combat/combat_state_manager.py ---

--- START OF FILE backend/app/models/character.py ---
# backend/app/models/character.py
import uuid
from typing import Any, Dict, Optional, List, TYPE_CHECKING

from sqlalchemy import JSON, Column, Integer, String, Boolean, ForeignKey, Enum, Text # Ensure Boolean is imported
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app import models

from ..db.base_class import Base

if TYPE_CHECKING:
    from .player import Player
    from .room import Room
    from .character_inventory_item import CharacterInventoryItem
    from .character_class_template import CharacterClassTemplate # <<< NEW IMPORT

class Character(Base):
    __tablename__ = "characters"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), index=True, nullable=False, unique=True)
    class_name: Mapped[str] = mapped_column(String(50), nullable=False, default="Adventurer") # Keep as stored field
    is_brief_mode: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    owner: Mapped["Player"] = relationship(back_populates="characters", lazy="joined") 

    hotbar: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSON, 
        nullable=True, 
        default=lambda: {str(i): None for i in range(1, 11)},
        comment="Stores hotbar configuration, mapping slot number to item/skill info"
    )

    player_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("players.id"), nullable=False, index=True)
    god_level: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="0 for mortals, 1-10 for gods")
    titles: Mapped[Optional[List[str]]] = mapped_column(JSON, nullable=True, default=lambda: [], comment="e.g., ['The Godslayer', 'Cheesewheel Enthusiast']")
    current_room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), nullable=False, index=True)
    is_brief_mode: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    # --- Class Template Link ---
    character_class_template_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True),
        ForeignKey("character_class_templates.id"),
        nullable=True
    )
    # Optional: if you want to access the template object directly.
    # `lazy="joined"` can be good if you always need it, but selective loading might be better.
    class_template_ref: Mapped[Optional["CharacterClassTemplate"]] = relationship(foreign_keys=[character_class_template_id])


    # --- Core Attributes ---
    strength: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    dexterity: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    constitution: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    intelligence: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    wisdom: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    charisma: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    luck: Mapped[int] = mapped_column(Integer, default=5, nullable=False)

    # --- Combat/Vital Stats ---
    current_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    max_health: Mapped[int] = mapped_column(Integer, default=20, nullable=False)
    current_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)
    max_mana: Mapped[int] = mapped_column(Integer, default=10, nullable=False)

    # --- Progression ---
    level: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    experience_points: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skills & Traits ---
    learned_skills: Mapped[Optional[List[str]]] = mapped_column(JSON, nullable=True, default=lambda: [])
    learned_traits: Mapped[Optional[List[str]]] = mapped_column(JSON, nullable=True, default=lambda: [])

    # --- Basic Combat Stats (Placeholders until derived from gear/attributes) ---
    base_ac: Mapped[int] = mapped_column(Integer, default=10, nullable=False, comment="Base Armor Class")
    base_attack_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base to-hit bonus")
    base_damage_dice: Mapped[str] = mapped_column(String(20), default="1d4", nullable=False, comment="e.g., 1d6")
    base_damage_bonus: Mapped[int] = mapped_column(Integer, default=0, nullable=False, comment="Base flat damage bonus")

    platinum_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    gold_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    silver_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    copper_coins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    # --- Skill and Trait Points ---
    skill_points: Mapped[int] = mapped_column(Integer, default=0, server_default="0", nullable=False)
    trait_points: Mapped[int] = mapped_column(Integer, default=0, server_default="0", nullable=False)

    autoloot_enabled: Mapped[bool] = mapped_column(Boolean, default=False, server_default="false", nullable=False)

    # Relationships
    inventory_items: Mapped[List["CharacterInventoryItem"]] = relationship(
        back_populates="character",
        cascade="all, delete-orphan"
    )

    def get_attribute_modifier(self, attribute_name: str) -> int:
        """Calculates the D&D-style modifier for a given attribute."""
        score = getattr(self, attribute_name, 10) # Default to 10 if attribute somehow not found
        return (score - 10) // 2

    def get_equipped_items_by_slot(self, slot_key: str) -> List['CharacterInventoryItem']: # type: ignore
        """Returns a list of items equipped in the specified slot."""
        if not hasattr(self, 'inventory_items') or not self.inventory_items:
            return []
        return [inv_item for inv_item in self.inventory_items if inv_item.equipped and inv_item.equipped_slot == slot_key]

    def calculate_combat_stats(self) -> Dict[str, Any]:
        stats = {
            "effective_ac": 10, 
            "attack_bonus": 0,
            "damage_dice": "1d2", # <<< CHANGED UNARMED TO 1d2 FROM 1d4
            "damage_bonus": 0,
            "primary_attribute_for_attack": "strength"
        }

        dex_modifier = self.get_attribute_modifier("dexterity")
        str_modifier = self.get_attribute_modifier("strength") # Calculate once

        # Initialize AC with base + dex_modifier
        # This initial_ac_with_dex will be adjusted if armor caps dex_modifier
        initial_ac_with_dex = 10 + dex_modifier
        current_ac = initial_ac_with_dex # Start with this

        equipped_weapon_item: Optional[models.Item] = None # Store the Item model directly
        max_dex_bonus_cap_from_armor: Optional[int] = None

        # Ensure inventory_items is accessible and not None
        # The relationship should be loaded. If it's not, that's a different problem (lazy loading config)
        # but usually `self.inventory_items` would work if the character ORM object is complete.
        if not hasattr(self, 'inventory_items') or self.inventory_items is None:
            # This case should ideally not happen if the character object is properly loaded.
            # If it does, we proceed with base stats.
            print(f"Warning: Character {self.name} has no inventory_items attribute or it's None during stat calculation.")
        else:
            for inv_item in self.inventory_items:
                if not inv_item.equipped or not inv_item.item:
                    continue

                item_model = inv_item.item # This is the actual Item model instance
                item_props = item_model.properties or {}

                # Armor Class contributions from armor AND shields
                if item_model.item_type == "armor": # This covers torso, head, feet, etc. AND shields if type is "armor"
                    current_ac += item_props.get("armor_class_bonus", 0)
                    
                    # Check for max_dex_bonus cap from this piece of armor
                    if "max_dex_bonus_to_ac" in item_props:
                        cap = item_props["max_dex_bonus_to_ac"]
                        if max_dex_bonus_cap_from_armor is None or cap < max_dex_bonus_cap_from_armor:
                            max_dex_bonus_cap_from_armor = cap
                
                # Specifically identify the main hand weapon
                if inv_item.equipped_slot == "main_hand" and item_model.item_type == "weapon":
                    equipped_weapon_item = item_model
        
        # After iterating all items, apply the Max Dex Bonus cap if one was found
        if max_dex_bonus_cap_from_armor is not None:
            # We started with current_ac = 10 + dex_modifier
            # If dex_modifier exceeds cap, we need to subtract the excess
            if dex_modifier > max_dex_bonus_cap_from_armor:
                excess_dex = dex_modifier - max_dex_bonus_cap_from_armor
                current_ac -= excess_dex
        
        stats["effective_ac"] = current_ac

        # Determine Attack and Damage
        if equipped_weapon_item:
            weapon_props = equipped_weapon_item.properties or {}
            stats["damage_dice"] = weapon_props.get("damage", "1d2") # Default to unarmed if weapon has no damage prop

            is_finesse = weapon_props.get("finesse", False)
            attack_attribute_modifier = str_modifier
            if is_finesse and dex_modifier > str_modifier:
                attack_attribute_modifier = dex_modifier
                stats["primary_attribute_for_attack"] = "dexterity"
            else:
                stats["primary_attribute_for_attack"] = "strength"
            
            stats["attack_bonus"] = attack_attribute_modifier + weapon_props.get("attack_bonus", 0)
            stats["damage_bonus"] = attack_attribute_modifier + weapon_props.get("damage_bonus", 0)
        else:
            # Unarmed: Already set damage_dice to "1d2". Bonus is Str mod.
            stats["attack_bonus"] = str_modifier
            stats["damage_bonus"] = str_modifier
            stats["primary_attribute_for_attack"] = "strength"

        # Add character's general base_attack_bonus (e.g. from level/class BAB)
        stats["attack_bonus"] += self.base_attack_bonus 
        # Note: self.base_damage_bonus is NOT added here if using weapon, as it's part of unarmed calculation.
        # If it were a generic +damage bonus for all attacks, it would be added.

        return stats

    def __repr__(self) -> str:
        return f"<Character(id={self.id}, name='{self.name}', class='{self.class_name}', level={self.level}, hp={self.current_health}/{self.max_health})>"
--- END OF FILE backend/app/models/character.py ---

--- START OF FILE backend/app/models/room_mob_instance.py ---
# backend/app/models/room_mob_instance.py
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, TYPE_CHECKING

from sqlalchemy import ForeignKey, Integer, JSON, DateTime, func, String, Boolean 
from sqlalchemy.dialects.postgresql import UUID as PG_UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base
# from .. import models # Let's remove this direct import from here

if TYPE_CHECKING:
    from .room import Room # Import specific model for type hinting
    from .mob_template import MobTemplate
    from .mob_spawn_definition import MobSpawnDefinition

class RoomMobInstance(Base):
    __tablename__ = "room_mob_instances"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    room_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    mob_template_id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), ForeignKey("mob_templates.id"), index=True, nullable=False)
    
    spawn_definition_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        PG_UUID(as_uuid=True), 
        ForeignKey("mob_spawn_definitions.id"),
        nullable=True, 
        index=True,
        name="spawn_point_id" 
    ) 

    current_health: Mapped[int] = mapped_column(Integer, nullable=False)
    instance_properties_override: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSON, nullable=True)
    spawned_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_action_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    is_static_placement: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False,
                                                      comment="True if this mob was placed specifically and should not be respawned by general systems.")

    # Relationships
    # For the Mapped type hint, use the specific import from TYPE_CHECKING
    # For the relationship string, use the class name directly if it's defined in another module
    # or the fully qualified string if needed.
    room: Mapped["Room"] = relationship(back_populates="mobs_in_room")
    mob_template: Mapped["MobTemplate"] = relationship(lazy="joined") 
    
    originating_spawn_definition: Mapped[Optional["MobSpawnDefinition"]] = relationship(
        foreign_keys=[spawn_definition_id], 
        back_populates="spawned_mob_instances"
    )

    def __repr__(self) -> str:
        return f"<RoomMobInstance(id={self.id}, room_id='{self.room_id}', template_id='{self.mob_template_id}', spawn_def_id='{self.spawn_definition_id}', hp={self.current_health})>"
--- END OF FILE backend/app/models/room_mob_instance.py ---

--- START OF FILE backend/app/models/mob_template.py ---
# backend/app/models/mob_template.py
import uuid
from typing import Optional, Dict, Any, List # Added List

from sqlalchemy import Boolean, String, Text, JSON, Integer, Float # Keep Column, Add Float
from sqlalchemy.dialects.postgresql import UUID as PG_UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from ..db.base_class import Base

class MobTemplate(Base):
    __tablename__ = "mob_templates"

    id: Mapped[uuid.UUID] = mapped_column(PG_UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # mob_type: Mapped[Optional[str]] = mapped_column(String(50), index=True, nullable=True, comment="e.g., beast, humanoid, undead") # Replaced by faction_tags

    level: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=1)
    base_health: Mapped[int] = mapped_column(Integer, nullable=False, default=10)
    base_mana: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) # <<< MODIFIED
    base_attack: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, comment="e.g., 1d6") 
    base_defense: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=10, comment="e.g., Armor Class")
    
    attack_speed_secs: Mapped[Optional[float]] = mapped_column(Float, nullable=True, default=3.0) # <<< MODIFIED
    aggro_radius: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=5) # <<< MODIFIED
    roam_radius: Mapped[Optional[int]] = mapped_column(Integer, nullable=True, default=0) # <<< MODIFIED
    is_boss: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    
    xp_value: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    
    
    # loot_table_ref: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, comment="Placeholder for loot table reference") # Replaced by loot_table_tags
    loot_table_tags: Mapped[Optional[List[str]]] = mapped_column(JSON, nullable=True, default=lambda: []) # <<< MODIFIED (JSONB for list of strings)
    
    currency_drop: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSON, 
        nullable=True,
        comment="Defines currency drop. E.g., {'c_min':0, ...}"
    ) # Default can be set by Pydantic model if not provided in JSON
    
    dialogue_lines: Mapped[Optional[List[str]]] = mapped_column(JSON, nullable=True, default=lambda: []) # <<< MODIFIED
    faction_tags: Mapped[Optional[List[str]]] = mapped_column(JSON, nullable=True, default=lambda: []) # <<< MODIFIED
    special_abilities: Mapped[Optional[List[str]]] = mapped_column(JSON, nullable=True, default=lambda: []) # <<< MODIFIED
    
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSON, nullable=True, default=lambda: {})
    
    # aggression_type: Mapped[Optional[str]] = mapped_column(String(50), default="NEUTRAL", nullable=True, index=True, comment="e.g., NEUTRAL, AGGRESSIVE_ON_SIGHT, AGGRESSIVE_IF_APPROACHED") 
    # Decided to remove this, as aggro_radius and faction logic should cover it.
    # If you reinstate it in schemas/JSON, add it back here too.

    def __repr__(self) -> str:
        return f"<MobTemplate(id={self.id}, name='{self.name}', level='{self.level}')>"
--- END OF FILE backend/app/models/mob_template.py ---

--- START OF FILE frontend/src/components/GameLayout.jsx ---
// frontend/src/components/GameLayout.jsx
import React, { useEffect } from 'react';
import useGameStore from '../state/gameStore'; // <<< Need the store
import { webSocketService } from '../services/webSocketService';
import TabBar from './TabBar';
import TabContent from './TabbedWindow';
import CharacterInfoBar from './CharacterInfoBar';
import VitalsMonitor from './VitalsMonitor';
import BottomInfoBar from './BottomInfoBar';
import CommandInput from './CommandInput';
import Map from './Map';
import Hotbar from './Hotbar';

// CSS IMPORTS - THE HOLY TEMPLE
import './TabBar.css';
import './TabbedWindow.css';
import './Terminal.css'; // This is the one we were missing.
import './CharacterInfoBar.css';
import './VitalsMonitor.css';
import './BottomInfoBar.css';
import './Map.css';

import './GroundItems.css'; // Importing GroundItems styles
import './LookResult.css'; // Importing LookResult styles

import './AbilityList.css'; 
import './ChatWindow.css'; // Importing ChatWindow styles

import './Inventory.css';
import './ShopListing.css'; // We will create this file next
import './Hotbar.css';

function GameLayout() {
  useEffect(() => {
    const handleKeyDown = (e) => {
        // Ignore keypresses if the user is focused on an input field
        if (e.target.tagName.toLowerCase() === 'input') {
            return;
        }

        // Map keys '1' through '9' to slots 1-9, and '0' to slot 10
        const slotId = e.key === '0' ? 10 : parseInt(e.key, 10);
        
        // Check if the key was a valid hotbar key (1-10)
        if (!isNaN(slotId) && slotId >= 1 && slotId <= 10) {
            e.preventDefault(); // This is important! Prevents the '1' from being typed into the command input.
            
            const { hotbar } = useGameStore.getState(); // Get the current hotbar state
            const slotData = hotbar[slotId];
            
            if (slotData) {
                // If the slot has something in it, send the 'use' command to the server
                console.log(`Hotbar slot ${slotId} triggered. Using: ${slotData.identifier}`);
                webSocketService.sendMessage({ command_text: `use ${slotData.identifier}` });
            }
        }
    };

    // Add the event listener to the whole window
    window.addEventListener('keydown', handleKeyDown);

    // This is the cleanup function. It runs when the component unmounts.
    // It's crucial for preventing memory leaks.
    return () => {
        window.removeEventListener('keydown', handleKeyDown);
    };
  }, []); // The empty array [] means this effect runs only once when the component mounts.


  // Your existing, beautiful JSX return statement is UNCHANGED.
  return (
    <>
      <header className="header-text">
        {/* Header stuff */}
      </header>
      <div className="game-area-wrapper">
        <div className="mud-container">
          <CharacterInfoBar />
          <div className="terminal-window-container">
            <TabBar />
            <TabContent />
          </div>
          <div className="game-footer-bar">
            <Hotbar />
            <BottomInfoBar />
            <VitalsMonitor />
            <CommandInput />
          </div>
        </div>
        <Map />
      </div>
    </>
  );
}

export default GameLayout;
--- END OF FILE frontend/src/components/GameLayout.jsx ---

--- START OF FILE frontend/src/state/gameStore.js ---
// frontend/src/state/gameStore.js
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { apiService } from '../services/apiService';
import { v4 as uuidv4 } from 'uuid';

const createLogLine = (data, type = 'html') => ({
  id: uuidv4(),
  type,
  data,
});

const initialState = {
  sessionState: 'LOGGED_OUT',
  token: null,
  characterId: null,
  characterName: '',
  characterClass: '',
  characterLevel: 1,
  characterList: [],
  classTemplates: [],
  logLines: [createLogLine('<span class="system-message-inline">Zustand brain is online. Please log in.</span>')],
  hasUnreadChatMessages: false,
  vitals: { hp: { current: 100, max: 100 }, mp: { current: 50, max: 50 }, xp: { current: 0, max: 100 }, platinum: 0, gold: 0, silver: 0, copper: 0 },
  mapData: null,
  currentRoomId: null,
  activeTab: 'Terminal',
  characterStats: null,
  inventory: null,
  abilities: null,
  whoListData: null, // Added for Who List
  hotbar: {},
};

const useGameStore = create(
  immer((set, get) => ({
    ...initialState,

    // === ACTIONS ===
    // For simple, pre-formatted HTML messages
    addLogLine: (data) => {
      set((state) => {
        state.logLines.push(createLogLine(data, 'html'));
      });
    },

    // For new structured chat payloads
    addMessage: (chatPayload) => {
      set((state) => {
        state.logLines.push(createLogLine(chatPayload, 'chat'));
        if (get().activeTab !== 'Chat') {
          state.hasUnreadChatMessages = true;
        }
      });
    },

    setSessionState: (newState) => set({ sessionState: newState }),
    login: (token) => set({ token, sessionState: 'CHAR_SELECT' }),
    startCharacterCreation: () => set({ sessionState: 'CHAR_CREATE' }),
    setClassTemplates: (templates) => set({ classTemplates: templates }),
    finishCharacterCreation: () => set({ sessionState: 'CHAR_SELECT' }),
    setCharacterList: (characters) => set({ characterList: characters }),

    selectCharacter: (character) => {
      set((state) => {
        state.characterId = character.id;
        state.characterName = character.name;
        state.characterClass = character.class_name;
        state.characterLevel = character.level;
        state.currentRoomId = character.current_room_id;
        state.sessionState = 'IN_GAME';
        state.logLines = [createLogLine(`<span class="system-message-inline">Welcome, ${character.name}!</span>`)];
      });
      get().fetchMapData();
    },

    setVitals: (vitalsUpdate) => {
      set((state) => {
        if (vitalsUpdate.current_hp !== undefined) state.vitals.hp.current = vitalsUpdate.current_hp;
        if (vitalsUpdate.max_hp !== undefined) state.vitals.hp.max = vitalsUpdate.max_hp;
        if (vitalsUpdate.current_mp !== undefined) state.vitals.mp.current = vitalsUpdate.current_mp;
        if (vitalsUpdate.max_mp !== undefined) state.vitals.mp.max = vitalsUpdate.max_mp;
        if (vitalsUpdate.current_xp !== undefined) state.vitals.xp.current = vitalsUpdate.current_xp;
        if (vitalsUpdate.next_level_xp !== undefined) state.vitals.xp.max = vitalsUpdate.next_level_xp;
        if (vitalsUpdate.platinum !== undefined) state.vitals.platinum = vitalsUpdate.platinum;
        if (vitalsUpdate.gold !== undefined) state.vitals.gold = vitalsUpdate.gold;
        if (vitalsUpdate.silver !== undefined) state.vitals.silver = vitalsUpdate.silver;
        if (vitalsUpdate.copper !== undefined) state.vitals.copper = vitalsUpdate.copper;

        // And we still check for level updates
        if (vitalsUpdate.level !== undefined) state.characterLevel = vitalsUpdate.level;
      });
    },
    setInventory: (inventoryData) => set({ inventory: inventoryData }),
    setActiveTab: (tabName) => {
      if (tabName === 'Chat') {
        set({ hasUnreadChatMessages: false });
      }
      set({ activeTab: tabName });
      const state = get();
      if (tabName === 'Score' && !state.characterStats) state.fetchScoreSheet();
      if ((tabName === 'Backpack' || tabName === 'Equipment') && !state.inventory) state.fetchInventory();
      if ((tabName === 'Skills/Spells' || tabName === 'Traits') && !state.abilities) state.fetchAbilities();
      if (tabName === 'Who' && !state.whoListData) state.fetchWhoList(); // Fetch Who List
    },

    fetchAbilities: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const abilitiesData = await apiService.fetchAbilities(token);
        set({ abilities: abilitiesData });
      } catch (error) {
        console.error("Failed to fetch abilities:", error);
        get().addLogLine("! Could not retrieve skills and traits list.");
      }
    },

    fetchScoreSheet: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const charDetails = await apiService.fetchCharacterDetails(token);
        set({ characterStats: charDetails });
      } catch (error) {
        console.error("Failed to fetch score sheet:", error);
        get().addLogLine("! Could not retrieve character score sheet.");
      }
    },
    setHotbar: (hotbarData) => {
      set({ hotbar: hotbarData });
    },
    setHotbarSlot: (slotId, data) => {
      set(state => {
        state.hotbar[slotId] = data;
      });
    },
    clearHotbarSlot: (slotId) => {
      set(state => {
        state.hotbar[slotId] = null;
      });
    },

    fetchInventory: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const inventoryData = await apiService.fetchInventory(token);
        set({ inventory: inventoryData });
      } catch (error) {
        console.error("Failed to fetch inventory:", error);
        get().addLogLine("! Could not retrieve inventory.");
      }
    },

    fetchMapData: async () => {
      const token = get().token;
      if (!token) return;
      try {
        const mapData = await apiService.fetchMapData(token);
        set({ mapData: mapData });
      } catch (error) {
        console.error("Failed to fetch map data:", error);
        get().addLogLine("! Failed to load map data.");
      }
    },

    fetchWhoList: async () => {
      // const token = get().token; // Needed if endpoint is secured
      // if (!token && endpoint_is_secured) return;
      try {
        const whoData = await apiService.fetchWhoList(/*token*/);
        set({ whoListData: whoData });
      } catch (error) {
        console.error("Failed to fetch who list:", error);
        get().addLogLine("! Could not retrieve who list.");
      }
    },

    logout: () => {
      set({ ...initialState, logLines: [createLogLine('<span class="system-message-inline">You have been logged out. Please log in again.</span>')] });
    },
  }))
);

export default useGameStore;
--- END OF FILE frontend/src/state/gameStore.js ---

--- START OF FILE frontend/src/services/webSocketService.js ---
// frontend/src/services/webSocketService.js
import useGameStore from '../state/gameStore';
import { v4 as uuidv4 } from 'uuid';

const WS_PROTOCOL = 'wss:';
const WS_HOST = 'llmud.trazen.org';

const { getState, setState } = useGameStore;

let socket = null;

const createLogEntry = (type, data) => ({
    id: uuidv4(),
    type: type,
    data: data,
});

const handleMessage = (event) => {
    try {
        const serverData = JSON.parse(event.data);
        console.log("WS RCV:", serverData);

        // Get all the actions we might need from the store.
        const { addLogLine, addMessage, setVitals, fetchWhoList, setHotbar } = getState(); // Add fetchWhoList

        switch (serverData.type) {
            case "welcome_package":
                // Handle log lines and map data separately...
                if (serverData.log && serverData.log.length > 0) {
                    const newLogEntries = serverData.log.map(line => createLogEntry('html', line));
                    setState(state => { state.logLines.push(...newLogEntries); });
                }
                if (serverData.room_data) {
                    setState(state => { state.currentRoomId = serverData.room_data.id; });
                    getState().fetchMapData(serverData.room_data.z);
                }
                // ...THEN call the single source of truth for vitals.
                if (serverData.character_vitals) {
                    setVitals(serverData.character_vitals);
                }
                if (serverData.hotbar) {
                    setHotbar(serverData.hotbar);
                }
                break;

            case "combat_update":
                // Handle log lines and map data separately...
                if (serverData.log && serverData.log.length > 0) {
                    const newLogEntries = serverData.log.map(line => createLogEntry('html', line));
                    setState(state => { state.logLines.push(...newLogEntries); });
                }
                if (serverData.room_data) {
                    setState(state => { state.currentRoomId = serverData.room_data.id; });
                    const currentZ = getState().mapData ? getState().mapData.z_level : null;
                    if (currentZ !== null && currentZ !== serverData.room_data.z) {
                        getState().fetchMapData(serverData.room_data.z);
                    }
                }
                // ...THEN call the single source of truth for vitals.
                if (serverData.character_vitals) {
                    setVitals(serverData.character_vitals);
                }
                break;

            case "look_response":
                setState(state => {
                    state.logLines.push(createLogEntry('look', serverData));
                    if (serverData.room_data) {
                        state.currentRoomId = serverData.room_data.id;
                        const currentZ = state.mapData ? state.mapData.z_level : null;
                        if (currentZ === null || currentZ !== serverData.room_data.z) {
                            getState().fetchMapData(serverData.room_data.z);
                        }
                    }
                });
                break;

            case "vitals_update":
                // No wrappers. No bullshit. Just call the action.
                setVitals(serverData);
                break;

            case "inventory_update":
                setState(state => {
                    state.inventory = serverData.inventory_data;
                });
                break;

            case "game_event":
                if (serverData.message) addLogLine(serverData.message, 'html');
                break;

            case "ooc_message":
                if (serverData.message) addLogLine(serverData.message, 'html');
                break;

            case "chat_message":
                if (serverData.payload) {
                    addMessage(serverData.payload);
                }
                break;

            case "who_list_updated": // New case
                console.log("WS: Received who_list_updated, fetching new list.");
                fetchWhoList();
                break;

            case "shop_listing":
                setState(state => {
                    state.logLines.push(createLogEntry('shop_listing', serverData));
                });
                break;

            default:
                console.warn("Unhandled WS message type:", serverData.type, serverData);
                addLogLine(`<span class="system-message-inline">Unhandled event: ${serverData.type}</span>`, 'html');
                break;
        }

    } catch (e) {
        console.error("Error parsing or handling WebSocket message:", e);
    }
};

const handleClose = (event) => {
    console.log("WebSocket connection closed:", event.code, event.reason);
    socket = null;
    const { addLogLine } = getState();
    const closeMessage = `! Game server connection closed. (Code: ${event.code} ${event.reason || ''})`.trim();
    addLogLine(`<span class="system-message-inline">${closeMessage}</span>`, 'html');
};

const handleError = (event) => {
    console.error("WebSocket error observed:", event);
    const { addLogLine } = getState();
    addLogLine('<span class="system-message-inline">! WebSocket connection error.</span>', 'html');
};

export const webSocketService = {
    connect: () => {
        const token = getState().token;
        const characterId = getState().characterId;

        if (!token || !characterId) {
            console.error("WS Connect: Missing token or character ID.");
            return;
        }

        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log("WebSocket already open.");
            return;
        }

        const wsUrl = `${WS_PROTOCOL}//${WS_HOST}/ws?token=${token}&character_id=${characterId}`;

        socket = new WebSocket(wsUrl);
        socket.onopen = () => console.log("WebSocket connection established.");
        socket.onmessage = handleMessage;
        socket.onclose = handleClose;
        socket.onerror = handleError;
    },

    disconnect: () => {
        if (socket) {
            socket.close();
        }
    },

    sendMessage: (payload) => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(payload));
        } else {
            console.error("Cannot send WS message: Not connected.");
            const { addLogLine } = getState();
            addLogLine('<span class="system-message-inline">! Cannot send command: Not connected.</span>', 'html');
        }
    },

    addClientEcho: (command) => {
        const { addLogLine } = getState();
        addLogLine(`> ${command}`, 'html');
    }
};
--- END OF FILE frontend/src/services/webSocketService.js ---

--- START OF FILE frontend/src/components/Map.jsx ---
import React, { useState, useRef, useEffect, useCallback } from 'react';
import useGameStore from '../state/gameStore';


// Constants can live outside the component for clarity
const TILE_SIZE = 24;
const CURRENT_ROOM_COLOR = 'rgba(255, 255, 0, 0.7)';
const DEFAULT_ROOM_COLOR = 'rgba(0, 128, 0, 0.3)';
const CONNECTION_LINE_COLOR = 'rgba(0, 192, 0, 0.6)';

function Map() {
  // Global state from Zustand
  const mapData = useGameStore((state) => state.mapData);
  const currentRoomId = useGameStore((state) => state.currentRoomId);

  // Local state for map interactivity
  const [viewBox, setViewBox] = useState('0 0 350 350');
  const [isPanning, setIsPanning] = useState(false);
  const lastPoint = useRef({ x: 0, y: 0 });
  const svgRef = useRef(null);

  // This effect hook runs when mapData changes to calculate the initial viewBox
  useEffect(() => {
    if (!mapData || !mapData.rooms || mapData.rooms.length === 0 || !svgRef.current) return;
    const { rooms } = mapData;
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    rooms.forEach(room => {
      minX = Math.min(minX, room.x); maxX = Math.max(maxX, room.x);
      minY = Math.min(minY, room.y); maxY = Math.max(maxY, room.y);
    });
    const contentWidth = (maxX - minX + 1) * TILE_SIZE;
    const contentHeight = (maxY - minY + 1) * TILE_SIZE;
    const vbX = (minX * TILE_SIZE) - TILE_SIZE; const vbY = (minY * TILE_SIZE) - TILE_SIZE;
    const vbW = contentWidth + (TILE_SIZE * 2); const vbH = contentHeight + (TILE_SIZE * 2);
    setViewBox(`${vbX} ${vbY} ${vbW} ${vbH}`);
  }, [mapData]);

  // Event handler for starting a pan
  const onMouseDown = (e) => {
    if (e.button !== 0) return; // Only pan on left-click
    e.preventDefault();
    setIsPanning(true);
    lastPoint.current = { x: e.clientX, y: e.clientY };
  };

  // Event handler for mouse movement during a pan
  const onMouseMove = (e) => {
    if (!isPanning) return;
    const [vx, vy, vw, vh] = viewBox.split(' ').map(parseFloat);
    const dx = (lastPoint.current.x - e.clientX) * (vw / svgRef.current.clientWidth);
    const dy = (lastPoint.current.y - e.clientY) * (vh / svgRef.current.clientHeight);
    setViewBox(`${vx + dx} ${vy + dy} ${vw} ${vh}`);
    lastPoint.current = { x: e.clientX, y: e.clientY };
  };

  // Event handler for ending a pan
  const onMouseUpOrLeave = () => {
    setIsPanning(false);
  };

  // Event handler for zooming with the mouse wheel
  const onWheel = useCallback((e) => {
    e.preventDefault(); // This is why we need a non-passive listener
    const [vx, vy, vw, vh] = viewBox.split(' ').map(parseFloat);
    const zoomFactor = 1.15;
    const newWidth = e.deltaY < 0 ? vw / zoomFactor : vw * zoomFactor;
    const newHeight = e.deltaY < 0 ? vh / zoomFactor : vh * zoomFactor;
    const CTM = svgRef.current.getScreenCTM().inverse();
    const mousePoint = new DOMPoint(e.clientX, e.clientY).matrixTransform(CTM);
    const newX = mousePoint.x - (newWidth / vw) * (mousePoint.x - vx);
    const newY = mousePoint.y - (newHeight / vh) * (mousePoint.y - vy);
    setViewBox(`${newX} ${newY} ${newWidth} ${newHeight}`);
  }, [viewBox]); // This callback is remade only when viewBox changes

  // Manually add and remove the 'wheel' event listener with `passive: false`
  useEffect(() => {
    const svgElement = svgRef.current;
    if (svgElement) {
      svgElement.addEventListener('wheel', onWheel, { passive: false });
      return () => { // Cleanup function
        svgElement.removeEventListener('wheel', onWheel);
      };
    }
  }, [onWheel]);


  // --- Render Logic ---

  if (!mapData || !mapData.rooms || mapData.rooms.length === 0) {
    return (
      <div id="map-column">
        <div id="map-title-bar"><span>Map</span></div>
        <div id="map-viewport"><svg id="map-svg" width="100%" height="100%"><text x="50%" y="50%" fill="#0f0" textAnchor="middle">Loading map...</text></svg></div>
        <div id="map-zone-bar"><span>[Unknown Zone]</span></div>
      </div>
    );
  }

  // Find map boundaries to flip the Y coordinates for drawing
  const { rooms } = mapData;
  let minY = Infinity, maxY = -Infinity;
  rooms.forEach(room => { minY = Math.min(minY, room.y); maxY = Math.max(maxY, room.y); });

  const transformedRooms = rooms.map(room => ({ ...room, drawY: maxY - room.y }));
  const currentRoom = transformedRooms.find(r => r.id === currentRoomId);

  return (
    <div id="map-column">
      <div id="map-title-bar" className="map-ui-bar">
        <span id="map-title-text">Map</span> | Coords:
        <span id="map-coords-text">{currentRoom ? `${currentRoom.x}, ${currentRoom.y}, ${mapData.z_level}` : '?, ?, ?'}</span>
      </div>
      <div id="map-viewport">
        <div id="map-z-level-box">
          <span className="z-level-label">Level</span>
          <span id="map-z-level-value">{mapData.z_level}</span>
        </div>
        <svg
          id="map-svg"
          ref={svgRef}
          viewBox={viewBox}
          onMouseDown={onMouseDown}
          onMouseMove={onMouseMove}
          onMouseUp={onMouseUpOrLeave}
          onMouseLeave={onMouseUpOrLeave}
          style={{ cursor: isPanning ? 'grabbing' : 'grab', width: '100%', height: '100%' }}
        >
          <g id="map-content-group">
            {/* Draw connections */}
            {transformedRooms.map(room =>
              Object.values(room.exits).map(exitInfo => {
                const targetRoom = transformedRooms.find(r => r.id === exitInfo.target_room_id);
                if (!targetRoom) return null;
                return (
                  <line
                    key={`${room.id}-${targetRoom.id}`}
                    x1={room.x * TILE_SIZE + TILE_SIZE / 2}
                    y1={room.drawY * TILE_SIZE + TILE_SIZE / 2}
                    x2={targetRoom.x * TILE_SIZE + TILE_SIZE / 2}
                    y2={targetRoom.drawY * TILE_SIZE + TILE_SIZE / 2}
                    stroke={CONNECTION_LINE_COLOR}
                    strokeWidth="1"
                  />
                );
              })
            )}
            {/* Draw rooms */}
            {transformedRooms.map(room => (
              <rect
                key={room.id}
                x={room.x * TILE_SIZE}
                y={room.drawY * TILE_SIZE}
                width={TILE_SIZE}
                height={TILE_SIZE}
                fill={room.id === currentRoomId ? CURRENT_ROOM_COLOR : DEFAULT_ROOM_COLOR}
                stroke="rgba(0,50,0,0.8)"
                strokeWidth="1"
              />
            ))}
          </g>
        </svg>
      </div>
       <div id="map-zone-bar" className="map-ui-bar">
        <span>
          {mapData.current_zone_name || 'Unknown Zone'}
          {mapData.current_zone_level_range && ` (Lvl ${mapData.current_zone_level_range})`}
        </span>
      </div>
    </div>
  );
}

export default Map;
--- END OF FILE frontend/src/components/Map.jsx ---
--- END OF CORE BUNDLED FILES ---

--- SCRIPT END --- Bundle complete: project_context_bundle.txt ---
