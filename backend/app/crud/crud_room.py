# backend/app/crud/crud_room.py
from sqlalchemy.orm import Session
import uuid # Import uuid
from typing import Optional, Dict, List
from .. import models, schemas

def get_room_by_id(db: Session, room_id: uuid.UUID) -> Optional[models.Room]: # room_id is now uuid.UUID
    """
    Retrieve a room from the database by its ID (which is a UUID).
    """
    return db.query(models.Room).filter(models.Room.id == room_id).first()

def get_room_by_coords(db: Session, *, x: int, y: int, z: int) -> Optional[models.Room]:
    return db.query(models.Room).filter(
        models.Room.x == x,
        models.Room.y == y,
        models.Room.z == z
    ).first()

def create_room(db: Session, *, room_in: schemas.RoomCreate) -> models.Room:
    """
    Create a new room in the database.
    Takes a Pydantic schema RoomCreate as input.
    If room_in.id is None (typical), a new UUID will be generated by the model's default.
    If room_in.id is provided, that UUID will be used.
    Returns the created SQLAlchemy ORM model instance.
    """
    db_room_data = room_in.model_dump(exclude_unset=True) # Exclude unset to allow DB defaults like UUID
    
    # If an ID (UUID) is provided in room_in, use it. Otherwise, DB default uuid.uuid4() kicks in.
    # The model_dump already includes 'id' if it was set in room_in.
    
    db_room = models.Room(**db_room_data)
    db.add(db_room)
    db.commit()
    db.refresh(db_room)
    return db_room

# We'll need a robust way to update room exits as well, or a general update_room
def update_room(db: Session, *, db_room: models.Room, room_in: schemas.RoomUpdate) -> models.Room:
    """
    General purpose room update.
    """
    update_data = room_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_room, field, value)
    db.add(db_room)
    db.commit()
    db.refresh(db_room)
    return db_room

# --- World Seeding Logic ---
# This will be called from main.py's startup event
# We'll define 3 rooms: Genesis (0,0,0), Chilly North (0,1,0), Overlook East (1,1,0)

# Store known UUIDs for linking (these will be generated once)
# In a real app, these might be constants or looked up if seeding is idempotent.
# For simplicity, we'll generate them if rooms don't exist.
# This global dict is a temporary hack for seeding to pass UUIDs between room creations.
_SEED_ROOM_UUIDS: Dict[str, uuid.UUID] = {}

def seed_initial_world(db: Session):
    print("Attempting to seed initial world with UUIDs...")

    room_definitions = [
        {
            "coords": {"x": 0, "y": 0, "z": 0},
            "name_tag": "genesis_room", # Internal tag for _SEED_ROOM_UUIDS
            "data": schemas.RoomCreate(
                name="The UUID Genesis of Despair",
                description="This void is now uniquely identified. The walls whisper of primary keys and existential uniqueness.",
                x=0, y=0, z=0,
                exits={} # Will be populated after all rooms are created/UUIDs known
            )
        },
        {
            "coords": {"x": 0, "y": 1, "z": 0}, # North of Genesis
            "name_tag": "chilly_north_room",
            "data": schemas.RoomCreate(
                name="The Chilly UUID Corridor",
                description="A uniquely cold passage. The air hums with the vibration of countless GUIDs.",
                x=0, y=1, z=0,
                exits={}
            )
        },
        {
            "coords": {"x": 1, "y": 1, "z": 0}, # East of Chilly North
            "name_tag": "overlook_east_room",
            "data": schemas.RoomCreate(
                name="The Overlook of Minor UUID Disappointment",
                description="From this vantage point, you can see a sea of globally unique identifiers, none of them particularly exciting.",
                x=1, y=1, z=0,
                exits={}
            )
        }
    ]

    created_rooms_this_run = False
    for room_def in room_definitions:
        coords = room_def["coords"]
        name_tag = room_def["name_tag"]
        
        existing_room = get_room_by_coords(db, **coords)
        if not existing_room:
            print(f"Creating room '{room_def['data'].name}' at {coords}...")
            # If ID is needed beforehand for linking (not in this simple exits model, but good to know):
            # room_def['data'].id = uuid.uuid4() # Pre-assign UUID if needed
            # _SEED_ROOM_UUIDS[name_tag] = room_def['data'].id
            
            created_room_orm = create_room(db, room_in=room_def["data"])
            _SEED_ROOM_UUIDS[name_tag] = created_room_orm.id # type: ignore[assignment] # Store the generated UUID
            print(f"  Created '{created_room_orm.name}' with UUID: {_SEED_ROOM_UUIDS[name_tag]}")
            created_rooms_this_run = True
        else:
            print(f"Room '{existing_room.name}' at {coords} already exists with UUID: {existing_room.id}.")
            _SEED_ROOM_UUIDS[name_tag] = existing_room.id # type: ignore[assignment] # Store existing UUID

    # If any rooms were newly created OR if we want to ensure exits are always up-to-date on startup:
    # Link rooms using their known/generated UUIDs
    # For simplicity, we'll re-fetch and update exits even if rooms existed.
    # This makes the seeding idempotent for exits too.

    print("Linking room exits with UUIDs...")
    # Genesis Room (0,0,0) exits
    if "genesis_room" in _SEED_ROOM_UUIDS and "chilly_north_room" in _SEED_ROOM_UUIDS:
        genesis_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS["genesis_room"])
        if genesis_room_orm:
            new_exits = {"north": str(_SEED_ROOM_UUIDS["chilly_north_room"])}
            if genesis_room_orm.exits != new_exits: # type: ignore[operator] # Only update if changed
                print(f"  Updating Genesis room exits to: {new_exits}")
                genesis_room_orm.exits = new_exits # type: ignore[assignment]
                db.add(genesis_room_orm) # Let SQLAlchemy track the change

    # Chilly North Room (0,1,0) exits
    if "chilly_north_room" in _SEED_ROOM_UUIDS and "genesis_room" in _SEED_ROOM_UUIDS and "overlook_east_room" in _SEED_ROOM_UUIDS:
        chilly_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS["chilly_north_room"])
        if chilly_room_orm:
            new_exits = {
                "south": str(_SEED_ROOM_UUIDS["genesis_room"]),
                "east": str(_SEED_ROOM_UUIDS["overlook_east_room"])
            }
            if chilly_room_orm.exits != new_exits: # type: ignore[operator]
                print(f"  Updating Chilly North room exits to: {new_exits}")
                chilly_room_orm.exits = new_exits # type: ignore[assignment]
                db.add(chilly_room_orm)

    # Overlook East Room (1,1,0) exits
    if "overlook_east_room" in _SEED_ROOM_UUIDS and "chilly_north_room" in _SEED_ROOM_UUIDS:
        overlook_room_orm = get_room_by_id(db, room_id=_SEED_ROOM_UUIDS["overlook_east_room"])
        if overlook_room_orm:
            new_exits = {"west": str(_SEED_ROOM_UUIDS["chilly_north_room"])}
            if overlook_room_orm.exits != new_exits: # type: ignore[operator]
                print(f"  Updating Overlook East room exits to: {new_exits}")
                overlook_room_orm.exits = new_exits # type: ignore[assignment]
                db.add(overlook_room_orm)
    
    db.commit() # Commit all exit updates at once
    print("World seeding and exit linking complete.")

# Remove the old init_first_room_if_not_exists or ensure it's not called if you keep it.
# The new seed_initial_world should be called from main.py startup.